###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        20/Nov/2015  05:04:57
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_pwr.c
#    Command line =  
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_pwr.c
#        -D USE_STDPERIPH_DRIVER -D VECT_TAB_FLASH -D STM32L1XX_MD -D
#        IAR_ARM_CM3 -D USE_FULL_ASSERT -D SPIRIT_USE_FULL_ASSERT -D
#        USE_SYSTICK_DELAY -D SDK -lC
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\List\
#        -o
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\.\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\examples\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\runtime\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\SDK_Eval_STM32L\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\SPIRIT1_Library\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\SDK_Eval_Util\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\SDK_Virtual_Com\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32_USB-FS-Device_Lib\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\ACQ\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\CMSIS\Include\"
#    List file    =  
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\List\stm32l1xx_pwr.lst
#    Object file  =  
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\Obj\stm32l1xx_pwr.o
#
###############################################################################

E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_pwr.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_pwr.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    31-December-2010
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Power Controller (PWR) peripheral:           
      9            *           - RTC Domain Access
     10            *           - PVD configuration
     11            *           - WakeUp pins configuration
     12            *           - Ultra Low Power mode configuration
     13            *           - Voltage Scaling configuration
     14            *           - Low Power modes configuration
     15            *           - Flags management
     16            *               
     17            ******************************************************************************
     18            * @attention
     19            *
     20            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     21            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     22            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     23            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     24            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     25            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     26            *
     27            * <h2><center>&copy; COPYRIGHT 2010 STMicroelectronics</center></h2>
     28            ******************************************************************************  
     29            */ 
     30          
     31          /* Includes ------------------------------------------------------------------*/
     32          #include "stm32l1xx_pwr.h"
     33          #include "stm32l1xx_rcc.h"
     34          
     35          /** @addtogroup STM32L1xx_StdPeriph_Driver
     36            * @{
     37            */
     38          
     39          /** @defgroup PWR 
     40            * @brief PWR driver modules
     41            * @{
     42            */ 
     43          
     44          /* Private typedef -----------------------------------------------------------*/
     45          /* Private define ------------------------------------------------------------*/
     46          /* --------- PWR registers bit address in the alias region ---------- */
     47          #define PWR_OFFSET               (PWR_BASE - PERIPH_BASE)
     48          
     49          /* --- CR Register ---*/
     50          
     51          /* Alias word address of DBP bit */
     52          #define CR_OFFSET                (PWR_OFFSET + 0x00)
     53          #define DBP_BitNumber            0x08
     54          #define CR_DBP_BB                (PERIPH_BB_BASE + (CR_OFFSET * 32) + (DBP_BitNumber * 4))
     55          
     56          /* Alias word address of PVDE bit */
     57          #define PVDE_BitNumber           0x04
     58          #define CR_PVDE_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PVDE_BitNumber * 4))
     59          
     60          /* Alias word address of ULP bit */
     61          #define ULP_BitNumber           0x09
     62          #define CR_ULP_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (ULP_BitNumber * 4))
     63          
     64          /* Alias word address of FWU bit */
     65          #define FWU_BitNumber           0x0A
     66          #define CR_FWU_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (FWU_BitNumber * 4))
     67          
     68          /* --- CSR Register ---*/
     69          
     70          /* Alias word address of EWUP bit */
     71          #define CSR_OFFSET               (PWR_OFFSET + 0x04)
     72          #define EWUP_BitNumber           0x08
     73          #define CSR_EWUP_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (EWUP_BitNumber * 4))
     74          
     75          /* ------------------ PWR registers bit mask ------------------------ */
     76          
     77          /* CR register bit mask */
     78          #define CR_DS_MASK               ((uint32_t)0xFFFFFFFC)
     79          #define CR_PLS_MASK              ((uint32_t)0xFFFFFF1F)
     80          #define CR_VOS_MASK              ((uint32_t)0xFFFFE7FF)
     81          
     82          /* Private macro -------------------------------------------------------------*/
     83          /* Private variables ---------------------------------------------------------*/
     84          /* Private function prototypes -----------------------------------------------*/
     85          /* Private functions ---------------------------------------------------------*/
     86          
     87          /** @defgroup PWR_Private_Functions
     88            * @{
     89            */
     90          
     91          /** @defgroup PWR_Group1 RTC Domain Access function 
     92           *  @brief   RTC Domain Access function  
     93           *
     94          @verbatim   
     95           ===============================================================================
     96                                      RTC Domain Access function 
     97           ===============================================================================  
     98          
     99           After reset, the RTC Registers (RCC CSR Register, RTC registers and RTC backup 
    100           registers) are protected against possible stray write accesses.
    101           To enable access to RTC domain use the PWR_RTCAccessCmd(ENABLE) function.
    102          
    103          @endverbatim
    104            * @{
    105            */
    106          
    107          /**
    108            * @brief  Deinitializes the PWR peripheral registers to their default reset values.
    109            * @note   Before calling this function, the VOS[1:0] bits should be configured 
    110            *         to "10" and the system frequency has to be configured accordingly. 
    111            *         To configure the VOS[1:0] bits, use the PWR_VoltageScalingConfig()
    112            *         function.      
    113            * @note   ULP and FWU bits are not reset by this function.    
    114            * @param  None
    115            * @retval None
    116            */

   \                                 In section .text, align 2, keep-with-next
    117          void PWR_DeInit(void)
    118          {
   \                     PWR_DeInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    119            RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0xF05F 0x5080      MOVS     R0,#+268435456
   \   00000008   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    120            RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, DISABLE);
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0xF05F 0x5080      MOVS     R0,#+268435456
   \   00000012   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    121          }
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    122          
    123          /**
    124            * @brief  Enables or disables access to the RTC and backup registers.
    125            * @note   If the HSE divided by 2, 4, 8 or 16 is used as the RTC clock, the 
    126            *         RTC Domain Access should be kept enabled.
    127            * @param  NewState: new state of the access to the RTC and backup registers.
    128            *   This parameter can be: ENABLE or DISABLE.
    129            * @retval None
    130            */

   \                                 In section .text, align 2, keep-with-next
    131          void PWR_RTCAccessCmd(FunctionalState NewState)
    132          {
   \                     PWR_RTCAccessCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    133            /* Check the parameters */
    134            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD006             BEQ.N    ??PWR_RTCAccessCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD003             BEQ.N    ??PWR_RTCAccessCmd_0
   \   00000010   0x2186             MOVS     R1,#+134
   \   00000012   0x....             LDR.N    R0,??DataTable12
   \   00000014   0x.... 0x....      BL       assert_failed
    135            
    136            *(__IO uint32_t *) CR_DBP_BB = (uint32_t)NewState;
   \                     ??PWR_RTCAccessCmd_0: (+1)
   \   00000018   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001A   0x....             LDR.N    R0,??DataTable12_1  ;; 0x420e0020
   \   0000001C   0x6004             STR      R4,[R0, #+0]
    137          }
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    138          
    139          /**
    140            * @}
    141            */
    142          
    143          /** @defgroup PWR_Group2 PVD configuration functions
    144           *  @brief   PVD configuration functions 
    145           *
    146          @verbatim   
    147           ===============================================================================
    148                                     PVD configuration functions
    149           ===============================================================================  
    150          
    151           - The PVD is used to monitor the VDD power supply by comparing it to a threshold
    152             selected by the PVD Level (PLS[2:0] bits in the PWR_CR).
    153           - The PVD can use an external input analog voltage (PVD_IN) which is compared 
    154             internally to VREFINT. The PVD_IN (PB7) has to be configured in Analog mode 
    155             when PWR_PVDLevel_7 is selected (PLS[2:0] = 111).
    156           - A PVDO flag is available to indicate if VDD/VDDA is higher or lower than the 
    157             PVD threshold. This event is internally connected to the EXTI line16
    158             and can generate an interrupt if enabled through the EXTI registers.
    159           - The PVD is stopped in Standby mode.
    160          
    161          @endverbatim
    162            * @{
    163            */
    164          
    165          /**
    166            * @brief  Configures the voltage threshold detected by the Power Voltage Detector(PVD).
    167            * @param  PWR_PVDLevel: specifies the PVD detection level
    168            *   This parameter can be one of the following values:
    169            *     @arg PWR_PVDLevel_0: PVD detection level set to 1.9V
    170            *     @arg PWR_PVDLevel_1: PVD detection level set to 2.1V
    171            *     @arg PWR_PVDLevel_2: PVD detection level set to 2.3V
    172            *     @arg PWR_PVDLevel_3: PVD detection level set to 2.5V
    173            *     @arg PWR_PVDLevel_4: PVD detection level set to 2.7V
    174            *     @arg PWR_PVDLevel_5: PVD detection level set to 2.9V
    175            *     @arg PWR_PVDLevel_6: PVD detection level set to 3.1V
    176            *     @arg PWR_PVDLevel_7: External input analog voltage (Compare internally to VREFINT)
    177            * @retval None
    178            */

   \                                 In section .text, align 2, keep-with-next
    179          void PWR_PVDLevelConfig(uint32_t PWR_PVDLevel)
    180          {
   \                     PWR_PVDLevelConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    181            uint32_t tmpreg = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    182            
    183            /* Check the parameters */
    184            assert_param(IS_PWR_PVD_LEVEL(PWR_PVDLevel));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD011             BEQ.N    ??PWR_PVDLevelConfig_0
   \   0000000A   0x2C20             CMP      R4,#+32
   \   0000000C   0xD00F             BEQ.N    ??PWR_PVDLevelConfig_0
   \   0000000E   0x2C40             CMP      R4,#+64
   \   00000010   0xD00D             BEQ.N    ??PWR_PVDLevelConfig_0
   \   00000012   0x2C60             CMP      R4,#+96
   \   00000014   0xD00B             BEQ.N    ??PWR_PVDLevelConfig_0
   \   00000016   0x2C80             CMP      R4,#+128
   \   00000018   0xD009             BEQ.N    ??PWR_PVDLevelConfig_0
   \   0000001A   0x2CA0             CMP      R4,#+160
   \   0000001C   0xD007             BEQ.N    ??PWR_PVDLevelConfig_0
   \   0000001E   0x2CC0             CMP      R4,#+192
   \   00000020   0xD005             BEQ.N    ??PWR_PVDLevelConfig_0
   \   00000022   0x2CE0             CMP      R4,#+224
   \   00000024   0xD003             BEQ.N    ??PWR_PVDLevelConfig_0
   \   00000026   0x21B8             MOVS     R1,#+184
   \   00000028   0x....             LDR.N    R0,??DataTable12
   \   0000002A   0x.... 0x....      BL       assert_failed
    185            
    186            tmpreg = PWR->CR;
   \                     ??PWR_PVDLevelConfig_0: (+1)
   \   0000002E   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40007000
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x0005             MOVS     R5,R0
    187            
    188            /* Clear PLS[7:5] bits */
    189            tmpreg &= CR_PLS_MASK;
   \   00000034   0xF035 0x05E0      BICS     R5,R5,#0xE0
    190            
    191            /* Set PLS[7:5] bits according to PWR_PVDLevel value */
    192            tmpreg |= PWR_PVDLevel;
   \   00000038   0x4325             ORRS     R5,R4,R5
    193            
    194            /* Store the new value */
    195            PWR->CR = tmpreg;
   \   0000003A   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40007000
   \   0000003C   0x6005             STR      R5,[R0, #+0]
    196          }
   \   0000003E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    197          
    198          /**
    199            * @brief  Enables or disables the Power Voltage Detector(PVD).
    200            * @param  NewState: new state of the PVD.
    201            *   This parameter can be: ENABLE or DISABLE.
    202            * @retval None
    203            */

   \                                 In section .text, align 2, keep-with-next
    204          void PWR_PVDCmd(FunctionalState NewState)
    205          {
   \                     PWR_PVDCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    206            /* Check the parameters */
    207            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD006             BEQ.N    ??PWR_PVDCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD003             BEQ.N    ??PWR_PVDCmd_0
   \   00000010   0x21CF             MOVS     R1,#+207
   \   00000012   0x....             LDR.N    R0,??DataTable12
   \   00000014   0x.... 0x....      BL       assert_failed
    208            
    209            *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)NewState;
   \                     ??PWR_PVDCmd_0: (+1)
   \   00000018   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001A   0x....             LDR.N    R0,??DataTable12_3  ;; 0x420e0010
   \   0000001C   0x6004             STR      R4,[R0, #+0]
    210          }
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    211          
    212          /**
    213            * @}
    214            */
    215          
    216          /** @defgroup PWR_Group3 WakeUp pins configuration functions
    217           *  @brief   WakeUp pins configuration functions 
    218           *
    219          @verbatim   
    220           ===============================================================================
    221                              WakeUp pins configuration functions
    222           ===============================================================================  
    223          
    224           - WakeUp pins are used to wakeup the system from Standby mode. These pins are 
    225             forced in input pull down configuration and are active on rising edges.
    226           - There are three WakeUp pins: WakeUp Pin 1 on PA.00, WakeUp Pin 2 on PC.13 and
    227             WakeUp Pin 3 on PE.06.
    228          
    229          @endverbatim
    230            * @{
    231            */
    232          
    233          /**
    234            * @brief  Enables or disables the WakeUp Pin functionality.
    235            * @param  PWR_WakeUpPin: specifies the WakeUpPin.
    236            *   This parameter can be: PWR_WakeUpPin_1, PWR_WakeUpPin_2 or PWR_WakeUpPin_3.
    237            * @param  NewState: new state of the WakeUp Pin functionality.
    238            *   This parameter can be: ENABLE or DISABLE.
    239            * @retval None
    240            */

   \                                 In section .text, align 2, keep-with-next
    241          void PWR_WakeUpPinCmd(uint32_t PWR_WakeUpPin, FunctionalState NewState)
    242          {
   \                     PWR_WakeUpPinCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    243            __IO uint32_t tmp = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
    244            
    245            /* Check the parameters */
    246            assert_param(IS_PWR_WAKEUP_PIN(PWR_WakeUpPin));
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD007             BEQ.N    ??PWR_WakeUpPinCmd_0
   \   0000000E   0x2C04             CMP      R4,#+4
   \   00000010   0xD005             BEQ.N    ??PWR_WakeUpPinCmd_0
   \   00000012   0x2C08             CMP      R4,#+8
   \   00000014   0xD003             BEQ.N    ??PWR_WakeUpPinCmd_0
   \   00000016   0x21F6             MOVS     R1,#+246
   \   00000018   0x....             LDR.N    R0,??DataTable12
   \   0000001A   0x.... 0x....      BL       assert_failed
    247            
    248            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??PWR_WakeUpPinCmd_0: (+1)
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD006             BEQ.N    ??PWR_WakeUpPinCmd_1
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0x2D01             CMP      R5,#+1
   \   00000028   0xD003             BEQ.N    ??PWR_WakeUpPinCmd_1
   \   0000002A   0x21F8             MOVS     R1,#+248
   \   0000002C   0x....             LDR.N    R0,??DataTable12
   \   0000002E   0x.... 0x....      BL       assert_failed
    249          
    250            tmp = CSR_EWUP_BB + PWR_WakeUpPin;
   \                     ??PWR_WakeUpPinCmd_1: (+1)
   \   00000032   0x....             LDR.N    R0,??DataTable12_4  ;; 0x420e00a0
   \   00000034   0x1900             ADDS     R0,R0,R4
   \   00000036   0x9000             STR      R0,[SP, #+0]
    251            
    252            *(__IO uint32_t *) (tmp) = (uint32_t)NewState;
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0x9800             LDR      R0,[SP, #+0]
   \   0000003C   0x6005             STR      R5,[R0, #+0]
    253          }
   \   0000003E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    254          
    255          /**
    256            * @}
    257            */
    258          
    259          /** @defgroup PWR_Group4 Ultra Low Power mode configuration functions
    260           *  @brief   Ultra Low Power mode configuration functions 
    261           *
    262          @verbatim   
    263           ===============================================================================
    264                              Ultra Low Power mode configuration functions
    265           ===============================================================================  
    266          
    267           - The internal voltage reference consumption is not negligible, in particular 
    268             in Stop and Standby mode. To reduce power consumption, use the PWR_UltraLowPowerCmd()
    269             function (ULP bit (Ultra low power) in the PWR_CR register) to disable the 
    270             internal voltage reference. However, in this case, when exiting from the 
    271             Stop/Standby mode, the functions managed through the internal voltage reference 
    272             are not reliable during the internal voltage reference startup time (up to 3 ms).
    273             To reduce the wakeup time, the device can exit from Stop/Standby mode without 
    274             waiting for the internal voltage reference startup time. This is performed 
    275             by using the PWR_FastWakeUpCmd() function (setting the FWU bit (Fast
    276             wakeup) in the PWR_CR register) before entering Stop/Standby mode.
    277          
    278          @endverbatim
    279            * @{
    280            */
    281          
    282          /**
    283            * @brief  Enables or disables the Fast WakeUp from Ultra Low Power mode.
    284            * @param  NewState: new state of the Fast WakeUp  functionality.
    285            *   This parameter can be: ENABLE or DISABLE.
    286            * @retval None
    287            */

   \                                 In section .text, align 2, keep-with-next
    288          void PWR_FastWakeUpCmd(FunctionalState NewState)
    289          {
   \                     PWR_FastWakeUpCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    290            /* Check the parameters */
    291            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??PWR_FastWakeUpCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD004             BEQ.N    ??PWR_FastWakeUpCmd_0
   \   00000010   0xF240 0x1123      MOVW     R1,#+291
   \   00000014   0x....             LDR.N    R0,??DataTable12
   \   00000016   0x.... 0x....      BL       assert_failed
    292          
    293            *(__IO uint32_t *) CR_FWU_BB = (uint32_t)NewState;
   \                     ??PWR_FastWakeUpCmd_0: (+1)
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x....             LDR.N    R0,??DataTable12_5  ;; 0x420e0028
   \   0000001E   0x6004             STR      R4,[R0, #+0]
    294          }
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    295          
    296          /**
    297            * @brief  Enables or disables the Ultra Low Power mode.
    298            * @param  NewState: new state of the Ultra Low Power mode.
    299            *   This parameter can be: ENABLE or DISABLE.
    300            * @retval None
    301            */

   \                                 In section .text, align 2, keep-with-next
    302          void PWR_UltraLowPowerCmd(FunctionalState NewState)
    303          {
   \                     PWR_UltraLowPowerCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    304            /* Check the parameters */
    305            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??PWR_UltraLowPowerCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD004             BEQ.N    ??PWR_UltraLowPowerCmd_0
   \   00000010   0xF240 0x1131      MOVW     R1,#+305
   \   00000014   0x....             LDR.N    R0,??DataTable12
   \   00000016   0x.... 0x....      BL       assert_failed
    306          
    307            *(__IO uint32_t *) CR_ULP_BB = (uint32_t)NewState;
   \                     ??PWR_UltraLowPowerCmd_0: (+1)
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x....             LDR.N    R0,??DataTable12_6  ;; 0x420e0024
   \   0000001E   0x6004             STR      R4,[R0, #+0]
    308          }
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    309          
    310          /**
    311            * @}
    312            */
    313          
    314          /** @defgroup PWR_Group5 Voltage Scaling configuration functions
    315           *  @brief   Voltage Scaling configuration functions 
    316           *
    317          @verbatim   
    318           ===============================================================================
    319                               Voltage Scaling configuration functions
    320           ===============================================================================  
    321          
    322           - The dynamic voltage scaling is a power management technique which consists in 
    323             increasing or decreasing the voltage used for the digital peripherals (VCORE), 
    324             according to the circumstances.
    325             
    326             Depending on the device voltage range, the maximum frequency and FLASH wait
    327             state should be adapted accordingly:
    328             
    329                  +------------------------------------------------------------------+     
    330                  |   Wait states   |                HCLK clock frequency (MHz)      |
    331                  |                 |------------------------------------------------|     
    332                  |    (Latency)    |            voltage range       | voltage range | 
    333                  |                 |            1.65 V - 3.6 V      | 2.0 V - 3.6 V |
    334                  |                 |----------------|---------------|---------------|
    335                  |                 |     Range 3    |    Range 2    |    Range 1    |
    336                  |                 |  VCORE = 1.2 V | VCORE = 1.5 V | VCORE = 1.8 V |
    337                  |---------------- |----------------|---------------|---------------|             
    338                  | 0WS(1CPU cycle) |0 < HCLK <= 2   |0 < HCLK <= 8  |0 < HCLK <= 16 |
    339                  |-----------------|----------------|---------------|---------------|  
    340                  | 1WS(2CPU cycle) |2 < HCLK <= 4   |8 < HCLK <= 16 |16 < HCLK <= 32|
    341                  |-----------------|----------------|---------------|---------------|  
    342                  | CPU Performance |      Low       |     Medium    |     High      |
    343                  |-----__----------|----------------|---------------|---------------|  
    344                  |Power Performance|      High      |     Medium    |      Low      |                 
    345                  +------------------------------------------------------------------+    
    346          
    347           - To modify the Product voltage range, user application has to:
    348             - Check VDD to identify which ranges are allowed (see table above)
    349             - Check the PWR_FLAG_VOSF (Voltage Scaling update ongoing) using the PWR_GetFlagStatus() 
    350               function and wait until it is  reset.
    351             - Configure the Voltage range using the PWR_VoltageScalingConfig() function.
    352          
    353           - When VCORE range 1 is selected and VDD drops below 2.0 V, the application must
    354             reconfigure the system:
    355             - Detect that VDD drops below 2.0 V using the PVD Level 1
    356             - Adapt the clock frequency to the voltage range that will be selected at next step
    357             - Select the required voltage range
    358             - When VCORE range 2 or range 3 is selected and VDD drops below 2.0 V, no system
    359               reconfiguration is required.
    360           
    361           - When VDD is above 2.0 V, any of the 3 voltage ranges can be selected
    362             - When the voltage range is above the targeted voltage range (e.g. from range 
    363               1 to 2):
    364               - Adapt the clock frequency to the lower voltage range that will be selected 
    365                 at next step.
    366               - Select the required voltage range.
    367             - When the voltage range is below the targeted voltage range (e.g. from range 
    368               3 to 1):
    369               - Select the required voltage range.
    370               - Tune the clock frequency if needed.
    371           
    372           - When VDD is below 2.0 V, only range 2 and 3 can be selected:
    373             - From range 2 to range 3
    374               - Adapt the clock frequency to voltage range 3.
    375               - Select voltage range 3.
    376             - From range 3 to range 2
    377               - Select the voltage range 2.
    378               - Tune the clock frequency if needed.
    379          
    380          @endverbatim
    381            * @{
    382            */
    383          
    384          /**
    385            * @brief  Configures the voltage scaling range.
    386            * @note   During voltage scaling configuration, the system clock is stopped 
    387            *         until the regulator is stabilized (VOSF = 0). This must be taken 
    388            *         into account during application developement, in case a critical 
    389            *         reaction time to interrupt is needed, and depending on peripheral 
    390            *         used (timer, communication,...).
    391            *             
    392            * @param  PWR_VoltageScaling: specifies the voltage scaling range.
    393            *   This parameter can be:
    394            *     @arg PWR_VoltageScaling_Range1: Voltage Scaling Range 1 (VCORE = 1.8V)
    395            *     @arg PWR_VoltageScaling_Range2: Voltage Scaling Range 2 (VCORE = 1.5V)
    396            *     @arg PWR_VoltageScaling_Range3: Voltage Scaling Range 3 (VCORE = 1.2V)     
    397            * @retval None
    398            */

   \                                 In section .text, align 2, keep-with-next
    399          void PWR_VoltageScalingConfig(uint32_t PWR_VoltageScaling)
    400          {
   \                     PWR_VoltageScalingConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    401            uint32_t tmp = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    402            
    403            /* Check the parameters */
    404            assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(PWR_VoltageScaling));
   \   00000006   0xF5B4 0x6F00      CMP      R4,#+2048
   \   0000000A   0xD00A             BEQ.N    ??PWR_VoltageScalingConfig_0
   \   0000000C   0xF5B4 0x5F80      CMP      R4,#+4096
   \   00000010   0xD007             BEQ.N    ??PWR_VoltageScalingConfig_0
   \   00000012   0xF5B4 0x5FC0      CMP      R4,#+6144
   \   00000016   0xD004             BEQ.N    ??PWR_VoltageScalingConfig_0
   \   00000018   0xF44F 0x71CA      MOV      R1,#+404
   \   0000001C   0x....             LDR.N    R0,??DataTable12
   \   0000001E   0x.... 0x....      BL       assert_failed
    405            
    406            tmp = PWR->CR;
   \                     ??PWR_VoltageScalingConfig_0: (+1)
   \   00000022   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40007000
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x0005             MOVS     R5,R0
    407          
    408            tmp &= CR_VOS_MASK;
   \   00000028   0xF435 0x55C0      BICS     R5,R5,#0x1800
    409            tmp |= PWR_VoltageScaling;
   \   0000002C   0x4325             ORRS     R5,R4,R5
    410            
    411            PWR->CR = tmp & 0xFFFFFFF3;
   \   0000002E   0xF035 0x000C      BICS     R0,R5,#0xC
   \   00000032   0x....             LDR.N    R1,??DataTable12_2  ;; 0x40007000
   \   00000034   0x6008             STR      R0,[R1, #+0]
    412          
    413          }
   \   00000036   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    414          
    415          /**
    416            * @}
    417            */
    418          
    419          /** @defgroup PWR_Group6 Low Power modes configuration functions
    420           *  @brief   Low Power modes configuration functions 
    421           *
    422          @verbatim   
    423           ===============================================================================
    424                              Low Power modes configuration functions
    425           ===============================================================================  
    426          
    427            The devices feature five low-power modes:
    428             - Low power run mode: regulator in low power mode, limited clock frequency, 
    429               limited number of peripherals running.
    430             - Sleep mode: Cortex-M3 core stopped, peripherals kept running.
    431             - Low power sleep mode: Cortex-M3 core stopped, limited clock frequency, 
    432               limited number of peripherals running, regulator in low power mode.
    433             - Stop mode: all clocks are stopped, regulator running, regulator in low power mode
    434             - Standby mode: VCORE domain powered off
    435             
    436             Low power run mode (LP run)
    437             ===========================
    438              - Entry:
    439                - Decrease the system frequency.
    440                - The regulator is forced in low power mode using the PWR_EnterLowPowerRunMode()
    441                  function.
    442              - Exit:
    443                - The regulator is forced in Main regulator mode sing the PWR_EnterLowPowerRunMode()
    444                  function.
    445                - Increase the system frequency if needed.
    446          
    447             Sleep mode
    448             ===========
    449              - Entry:
    450                - The Sleep mode is entered by using the PWR_EnterSleepMode(PWR_Regulator_ON,) 
    451                  function with regulator ON.
    452              - Exit:
    453                - Any peripheral interrupt acknowledged by the nested vectored interrupt 
    454                  controller (NVIC) can wake up the device from Sleep mode.
    455          
    456             Low power sleep mode (LP sleep)
    457             ===============================
    458              - Entry:
    459                - The Flash memory must be switched off by using the FLASH_SLEEPPowerDownCmd()
    460                  function.
    461                - Decrease the system frequency.
    462                - The regulator is forced in low power mode and the WFI or WFE instructions
    463                  are executed using the PWR_EnterSleepMode(PWR_Regulator_LowPower,) function 
    464                  with regulator in LowPower.
    465              - Exit:
    466                - Any peripheral interrupt acknowledged by the nested vectored interrupt 
    467                  controller (NVIC) can wake up the device from Sleep LP mode.
    468          
    469             Stop mode
    470             ==========
    471             In Stop mode, all clocks in the VCORE domain are stopped, the PLL, the MSI,
    472             the HSI and the HSE RC oscillators are disabled. Internal SRAM and register 
    473             contents are preserved.
    474             The voltage regulator can be configured either in normal or low-power mode.
    475             To minimize the consumption In Stop mode, VREFINT, the BOR, PVD, and temperature
    476             sensor can be switched off before entering the Stop mode. They can be switched 
    477             on again by software after exiting the Stop mode using the PWR_UltraLowPowerCmd()
    478             function. 
    479             
    480              - Entry:
    481                - The Stop mode is entered using the PWR_EnterSTOPMode(PWR_Regulator_LowPower,) 
    482                  function with regulator in LowPower or with Regulator ON.
    483              - Exit:
    484                - Any EXTI Line (Internal or External) configured in Interrupt/Event mode.
    485                
    486             Standby mode
    487             ============
    488             The Standby mode allows to achieve the lowest power consumption. It is based 
    489             on the Cortex-M3 deepsleep mode, with the voltage regulator disabled. 
    490             The VCORE domain is consequently powered off. The PLL, the MSI, the HSI 
    491             oscillator and the HSE oscillator are also switched off. SRAM and register 
    492             contents are lost except for the RTC registers, RTC backup registers and 
    493             Standby circuitry.
    494             
    495             The voltage regulator is OFF.
    496             
    497             To minimize the consumption In Standby mode, VREFINT, the BOR, PVD, and temperature
    498             sensor can be switched off before entering the Standby mode. They can be switched 
    499             on again by software after exiting the Standby mode using the PWR_UltraLowPowerCmd()
    500             function. 
    501             
    502              - Entry:
    503                - The Standby mode is entered using the PWR_EnterSTANDBYMode() function.
    504              - Exit:
    505                - WKUP pin rising edge, RTC alarm (Alarm A and Alarm B), RTC wakeup,
    506                  tamper event, time-stamp event, external reset in NRST pin, IWDG reset.              
    507          
    508             Auto-wakeup (AWU) from low-power mode
    509             =====================================
    510             The MCU can be woken up from low-power mode by an RTC Alarm event, an RTC 
    511             Wakeup event, a tamper event, a time-stamp event, or a comparator event, 
    512             without depending on an external interrupt (Auto-wakeup mode).
    513          
    514             - RTC auto-wakeup (AWU) from the Stop mode
    515               ----------------------------------------
    516               
    517               - To wake up from the Stop mode with an RTC alarm event, it is necessary to:
    518                 - Configure the EXTI Line 17 to be sensitive to rising edges (Interrupt 
    519                   or Event modes) using the EXTI_Init() function.
    520                 - Enable the RTC Alarm Interrupt using the RTC_ITConfig() function
    521                 - Configure the RTC to generate the RTC alarm using the RTC_SetAlarm() 
    522                   and RTC_AlarmCmd() functions.
    523               - To wake up from the Stop mode with an RTC Tamper or time stamp event, it 
    524                 is necessary to:
    525                 - Configure the EXTI Line 19 to be sensitive to rising edges (Interrupt 
    526                   or Event modes) using the EXTI_Init() function.
    527                 - Enable the RTC Tamper or time stamp Interrupt using the RTC_ITConfig() 
    528                   function
    529                 - Configure the RTC to detect the tamper or time stamp event using the
    530                   RTC_TimeStampConfig(), RTC_TamperTriggerConfig() and RTC_TamperCmd()
    531                   functions.
    532               - To wake up from the Stop mode with an RTC WakeUp event, it is necessary to:
    533                 - Configure the EXTI Line 20 to be sensitive to rising edges (Interrupt 
    534                   or Event modes) using the EXTI_Init() function.
    535                 - Enable the RTC WakeUp Interrupt using the RTC_ITConfig() function
    536                 - Configure the RTC to generate the RTC WakeUp event using the RTC_WakeUpClockConfig(), 
    537                   RTC_SetWakeUpCounter() and RTC_WakeUpCmd() functions.
    538          
    539             - RTC auto-wakeup (AWU) from the Standby mode
    540               -------------------------------------------
    541               - To wake up from the Standby mode with an RTC alarm event, it is necessary to:
    542                 - Enable the RTC Alarm Interrupt using the RTC_ITConfig() function
    543                 - Configure the RTC to generate the RTC alarm using the RTC_SetAlarm() 
    544                   and RTC_AlarmCmd() functions.
    545               - To wake up from the Standby mode with an RTC Tamper or time stamp event, it 
    546                 is necessary to:
    547                 - Enable the RTC Tamper or time stamp Interrupt using the RTC_ITConfig() 
    548                   function
    549                 - Configure the RTC to detect the tamper or time stamp event using the
    550                   RTC_TimeStampConfig(), RTC_TamperTriggerConfig() and RTC_TamperCmd()
    551                   functions.
    552               - To wake up from the Standby mode with an RTC WakeUp event, it is necessary to:
    553                 - Enable the RTC WakeUp Interrupt using the RTC_ITConfig() function
    554                 - Configure the RTC to generate the RTC WakeUp event using the RTC_WakeUpClockConfig(), 
    555                   RTC_SetWakeUpCounter() and RTC_WakeUpCmd() functions.
    556          
    557             - Comparator auto-wakeup (AWU) from the Stop mode
    558               -----------------------------------------------
    559               - To wake up from the Stop mode with an comparator 1 or comparator 2 wakeup
    560                 event, it is necessary to:
    561                 - Configure the EXTI Line 21 for comparator 1 or EXTI Line 22 for comparator 2 
    562                   to be sensitive to to the selected edges (falling, rising or falling 
    563                   and rising) (Interrupt or Event modes) using the EXTI_Init() function.
    564                 - Configure the comparator to generate the event.
    565          
    566          @endverbatim
    567            * @{
    568            */
    569          
    570          /**
    571            * @brief  Enters/Exits the Low Power Run mode.
    572            * @note   Low power run mode can only be entered when VCORE is in range 2.
    573            *         In addition, the dynamic voltage scaling must not be used when Low 
    574            *         power run mode is selected. Only Stop and Sleep modes with regulator 
    575            *         configured in Low power mode is allowed when Low power run mode is 
    576            *         selected.  
    577            * @note   In Low power run mode, all I/O pins keep the same state as in Run mode.        
    578            * @param  NewState: new state of the Low Power Run mode.
    579            *   This parameter can be: ENABLE or DISABLE.
    580            * @retval None
    581            */

   \                                 In section .text, align 2, keep-with-next
    582          void PWR_EnterLowPowerRunMode(FunctionalState NewState)
    583          {
   \                     PWR_EnterLowPowerRunMode: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    584            /* Check the parameters */
    585            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??PWR_EnterLowPowerRunMode_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD004             BEQ.N    ??PWR_EnterLowPowerRunMode_0
   \   00000010   0xF240 0x2149      MOVW     R1,#+585
   \   00000014   0x....             LDR.N    R0,??DataTable12
   \   00000016   0x.... 0x....      BL       assert_failed
    586          
    587            if (NewState != DISABLE)
   \                     ??PWR_EnterLowPowerRunMode_0: (+1)
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD00C             BEQ.N    ??PWR_EnterLowPowerRunMode_1
    588            {
    589              PWR->CR |= PWR_CR_LPSDSR;
   \   00000020   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40007000
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000028   0x....             LDR.N    R1,??DataTable12_2  ;; 0x40007000
   \   0000002A   0x6008             STR      R0,[R1, #+0]
    590              PWR->CR |= PWR_CR_LPRUN;     
   \   0000002C   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40007000
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \   00000034   0x....             LDR.N    R1,??DataTable12_2  ;; 0x40007000
   \   00000036   0x6008             STR      R0,[R1, #+0]
   \   00000038   0xE00B             B.N      ??PWR_EnterLowPowerRunMode_2
    591            }
    592            else
    593            {
    594              PWR->CR &= (uint32_t)~((uint32_t)PWR_CR_LPRUN); 
   \                     ??PWR_EnterLowPowerRunMode_1: (+1)
   \   0000003A   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40007000
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0xF430 0x4080      BICS     R0,R0,#0x4000
   \   00000042   0x....             LDR.N    R1,??DataTable12_2  ;; 0x40007000
   \   00000044   0x6008             STR      R0,[R1, #+0]
    595              PWR->CR &= (uint32_t)~((uint32_t)PWR_CR_LPSDSR);  
   \   00000046   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40007000
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x0840             LSRS     R0,R0,#+1
   \   0000004C   0x0040             LSLS     R0,R0,#+1
   \   0000004E   0x....             LDR.N    R1,??DataTable12_2  ;; 0x40007000
   \   00000050   0x6008             STR      R0,[R1, #+0]
    596            }  
    597          }
   \                     ??PWR_EnterLowPowerRunMode_2: (+1)
   \   00000052   0xBD10             POP      {R4,PC}          ;; return
    598          
    599          /**
    600            * @brief  Enters Sleep mode.
    601            * @note   In Sleep mode, all I/O pins keep the same state as in Run mode.  
    602            * @param  PWR_Regulator: specifies the regulator state in Sleep mode.
    603            *   This parameter can be one of the following values:
    604            *     @arg PWR_Regulator_ON: Sleep mode with regulator ON
    605            *     @arg PWR_Regulator_LowPower: Sleep mode with regulator in low power mode
    606            * @note   Low power sleep mode can only be entered when VCORE is in range 2.
    607            * @note   When the voltage regulator operates in low power mode, an additional 
    608            *         startup delay is incurred when waking up from Low power sleep mode.
    609            *                   
    610            * @param  PWR_SLEEPEntry: specifies if SLEEP mode in entered with WFI or WFE instruction.
    611            *   This parameter can be one of the following values:
    612            *     @arg PWR_SLEEPEntry_WFI: enter SLEEP mode with WFI instruction
    613            *     @arg PWR_SLEEPEntry_WFE: enter SLEEP mode with WFE instruction
    614            * @retval None
    615            */

   \                                 In section .text, align 2, keep-with-next
    616          void PWR_EnterSleepMode(uint32_t PWR_Regulator, uint8_t PWR_SLEEPEntry)
    617          {
   \                     PWR_EnterSleepMode: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    618            uint32_t tmpreg = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    619          
    620            /* Check the parameters */
    621            assert_param(IS_PWR_REGULATOR(PWR_Regulator));
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD006             BEQ.N    ??PWR_EnterSleepMode_0
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD004             BEQ.N    ??PWR_EnterSleepMode_0
   \   00000010   0xF240 0x216D      MOVW     R1,#+621
   \   00000014   0x....             LDR.N    R0,??DataTable12
   \   00000016   0x.... 0x....      BL       assert_failed
    622          
    623            assert_param(IS_PWR_SLEEP_ENTRY(PWR_SLEEPEntry));
   \                     ??PWR_EnterSleepMode_0: (+1)
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D01             CMP      R5,#+1
   \   0000001E   0xD007             BEQ.N    ??PWR_EnterSleepMode_1
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D02             CMP      R5,#+2
   \   00000024   0xD004             BEQ.N    ??PWR_EnterSleepMode_1
   \   00000026   0xF240 0x216F      MOVW     R1,#+623
   \   0000002A   0x....             LDR.N    R0,??DataTable12
   \   0000002C   0x.... 0x....      BL       assert_failed
    624            
    625            /* Select the regulator state in Sleep mode ---------------------------------*/
    626            tmpreg = PWR->CR;
   \                     ??PWR_EnterSleepMode_1: (+1)
   \   00000030   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40007000
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x0006             MOVS     R6,R0
    627            
    628            /* Clear PDDS and LPDSR bits */
    629            tmpreg &= CR_DS_MASK;
   \   00000036   0x08B6             LSRS     R6,R6,#+2
   \   00000038   0x00B6             LSLS     R6,R6,#+2
    630            
    631            /* Set LPDSR bit according to PWR_Regulator value */
    632            tmpreg |= PWR_Regulator;
   \   0000003A   0x4326             ORRS     R6,R4,R6
    633            
    634            /* Store the new value */
    635            PWR->CR = tmpreg;
   \   0000003C   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40007000
   \   0000003E   0x6006             STR      R6,[R0, #+0]
    636          
    637            /* Clear SLEEPDEEP bit of Cortex System Control Register */
    638            SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP);
   \   00000040   0x....             LDR.N    R0,??DataTable12_7  ;; 0xe000ed10
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000048   0x....             LDR.N    R1,??DataTable12_7  ;; 0xe000ed10
   \   0000004A   0x6008             STR      R0,[R1, #+0]
    639            
    640            /* Select SLEEP mode entry -------------------------------------------------*/
    641            if(PWR_SLEEPEntry == PWR_SLEEPEntry_WFI)
   \   0000004C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004E   0x2D01             CMP      R5,#+1
   \   00000050   0xD101             BNE.N    ??PWR_EnterSleepMode_2
    642            {   
    643              /* Request Wait For Interrupt */
    644              __WFI();
   \   00000052   0xBF30             WFI      
   \   00000054   0xE000             B.N      ??PWR_EnterSleepMode_3
    645            }
    646            else
    647            {
    648              /* Request Wait For Event */
    649              __WFE();
   \                     ??PWR_EnterSleepMode_2: (+1)
   \   00000056   0xBF20             WFE      
    650            }
    651          }
   \                     ??PWR_EnterSleepMode_3: (+1)
   \   00000058   0xBD70             POP      {R4-R6,PC}       ;; return
    652          
    653          /**
    654            * @brief  Enters STOP mode.
    655            * @note   In Stop mode, all I/O pins keep the same state as in Run mode.
    656            * @note   When exiting Stop mode by issuing an interrupt or a wakeup event, 
    657            *         the MSI RC oscillator is selected as system clock.
    658            * @note   When the voltage regulator operates in low power mode, an additional 
    659            *         startup delay is incurred when waking up from Stop mode. 
    660            *         By keeping the internal regulator ON during Stop mode, the consumption 
    661            *         is higher although the startup time is reduced.              
    662            * @param  PWR_Regulator: specifies the regulator state in STOP mode.
    663            *   This parameter can be one of the following values:
    664            *     @arg PWR_Regulator_ON: STOP mode with regulator ON
    665            *     @arg PWR_Regulator_LowPower: STOP mode with regulator in low power mode
    666            * @param  PWR_STOPEntry: specifies if STOP mode in entered with WFI or WFE instruction.
    667            *   This parameter can be one of the following values:
    668            *     @arg PWR_STOPEntry_WFI: enter STOP mode with WFI instruction
    669            *     @arg PWR_STOPEntry_WFE: enter STOP mode with WFE instruction
    670            * @retval None
    671            */

   \                                 In section .text, align 2, keep-with-next
    672          void PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry)
    673          {
   \                     PWR_EnterSTOPMode: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    674            uint32_t tmpreg = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    675            
    676            /* Check the parameters */
    677            assert_param(IS_PWR_REGULATOR(PWR_Regulator));
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD006             BEQ.N    ??PWR_EnterSTOPMode_0
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD004             BEQ.N    ??PWR_EnterSTOPMode_0
   \   00000010   0xF240 0x21A5      MOVW     R1,#+677
   \   00000014   0x....             LDR.N    R0,??DataTable12
   \   00000016   0x.... 0x....      BL       assert_failed
    678            assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
   \                     ??PWR_EnterSTOPMode_0: (+1)
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D01             CMP      R5,#+1
   \   0000001E   0xD007             BEQ.N    ??PWR_EnterSTOPMode_1
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D02             CMP      R5,#+2
   \   00000024   0xD004             BEQ.N    ??PWR_EnterSTOPMode_1
   \   00000026   0xF240 0x21A6      MOVW     R1,#+678
   \   0000002A   0x....             LDR.N    R0,??DataTable12
   \   0000002C   0x.... 0x....      BL       assert_failed
    679            
    680            /* Select the regulator state in STOP mode ---------------------------------*/
    681            tmpreg = PWR->CR;
   \                     ??PWR_EnterSTOPMode_1: (+1)
   \   00000030   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40007000
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x0006             MOVS     R6,R0
    682            /* Clear PDDS and LPDSR bits */
    683            tmpreg &= CR_DS_MASK;
   \   00000036   0x08B6             LSRS     R6,R6,#+2
   \   00000038   0x00B6             LSLS     R6,R6,#+2
    684            
    685            /* Set LPDSR bit according to PWR_Regulator value */
    686            tmpreg |= PWR_Regulator;
   \   0000003A   0x4326             ORRS     R6,R4,R6
    687            
    688            /* Store the new value */
    689            PWR->CR = tmpreg;
   \   0000003C   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40007000
   \   0000003E   0x6006             STR      R6,[R0, #+0]
    690            
    691            /* Set SLEEPDEEP bit of Cortex System Control Register */
    692            SCB->SCR |= SCB_SCR_SLEEPDEEP;
   \   00000040   0x....             LDR.N    R0,??DataTable12_7  ;; 0xe000ed10
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000048   0x....             LDR.N    R1,??DataTable12_7  ;; 0xe000ed10
   \   0000004A   0x6008             STR      R0,[R1, #+0]
    693            
    694            /* Select STOP mode entry --------------------------------------------------*/
    695            if(PWR_STOPEntry == PWR_STOPEntry_WFI)
   \   0000004C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004E   0x2D01             CMP      R5,#+1
   \   00000050   0xD101             BNE.N    ??PWR_EnterSTOPMode_2
    696            {   
    697              /* Request Wait For Interrupt */
    698              __WFI();
   \   00000052   0xBF30             WFI      
   \   00000054   0xE000             B.N      ??PWR_EnterSTOPMode_3
    699            }
    700            else
    701            {
    702              /* Request Wait For Event */
    703              __WFE();
   \                     ??PWR_EnterSTOPMode_2: (+1)
   \   00000056   0xBF20             WFE      
    704            }
    705            /* Reset SLEEPDEEP bit of Cortex System Control Register */
    706            SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP);  
   \                     ??PWR_EnterSTOPMode_3: (+1)
   \   00000058   0x....             LDR.N    R0,??DataTable12_7  ;; 0xe000ed10
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000060   0x....             LDR.N    R1,??DataTable12_7  ;; 0xe000ed10
   \   00000062   0x6008             STR      R0,[R1, #+0]
    707          }
   \   00000064   0xBD70             POP      {R4-R6,PC}       ;; return
    708          
    709          /**
    710            * @brief  Enters STANDBY mode.
    711            * @note   In Standby mode, all I/O pins are high impedance except for:
    712            *          - Reset pad (still available) 
    713            *          - RTC_AF1 pin (PC13) if configured for Wakeup pin 2 (WKUP2), tamper, 
    714            *            time-stamp, RTC Alarm out, or RTC clock calibration out.
    715            *          - WKUP pin 1 (PA0) and WKUP pin 3 (PE6), if enabled.       
    716            * @param  None
    717            * @retval None
    718            */

   \                                 In section .text, align 2, keep-with-next
    719          void PWR_EnterSTANDBYMode(void)
    720          {
    721            /* Clear Wakeup flag */
    722            PWR->CR |= PWR_CR_CWUF;
   \                     PWR_EnterSTANDBYMode: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40007000
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000008   0x....             LDR.N    R1,??DataTable12_2  ;; 0x40007000
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    723            
    724            /* Select STANDBY mode */
    725            PWR->CR |= PWR_CR_PDDS;
   \   0000000C   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40007000
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000014   0x....             LDR.N    R1,??DataTable12_2  ;; 0x40007000
   \   00000016   0x6008             STR      R0,[R1, #+0]
    726            
    727            /* Set SLEEPDEEP bit of Cortex System Control Register */
    728            SCB->SCR |= SCB_SCR_SLEEPDEEP;
   \   00000018   0x....             LDR.N    R0,??DataTable12_7  ;; 0xe000ed10
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000020   0x....             LDR.N    R1,??DataTable12_7  ;; 0xe000ed10
   \   00000022   0x6008             STR      R0,[R1, #+0]
    729            
    730          /* This option is used to ensure that store operations are completed */
    731          #if defined ( __CC_ARM   )
    732            __force_stores();
    733          #endif
    734            /* Request Wait For Interrupt */
    735            __WFI();
   \   00000024   0xBF30             WFI      
    736          }
   \   00000026   0x4770             BX       LR               ;; return
    737          
    738          /**
    739            * @}
    740            */
    741          
    742          /** @defgroup PWR_Group7 Flags management functions
    743           *  @brief   Flags management functions 
    744           *
    745          @verbatim   
    746           ===============================================================================
    747                                     Flags management functions
    748           ===============================================================================  
    749          
    750          @endverbatim
    751            * @{
    752            */
    753          
    754          /**
    755            * @brief  Checks whether the specified PWR flag is set or not.
    756            * @param  PWR_FLAG: specifies the flag to check.
    757            *   This parameter can be one of the following values:
    758            *     @arg PWR_FLAG_WU: Wake Up flag. This flag indicates that a wakeup event 
    759            *       was received from the WKUP pin or from the RTC alarm (Alarm A or Alarm B), 
    760            *       RTC Tamper event, RTC TimeStamp event or RTC Wakeup.
    761            *     @arg PWR_FLAG_SB: StandBy flag. This flag indicates that the system was
    762            *                       resumed from StandBy mode.    
    763            *     @arg PWR_FLAG_PVDO: PVD Output. This flag is valid only if PVD is enabled 
    764            *       by the PWR_PVDCmd() function.
    765            *     @arg PWR_FLAG_VREFINTRDY: Internal Voltage Reference Ready flag. This 
    766            *       flag indicates the state of the internal voltage reference, VREFINT.
    767            *     @arg PWR_FLAG_VOS: Voltage Scaling select flag. A delay is required for 
    768            *       the internal regulator to be ready after the voltage range is changed.
    769            *       The VOSF flag indicates that the regulator has reached the voltage level 
    770            *       defined with bits VOS[1:0] of PWR_CR register.
    771            *     @arg PWR_FLAG_REGLP: Regulator LP flag. This flag is set by hardware 
    772            *       when the MCU is in Low power run mode.
    773            *       When the MCU exits from Low power run mode, this flag stays SET until 
    774            *       the regulator is ready in main mode. A polling on this flag is 
    775            *       recommended to wait for the regulator main mode. 
    776            *       This flag is RESET by hardware when the regulator is ready.       
    777            * @retval The new state of PWR_FLAG (SET or RESET).
    778            */

   \                                 In section .text, align 2, keep-with-next
    779          FlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG)
    780          {
   \                     PWR_GetFlagStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    781            FlagStatus bitstatus = RESET;
   \   00000004   0x2500             MOVS     R5,#+0
    782            /* Check the parameters */
    783            assert_param(IS_PWR_GET_FLAG(PWR_FLAG));
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD00E             BEQ.N    ??PWR_GetFlagStatus_0
   \   0000000A   0x2C02             CMP      R4,#+2
   \   0000000C   0xD00C             BEQ.N    ??PWR_GetFlagStatus_0
   \   0000000E   0x2C04             CMP      R4,#+4
   \   00000010   0xD00A             BEQ.N    ??PWR_GetFlagStatus_0
   \   00000012   0x2C08             CMP      R4,#+8
   \   00000014   0xD008             BEQ.N    ??PWR_GetFlagStatus_0
   \   00000016   0x2C10             CMP      R4,#+16
   \   00000018   0xD006             BEQ.N    ??PWR_GetFlagStatus_0
   \   0000001A   0x2C20             CMP      R4,#+32
   \   0000001C   0xD004             BEQ.N    ??PWR_GetFlagStatus_0
   \   0000001E   0xF240 0x310F      MOVW     R1,#+783
   \   00000022   0x....             LDR.N    R0,??DataTable12
   \   00000024   0x.... 0x....      BL       assert_failed
    784            
    785            if ((PWR->CSR & PWR_FLAG) != (uint32_t)RESET)
   \                     ??PWR_GetFlagStatus_0: (+1)
   \   00000028   0x....             LDR.N    R0,??DataTable12_8  ;; 0x40007004
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x4220             TST      R0,R4
   \   0000002E   0xD002             BEQ.N    ??PWR_GetFlagStatus_1
    786            {
    787              bitstatus = SET;
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x0005             MOVS     R5,R0
   \   00000034   0xE001             B.N      ??PWR_GetFlagStatus_2
    788            }
    789            else
    790            {
    791              bitstatus = RESET;
   \                     ??PWR_GetFlagStatus_1: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x0005             MOVS     R5,R0
    792            }
    793            /* Return the flag status */
    794            return bitstatus;
   \                     ??PWR_GetFlagStatus_2: (+1)
   \   0000003A   0x0028             MOVS     R0,R5
   \   0000003C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    795          }
    796          
    797          /**
    798            * @brief  Clears the PWR's pending flags.
    799            * @param  PWR_FLAG: specifies the flag to clear.
    800            *   This parameter can be one of the following values:
    801            *     @arg PWR_FLAG_WU: Wake Up flag
    802            *     @arg PWR_FLAG_SB: StandBy flag
    803            * @retval None
    804            */

   \                                 In section .text, align 2, keep-with-next
    805          void PWR_ClearFlag(uint32_t PWR_FLAG)
    806          {
   \                     PWR_ClearFlag: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    807            /* Check the parameters */
    808            assert_param(IS_PWR_CLEAR_FLAG(PWR_FLAG));
   \   00000004   0x2C01             CMP      R4,#+1
   \   00000006   0xD006             BEQ.N    ??PWR_ClearFlag_0
   \   00000008   0x2C02             CMP      R4,#+2
   \   0000000A   0xD004             BEQ.N    ??PWR_ClearFlag_0
   \   0000000C   0xF44F 0x714A      MOV      R1,#+808
   \   00000010   0x....             LDR.N    R0,??DataTable12
   \   00000012   0x.... 0x....      BL       assert_failed
    809                   
    810            PWR->CR |=  PWR_FLAG << 2;
   \                     ??PWR_ClearFlag_0: (+1)
   \   00000016   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40007000
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0xEA50 0x0084      ORRS     R0,R0,R4, LSL #+2
   \   0000001E   0x....             LDR.N    R1,??DataTable12_2  ;; 0x40007000
   \   00000020   0x6008             STR      R0,[R1, #+0]
    811          }
   \   00000022   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x420E0020         DC32     0x420e0020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0x40007000         DC32     0x40007000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   0x420E0010         DC32     0x420e0010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \   00000000   0x420E00A0         DC32     0x420e00a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \   00000000   0x420E0028         DC32     0x420e0028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_6:
   \   00000000   0x420E0024         DC32     0x420e0024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_7:
   \   00000000   0xE000ED10         DC32     0xe000ed10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_8:
   \   00000000   0x40007004         DC32     0x40007004

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x45 0x3A          DC8 45H, 3AH, 5CH, 41H, 43H, 51H, 5CH, 50H
   \              0x5C 0x41    
   \              0x43 0x51    
   \              0x5C 0x50    
   \   00000008   0x72 0x6F          DC8 72H, 6FH, 6AH, 5FH, 76H, 65H, 72H, 30H
   \              0x6A 0x5F    
   \              0x76 0x65    
   \              0x72 0x30    
   \   00000010   0x39 0x61          DC8 39H, 61H, 5FH, 31H, 35H, 31H, 30H, 32H
   \              0x5F 0x31    
   \              0x35 0x31    
   \              0x30 0x32    
   \   00000018   0x30 0x31          DC8 30H, 31H, 35H, 5CH, 45H, 6EH, 64H, 5FH
   \              0x35 0x5C    
   \              0x45 0x6E    
   \              0x64 0x5F    
   \   00000020   0x30 0x32          DC8 30H, 32H, 5CH, 32H, 30H, 31H, 33H, 5FH
   \              0x5C 0x32    
   \              0x30 0x31    
   \              0x33 0x5F    
   \   00000028   0x31 0x31          DC8 31H, 31H, 5FH, 32H, 35H, 5FH, 53H, 70H
   \              0x5F 0x32    
   \              0x35 0x5F    
   \              0x53 0x70    
   \   00000030   0x69 0x72          DC8 69H, 72H, 69H, 74H, 31H, 5FH, 45H, 6CH
   \              0x69 0x74    
   \              0x31 0x5F    
   \              0x45 0x6C    
   \   00000038   0x65 0x6B          DC8 65H, 6BH, 74H, 72H, 6FH, 6CH, 75H, 78H
   \              0x74 0x72    
   \              0x6F 0x6C    
   \              0x75 0x78    
   \   00000040   0x5C 0x53          DC8 5CH, 53H, 54H, 4DH, 33H, 32H, 4CH, 5CH
   \              0x54 0x4D    
   \              0x33 0x32    
   \              0x4C 0x5C    
   \   00000048   0x53 0x54          DC8 53H, 54H, 4DH, 33H, 32H, 4CH, 31H, 78H
   \              0x4D 0x33    
   \              0x32 0x4C    
   \              0x31 0x78    
   \   00000050   0x78 0x5F          DC8 78H, 5FH, 53H, 74H, 64H, 50H, 65H, 72H
   \              0x53 0x74    
   \              0x64 0x50    
   \              0x65 0x72    
   \   00000058   0x69 0x70          DC8 69H, 70H, 68H, 5FH, 4CH, 69H, 62H, 5CH
   \              0x68 0x5F    
   \              0x4C 0x69    
   \              0x62 0x5C    
   \   00000060   0x53 0x6F          DC8 53H, 6FH, 75H, 72H, 63H, 65H, 5CH, 53H
   \              0x75 0x72    
   \              0x63 0x65    
   \              0x5C 0x53    
   \   00000068   0x54 0x4D          DC8 54H, 4DH, 33H, 32H, 4CH, 31H, 78H, 78H
   \              0x33 0x32    
   \              0x4C 0x31    
   \              0x78 0x78    
   \   00000070   0x5F 0x53          DC8 5FH, 53H, 74H, 64H, 50H, 65H, 72H, 69H
   \              0x74 0x64    
   \              0x50 0x65    
   \              0x72 0x69    
   \   00000078   0x70 0x68          DC8 70H, 68H, 5FH, 44H, 72H, 69H, 76H, 65H
   \              0x5F 0x44    
   \              0x72 0x69    
   \              0x76 0x65    
   \   00000080   0x72 0x5C          DC8 72H, 5CH, 73H, 72H, 63H, 5CH, 73H, 74H
   \              0x73 0x72    
   \              0x63 0x5C    
   \              0x73 0x74    
   \   00000088   0x6D 0x33          DC8 6DH, 33H, 32H, 6CH, 31H, 78H, 78H, 5FH
   \              0x32 0x6C    
   \              0x31 0x78    
   \              0x78 0x5F    
   \   00000090   0x70 0x77          DC8 70H, 77H, 72H, 2EH, 63H, 0
   \              0x72 0x2E    
   \              0x63 0x00    
   \   00000096   0x00 0x00          DC8 0, 0
    812          
    813          /**
    814            * @}
    815            */
    816          
    817          /**
    818            * @}
    819            */
    820          
    821          /**
    822            * @}
    823            */
    824          
    825          /**
    826            * @}
    827            */
    828          
    829          /******************* (C) COPYRIGHT 2010 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   PWR_ClearFlag
         8   -> assert_failed
       8   PWR_DeInit
         8   -> RCC_APB1PeriphResetCmd
       8   PWR_EnterLowPowerRunMode
         8   -> assert_failed
       0   PWR_EnterSTANDBYMode
      16   PWR_EnterSTOPMode
        16   -> assert_failed
      16   PWR_EnterSleepMode
        16   -> assert_failed
       8   PWR_FastWakeUpCmd
         8   -> assert_failed
      16   PWR_GetFlagStatus
        16   -> assert_failed
       8   PWR_PVDCmd
         8   -> assert_failed
      16   PWR_PVDLevelConfig
        16   -> assert_failed
       8   PWR_RTCAccessCmd
         8   -> assert_failed
       8   PWR_UltraLowPowerCmd
         8   -> assert_failed
      16   PWR_VoltageScalingConfig
        16   -> assert_failed
      16   PWR_WakeUpPinCmd
        16   -> assert_failed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
     152  ?_0
      36  PWR_ClearFlag
      24  PWR_DeInit
      84  PWR_EnterLowPowerRunMode
      40  PWR_EnterSTANDBYMode
     102  PWR_EnterSTOPMode
      90  PWR_EnterSleepMode
      34  PWR_FastWakeUpCmd
      64  PWR_GetFlagStatus
      32  PWR_PVDCmd
      64  PWR_PVDLevelConfig
      32  PWR_RTCAccessCmd
      34  PWR_UltraLowPowerCmd
      56  PWR_VoltageScalingConfig
      64  PWR_WakeUpPinCmd

 
 152 bytes in section .rodata
 792 bytes in section .text
 
 792 bytes of CODE  memory
 152 bytes of CONST memory

Errors: none
Warnings: none
