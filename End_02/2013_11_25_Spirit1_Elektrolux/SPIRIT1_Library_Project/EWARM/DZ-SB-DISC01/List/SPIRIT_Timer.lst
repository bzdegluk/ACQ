###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        20/Nov/2015  05:04:46
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\SPIRIT1_Library\Source\src\SPIRIT_Timer.c
#    Command line =  
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\SPIRIT1_Library\Source\src\SPIRIT_Timer.c
#        -D USE_STDPERIPH_DRIVER -D VECT_TAB_FLASH -D STM32L1XX_MD -D
#        IAR_ARM_CM3 -D USE_FULL_ASSERT -D SPIRIT_USE_FULL_ASSERT -D
#        USE_SYSTICK_DELAY -D SDK -lC
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\List\
#        -o
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\.\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\examples\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\runtime\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\SDK_Eval_STM32L\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\SPIRIT1_Library\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\SDK_Eval_Util\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\SDK_Virtual_Com\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32_USB-FS-Device_Lib\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\ACQ\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\CMSIS\Include\"
#    List file    =  
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\List\SPIRIT_Timer.lst
#    Object file  =  
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\Obj\SPIRIT_Timer.o
#
###############################################################################

E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\SPIRIT1_Library\Source\src\SPIRIT_Timer.c
      1          /**
      2           * @file    SPIRIT_Timer.c
      3           * @author  High End Analog & RF BU - AMS / ART Team IMS-Systems Lab
      4           * @version V3.0.1
      5           * @date    November 19, 2012
      6           * @brief   Configuration and management of SPIRIT timers.
      7           * @details
      8           *
      9           * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     10           * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     11           * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     12           * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     13           * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     14           * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     15           *
     16           * THIS SOURCE CODE IS PROTECTED BY A LICENSE.
     17           * FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED
     18           * IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
     19           *
     20           * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     21           */
     22          
     23          
     24          /* Includes ------------------------------------------------------------------*/
     25          #include "SPIRIT_Timer.h"
     26          #include "SPIRIT_Radio.h"
     27          #include "MCU_Interface.h"
     28          
     29          
     30          
     31          
     32          /**
     33           * @addtogroup SPIRIT_Libraries
     34           * @{
     35           */
     36          
     37          
     38          /**
     39           * @addtogroup SPIRIT_Timer
     40           * @{
     41           */
     42          
     43          
     44          /**
     45           * @defgroup Timer_Private_TypesDefinitions             Timer Private Types Definitions
     46           * @{
     47           */
     48          
     49          /**
     50           *@}
     51           */
     52          
     53          
     54          /**
     55           * @defgroup Timer_Private_Defines                      Timer Private Defines
     56           * @{
     57           */
     58          
     59          /**
     60           *@}
     61           */
     62          
     63          
     64          /**
     65           * @defgroup Timer_Private_Macros                       Timer Private Macros
     66           * @{
     67           */
     68          
     69          
     70          /**
     71           *@}
     72           */
     73          
     74          
     75          /**
     76           * @defgroup Timer_Private_Variables                    Timer Private Variables
     77           * @{
     78           */
     79          
     80          /**
     81           *@}
     82           */
     83          
     84          
     85          /**
     86           * @defgroup Timer_Private_FunctionPrototypes            Timer Private Function Prototypes
     87           * @{
     88           */
     89          
     90          /**
     91           *@}
     92           */
     93          
     94          
     95          /**
     96           * @defgroup Timer_Private_Functions                    Timer Private Functions
     97           * @{
     98           */
     99          
    100          /**
    101           * @brief  Enables or Disables the LDCR mode.
    102           * @param  xNewState new state for LDCR mode.
    103           *         This parameter can be: S_ENABLE or S_DISABLE.
    104           * @retval None.
    105           */

   \                                 In section .text, align 2, keep-with-next
    106          void SpiritTimerLdcrMode(SpiritFunctionalState xNewState)
    107          {
   \                     SpiritTimerLdcrMode: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    108            uint8_t tempRegValue;
    109          
    110            /* Reads the register value */
    111            g_xStatus = SpiritSpiReadRegisters(PROTOCOL2_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2050             MOVS     R0,#+80
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000014   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000018   0x8001             STRH     R1,[R0, #+0]
    112          
    113            /* Mask the read value to enable or disable the LDC mode */
    114            if(xNewState==S_ENABLE)
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x2C01             CMP      R4,#+1
   \   0000001E   0xD106             BNE.N    ??SpiritTimerLdcrMode_0
    115            {
    116              tempRegValue |= PROTOCOL2_LDC_MODE_MASK;
   \   00000020   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000024   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000028   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000002C   0xE005             B.N      ??SpiritTimerLdcrMode_1
    117            }
    118            else
    119            {
    120              tempRegValue &= ~PROTOCOL2_LDC_MODE_MASK;
   \                     ??SpiritTimerLdcrMode_0: (+1)
   \   0000002E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000032   0xF010 0x00FE      ANDS     R0,R0,#0xFE
   \   00000036   0xF88D 0x0000      STRB     R0,[SP, #+0]
    121            }
    122          
    123            /* Writes the register to Enable or Disable the LDCR mode */
    124            g_xStatus = SpiritSpiWriteRegisters(PROTOCOL2_BASE, 1, &tempRegValue);
   \                     ??SpiritTimerLdcrMode_1: (+1)
   \   0000003A   0xAA00             ADD      R2,SP,#+0
   \   0000003C   0x2101             MOVS     R1,#+1
   \   0000003E   0x2050             MOVS     R0,#+80
   \   00000040   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000044   0x9001             STR      R0,[SP, #+4]
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable21
   \   0000004A   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   0000004E   0x8001             STRH     R1,[R0, #+0]
    125          
    126          }
   \   00000050   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    127          
    128          
    129          /**
    130           * @brief  Enables or Disables the LDCR timer reloading with the value stored in the LDCR_RELOAD registers.
    131           * @param  xNewState new state for LDCR reloading.
    132           *         This parameter can be: S_ENABLE or S_DISABLE.
    133           * @retval None.
    134           */

   \                                 In section .text, align 2, keep-with-next
    135          void SpiritTimerLdcrAutoReload(SpiritFunctionalState xNewState)
    136          {
   \                     SpiritTimerLdcrAutoReload: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    137            uint8_t tempRegValue;
    138          
    139            /* Reads the register value */
    140            g_xStatus = SpiritSpiReadRegisters(PROTOCOL1_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2051             MOVS     R0,#+81
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000014   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000018   0x8001             STRH     R1,[R0, #+0]
    141          
    142            /* Mask te read value to enable or disable the reload on sync mode */
    143            if(xNewState==S_ENABLE)
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x2C01             CMP      R4,#+1
   \   0000001E   0xD106             BNE.N    ??SpiritTimerLdcrAutoReload_0
    144            {
    145              tempRegValue |= PROTOCOL1_LDC_RELOAD_ON_SYNC_MASK;
   \   00000020   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000024   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000028   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000002C   0xE005             B.N      ??SpiritTimerLdcrAutoReload_1
    146            }
    147            else
    148            {
    149              tempRegValue &= ~PROTOCOL1_LDC_RELOAD_ON_SYNC_MASK;
   \                     ??SpiritTimerLdcrAutoReload_0: (+1)
   \   0000002E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000032   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   00000036   0xF88D 0x0000      STRB     R0,[SP, #+0]
    150            }
    151          
    152            /* Writes the register to Enable or Disable the Auto Reload */
    153            g_xStatus = SpiritSpiWriteRegisters(PROTOCOL1_BASE, 1, &tempRegValue);
   \                     ??SpiritTimerLdcrAutoReload_1: (+1)
   \   0000003A   0xAA00             ADD      R2,SP,#+0
   \   0000003C   0x2101             MOVS     R1,#+1
   \   0000003E   0x2051             MOVS     R0,#+81
   \   00000040   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000044   0x9001             STR      R0,[SP, #+4]
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable21
   \   0000004A   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   0000004E   0x8001             STRH     R1,[R0, #+0]
    154          
    155          }
   \   00000050   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    156          
    157          
    158          /**
    159           * @brief  Returns the LDCR timer reload bit.
    160           * @param  None.
    161           * @retval SpiritFunctionalState: value of the reload bit.
    162           */

   \                                 In section .text, align 2, keep-with-next
    163          SpiritFunctionalState SpiritTimerLdcrGetAutoReload(void)
    164          {
   \                     SpiritTimerLdcrGetAutoReload: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    165            uint8_t tempRegValue;
    166          
    167            /* Reads the register value */
    168            g_xStatus = SpiritSpiReadRegisters(PROTOCOL1_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2051             MOVS     R0,#+81
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000014   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000018   0x8001             STRH     R1,[R0, #+0]
    169          
    170            return (SpiritFunctionalState)(tempRegValue & 0x80);
   \   0000001A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001E   0xF010 0x0080      ANDS     R0,R0,#0x80
   \   00000022   0xBD0E             POP      {R1-R3,PC}       ;; return
    171          
    172          }
    173          
    174          /**
    175           * @brief  Sets the RX timeout timer initialization registers with the values of COUNTER and PRESCALER according to the formula: Trx=PRESCALER*COUNTER*Tck.
    176           *         Remember that it is possible to have infinite RX_Timeout writing 0 in the RX_Timeout_Counter and/or RX_Timeout_Prescaler registers.
    177           * @param  cCounter value for the timer counter.
    178           *         This parameter must be an uint8_t.
    179           * @param  cPrescaler value for the timer prescaler.
    180           *         This parameter must be an uint8_t.
    181           * @retval None.
    182           */

   \                                 In section .text, align 2, keep-with-next
    183          void SpiritTimerSetRxTimeout(uint8_t cCounter , uint8_t cPrescaler)
    184          {
   \                     SpiritTimerSetRxTimeout: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    185            uint8_t tempRegValue[2]={cPrescaler,cCounter};
   \   00000008   0xF88D 0x5000      STRB     R5,[SP, #+0]
   \   0000000C   0xF88D 0x4001      STRB     R4,[SP, #+1]
    186          
    187            /* Writes the prescaler and counter value for RX timeout in the corresponding register */
    188            g_xStatus = SpiritSpiWriteRegisters(TIMERS5_RX_TIMEOUT_PRESCALER_BASE, 2, tempRegValue);
   \   00000010   0xAA00             ADD      R2,SP,#+0
   \   00000012   0x2102             MOVS     R1,#+2
   \   00000014   0x2053             MOVS     R0,#+83
   \   00000016   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   0000001A   0x9001             STR      R0,[SP, #+4]
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000020   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000024   0x8001             STRH     R1,[R0, #+0]
    189          
    190          }
   \   00000026   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    191          
    192          
    193          /**
    194           * @brief  Sets the RX timeout timer counter and prescaler from the desired value in ms. it is possible to fix the RX_Timeout to
    195           *         a minimum value of 50.417us to a maximum value of about 3.28 s.
    196           * @param  fDesiredMsec desired timer value.
    197           *         This parameter must be a float.
    198           * @retval None
    199           */
    200          

   \                                 In section .text, align 2, keep-with-next
    201          void SpiritTimerSetRxTimeoutMs(float fDesiredMsec)
    202          {
   \                     SpiritTimerSetRxTimeoutMs: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    203            uint8_t tempRegValue[2];
    204          
    205            /* Computes the counter and prescaler value */
    206            SpiritTimerComputeRxTimeoutValues(fDesiredMsec , &tempRegValue[1] , &tempRegValue[0]);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0xF10D 0x0101      ADD      R1,SP,#+1
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       SpiritTimerComputeRxTimeoutValues
    207          
    208            /* Writes the prescaler and counter value for RX timeout in the corresponding register */
    209            g_xStatus = SpiritSpiWriteRegisters(TIMERS5_RX_TIMEOUT_PRESCALER_BASE, 2, tempRegValue);
   \   00000010   0xAA00             ADD      R2,SP,#+0
   \   00000012   0x2102             MOVS     R1,#+2
   \   00000014   0x2053             MOVS     R0,#+83
   \   00000016   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   0000001A   0x9001             STR      R0,[SP, #+4]
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000020   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000024   0x8001             STRH     R1,[R0, #+0]
    210          
    211          }
   \   00000026   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    212          
    213          
    214          /**
    215           * @brief  Sets the RX timeout timer counter. If it is equal to 0 the timeout is infinite.
    216           * @param  cCounter value for the timer counter.
    217           *         This parameter must be an uint8_t.
    218           * @retval None.
    219           */

   \                                 In section .text, align 2, keep-with-next
    220          void SpiritTimerSetRxTimeoutCounter(uint8_t cCounter)
    221          {
   \                     SpiritTimerSetRxTimeoutCounter: (+1)
   \   00000000   0xB501             PUSH     {R0,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    222            /* Writes the counter value for RX timeout in the corresponding register */
    223            g_xStatus = SpiritSpiWriteRegisters(TIMERS4_RX_TIMEOUT_COUNTER_BASE, 1, &cCounter);
   \   00000004   0xAA02             ADD      R2,SP,#+8
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2054             MOVS     R0,#+84
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   0000000E   0x9000             STR      R0,[SP, #+0]
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000014   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   00000018   0x8001             STRH     R1,[R0, #+0]
    224          
    225          }
   \   0000001A   0xBD07             POP      {R0-R2,PC}       ;; return
    226          
    227          
    228          /**
    229           * @brief  Sets the RX timeout timer prescaler. If it is equal to 0 the timeout is infinite.
    230           * @param  cPrescaler value for the timer prescaler.
    231           *         This parameter must be an uint8_t.
    232           * @retval None
    233           */

   \                                 In section .text, align 2, keep-with-next
    234          void SpiritTimerSetRxTimeoutPrescaler(uint8_t cPrescaler)
    235          {
   \                     SpiritTimerSetRxTimeoutPrescaler: (+1)
   \   00000000   0xB501             PUSH     {R0,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    236            /* Writes the prescaler value for RX timeout in the corresponding register */
    237            g_xStatus = SpiritSpiWriteRegisters(TIMERS5_RX_TIMEOUT_PRESCALER_BASE, 1, &cPrescaler);
   \   00000004   0xAA02             ADD      R2,SP,#+8
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2053             MOVS     R0,#+83
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   0000000E   0x9000             STR      R0,[SP, #+0]
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000014   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   00000018   0x8001             STRH     R1,[R0, #+0]
    238          
    239          }
   \   0000001A   0xBD07             POP      {R0-R2,PC}       ;; return
    240          
    241          
    242          /**
    243           * @brief  Returns the RX timeout timer.
    244           * @param  pfTimeoutMsec pointer to the variable in which the timeout expressed in milliseconds has to be stored.
    245           *         If the returned value is 0, it means that the RX_Timeout is infinite.
    246           *         This parameter must be a float*.
    247           * @param  pcCounter pointer to the variable in which the timer counter has to be stored.
    248           *         This parameter must be an uint8_t*.
    249           * @param  pcPrescaler pointer to the variable in which the timer prescaler has to be stored.
    250           *         This parameter must be an uint8_t*.
    251           * @retval None.
    252           */

   \                                 In section .text, align 2, keep-with-next
    253          void SpiritTimerGetRxTimeout(float* pfTimeoutMsec, uint8_t* pcCounter , uint8_t* pcPrescaler)
    254          {
   \                     SpiritTimerGetRxTimeout: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
    255            uint8_t tempRegValue[2];
    256          
    257            /* Reads the RX timeout registers value */
    258            g_xStatus = SpiritSpiReadRegisters(TIMERS5_RX_TIMEOUT_PRESCALER_BASE, 2, tempRegValue);
   \   0000000C   0xAA00             ADD      R2,SP,#+0
   \   0000000E   0x2102             MOVS     R1,#+2
   \   00000010   0x2053             MOVS     R0,#+83
   \   00000012   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   00000016   0x9001             STR      R0,[SP, #+4]
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable21
   \   0000001C   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000020   0x8001             STRH     R1,[R0, #+0]
    259          
    260            /* Returns values */
    261            (*pcPrescaler) = tempRegValue[0];
   \   00000022   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000026   0x7030             STRB     R0,[R6, #+0]
    262            (*pcCounter) = tempRegValue[1];
   \   00000028   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000002C   0x7028             STRB     R0,[R5, #+0]
    263              
    264            float nXtalFrequency = (float)SpiritRadioGetXtalFrequency();
   \   0000002E   0x.... 0x....      BL       SpiritRadioGetXtalFrequency
   \   00000032   0x.... 0x....      BL       __aeabi_ui2f
   \   00000036   0x0007             MOVS     R7,R0
    265            if(nXtalFrequency>26000000) {
   \   00000038   0x0038             MOVS     R0,R7
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable21_1  ;; 0x4bc65d41
   \   0000003E   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000042   0xD80A             BHI.N    ??SpiritTimerGetRxTimeout_0
    266              nXtalFrequency /= 2.0;
   \   00000044   0x0038             MOVS     R0,R7
   \   00000046   0x.... 0x....      BL       __aeabi_f2d
   \   0000004A   0x2200             MOVS     R2,#+0
   \   0000004C   0xF05F 0x4380      MOVS     R3,#+1073741824
   \   00000050   0x.... 0x....      BL       __aeabi_ddiv
   \   00000054   0x.... 0x....      BL       __aeabi_d2f
   \   00000058   0x0007             MOVS     R7,R0
    267            }
    268            nXtalFrequency /= 1000.0;
   \                     ??SpiritTimerGetRxTimeout_0: (+1)
   \   0000005A   0x0038             MOVS     R0,R7
   \   0000005C   0x.... 0x....      BL       __aeabi_f2d
   \   00000060   0x2200             MOVS     R2,#+0
   \   00000062   0x.... 0x....      LDR.W    R3,??DataTable21_2  ;; 0x408f4000
   \   00000066   0x.... 0x....      BL       __aeabi_ddiv
   \   0000006A   0x.... 0x....      BL       __aeabi_d2f
   \   0000006E   0x0007             MOVS     R7,R0
    269            *pfTimeoutMsec = (float)((tempRegValue[0]+1)*tempRegValue[1]*(1210.0/nXtalFrequency));
   \   00000070   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000074   0x1C40             ADDS     R0,R0,#+1
   \   00000076   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \   0000007A   0x4348             MULS     R0,R1,R0
   \   0000007C   0x.... 0x....      BL       __aeabi_i2d
   \   00000080   0x4680             MOV      R8,R0
   \   00000082   0x4689             MOV      R9,R1
   \   00000084   0x0038             MOVS     R0,R7
   \   00000086   0x.... 0x....      BL       __aeabi_f2d
   \   0000008A   0x0002             MOVS     R2,R0
   \   0000008C   0x000B             MOVS     R3,R1
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x.... 0x....      LDR.W    R1,??DataTable21_3  ;; 0x4092e800
   \   00000094   0x.... 0x....      BL       __aeabi_ddiv
   \   00000098   0x4642             MOV      R2,R8
   \   0000009A   0x464B             MOV      R3,R9
   \   0000009C   0x.... 0x....      BL       __aeabi_dmul
   \   000000A0   0x.... 0x....      BL       __aeabi_d2f
   \   000000A4   0x6020             STR      R0,[R4, #+0]
    270            
    271          
    272          }
   \   000000A6   0xE8BD 0x83F7      POP      {R0-R2,R4-R9,PC}  ;; return
    273          
    274          
    275          /**
    276           * @brief  Sets the LDCR wake up timer initialization registers with the values of
    277           *         COUNTER and PRESCALER according to the formula: Twu=(PRESCALER +1)*(COUNTER+1)*Tck, where
    278           *         Tck = 28.818 us. The minimum vale of the wakeup timeout is 28.818us (PRESCALER and
    279           *         COUNTER equals to 0) and the maximum value is about 1.89 s (PRESCALER anc COUNTER equals
    280           *         to 255).
    281           * @param  cCounter value for the timer counter.
    282           *         This parameter must be an uint8_t.
    283           * @param  cPrescaler value for the timer prescaler.
    284           *         This parameter must be an uint8_t.
    285           * @retval None.
    286           */

   \                                 In section .text, align 2, keep-with-next
    287          void SpiritTimerSetWakeUpTimer(uint8_t cCounter , uint8_t cPrescaler)
    288          {
   \                     SpiritTimerSetWakeUpTimer: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    289            uint8_t tempRegValue[2]={cPrescaler,cCounter};
   \   00000008   0xF88D 0x5000      STRB     R5,[SP, #+0]
   \   0000000C   0xF88D 0x4001      STRB     R4,[SP, #+1]
    290          
    291            /* Writes the counter and prescaler value of wake-up timer in the corresponding register */
    292            g_xStatus = SpiritSpiWriteRegisters(TIMERS3_LDC_PRESCALER_BASE, 2, tempRegValue);
   \   00000010   0xAA00             ADD      R2,SP,#+0
   \   00000012   0x2102             MOVS     R1,#+2
   \   00000014   0x2055             MOVS     R0,#+85
   \   00000016   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   0000001A   0x9001             STR      R0,[SP, #+4]
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000020   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000024   0x8001             STRH     R1,[R0, #+0]
    293          
    294          }
   \   00000026   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    295          
    296          
    297          /**
    298           * @brief  Sets the LDCR wake up timer counter and prescaler from the desired value in ms,
    299           *         according to the formula: Twu=(PRESCALER +1)*(COUNTER+1)*Tck, where Tck = 28.818 us.
    300           *         The minimum vale of the wakeup timeout is 28.818us (PRESCALER and COUNTER equals to 0)
    301           *         and the maximum value is about 1.89 s (PRESCALER anc COUNTER equals to 255).
    302           * @param  fDesiredMsec desired timer value.
    303           *         This parameter must be a float.
    304           * @retval None.
    305           */

   \                                 In section .text, align 2, keep-with-next
    306          void SpiritTimerSetWakeUpTimerMs(float fDesiredMsec)
    307          {
   \                     SpiritTimerSetWakeUpTimerMs: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    308            uint8_t tempRegValue[2];
    309          
    310            /* Computes counter and prescaler */
    311            SpiritTimerComputeWakeUpValues(fDesiredMsec , &tempRegValue[1] , &tempRegValue[0]);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0xF10D 0x0101      ADD      R1,SP,#+1
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       SpiritTimerComputeWakeUpValues
    312          
    313            /* Writes the counter and prescaler value of wake-up timer in the corresponding register */
    314            g_xStatus = SpiritSpiWriteRegisters(TIMERS3_LDC_PRESCALER_BASE, 2, tempRegValue);
   \   00000010   0xAA00             ADD      R2,SP,#+0
   \   00000012   0x2102             MOVS     R1,#+2
   \   00000014   0x2055             MOVS     R0,#+85
   \   00000016   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   0000001A   0x9001             STR      R0,[SP, #+4]
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000020   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000024   0x8001             STRH     R1,[R0, #+0]
    315          
    316          }
   \   00000026   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    317          
    318          
    319          /**
    320           * @brief  Sets the LDCR wake up timer counter. Remember that this value is incresead by one in the Twu calculation.
    321           *         Twu=(PRESCALER +1)*(COUNTER+1)*Tck, where Tck = 28.818 us
    322           * @param  cCounter value for the timer counter.
    323           *         This parameter must be an uint8_t.
    324           * @retval None.
    325           */

   \                                 In section .text, align 2, keep-with-next
    326          void SpiritTimerSetWakeUpTimerCounter(uint8_t cCounter)
    327          {
   \                     SpiritTimerSetWakeUpTimerCounter: (+1)
   \   00000000   0xB501             PUSH     {R0,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    328            /* Writes the counter value for Wake_Up timer in the corresponding register */
    329            g_xStatus = SpiritSpiWriteRegisters(TIMERS2_LDC_COUNTER_BASE, 1, &cCounter);
   \   00000004   0xAA02             ADD      R2,SP,#+8
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2056             MOVS     R0,#+86
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   0000000E   0x9000             STR      R0,[SP, #+0]
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000014   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   00000018   0x8001             STRH     R1,[R0, #+0]
    330          
    331          }
   \   0000001A   0xBD07             POP      {R0-R2,PC}       ;; return
    332          
    333          
    334          /**
    335           * @brief  Sets the LDCR wake up timer prescaler. Remember that this value is incresead by one in the Twu calculation.
    336           *         Twu=(PRESCALER +1)*(COUNTER+1)*Tck, where Tck = 28.818 us
    337           * @param  cPrescaler value for the timer prescaler.
    338           *         This parameter must be an uint8_t.
    339           * @retval None.
    340           */

   \                                 In section .text, align 2, keep-with-next
    341          void SpiritTimerSetWakeUpTimerPrescaler(uint8_t cPrescaler)
    342          {
   \                     SpiritTimerSetWakeUpTimerPrescaler: (+1)
   \   00000000   0xB501             PUSH     {R0,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    343            /* Writes the prescaler value for Wake_Up timer in the corresponding register */
    344            g_xStatus = SpiritSpiWriteRegisters(TIMERS3_LDC_PRESCALER_BASE, 1, &cPrescaler);
   \   00000004   0xAA02             ADD      R2,SP,#+8
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2055             MOVS     R0,#+85
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   0000000E   0x9000             STR      R0,[SP, #+0]
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000014   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   00000018   0x8001             STRH     R1,[R0, #+0]
    345          
    346          }
   \   0000001A   0xBD07             POP      {R0-R2,PC}       ;; return
    347          
    348          
    349          /**
    350           * @brief  Returns the LDCR wake up timer, according to the formula: Twu=(PRESCALER +1)*(COUNTER+1)*Tck, where Tck = 28.818 us.
    351           * @param  pfWakeUpMsec pointer to the variable in which the wake-up time expressed in milliseconds has to be stored.
    352           *         This parameter must be a float*.
    353           * @param  pcCounter pointer to the variable in which the timer counter has to be stored.
    354           *         This parameter must be an uint8_t*.
    355           * @param  pcPrescaler pointer to the variable in which the timer prescaler has to be stored.
    356           *         This parameter must be an uint8_t*.
    357           * @retval None.
    358           */

   \                                 In section .text, align 2, keep-with-next
    359          void SpiritTimerGetWakeUpTimer(float* pfWakeUpMsec, uint8_t* pcCounter , uint8_t* pcPrescaler)
    360          {
   \                     SpiritTimerGetWakeUpTimer: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    361            uint8_t tempRegValue[2];
    362          
    363            /* Reads the Wake_Up timer registers value */
    364            g_xStatus = SpiritSpiReadRegisters(TIMERS3_LDC_PRESCALER_BASE, 2, tempRegValue);
   \   00000008   0xAA00             ADD      R2,SP,#+0
   \   0000000A   0x2102             MOVS     R1,#+2
   \   0000000C   0x2055             MOVS     R0,#+85
   \   0000000E   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   00000012   0x9001             STR      R0,[SP, #+4]
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000018   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   0000001C   0x8001             STRH     R1,[R0, #+0]
    365          
    366            /* Returns values */
    367            (*pcPrescaler)=tempRegValue[0];
   \   0000001E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000022   0x7030             STRB     R0,[R6, #+0]
    368            (*pcCounter)=tempRegValue[1];
   \   00000024   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000028   0x7028             STRB     R0,[R5, #+0]
    369            *pfWakeUpMsec = (float)((((*pcPrescaler)+2)*((*pcCounter)+2)*(1000.0/34.7)));
   \   0000002A   0x7830             LDRB     R0,[R6, #+0]
   \   0000002C   0x1C80             ADDS     R0,R0,#+2
   \   0000002E   0x7829             LDRB     R1,[R5, #+0]
   \   00000030   0x1C89             ADDS     R1,R1,#+2
   \   00000032   0x4348             MULS     R0,R1,R0
   \   00000034   0x.... 0x....      BL       __aeabi_i2d
   \   00000038   0x.... 0x....      LDR.W    R2,??DataTable21_4  ;; 0x887bf13e
   \   0000003C   0x.... 0x....      LDR.W    R3,??DataTable21_5  ;; 0x403cd185
   \   00000040   0x.... 0x....      BL       __aeabi_dmul
   \   00000044   0x.... 0x....      BL       __aeabi_d2f
   \   00000048   0x6020             STR      R0,[R4, #+0]
    370          
    371          }
   \   0000004A   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    372          
    373          
    374          /**
    375           * @brief  Sets the LDCR wake up timer reloading registers with the values of
    376           *         COUNTER and PRESCALER according to the formula: Twu=(PRESCALER +1)*(COUNTER+1)*Tck, where
    377           *         Tck = 28.818 us. The minimum vale of the wakeup timeout is 28.818us (PRESCALER and
    378           *         COUNTER equals to 0) and the maximum value is about 1.89 s (PRESCALER anc COUNTER equals
    379           *         to 255).
    380           * @param  cCounter reload value for the timer counter.
    381           *         This parameter must be an uint8_t.
    382           * @param  cPrescaler reload value for the timer prescaler.
    383           *         This parameter must be an uint8_t.
    384           * @retval None.
    385           */

   \                                 In section .text, align 2, keep-with-next
    386          void SpiritTimerSetWakeUpTimerReload(uint8_t cCounter , uint8_t cPrescaler)
    387          {
   \                     SpiritTimerSetWakeUpTimerReload: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    388            uint8_t tempRegValue[2]={cPrescaler,cCounter};
   \   00000008   0xF88D 0x5000      STRB     R5,[SP, #+0]
   \   0000000C   0xF88D 0x4001      STRB     R4,[SP, #+1]
    389          
    390            /* Writes the counter and prescaler value of reload wake-up timer in the corresponding register */
    391            g_xStatus = SpiritSpiWriteRegisters(TIMERS1_LDC_RELOAD_PRESCALER_BASE, 2, tempRegValue);
   \   00000010   0xAA00             ADD      R2,SP,#+0
   \   00000012   0x2102             MOVS     R1,#+2
   \   00000014   0x2057             MOVS     R0,#+87
   \   00000016   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   0000001A   0x9001             STR      R0,[SP, #+4]
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000020   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000024   0x8001             STRH     R1,[R0, #+0]
    392          
    393          }
   \   00000026   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    394          
    395          
    396          /**
    397           * @brief  Sets the LDCR wake up reload timer counter and prescaler from the desired value in ms,
    398           *         according to the formula: Twu=(PRESCALER +1)*(COUNTER+1)*Tck, where Tck = 28.818 us.
    399           *         The minimum vale of the wakeup timeout is 28.818us (PRESCALER and COUNTER equals to 0)
    400           *         and the maximum value is about 1.89 s (PRESCALER anc COUNTER equals to 255).
    401           * @param  fDesiredMsec desired timer value.
    402           *         This parameter must be a float.
    403           * @retval None.
    404           */

   \                                 In section .text, align 2, keep-with-next
    405          void SpiritTimerSetWakeUpTimerReloadMs(float fDesiredMsec)
    406          {
   \                     SpiritTimerSetWakeUpTimerReloadMs: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    407            uint8_t tempRegValue[2];
    408          
    409            /* Computes counter and prescaler */
    410            SpiritTimerComputeWakeUpValues(fDesiredMsec , &tempRegValue[1] , &tempRegValue[0]);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0xF10D 0x0101      ADD      R1,SP,#+1
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       SpiritTimerComputeWakeUpValues
    411          
    412            /* Writes the counter and prescaler value of reload wake-up timer in the corresponding register */
    413            g_xStatus = SpiritSpiWriteRegisters(TIMERS1_LDC_RELOAD_PRESCALER_BASE, 2, tempRegValue);
   \   00000010   0xAA00             ADD      R2,SP,#+0
   \   00000012   0x2102             MOVS     R1,#+2
   \   00000014   0x2057             MOVS     R0,#+87
   \   00000016   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   0000001A   0x9001             STR      R0,[SP, #+4]
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000020   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000024   0x8001             STRH     R1,[R0, #+0]
    414          
    415          }
   \   00000026   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    416          
    417          
    418          /**
    419           * @brief  Sets the LDCR wake up timer reload counter. Remember that this value is incresead by one in the Twu calculation.
    420           *         Twu=(PRESCALER +1)*(COUNTER+1)*Tck, where Tck = 28.818 us
    421           * @param  cCounter value for the timer counter.
    422           *         This parameter must be an uint8_t.
    423           * @retval None
    424           */

   \                                 In section .text, align 2, keep-with-next
    425          void SpiritTimerSetWakeUpTimerReloadCounter(uint8_t cCounter)
    426          {
   \                     SpiritTimerSetWakeUpTimerReloadCounter: (+1)
   \   00000000   0xB501             PUSH     {R0,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    427            /* Writes the counter value for reload Wake_Up timer in the corresponding register */
    428            g_xStatus = SpiritSpiWriteRegisters(TIMERS0_LDC_RELOAD_COUNTER_BASE, 1, &cCounter);
   \   00000004   0xAA02             ADD      R2,SP,#+8
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2058             MOVS     R0,#+88
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   0000000E   0x9000             STR      R0,[SP, #+0]
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000014   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   00000018   0x8001             STRH     R1,[R0, #+0]
    429          
    430          }
   \   0000001A   0xBD07             POP      {R0-R2,PC}       ;; return
    431          
    432          
    433          /**
    434           * @brief  Sets the LDCR wake up timer reload prescaler. Remember that this value is incresead by one in the Twu calculation.
    435           *         Twu=(PRESCALER +1)*(COUNTER+1)*Tck, where Tck = 28.818 us
    436           * @param  cPrescaler value for the timer prescaler.
    437           *         This parameter must be an uint8_t.
    438           * @retval None
    439           */

   \                                 In section .text, align 2, keep-with-next
    440          void SpiritTimerSetWakeUpTimerReloadPrescaler(uint8_t cPrescaler)
    441          {
   \                     SpiritTimerSetWakeUpTimerReloadPrescaler: (+1)
   \   00000000   0xB501             PUSH     {R0,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    442            /* Writes the prescaler value for reload Wake_Up timer in the corresponding register */
    443            g_xStatus = SpiritSpiWriteRegisters(TIMERS1_LDC_RELOAD_PRESCALER_BASE, 1, &cPrescaler);
   \   00000004   0xAA02             ADD      R2,SP,#+8
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2057             MOVS     R0,#+87
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   0000000E   0x9000             STR      R0,[SP, #+0]
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000014   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   00000018   0x8001             STRH     R1,[R0, #+0]
    444          
    445          }
   \   0000001A   0xBD07             POP      {R0-R2,PC}       ;; return
    446          
    447          
    448          /**
    449           * @brief  Returns the LDCR wake up reload timer, according to the formula: Twu=(PRESCALER +1)*(COUNTER+1)*Tck, where Tck = 28.818 us.
    450           * @param  pfWakeUpReloadMsec pointer to the variable in which the wake-up reload time expressed in milliseconds has to be stored.
    451           *         This parameter must be a float*.
    452           * @param  pcCounter pointer to the variable in which the timer counter has to be stored.
    453           *         This parameter must be an uint8_t*.
    454           * @param  pcPrescaler pointer to the variable in which the timer prescaler has to be stored.
    455           *         This parameter must be an uint8_t*.
    456           * @retval None.
    457           */

   \                                 In section .text, align 2, keep-with-next
    458          void SpiritTimerGetWakeUpTimerReload(float* pfWakeUpReloadMsec, uint8_t* pcCounter , uint8_t* pcPrescaler)
    459          {
   \                     SpiritTimerGetWakeUpTimerReload: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    460            uint8_t tempRegValue[2];
    461          
    462            /* Reads the reload Wake_Up timer registers value */
    463            g_xStatus = SpiritSpiReadRegisters(TIMERS1_LDC_RELOAD_PRESCALER_BASE, 2, tempRegValue);
   \   00000008   0xAA00             ADD      R2,SP,#+0
   \   0000000A   0x2102             MOVS     R1,#+2
   \   0000000C   0x2057             MOVS     R0,#+87
   \   0000000E   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   00000012   0x9001             STR      R0,[SP, #+4]
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000018   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   0000001C   0x8001             STRH     R1,[R0, #+0]
    464          
    465            /* Returns values */
    466            (*pcPrescaler)=tempRegValue[0];
   \   0000001E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000022   0x7030             STRB     R0,[R6, #+0]
    467            (*pcCounter)=tempRegValue[1];
   \   00000024   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000028   0x7028             STRB     R0,[R5, #+0]
    468            *pfWakeUpReloadMsec = (float)((((*pcPrescaler)+2)*((*pcCounter)+2)*(1000.0/34.7)));
   \   0000002A   0x7830             LDRB     R0,[R6, #+0]
   \   0000002C   0x1C80             ADDS     R0,R0,#+2
   \   0000002E   0x7829             LDRB     R1,[R5, #+0]
   \   00000030   0x1C89             ADDS     R1,R1,#+2
   \   00000032   0x4348             MULS     R0,R1,R0
   \   00000034   0x.... 0x....      BL       __aeabi_i2d
   \   00000038   0x....             LDR.N    R2,??DataTable21_4  ;; 0x887bf13e
   \   0000003A   0x....             LDR.N    R3,??DataTable21_5  ;; 0x403cd185
   \   0000003C   0x.... 0x....      BL       __aeabi_dmul
   \   00000040   0x.... 0x....      BL       __aeabi_d2f
   \   00000044   0x6020             STR      R0,[R4, #+0]
    469          
    470          }
   \   00000046   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    471          
    472          
    473          /**
    474           * @brief  Computes the values of the wakeup timer counter and prescaler from the user time expressed in millisecond.
    475           *         The prescaler and the counter values are computed maintaining the prescaler value as
    476           *         small as possible in order to obtain the best resolution, and in the meantime minimizing the error.
    477           * @param  fDesiredMsec desired wakeup timeout in millisecs.
    478           *         This parameter must be a float. Since the counter and prescaler are 8 bit registers the maximum
    479           *         reachable value is maxTime = fTclk x 256 x 256.
    480           * @param  pcCounter pointer to the variable in which the value for the wakeup timer counter has to be stored.
    481           *         This parameter must be a uint8_t*.
    482           * @param  pcPrescaler pointer to the variable in which the value for the wakeup timer prescaler has to be stored.
    483           *         This parameter must be an uint8_t*.
    484           * @retval None
    485           */
    486          

   \                                 In section .text, align 2, keep-with-next
    487          void SpiritTimerComputeWakeUpValues(float fDesiredMsec , uint8_t* pcCounter , uint8_t* pcPrescaler)
    488          {
   \                     SpiritTimerComputeWakeUpValues: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4683             MOV      R11,R0
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x0015             MOVS     R5,R2
    489            uint8_t b0, a0;
    490            uint32_t n;
    491            int32_t err, err_min;
    492            
    493            /* If the desired value is over the maximum limit, the counter and the
    494            prescaler are settled to their maximum values, and doesn't execute the routine */
    495            if(fDesiredMsec>1903.0)
   \   0000000A   0x4658             MOV      R0,R11
   \   0000000C   0x....             LDR.N    R1,??DataTable21_6  ;; 0x44ede001
   \   0000000E   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000012   0xD804             BHI.N    ??SpiritTimerComputeWakeUpValues_0
    496            {
    497              *pcCounter = 0xFF;
   \   00000014   0x20FF             MOVS     R0,#+255
   \   00000016   0x7020             STRB     R0,[R4, #+0]
    498              *pcPrescaler = 0xFF;
   \   00000018   0x20FF             MOVS     R0,#+255
   \   0000001A   0x7028             STRB     R0,[R5, #+0]
    499              return;
   \   0000001C   0xE073             B.N      ??SpiritTimerComputeWakeUpValues_1
    500            }
    501            else
    502            {
    503              n = (uint32_t)(fDesiredMsec*34.7);
   \                     ??SpiritTimerComputeWakeUpValues_0: (+1)
   \   0000001E   0x4658             MOV      R0,R11
   \   00000020   0x.... 0x....      BL       __aeabi_f2d
   \   00000024   0x....             LDR.N    R2,??DataTable21_7  ;; 0x9999999a
   \   00000026   0x....             LDR.N    R3,??DataTable21_8  ;; 0x40415999
   \   00000028   0x.... 0x....      BL       __aeabi_dmul
   \   0000002C   0x.... 0x....      BL       __aeabi_d2uiz
   \   00000030   0x0006             MOVS     R6,R0
    504              err_min = n;
   \   00000032   0x46B1             MOV      R9,R6
    505              /* These are the initial values for the prescaler and the counter, where the prescaler
    506              is settled to the minimum value and the counter accordingly. In order to avoid a zero
    507              division for the counter the prescaler is increased by one. Then because the wakeup timeout
    508              is calculated as: Twu=(PRESCALER +1)*(COUNTER+1)*Tck the counter and the prescaler are decreased by one.*/
    509              *pcPrescaler = a0 = (n/0xFF);
   \   00000034   0x20FF             MOVS     R0,#+255
   \   00000036   0xFBB6 0xF0F0      UDIV     R0,R6,R0
   \   0000003A   0x4682             MOV      R10,R0
   \   0000003C   0xF885 0xA000      STRB     R10,[R5, #+0]
    510               if(a0==0)
   \   00000040   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000044   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000048   0xD104             BNE.N    ??SpiritTimerComputeWakeUpValues_2
    511                *pcCounter = b0 = 0;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x4680             MOV      R8,R0
   \   0000004E   0xF884 0x8000      STRB     R8,[R4, #+0]
   \   00000052   0xE006             B.N      ??SpiritTimerComputeWakeUpValues_3
    512              else
    513                *pcCounter = b0 = (n / *pcPrescaler)-2;
   \                     ??SpiritTimerComputeWakeUpValues_2: (+1)
   \   00000054   0x7828             LDRB     R0,[R5, #+0]
   \   00000056   0xFBB6 0xF0F0      UDIV     R0,R6,R0
   \   0000005A   0x1E80             SUBS     R0,R0,#+2
   \   0000005C   0x4680             MOV      R8,R0
   \   0000005E   0xF884 0x8000      STRB     R8,[R4, #+0]
    514              
    515              /* Iterative cycle to minimize the error */
    516              for (; ; (*pcPrescaler)++)
    517              {
    518                *pcCounter = ((n/(*pcPrescaler+2))-2);
   \                     ??SpiritTimerComputeWakeUpValues_3: (+1)
   \   00000062   0x7828             LDRB     R0,[R5, #+0]
   \   00000064   0x1C80             ADDS     R0,R0,#+2
   \   00000066   0xFBB6 0xF0F0      UDIV     R0,R6,R0
   \   0000006A   0x1E80             SUBS     R0,R0,#+2
   \   0000006C   0x7020             STRB     R0,[R4, #+0]
    519                err = (((uint32_t)(*pcPrescaler)+0) * ((uint32_t)*pcCounter)+0) - (uint32_t)n;
   \   0000006E   0x7828             LDRB     R0,[R5, #+0]
   \   00000070   0x7821             LDRB     R1,[R4, #+0]
   \   00000072   0x4348             MULS     R0,R1,R0
   \   00000074   0x1B80             SUBS     R0,R0,R6
   \   00000076   0x0007             MOVS     R7,R0
    520                if ((uint32_t)S_ABS(err) > (uint32_t)(*pcPrescaler / 2))
   \   00000078   0x2F01             CMP      R7,#+1
   \   0000007A   0xDB01             BLT.N    ??SpiritTimerComputeWakeUpValues_4
   \   0000007C   0x0038             MOVS     R0,R7
   \   0000007E   0xE000             B.N      ??SpiritTimerComputeWakeUpValues_5
   \                     ??SpiritTimerComputeWakeUpValues_4: (+1)
   \   00000080   0x4278             RSBS     R0,R7,#+0
   \                     ??SpiritTimerComputeWakeUpValues_5: (+1)
   \   00000082   0x7829             LDRB     R1,[R5, #+0]
   \   00000084   0x2202             MOVS     R2,#+2
   \   00000086   0xFB91 0xF1F2      SDIV     R1,R1,R2
   \   0000008A   0x4281             CMP      R1,R0
   \   0000008C   0xD207             BCS.N    ??SpiritTimerComputeWakeUpValues_6
    521                {
    522                  (*pcCounter)++;
   \   0000008E   0x7820             LDRB     R0,[R4, #+0]
   \   00000090   0x1C40             ADDS     R0,R0,#+1
   \   00000092   0x7020             STRB     R0,[R4, #+0]
    523                  err = (((uint32_t)(*pcPrescaler)+0) * ((uint32_t)*pcCounter)+0) - (uint32_t)n;
   \   00000094   0x7828             LDRB     R0,[R5, #+0]
   \   00000096   0x7821             LDRB     R1,[R4, #+0]
   \   00000098   0x4348             MULS     R0,R1,R0
   \   0000009A   0x1B80             SUBS     R0,R0,R6
   \   0000009C   0x0007             MOVS     R7,R0
    524                }
    525                if (S_ABS(err) < S_ABS(err_min))
   \                     ??SpiritTimerComputeWakeUpValues_6: (+1)
   \   0000009E   0x2F01             CMP      R7,#+1
   \   000000A0   0xDB01             BLT.N    ??SpiritTimerComputeWakeUpValues_7
   \   000000A2   0x0038             MOVS     R0,R7
   \   000000A4   0xE000             B.N      ??SpiritTimerComputeWakeUpValues_8
   \                     ??SpiritTimerComputeWakeUpValues_7: (+1)
   \   000000A6   0x4278             RSBS     R0,R7,#+0
   \                     ??SpiritTimerComputeWakeUpValues_8: (+1)
   \   000000A8   0xF1B9 0x0F01      CMP      R9,#+1
   \   000000AC   0xDB01             BLT.N    ??SpiritTimerComputeWakeUpValues_9
   \   000000AE   0x4649             MOV      R1,R9
   \   000000B0   0xE001             B.N      ??SpiritTimerComputeWakeUpValues_10
   \                     ??SpiritTimerComputeWakeUpValues_9: (+1)
   \   000000B2   0xF1D9 0x0100      RSBS     R1,R9,#+0
   \                     ??SpiritTimerComputeWakeUpValues_10: (+1)
   \   000000B6   0x4288             CMP      R0,R1
   \   000000B8   0xDA06             BGE.N    ??SpiritTimerComputeWakeUpValues_11
    526                {
    527                  err_min = err;
   \   000000BA   0x46B9             MOV      R9,R7
    528                  a0 = *pcPrescaler;
   \   000000BC   0x7828             LDRB     R0,[R5, #+0]
   \   000000BE   0x4682             MOV      R10,R0
    529                  b0 = *pcCounter;
   \   000000C0   0x7820             LDRB     R0,[R4, #+0]
   \   000000C2   0x4680             MOV      R8,R0
    530                  if (err == 0) 
   \   000000C4   0x2F00             CMP      R7,#+0
   \   000000C6   0xD006             BEQ.N    ??SpiritTimerComputeWakeUpValues_12
    531                  {
    532                    break;
    533                  }
    534                }
    535                if(*pcPrescaler == 0xFF) 
   \                     ??SpiritTimerComputeWakeUpValues_11: (+1)
   \   000000C8   0x7828             LDRB     R0,[R5, #+0]
   \   000000CA   0x28FF             CMP      R0,#+255
   \   000000CC   0xD003             BEQ.N    ??SpiritTimerComputeWakeUpValues_12
    536                {
    537                  break;
    538                }
    539              }
   \                     ??SpiritTimerComputeWakeUpValues_13: (+1)
   \   000000CE   0x7828             LDRB     R0,[R5, #+0]
   \   000000D0   0x1C40             ADDS     R0,R0,#+1
   \   000000D2   0x7028             STRB     R0,[R5, #+0]
   \   000000D4   0xE7C5             B.N      ??SpiritTimerComputeWakeUpValues_3
    540              if(a0==0)
   \                     ??SpiritTimerComputeWakeUpValues_12: (+1)
   \   000000D6   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000DA   0xF1BA 0x0F00      CMP      R10,#+0
   \   000000DE   0xD101             BNE.N    ??SpiritTimerComputeWakeUpValues_14
    541                a0=1;
   \   000000E0   0x2001             MOVS     R0,#+1
   \   000000E2   0x4682             MOV      R10,R0
    542              if(b0==0 || b0==1)
   \                     ??SpiritTimerComputeWakeUpValues_14: (+1)
   \   000000E4   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000E8   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000EC   0xD004             BEQ.N    ??SpiritTimerComputeWakeUpValues_15
   \   000000EE   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000F2   0xF1B8 0x0F01      CMP      R8,#+1
   \   000000F6   0xD101             BNE.N    ??SpiritTimerComputeWakeUpValues_16
    543                b0=2;
   \                     ??SpiritTimerComputeWakeUpValues_15: (+1)
   \   000000F8   0x2002             MOVS     R0,#+2
   \   000000FA   0x4680             MOV      R8,R0
    544              
    545              *pcPrescaler = a0;
   \                     ??SpiritTimerComputeWakeUpValues_16: (+1)
   \   000000FC   0xF885 0xA000      STRB     R10,[R5, #+0]
    546              *pcCounter = b0-1;
   \   00000100   0xF1B8 0x0001      SUBS     R0,R8,#+1
   \   00000104   0x7020             STRB     R0,[R4, #+0]
    547            }
    548          
    549          }
   \                     ??SpiritTimerComputeWakeUpValues_1: (+1)
   \   00000106   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
    550          
    551          /**
    552           * @brief  Computes the values of the rx_timeout timer counter and prescaler from the user time expressed in millisecond.
    553           *         The prescaler and the counter values are computed maintaining the prescaler value as
    554           *         small as possible in order to obtain the best resolution, and in the meantime minimizing the error.
    555           * @param  fDesiredMsec desired rx_timeout in millisecs.
    556           *         This parameter must be a float. Since the counter and prescaler are 8 bit registers the maximum
    557           *         reachable value is maxTime = fTclk x 255 x 255.
    558           * @param  pcCounter pointer to the variable in which the value for the rx_timeout counter has to be stored.
    559           *         This parameter must be a uint8_t*.
    560           * @param  pcPrescaler pointer to the variable in which the value for the rx_timeout prescaler has to be stored.
    561           *         This parameter must be an uint8_t*.
    562           * @retval None
    563           */

   \                                 In section .text, align 2, keep-with-next
    564          void SpiritTimerComputeRxTimeoutValues(float fDesiredMsec , uint8_t* pcCounter , uint8_t* pcPrescaler)
    565          {
   \                     SpiritTimerComputeRxTimeoutValues: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    566            uint32_t nXtalFrequency = SpiritRadioGetXtalFrequency();
   \   0000000A   0x.... 0x....      BL       SpiritRadioGetXtalFrequency
   \   0000000E   0x0007             MOVS     R7,R0
    567            if(nXtalFrequency>26000000) {
   \   00000010   0x....             LDR.N    R0,??DataTable21_9  ;; 0x18cba81
   \   00000012   0x4287             CMP      R7,R0
   \   00000014   0xD300             BCC.N    ??SpiritTimerComputeRxTimeoutValues_0
    568              nXtalFrequency >>= 1;
   \   00000016   0x087F             LSRS     R7,R7,#+1
    569            }
    570            
    571            /* If the desired value is over the maximum limit, the counter and the
    572            prescaler are settled to their maximum values, and doesn't execute the routine */
    573            if(fDesiredMsec>3291.0 && nXtalFrequency==24000000 || fDesiredMsec>3159.0 && nXtalFrequency==25000000 || fDesiredMsec>3038.0 && nXtalFrequency==26000000)
   \                     ??SpiritTimerComputeRxTimeoutValues_0: (+1)
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x....             LDR.N    R1,??DataTable21_10  ;; 0x454db001
   \   0000001C   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000020   0xD802             BHI.N    ??SpiritTimerComputeRxTimeoutValues_1
   \   00000022   0x....             LDR.N    R0,??DataTable21_11  ;; 0x16e3600
   \   00000024   0x4287             CMP      R7,R0
   \   00000026   0xD00F             BEQ.N    ??SpiritTimerComputeRxTimeoutValues_2
   \                     ??SpiritTimerComputeRxTimeoutValues_1: (+1)
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0x....             LDR.N    R1,??DataTable21_12  ;; 0x45457001
   \   0000002C   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000030   0xD802             BHI.N    ??SpiritTimerComputeRxTimeoutValues_3
   \   00000032   0x....             LDR.N    R0,??DataTable21_13  ;; 0x17d7840
   \   00000034   0x4287             CMP      R7,R0
   \   00000036   0xD007             BEQ.N    ??SpiritTimerComputeRxTimeoutValues_2
   \                     ??SpiritTimerComputeRxTimeoutValues_3: (+1)
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x....             LDR.N    R1,??DataTable21_14  ;; 0x453de001
   \   0000003C   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000040   0xD807             BHI.N    ??SpiritTimerComputeRxTimeoutValues_4
   \   00000042   0x....             LDR.N    R0,??DataTable21_15  ;; 0x18cba80
   \   00000044   0x4287             CMP      R7,R0
   \   00000046   0xD104             BNE.N    ??SpiritTimerComputeRxTimeoutValues_4
    574            {
    575              *pcCounter = 0xFF;
   \                     ??SpiritTimerComputeRxTimeoutValues_2: (+1)
   \   00000048   0x20FF             MOVS     R0,#+255
   \   0000004A   0x7028             STRB     R0,[R5, #+0]
    576              *pcPrescaler = 0xFF;
   \   0000004C   0x20FF             MOVS     R0,#+255
   \   0000004E   0x7030             STRB     R0,[R6, #+0]
    577              return;
   \   00000050   0xE082             B.N      ??SpiritTimerComputeRxTimeoutValues_5
    578            }
    579            else
    580            {
    581              float FPeriod = 1210.0 / (nXtalFrequency/1000000);
   \                     ??SpiritTimerComputeRxTimeoutValues_4: (+1)
   \   00000052   0x....             LDR.N    R0,??DataTable21_16  ;; 0xf4240
   \   00000054   0xFBB7 0xF0F0      UDIV     R0,R7,R0
   \   00000058   0x.... 0x....      BL       __aeabi_ui2d
   \   0000005C   0x0002             MOVS     R2,R0
   \   0000005E   0x000B             MOVS     R3,R1
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x....             LDR.N    R1,??DataTable21_3  ;; 0x4092e800
   \   00000064   0x.... 0x....      BL       __aeabi_ddiv
   \   00000068   0x.... 0x....      BL       __aeabi_d2f
   \   0000006C   0x4680             MOV      R8,R0
    582          
    583              uint8_t b0, a0;
    584              uint32_t n = (uint32_t)((fDesiredMsec*1000)/FPeriod);
   \   0000006E   0x....             LDR.N    R0,??DataTable21_17  ;; 0x447a0000
   \   00000070   0x0021             MOVS     R1,R4
   \   00000072   0x.... 0x....      BL       __aeabi_fmul
   \   00000076   0x4641             MOV      R1,R8
   \   00000078   0x.... 0x....      BL       __aeabi_fdiv
   \   0000007C   0x.... 0x....      BL       __aeabi_f2uiz
    585              int32_t err, err_min;
    586              
    587              err_min = n;
   \   00000080   0x0002             MOVS     R2,R0
    588              /* These are the initial values for the prescaler and the counter, where the prescaler
    589              is settled to the minimum value and the counter accordingly. In order to avoid a zero
    590              division for the counter the prescaler is increased by one.*/
    591              
    592              *pcPrescaler = a0 = (uint8_t)((n-1)/0xFF);
   \   00000082   0x1E43             SUBS     R3,R0,#+1
   \   00000084   0xF04F 0x0CFF      MOV      R12,#+255
   \   00000088   0xFBB3 0xF3FC      UDIV     R3,R3,R12
   \   0000008C   0x469A             MOV      R10,R3
   \   0000008E   0xF886 0xA000      STRB     R10,[R6, #+0]
    593              if(a0==0)
   \   00000092   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000096   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000009A   0xD104             BNE.N    ??SpiritTimerComputeRxTimeoutValues_6
    594                *pcCounter = b0 = 0;
   \   0000009C   0x2300             MOVS     R3,#+0
   \   0000009E   0x4699             MOV      R9,R3
   \   000000A0   0xF885 0x9000      STRB     R9,[R5, #+0]
   \   000000A4   0xE006             B.N      ??SpiritTimerComputeRxTimeoutValues_7
    595              else
    596                *pcCounter = b0 = (uint8_t)(n / *pcPrescaler)-1;
   \                     ??SpiritTimerComputeRxTimeoutValues_6: (+1)
   \   000000A6   0x7833             LDRB     R3,[R6, #+0]
   \   000000A8   0xFBB0 0xF3F3      UDIV     R3,R0,R3
   \   000000AC   0x1E5B             SUBS     R3,R3,#+1
   \   000000AE   0x4699             MOV      R9,R3
   \   000000B0   0xF885 0x9000      STRB     R9,[R5, #+0]
    597          
    598              for (; ; (*pcPrescaler)++)
    599              {
    600                *pcCounter = (uint8_t)(n / *pcPrescaler)-1;
   \                     ??SpiritTimerComputeRxTimeoutValues_7: (+1)
   \   000000B4   0x7833             LDRB     R3,[R6, #+0]
   \   000000B6   0xFBB0 0xF3F3      UDIV     R3,R0,R3
   \   000000BA   0x1E5B             SUBS     R3,R3,#+1
   \   000000BC   0x702B             STRB     R3,[R5, #+0]
    601                err = (((uint32_t)(*pcPrescaler)+1) * ((uint32_t)*pcCounter)) - (uint32_t)n;
   \   000000BE   0x7833             LDRB     R3,[R6, #+0]
   \   000000C0   0x1C5B             ADDS     R3,R3,#+1
   \   000000C2   0xF895 0xC000      LDRB     R12,[R5, #+0]
   \   000000C6   0xFB0C 0xF303      MUL      R3,R12,R3
   \   000000CA   0x1A1B             SUBS     R3,R3,R0
   \   000000CC   0x0019             MOVS     R1,R3
    602          
    603                if ((uint32_t)S_ABS(err) > (uint32_t)(*pcPrescaler / 2))
   \   000000CE   0x2901             CMP      R1,#+1
   \   000000D0   0xDB01             BLT.N    ??SpiritTimerComputeRxTimeoutValues_8
   \   000000D2   0x000B             MOVS     R3,R1
   \   000000D4   0xE000             B.N      ??SpiritTimerComputeRxTimeoutValues_9
   \                     ??SpiritTimerComputeRxTimeoutValues_8: (+1)
   \   000000D6   0x424B             RSBS     R3,R1,#+0
   \                     ??SpiritTimerComputeRxTimeoutValues_9: (+1)
   \   000000D8   0xF896 0xC000      LDRB     R12,[R6, #+0]
   \   000000DC   0xF05F 0x0E02      MOVS     LR,#+2
   \   000000E0   0xFB9C 0xFCFE      SDIV     R12,R12,LR
   \   000000E4   0x459C             CMP      R12,R3
   \   000000E6   0xD20A             BCS.N    ??SpiritTimerComputeRxTimeoutValues_10
    604                {
    605                  (*pcCounter)++;
   \   000000E8   0x782B             LDRB     R3,[R5, #+0]
   \   000000EA   0x1C5B             ADDS     R3,R3,#+1
   \   000000EC   0x702B             STRB     R3,[R5, #+0]
    606                  err = (((uint32_t)(*pcPrescaler)+1) * ((uint32_t)*pcCounter)) - (uint32_t)n;
   \   000000EE   0x7833             LDRB     R3,[R6, #+0]
   \   000000F0   0x1C5B             ADDS     R3,R3,#+1
   \   000000F2   0xF895 0xC000      LDRB     R12,[R5, #+0]
   \   000000F6   0xFB0C 0xF303      MUL      R3,R12,R3
   \   000000FA   0x1A1B             SUBS     R3,R3,R0
   \   000000FC   0x0019             MOVS     R1,R3
    607                }
    608                if (S_ABS(err) < S_ABS(err_min))
   \                     ??SpiritTimerComputeRxTimeoutValues_10: (+1)
   \   000000FE   0x2901             CMP      R1,#+1
   \   00000100   0xDB01             BLT.N    ??SpiritTimerComputeRxTimeoutValues_11
   \   00000102   0x000B             MOVS     R3,R1
   \   00000104   0xE000             B.N      ??SpiritTimerComputeRxTimeoutValues_12
   \                     ??SpiritTimerComputeRxTimeoutValues_11: (+1)
   \   00000106   0x424B             RSBS     R3,R1,#+0
   \                     ??SpiritTimerComputeRxTimeoutValues_12: (+1)
   \   00000108   0x2A01             CMP      R2,#+1
   \   0000010A   0xDB01             BLT.N    ??SpiritTimerComputeRxTimeoutValues_13
   \   0000010C   0x4694             MOV      R12,R2
   \   0000010E   0xE001             B.N      ??SpiritTimerComputeRxTimeoutValues_14
   \                     ??SpiritTimerComputeRxTimeoutValues_13: (+1)
   \   00000110   0xF1D2 0x0C00      RSBS     R12,R2,#+0
   \                     ??SpiritTimerComputeRxTimeoutValues_14: (+1)
   \   00000114   0x4563             CMP      R3,R12
   \   00000116   0xDA06             BGE.N    ??SpiritTimerComputeRxTimeoutValues_15
    609                {
    610                  err_min = err;
   \   00000118   0x000A             MOVS     R2,R1
    611                  a0 = *pcPrescaler;
   \   0000011A   0x7833             LDRB     R3,[R6, #+0]
   \   0000011C   0x469A             MOV      R10,R3
    612                  b0 = *pcCounter;
   \   0000011E   0x782B             LDRB     R3,[R5, #+0]
   \   00000120   0x4699             MOV      R9,R3
    613                  if (err_min == 0) 
   \   00000122   0x2A00             CMP      R2,#+0
   \   00000124   0xD006             BEQ.N    ??SpiritTimerComputeRxTimeoutValues_16
    614                  {
    615                    break;
    616                  }
    617                }
    618                if(*pcPrescaler == (0xFF-1)) 
   \                     ??SpiritTimerComputeRxTimeoutValues_15: (+1)
   \   00000126   0x7833             LDRB     R3,[R6, #+0]
   \   00000128   0x2BFE             CMP      R3,#+254
   \   0000012A   0xD003             BEQ.N    ??SpiritTimerComputeRxTimeoutValues_16
    619                {
    620                  break;
    621                }
    622              }
   \                     ??SpiritTimerComputeRxTimeoutValues_17: (+1)
   \   0000012C   0x7833             LDRB     R3,[R6, #+0]
   \   0000012E   0x1C5B             ADDS     R3,R3,#+1
   \   00000130   0x7033             STRB     R3,[R6, #+0]
   \   00000132   0xE7BF             B.N      ??SpiritTimerComputeRxTimeoutValues_7
    623          
    624              if(a0==0)
   \                     ??SpiritTimerComputeRxTimeoutValues_16: (+1)
   \   00000134   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000138   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000013C   0xD101             BNE.N    ??SpiritTimerComputeRxTimeoutValues_18
    625                a0=1;
   \   0000013E   0x2301             MOVS     R3,#+1
   \   00000140   0x469A             MOV      R10,R3
    626              if(b0==0)
   \                     ??SpiritTimerComputeRxTimeoutValues_18: (+1)
   \   00000142   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000146   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000014A   0xD101             BNE.N    ??SpiritTimerComputeRxTimeoutValues_19
    627                b0=1;
   \   0000014C   0x2301             MOVS     R3,#+1
   \   0000014E   0x4699             MOV      R9,R3
    628              
    629              *pcPrescaler = a0;
   \                     ??SpiritTimerComputeRxTimeoutValues_19: (+1)
   \   00000150   0xF886 0xA000      STRB     R10,[R6, #+0]
    630              *pcCounter = b0;
   \   00000154   0xF885 0x9000      STRB     R9,[R5, #+0]
    631            }
    632          }
   \                     ??SpiritTimerComputeRxTimeoutValues_5: (+1)
   \   00000158   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    633          
    634          /**
    635           * @brief  Sets the RX timeout stop conditions.
    636           * @param  xStopCondition new stop condition.
    637           *         This parameter can be any value of @ref RxTimeoutStopCondition.
    638           * @retval None
    639           */

   \                                 In section .text, align 2, keep-with-next
    640          void SpiritTimerSetRxTimeoutStopCondition(RxTimeoutStopCondition xStopCondition)
    641          {
   \                     SpiritTimerSetRxTimeoutStopCondition: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    642            uint8_t tempRegValue[2];
    643          
    644            /* Check the parameters */
    645            s_assert_param(IS_RX_TIMEOUT_STOP_CONDITION(xStopCondition));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD028             BEQ.N    ??SpiritTimerSetRxTimeoutStopCondition_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C08             CMP      R4,#+8
   \   0000000E   0xD025             BEQ.N    ??SpiritTimerSetRxTimeoutStopCondition_0
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C04             CMP      R4,#+4
   \   00000014   0xD022             BEQ.N    ??SpiritTimerSetRxTimeoutStopCondition_0
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0x2C02             CMP      R4,#+2
   \   0000001A   0xD01F             BEQ.N    ??SpiritTimerSetRxTimeoutStopCondition_0
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x2C01             CMP      R4,#+1
   \   00000020   0xD01C             BEQ.N    ??SpiritTimerSetRxTimeoutStopCondition_0
   \   00000022   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000024   0x2C06             CMP      R4,#+6
   \   00000026   0xD019             BEQ.N    ??SpiritTimerSetRxTimeoutStopCondition_0
   \   00000028   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002A   0x2C05             CMP      R4,#+5
   \   0000002C   0xD016             BEQ.N    ??SpiritTimerSetRxTimeoutStopCondition_0
   \   0000002E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000030   0x2C03             CMP      R4,#+3
   \   00000032   0xD013             BEQ.N    ??SpiritTimerSetRxTimeoutStopCondition_0
   \   00000034   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000036   0x2C07             CMP      R4,#+7
   \   00000038   0xD010             BEQ.N    ??SpiritTimerSetRxTimeoutStopCondition_0
   \   0000003A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003C   0x2C0E             CMP      R4,#+14
   \   0000003E   0xD00D             BEQ.N    ??SpiritTimerSetRxTimeoutStopCondition_0
   \   00000040   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000042   0x2C0D             CMP      R4,#+13
   \   00000044   0xD00A             BEQ.N    ??SpiritTimerSetRxTimeoutStopCondition_0
   \   00000046   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000048   0x2C0B             CMP      R4,#+11
   \   0000004A   0xD007             BEQ.N    ??SpiritTimerSetRxTimeoutStopCondition_0
   \   0000004C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004E   0x2C0F             CMP      R4,#+15
   \   00000050   0xD004             BEQ.N    ??SpiritTimerSetRxTimeoutStopCondition_0
   \   00000052   0xF240 0x2185      MOVW     R1,#+645
   \   00000056   0x....             LDR.N    R0,??DataTable21_18
   \   00000058   0x.... 0x....      BL       s_assert_failed
    646          
    647            /* Reads value on the PKT_FLT_OPTIONS and PROTOCOL2 register */
    648            g_xStatus = SpiritSpiReadRegisters(PCKT_FLT_OPTIONS_BASE, 2, tempRegValue);
   \                     ??SpiritTimerSetRxTimeoutStopCondition_0: (+1)
   \   0000005C   0xAA00             ADD      R2,SP,#+0
   \   0000005E   0x2102             MOVS     R1,#+2
   \   00000060   0x204F             MOVS     R0,#+79
   \   00000062   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   00000066   0x9001             STR      R0,[SP, #+4]
   \   00000068   0x....             LDR.N    R0,??DataTable21
   \   0000006A   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   0000006E   0x8001             STRH     R1,[R0, #+0]
    649          
    650            tempRegValue[0] &= 0xBF;
   \   00000070   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000074   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   00000078   0xF88D 0x0000      STRB     R0,[SP, #+0]
    651            tempRegValue[0] |= ((xStopCondition & 0x08)  << 3);
   \   0000007C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000080   0xF014 0x0108      ANDS     R1,R4,#0x8
   \   00000084   0xEA50 0x00C1      ORRS     R0,R0,R1, LSL #+3
   \   00000088   0xF88D 0x0000      STRB     R0,[SP, #+0]
    652          
    653            tempRegValue[1] &= 0x1F;
   \   0000008C   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000090   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   00000094   0xF88D 0x0001      STRB     R0,[SP, #+1]
    654            tempRegValue[1] |= (xStopCondition << 5);
   \   00000098   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000009C   0xEA50 0x1044      ORRS     R0,R0,R4, LSL #+5
   \   000000A0   0xF88D 0x0001      STRB     R0,[SP, #+1]
    655          
    656            /* Writes value on the PKT_FLT_OPTIONS and PROTOCOL2 register */
    657            g_xStatus = SpiritSpiWriteRegisters(PCKT_FLT_OPTIONS_BASE, 2, tempRegValue);
   \   000000A4   0xAA00             ADD      R2,SP,#+0
   \   000000A6   0x2102             MOVS     R1,#+2
   \   000000A8   0x204F             MOVS     R0,#+79
   \   000000AA   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   000000AE   0x9001             STR      R0,[SP, #+4]
   \   000000B0   0x....             LDR.N    R0,??DataTable21
   \   000000B2   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   000000B6   0x8001             STRH     R1,[R0, #+0]
    658          
    659          }
   \   000000B8   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    660          
    661          /**
    662           * @brief  Sends the LDC_RELOAD command to SPIRIT. Reload the LDC timer with the value stored in the LDC_PRESCALER / COUNTER registers.
    663           * @param  None.
    664           * @retval None
    665           */

   \                                 In section .text, align 2, keep-with-next
    666          void SpiritTimerReloadStrobe(void)
    667          {
   \                     SpiritTimerReloadStrobe: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    668            /* Sends the CMD_LDC_RELOAD command */
    669            g_xStatus = SpiritSpiCommandStrobes(COMMAND_LDC_RELOAD);
   \   00000002   0x2068             MOVS     R0,#+104
   \   00000004   0x.... 0x....      BL       SdkEvalSpiCommandStrobes
   \   00000008   0x9000             STR      R0,[SP, #+0]
   \   0000000A   0x....             LDR.N    R0,??DataTable21
   \   0000000C   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   00000010   0x8001             STRH     R1,[R0, #+0]
    670          
    671          }
   \   00000012   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0x........         DC32     g_xStatus

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_1:
   \   00000000   0x4BC65D41         DC32     0x4bc65d41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_2:
   \   00000000   0x408F4000         DC32     0x408f4000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_3:
   \   00000000   0x4092E800         DC32     0x4092e800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_4:
   \   00000000   0x887BF13E         DC32     0x887bf13e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_5:
   \   00000000   0x403CD185         DC32     0x403cd185

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_6:
   \   00000000   0x44EDE001         DC32     0x44ede001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_7:
   \   00000000   0x9999999A         DC32     0x9999999a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_8:
   \   00000000   0x40415999         DC32     0x40415999

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_9:
   \   00000000   0x018CBA81         DC32     0x18cba81

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_10:
   \   00000000   0x454DB001         DC32     0x454db001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_11:
   \   00000000   0x016E3600         DC32     0x16e3600

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_12:
   \   00000000   0x45457001         DC32     0x45457001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_13:
   \   00000000   0x017D7840         DC32     0x17d7840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_14:
   \   00000000   0x453DE001         DC32     0x453de001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_15:
   \   00000000   0x018CBA80         DC32     0x18cba80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_16:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_17:
   \   00000000   0x447A0000         DC32     0x447a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_18:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x45 0x3A          DC8 45H, 3AH, 5CH, 41H, 43H, 51H, 5CH, 50H
   \              0x5C 0x41    
   \              0x43 0x51    
   \              0x5C 0x50    
   \   00000008   0x72 0x6F          DC8 72H, 6FH, 6AH, 5FH, 76H, 65H, 72H, 30H
   \              0x6A 0x5F    
   \              0x76 0x65    
   \              0x72 0x30    
   \   00000010   0x39 0x61          DC8 39H, 61H, 5FH, 31H, 35H, 31H, 30H, 32H
   \              0x5F 0x31    
   \              0x35 0x31    
   \              0x30 0x32    
   \   00000018   0x30 0x31          DC8 30H, 31H, 35H, 5CH, 45H, 6EH, 64H, 5FH
   \              0x35 0x5C    
   \              0x45 0x6E    
   \              0x64 0x5F    
   \   00000020   0x30 0x32          DC8 30H, 32H, 5CH, 32H, 30H, 31H, 33H, 5FH
   \              0x5C 0x32    
   \              0x30 0x31    
   \              0x33 0x5F    
   \   00000028   0x31 0x31          DC8 31H, 31H, 5FH, 32H, 35H, 5FH, 53H, 70H
   \              0x5F 0x32    
   \              0x35 0x5F    
   \              0x53 0x70    
   \   00000030   0x69 0x72          DC8 69H, 72H, 69H, 74H, 31H, 5FH, 45H, 6CH
   \              0x69 0x74    
   \              0x31 0x5F    
   \              0x45 0x6C    
   \   00000038   0x65 0x6B          DC8 65H, 6BH, 74H, 72H, 6FH, 6CH, 75H, 78H
   \              0x74 0x72    
   \              0x6F 0x6C    
   \              0x75 0x78    
   \   00000040   0x5C 0x53          DC8 5CH, 53H, 50H, 49H, 52H, 49H, 54H, 31H
   \              0x50 0x49    
   \              0x52 0x49    
   \              0x54 0x31    
   \   00000048   0x5F 0x4C          DC8 5FH, 4CH, 69H, 62H, 72H, 61H, 72H, 79H
   \              0x69 0x62    
   \              0x72 0x61    
   \              0x72 0x79    
   \   00000050   0x5F 0x50          DC8 5FH, 50H, 72H, 6FH, 6AH, 65H, 63H, 74H
   \              0x72 0x6F    
   \              0x6A 0x65    
   \              0x63 0x74    
   \   00000058   0x5C 0x53          DC8 5CH, 53H, 50H, 49H, 52H, 49H, 54H, 31H
   \              0x50 0x49    
   \              0x52 0x49    
   \              0x54 0x31    
   \   00000060   0x5F 0x4C          DC8 5FH, 4CH, 69H, 62H, 72H, 61H, 72H, 79H
   \              0x69 0x62    
   \              0x72 0x61    
   \              0x72 0x79    
   \   00000068   0x5C 0x53          DC8 5CH, 53H, 6FH, 75H, 72H, 63H, 65H, 5CH
   \              0x6F 0x75    
   \              0x72 0x63    
   \              0x65 0x5C    
   \   00000070   0x73 0x72          DC8 73H, 72H, 63H, 5CH, 53H, 50H, 49H, 52H
   \              0x63 0x5C    
   \              0x53 0x50    
   \              0x49 0x52    
   \   00000078   0x49 0x54          DC8 49H, 54H, 5FH, 54H, 69H, 6DH, 65H, 72H
   \              0x5F 0x54    
   \              0x69 0x6D    
   \              0x65 0x72    
   \   00000080   0x2E 0x63          DC8 2EH, 63H, 0
   \              0x00         
   \   00000083   0x00               DC8 0
    672          
    673          
    674          /**
    675           *@}
    676           */
    677          
    678          
    679          /**
    680           *@}
    681           */
    682          
    683          
    684          /**
    685           *@}
    686           */
    687          
    688          
    689          
    690          /******************* (C) COPYRIGHT 2012 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   SpiritTimerComputeRxTimeoutValues
        32   -> SpiritRadioGetXtalFrequency
        32   -> __aeabi_d2f
        32   -> __aeabi_ddiv
        32   -> __aeabi_f2uiz
        32   -> __aeabi_fdiv
        32   -> __aeabi_fmul
        32   -> __aeabi_ui2d
        32 __aeabi_cfrcmple
      40   SpiritTimerComputeWakeUpValues
        40   -> __aeabi_d2uiz
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40 __aeabi_cfrcmple
      40   SpiritTimerGetRxTimeout
        40   -> SdkEvalSpiReadRegisters
        40   -> SpiritRadioGetXtalFrequency
        40   -> __aeabi_d2f
        40   -> __aeabi_ddiv
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> __aeabi_i2d
        40   -> __aeabi_ui2f
        40 __aeabi_cfrcmple
      24   SpiritTimerGetWakeUpTimer
        24   -> SdkEvalSpiReadRegisters
        24   -> __aeabi_d2f
        24   -> __aeabi_dmul
        24   -> __aeabi_i2d
      24   SpiritTimerGetWakeUpTimerReload
        24   -> SdkEvalSpiReadRegisters
        24   -> __aeabi_d2f
        24   -> __aeabi_dmul
        24   -> __aeabi_i2d
      16   SpiritTimerLdcrAutoReload
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
      16   SpiritTimerLdcrGetAutoReload
        16   -> SdkEvalSpiReadRegisters
      16   SpiritTimerLdcrMode
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
       8   SpiritTimerReloadStrobe
         8   -> SdkEvalSpiCommandStrobes
      24   SpiritTimerSetRxTimeout
        24   -> SdkEvalSpiWriteRegisters
      16   SpiritTimerSetRxTimeoutCounter
        16   -> SdkEvalSpiWriteRegisters
      16   SpiritTimerSetRxTimeoutMs
        16   -> SdkEvalSpiWriteRegisters
        16   -> SpiritTimerComputeRxTimeoutValues
      16   SpiritTimerSetRxTimeoutPrescaler
        16   -> SdkEvalSpiWriteRegisters
      16   SpiritTimerSetRxTimeoutStopCondition
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      24   SpiritTimerSetWakeUpTimer
        24   -> SdkEvalSpiWriteRegisters
      16   SpiritTimerSetWakeUpTimerCounter
        16   -> SdkEvalSpiWriteRegisters
      16   SpiritTimerSetWakeUpTimerMs
        16   -> SdkEvalSpiWriteRegisters
        16   -> SpiritTimerComputeWakeUpValues
      16   SpiritTimerSetWakeUpTimerPrescaler
        16   -> SdkEvalSpiWriteRegisters
      24   SpiritTimerSetWakeUpTimerReload
        24   -> SdkEvalSpiWriteRegisters
      16   SpiritTimerSetWakeUpTimerReloadCounter
        16   -> SdkEvalSpiWriteRegisters
      16   SpiritTimerSetWakeUpTimerReloadMs
        16   -> SdkEvalSpiWriteRegisters
        16   -> SpiritTimerComputeWakeUpValues
      16   SpiritTimerSetWakeUpTimerReloadPrescaler
        16   -> SdkEvalSpiWriteRegisters


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_10
       4  ??DataTable21_11
       4  ??DataTable21_12
       4  ??DataTable21_13
       4  ??DataTable21_14
       4  ??DataTable21_15
       4  ??DataTable21_16
       4  ??DataTable21_17
       4  ??DataTable21_18
       4  ??DataTable21_2
       4  ??DataTable21_3
       4  ??DataTable21_4
       4  ??DataTable21_5
       4  ??DataTable21_6
       4  ??DataTable21_7
       4  ??DataTable21_8
       4  ??DataTable21_9
     132  ?_0
     348  SpiritTimerComputeRxTimeoutValues
     266  SpiritTimerComputeWakeUpValues
     170  SpiritTimerGetRxTimeout
      76  SpiritTimerGetWakeUpTimer
      72  SpiritTimerGetWakeUpTimerReload
      82  SpiritTimerLdcrAutoReload
      36  SpiritTimerLdcrGetAutoReload
      82  SpiritTimerLdcrMode
      20  SpiritTimerReloadStrobe
      40  SpiritTimerSetRxTimeout
      28  SpiritTimerSetRxTimeoutCounter
      40  SpiritTimerSetRxTimeoutMs
      28  SpiritTimerSetRxTimeoutPrescaler
     186  SpiritTimerSetRxTimeoutStopCondition
      40  SpiritTimerSetWakeUpTimer
      28  SpiritTimerSetWakeUpTimerCounter
      40  SpiritTimerSetWakeUpTimerMs
      28  SpiritTimerSetWakeUpTimerPrescaler
      40  SpiritTimerSetWakeUpTimerReload
      28  SpiritTimerSetWakeUpTimerReloadCounter
      40  SpiritTimerSetWakeUpTimerReloadMs
      28  SpiritTimerSetWakeUpTimerReloadPrescaler

 
   132 bytes in section .rodata
 1 822 bytes in section .text
 
 1 822 bytes of CODE  memory
   132 bytes of CONST memory

Errors: none
Warnings: none
