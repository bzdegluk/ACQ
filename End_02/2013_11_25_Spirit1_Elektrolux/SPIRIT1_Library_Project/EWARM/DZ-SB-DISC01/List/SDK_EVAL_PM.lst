###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        20/Nov/2015  05:04:38
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\STM32L\SDK_Eval_STM32L\Source\src\SDK_EVAL_PM.c
#    Command line =  
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\STM32L\SDK_Eval_STM32L\Source\src\SDK_EVAL_PM.c
#        -D USE_STDPERIPH_DRIVER -D VECT_TAB_FLASH -D STM32L1XX_MD -D
#        IAR_ARM_CM3 -D USE_FULL_ASSERT -D SPIRIT_USE_FULL_ASSERT -D
#        USE_SYSTICK_DELAY -D SDK -lC
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\List\
#        -o
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\.\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\examples\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\runtime\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\SDK_Eval_STM32L\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\SPIRIT1_Library\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\SDK_Eval_Util\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\SDK_Virtual_Com\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32_USB-FS-Device_Lib\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\ACQ\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\CMSIS\Include\"
#    List file    =  
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\List\SDK_EVAL_PM.lst
#    Object file  =  
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\Obj\SDK_EVAL_PM.o
#
###############################################################################

E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\STM32L\SDK_Eval_STM32L\Source\src\SDK_EVAL_PM.c
      1          /**
      2           * @file    SDK_EVAL_PM.c
      3           * @author  High End Analog & RF BU - AMS / ART Team IMS-Systems Lab
      4           * @version V3.0.0
      5           * @date    August 7, 2012
      6           * @brief   This file provides all the low level API to manage SDK Digipots.
      7           * @details
      8           *
      9           * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     10           * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     11           * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     12           * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     13           * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     14           * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     15           *
     16           * THIS SOURCE CODE IS PROTECTED BY A LICENSE.
     17           * FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED
     18           * IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
     19           *
     20           * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     21           */
     22          
     23          
     24          /* Includes ------------------------------------------------------------------*/
     25          #include "SDK_EVAL_PM.h"
     26          #include "SDK_EVAL_Config.h"
     27          
     28          /** @addtogroup SDK_EVAL_STM32L
     29           * @{
     30           */
     31          
     32          
     33          /** @addtogroup SDK_EVAL_PM
     34           * @{
     35           */
     36          
     37          /** @defgroup SDK_EVAL_PM_Private_TypesDefinitions      SDK EVAL PM Private Types Definitions
     38           * @{
     39           */
     40          
     41          /**
     42           * @}
     43           */
     44          
     45          
     46          /** @defgroup SDK_EVAL_PM_Private_Defines               SDK EVAL PM Private Defines
     47           * @{
     48           */
     49          
     50          /**
     51           * @}
     52           */
     53          
     54          
     55          /** @defgroup SDK_EVAL_PM_Private_Macros                SDK EVAL PM Private Macros
     56           * @{
     57           */
     58          
     59          #define ABS(a)      (a>0 ? a:-a)
     60          
     61          /**
     62           * @brief Timeout used to notify errors on I2C operations.
     63           */
     64          #define I2C_WAIT_TIMER()    {\
     65                                        static uint16_t s_nTimeout=0xFFFF;\
     66                                        if(--s_nTimeout == 0){\
     67                                           s_nTimeout=0xFFFF;\
     68                                           return I2C_DIGIPOT_ERROR;\
     69                                        }\
     70                                      }
     71          
     72          
     73          /**
     74           * @}
     75           */
     76          
     77          
     78          /** @defgroup SDK_EVAL_PM_Private_Variables                     SDK EVAL PM Private Variables
     79           * @{
     80           */
     81          

   \                                 In section .rodata, align 2
     82          static const SdkEvalDigipotAddress s_vectxDigipotAddress[2] = { DIGIPOT1_ADDRESS , DIGIPOT2_ADDRESS};
   \                     s_vectxDigipotAddress:
   \   00000000   0x5A 0x58          DC8 90, 88
     83          
     84          
     85          /**
     86           * @}
     87           */
     88          
     89          
     90          /**
     91           * @defgroup SDK_EVAL_PM_Private_FunctionPrototypes             SDK EVAL PM Private Function Prototypes
     92           * @{
     93           */
     94          
     95          /**
     96           * @}
     97           */
     98          
     99          
    100          /**
    101           * @defgroup SDK_EVAL_PM_Private_Functions                      SDK EVAL PM Private Functions
    102           * @{
    103           */
    104          /**
    105           * @brief  Configures the I2C interface and the correspondent GPIO pins.
    106           * @param  None.
    107           * @retval None.
    108           */

   \                                 In section .text, align 2, keep-with-next
    109          void SdkEvalPmI2CInit(void){
   \                     SdkEvalPmI2CInit: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
    110          if(!SdkEvalGetVersion())
   \   00000004   0x.... 0x....      BL       SdkEvalGetVersion
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD14B             BNE.N    ??SdkEvalPmI2CInit_0
    111          {
    112            I2C_InitTypeDef I2C_InitStructure;
    113            GPIO_InitTypeDef GPIO_InitStructure;
    114          
    115            /* Enables I2C and GPIO clocks */
    116            RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C2, ENABLE);
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF45F 0x0080      MOVS     R0,#+4194304
   \   00000012   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
    117            RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0x.... 0x....      BL       RCC_AHBPeriphClockCmd
    118          
    119            /* GPIO AF configuration */
    120            GPIO_PinAFConfig(DIGIPOT_I2C_SCL_Port, DIGIPOT_I2C_SCL_RCC_SOURCE, DIGIPOT_I2C_SCL_AF);
   \   0000001E   0x2204             MOVS     R2,#+4
   \   00000020   0x210A             MOVS     R1,#+10
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40020400
   \   00000026   0x.... 0x....      BL       GPIO_PinAFConfig
    121            GPIO_PinAFConfig(DIGIPOT_I2C_SDA_Port, DIGIPOT_I2C_SDA_RCC_SOURCE, DIGIPOT_I2C_SDA_AF);
   \   0000002A   0x2204             MOVS     R2,#+4
   \   0000002C   0x210B             MOVS     R1,#+11
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40020400
   \   00000032   0x.... 0x....      BL       GPIO_PinAFConfig
    122          
    123            /* Configures I2C pins: SCL and SDA */
    124            GPIO_InitStructure.GPIO_Pin =  DIGIPOT_I2C_SCL_Pin | DIGIPOT_I2C_SDA_Pin;
   \   00000036   0xF44F 0x6040      MOV      R0,#+3072
   \   0000003A   0x9000             STR      R0,[SP, #+0]
    125            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_40MHz;
   \   0000003C   0x2003             MOVS     R0,#+3
   \   0000003E   0xF88D 0x0005      STRB     R0,[SP, #+5]
    126            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
   \   00000042   0x2002             MOVS     R0,#+2
   \   00000044   0xF88D 0x0004      STRB     R0,[SP, #+4]
    127            GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0xF88D 0x0006      STRB     R0,[SP, #+6]
    128            GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xF88D 0x0007      STRB     R0,[SP, #+7]
    129          
    130            GPIO_Init(GPIOB, &GPIO_InitStructure);
   \   00000054   0xA900             ADD      R1,SP,#+0
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40020400
   \   0000005A   0x.... 0x....      BL       GPIO_Init
    131          
    132            /* Configures I2C */
    133            I2C_DeInit(DIGIPOT_I2C);
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40005800
   \   00000062   0x.... 0x....      BL       I2C_DeInit
    134            I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    135            I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
   \   0000006C   0xF64B 0x70FF      MOVW     R0,#+49151
   \   00000070   0xF8AD 0x000E      STRH     R0,[SP, #+14]
    136            I2C_InitStructure.I2C_OwnAddress1 = 0xA0;
   \   00000074   0x20A0             MOVS     R0,#+160
   \   00000076   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    137            I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
   \   0000007A   0xF44F 0x6080      MOV      R0,#+1024
   \   0000007E   0xF8AD 0x0012      STRH     R0,[SP, #+18]
    138            I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
   \   00000082   0xF44F 0x4080      MOV      R0,#+16384
   \   00000086   0xF8AD 0x0014      STRH     R0,[SP, #+20]
    139            I2C_InitStructure.I2C_ClockSpeed = DIGIPOT_I2C_SPEED;
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable9_2  ;; 0x186a0
   \   0000008E   0x9002             STR      R0,[SP, #+8]
    140          
    141            /* DIGIPOT_I2C Init */
    142            I2C_Init(DIGIPOT_I2C, &I2C_InitStructure);
   \   00000090   0xA902             ADD      R1,SP,#+8
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40005800
   \   00000096   0x.... 0x....      BL       I2C_Init
    143          
    144            /* DIGIPOT_I2C Enable */
    145            I2C_Cmd(DIGIPOT_I2C, ENABLE);
   \   0000009A   0x2101             MOVS     R1,#+1
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40005800
   \   000000A0   0x.... 0x....      BL       I2C_Cmd
    146          }
    147          }
   \                     ??SdkEvalPmI2CInit_0: (+1)
   \   000000A4   0xB007             ADD      SP,SP,#+28
   \   000000A6   0xBD00             POP      {PC}             ;; return
    148          
    149          
    150          /**
    151           * @brief  Writes an 8-bit value in the RDAC register. The potentiometer value in ohm is
    152           *         given by the formula (cDValue/256*Rab + Rw), where Rab = xxxx and Rw = 60 ohm.
    153           * @param  xDigipot specifies what digipot has to be set.
    154           *         This parameter can be DIGIPOT1 or DIGIPOT2.
    155           * @param  cDValue D value to be written in the RDAC register.
    156           *         This parameter is an uint8_t.
    157           * @retval uint8_t Notifies if an I2C error has occured or if the communication has been correctly done.
    158           *         This parameter can be I2C_DIGIPOT_OK or I2C_DIGIPOT_ERROR.
    159           */

   \                                 In section .text, align 2, keep-with-next
    160          uint8_t SdkEvalPmDigipotWrite(SdkEvalDigipot xDigipot, uint8_t cDValue)
    161          {
   \                     SdkEvalPmDigipotWrite: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    162          
    163            /* Test on BUSY flag */
    164            while (I2C_GetFlagStatus(DIGIPOT_I2C,I2C_FLAG_BUSY))I2C_WAIT_TIMER();
   \                     ??SdkEvalPmDigipotWrite_0: (+1)
   \   00000006   0xF45F 0x3100      MOVS     R1,#+131072
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40005800
   \   0000000E   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD012             BEQ.N    ??SdkEvalPmDigipotWrite_1
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable9_3
   \   0000001A   0x8800             LDRH     R0,[R0, #+0]
   \   0000001C   0x1E40             SUBS     R0,R0,#+1
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable9_3
   \   00000022   0x8008             STRH     R0,[R1, #+0]
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable9_3
   \   00000028   0x8800             LDRH     R0,[R0, #+0]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD1EB             BNE.N    ??SdkEvalPmDigipotWrite_0
   \   0000002E   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable9_3
   \   00000036   0x8008             STRH     R0,[R1, #+0]
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xE0A5             B.N      ??SdkEvalPmDigipotWrite_2
    165          
    166            /* Enables the I2C peripheral */
    167            I2C_GenerateSTART(DIGIPOT_I2C, ENABLE);
   \                     ??SdkEvalPmDigipotWrite_1: (+1)
   \   0000003C   0x2101             MOVS     R1,#+1
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40005800
   \   00000042   0x.... 0x....      BL       I2C_GenerateSTART
    168          
    169            /* Test on EV5 and clear it */
    170            while(!I2C_CheckEvent(DIGIPOT_I2C, I2C_EVENT_MASTER_MODE_SELECT)) I2C_WAIT_TIMER();
   \                     ??SdkEvalPmDigipotWrite_3: (+1)
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable9_4  ;; 0x30001
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40005800
   \   0000004E   0x.... 0x....      BL       I2C_CheckEvent
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD112             BNE.N    ??SdkEvalPmDigipotWrite_4
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable9_5
   \   0000005A   0x8800             LDRH     R0,[R0, #+0]
   \   0000005C   0x1E40             SUBS     R0,R0,#+1
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable9_5
   \   00000062   0x8008             STRH     R0,[R1, #+0]
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable9_5
   \   00000068   0x8800             LDRH     R0,[R0, #+0]
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD1EB             BNE.N    ??SdkEvalPmDigipotWrite_3
   \   0000006E   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable9_5
   \   00000076   0x8008             STRH     R0,[R1, #+0]
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xE085             B.N      ??SdkEvalPmDigipotWrite_2
    171          
    172            /* Transmits the slave address and enable writing operation */
    173            I2C_Send7bitAddress(DIGIPOT_I2C, s_vectxDigipotAddress[xDigipot], I2C_Direction_Transmitter);
   \                     ??SdkEvalPmDigipotWrite_4: (+1)
   \   0000007C   0x2200             MOVS     R2,#+0
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable9_6
   \   00000082   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000084   0x5C21             LDRB     R1,[R4, R0]
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40005800
   \   0000008A   0x.... 0x....      BL       I2C_Send7bitAddress
    174          
    175            /* Test on EV6 flag */
    176            while (!I2C_CheckEvent(DIGIPOT_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)) I2C_WAIT_TIMER();
   \                     ??SdkEvalPmDigipotWrite_5: (+1)
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable9_7  ;; 0x70082
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40005800
   \   00000096   0x.... 0x....      BL       I2C_CheckEvent
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD112             BNE.N    ??SdkEvalPmDigipotWrite_6
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable9_8
   \   000000A2   0x8800             LDRH     R0,[R0, #+0]
   \   000000A4   0x1E40             SUBS     R0,R0,#+1
   \   000000A6   0x.... 0x....      LDR.W    R1,??DataTable9_8
   \   000000AA   0x8008             STRH     R0,[R1, #+0]
   \   000000AC   0x.... 0x....      LDR.W    R0,??DataTable9_8
   \   000000B0   0x8800             LDRH     R0,[R0, #+0]
   \   000000B2   0x2800             CMP      R0,#+0
   \   000000B4   0xD1EB             BNE.N    ??SdkEvalPmDigipotWrite_5
   \   000000B6   0xF64F 0x70FF      MOVW     R0,#+65535
   \   000000BA   0x.... 0x....      LDR.W    R1,??DataTable9_8
   \   000000BE   0x8008             STRH     R0,[R1, #+0]
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0xE061             B.N      ??SdkEvalPmDigipotWrite_2
    177          
    178            /* Transmits the instruction byte */
    179            I2C_SendData(DIGIPOT_I2C, 0x00);
   \                     ??SdkEvalPmDigipotWrite_6: (+1)
   \   000000C4   0x2100             MOVS     R1,#+0
   \   000000C6   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40005800
   \   000000CA   0x.... 0x....      BL       I2C_SendData
    180          
    181            /* Test on TXE flag (data sent) */
    182            while (!I2C_GetFlagStatus(DIGIPOT_I2C,I2C_FLAG_TXE)) I2C_WAIT_TIMER();
   \                     ??SdkEvalPmDigipotWrite_7: (+1)
   \   000000CE   0x.... 0x....      LDR.W    R1,??DataTable9_9  ;; 0x10000080
   \   000000D2   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40005800
   \   000000D6   0x.... 0x....      BL       I2C_GetFlagStatus
   \   000000DA   0x2800             CMP      R0,#+0
   \   000000DC   0xD112             BNE.N    ??SdkEvalPmDigipotWrite_8
   \   000000DE   0x.... 0x....      LDR.W    R0,??DataTable9_10
   \   000000E2   0x8800             LDRH     R0,[R0, #+0]
   \   000000E4   0x1E40             SUBS     R0,R0,#+1
   \   000000E6   0x.... 0x....      LDR.W    R1,??DataTable9_10
   \   000000EA   0x8008             STRH     R0,[R1, #+0]
   \   000000EC   0x.... 0x....      LDR.W    R0,??DataTable9_10
   \   000000F0   0x8800             LDRH     R0,[R0, #+0]
   \   000000F2   0x2800             CMP      R0,#+0
   \   000000F4   0xD1EB             BNE.N    ??SdkEvalPmDigipotWrite_7
   \   000000F6   0xF64F 0x70FF      MOVW     R0,#+65535
   \   000000FA   0x.... 0x....      LDR.W    R1,??DataTable9_10
   \   000000FE   0x8008             STRH     R0,[R1, #+0]
   \   00000100   0x2000             MOVS     R0,#+0
   \   00000102   0xE041             B.N      ??SdkEvalPmDigipotWrite_2
    183          
    184            /* Transmits the first address for r/w operations */
    185            I2C_SendData(DIGIPOT_I2C, cDValue);
   \                     ??SdkEvalPmDigipotWrite_8: (+1)
   \   00000104   0x0029             MOVS     R1,R5
   \   00000106   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000108   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40005800
   \   0000010C   0x.... 0x....      BL       I2C_SendData
    186          
    187            /* Test on TXE flag (data sent) */
    188            while (!I2C_GetFlagStatus(DIGIPOT_I2C,I2C_FLAG_TXE)) I2C_WAIT_TIMER();
   \                     ??SdkEvalPmDigipotWrite_9: (+1)
   \   00000110   0x.... 0x....      LDR.W    R1,??DataTable9_9  ;; 0x10000080
   \   00000114   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40005800
   \   00000118   0x.... 0x....      BL       I2C_GetFlagStatus
   \   0000011C   0x2800             CMP      R0,#+0
   \   0000011E   0xD112             BNE.N    ??SdkEvalPmDigipotWrite_10
   \   00000120   0x.... 0x....      LDR.W    R0,??DataTable9_11
   \   00000124   0x8800             LDRH     R0,[R0, #+0]
   \   00000126   0x1E40             SUBS     R0,R0,#+1
   \   00000128   0x.... 0x....      LDR.W    R1,??DataTable9_11
   \   0000012C   0x8008             STRH     R0,[R1, #+0]
   \   0000012E   0x.... 0x....      LDR.W    R0,??DataTable9_11
   \   00000132   0x8800             LDRH     R0,[R0, #+0]
   \   00000134   0x2800             CMP      R0,#+0
   \   00000136   0xD1EB             BNE.N    ??SdkEvalPmDigipotWrite_9
   \   00000138   0xF64F 0x70FF      MOVW     R0,#+65535
   \   0000013C   0x.... 0x....      LDR.W    R1,??DataTable9_11
   \   00000140   0x8008             STRH     R0,[R1, #+0]
   \   00000142   0x2000             MOVS     R0,#+0
   \   00000144   0xE020             B.N      ??SdkEvalPmDigipotWrite_2
    189          
    190            /* Test on BTF flag before the STOP command */
    191            while (!I2C_GetFlagStatus(DIGIPOT_I2C,I2C_FLAG_BTF)) I2C_WAIT_TIMER();
   \                     ??SdkEvalPmDigipotWrite_10: (+1)
   \   00000146   0x.... 0x....      LDR.W    R1,??DataTable9_12  ;; 0x10000004
   \   0000014A   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40005800
   \   0000014E   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000152   0x2800             CMP      R0,#+0
   \   00000154   0xD112             BNE.N    ??SdkEvalPmDigipotWrite_11
   \   00000156   0x.... 0x....      LDR.W    R0,??DataTable9_13
   \   0000015A   0x8800             LDRH     R0,[R0, #+0]
   \   0000015C   0x1E40             SUBS     R0,R0,#+1
   \   0000015E   0x.... 0x....      LDR.W    R1,??DataTable9_13
   \   00000162   0x8008             STRH     R0,[R1, #+0]
   \   00000164   0x.... 0x....      LDR.W    R0,??DataTable9_13
   \   00000168   0x8800             LDRH     R0,[R0, #+0]
   \   0000016A   0x2800             CMP      R0,#+0
   \   0000016C   0xD1EB             BNE.N    ??SdkEvalPmDigipotWrite_10
   \   0000016E   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000172   0x.... 0x....      LDR.W    R1,??DataTable9_13
   \   00000176   0x8008             STRH     R0,[R1, #+0]
   \   00000178   0x2000             MOVS     R0,#+0
   \   0000017A   0xE005             B.N      ??SdkEvalPmDigipotWrite_2
    192          
    193            /* Sends STOP Condition */
    194            I2C_GenerateSTOP(DIGIPOT_I2C, ENABLE);
   \                     ??SdkEvalPmDigipotWrite_11: (+1)
   \   0000017C   0x2101             MOVS     R1,#+1
   \   0000017E   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40005800
   \   00000182   0x.... 0x....      BL       I2C_GenerateSTOP
    195          
    196            /* Returns I2C operation OK value */
    197            return I2C_DIGIPOT_OK;
   \   00000186   0x2001             MOVS     R0,#+1
   \                     ??SdkEvalPmDigipotWrite_2: (+1)
   \   00000188   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    198          }

   \                                 In section .data, align 2
   \                     ??s_nTimeout:
   \   00000000   0xFFFF             DC16 65535

   \                                 In section .data, align 2
   \                     ??s_nTimeout_1:
   \   00000000   0xFFFF             DC16 65535

   \                                 In section .data, align 2
   \                     ??s_nTimeout_2:
   \   00000000   0xFFFF             DC16 65535

   \                                 In section .data, align 2
   \                     ??s_nTimeout_3:
   \   00000000   0xFFFF             DC16 65535

   \                                 In section .data, align 2
   \                     ??s_nTimeout_4:
   \   00000000   0xFFFF             DC16 65535

   \                                 In section .data, align 2
   \                     ??s_nTimeout_5:
   \   00000000   0xFFFF             DC16 65535
    199          
    200          /**
    201           * @brief  Returns the RDAC register. The potentiometer value in ohm is
    202           *         given by the formula (cDValue/256*Rab + Rw), where Rab = xxxx and Rw = 60 ohm.
    203           * @param  xDigipot specifies what digipot has to be set.
    204           *         This parameter can be DIGIPOT1 or DIGIPOT2.
    205           * @param  pcDValue pointer to the variable in which the D value has to be stored.
    206           *         This parameter is an uint8_t*.
    207           * @retval uint8_t Notifies if an I2C error has occured or if the communication has been correctly done.
    208           *         This parameter can be I2C_DIGIPOT_OK or I2C_DIGIPOT_ERROR.
    209           */

   \                                 In section .text, align 2, keep-with-next
    210          uint8_t SdkEvalPmDigipotRead(SdkEvalDigipot xDigipot, uint8_t* pcDValue)
    211          {
   \                     SdkEvalPmDigipotRead: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    212            /* Test on BUSY flag */
    213            while (I2C_GetFlagStatus(DIGIPOT_I2C,I2C_FLAG_BUSY)) I2C_WAIT_TIMER();
   \                     ??SdkEvalPmDigipotRead_0: (+1)
   \   00000006   0xF45F 0x3100      MOVS     R1,#+131072
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40005800
   \   0000000E   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD012             BEQ.N    ??SdkEvalPmDigipotRead_1
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable9_14
   \   0000001A   0x8800             LDRH     R0,[R0, #+0]
   \   0000001C   0x1E40             SUBS     R0,R0,#+1
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable9_14
   \   00000022   0x8008             STRH     R0,[R1, #+0]
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable9_14
   \   00000028   0x8800             LDRH     R0,[R0, #+0]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD1EB             BNE.N    ??SdkEvalPmDigipotRead_0
   \   0000002E   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable9_14
   \   00000036   0x8008             STRH     R0,[R1, #+0]
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xE073             B.N      ??SdkEvalPmDigipotRead_2
    214          
    215            /* Sends START condition */
    216            I2C_GenerateSTART(DIGIPOT_I2C, ENABLE);
   \                     ??SdkEvalPmDigipotRead_1: (+1)
   \   0000003C   0x2101             MOVS     R1,#+1
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40005800
   \   00000042   0x.... 0x....      BL       I2C_GenerateSTART
    217          
    218            /* Test on EV5 and clear it */
    219            while(!I2C_CheckEvent(DIGIPOT_I2C, I2C_EVENT_MASTER_MODE_SELECT)) I2C_WAIT_TIMER();
   \                     ??SdkEvalPmDigipotRead_3: (+1)
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable9_4  ;; 0x30001
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40005800
   \   0000004E   0x.... 0x....      BL       I2C_CheckEvent
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD112             BNE.N    ??SdkEvalPmDigipotRead_4
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable9_15
   \   0000005A   0x8800             LDRH     R0,[R0, #+0]
   \   0000005C   0x1E40             SUBS     R0,R0,#+1
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable9_15
   \   00000062   0x8008             STRH     R0,[R1, #+0]
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable9_15
   \   00000068   0x8800             LDRH     R0,[R0, #+0]
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD1EB             BNE.N    ??SdkEvalPmDigipotRead_3
   \   0000006E   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable9_15
   \   00000076   0x8008             STRH     R0,[R1, #+0]
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xE053             B.N      ??SdkEvalPmDigipotRead_2
    220          
    221            /* Sends address for read */
    222            I2C_Send7bitAddress(DIGIPOT_I2C, s_vectxDigipotAddress[xDigipot], I2C_Direction_Receiver);
   \                     ??SdkEvalPmDigipotRead_4: (+1)
   \   0000007C   0x2201             MOVS     R2,#+1
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable9_6
   \   00000082   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000084   0x5C21             LDRB     R1,[R4, R0]
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40005800
   \   0000008A   0x.... 0x....      BL       I2C_Send7bitAddress
    223          
    224            /* Test on EV6 and clear it */
    225            while(!I2C_CheckEvent(DIGIPOT_I2C, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED)) I2C_WAIT_TIMER();
   \                     ??SdkEvalPmDigipotRead_5: (+1)
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable9_16  ;; 0x30002
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40005800
   \   00000096   0x.... 0x....      BL       I2C_CheckEvent
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD112             BNE.N    ??SdkEvalPmDigipotRead_6
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable9_17
   \   000000A2   0x8800             LDRH     R0,[R0, #+0]
   \   000000A4   0x1E40             SUBS     R0,R0,#+1
   \   000000A6   0x.... 0x....      LDR.W    R1,??DataTable9_17
   \   000000AA   0x8008             STRH     R0,[R1, #+0]
   \   000000AC   0x.... 0x....      LDR.W    R0,??DataTable9_17
   \   000000B0   0x8800             LDRH     R0,[R0, #+0]
   \   000000B2   0x2800             CMP      R0,#+0
   \   000000B4   0xD1EB             BNE.N    ??SdkEvalPmDigipotRead_5
   \   000000B6   0xF64F 0x70FF      MOVW     R0,#+65535
   \   000000BA   0x.... 0x....      LDR.W    R1,??DataTable9_17
   \   000000BE   0x8008             STRH     R0,[R1, #+0]
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0xE02F             B.N      ??SdkEvalPmDigipotRead_2
    226          
    227            /* Disables acknowledgement */
    228            I2C_AcknowledgeConfig(DIGIPOT_I2C, DISABLE);
   \                     ??SdkEvalPmDigipotRead_6: (+1)
   \   000000C4   0x2100             MOVS     R1,#+0
   \   000000C6   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40005800
   \   000000CA   0x.... 0x....      BL       I2C_AcknowledgeConfig
    229          
    230            /* Test on EV7 and clear it */
    231            while(!I2C_CheckEvent(DIGIPOT_I2C, I2C_EVENT_MASTER_BYTE_RECEIVED)) I2C_WAIT_TIMER();
   \                     ??SdkEvalPmDigipotRead_7: (+1)
   \   000000CE   0x.... 0x....      LDR.W    R1,??DataTable9_18  ;; 0x30040
   \   000000D2   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40005800
   \   000000D6   0x.... 0x....      BL       I2C_CheckEvent
   \   000000DA   0x2800             CMP      R0,#+0
   \   000000DC   0xD112             BNE.N    ??SdkEvalPmDigipotRead_8
   \   000000DE   0x.... 0x....      LDR.W    R0,??DataTable9_19
   \   000000E2   0x8800             LDRH     R0,[R0, #+0]
   \   000000E4   0x1E40             SUBS     R0,R0,#+1
   \   000000E6   0x.... 0x....      LDR.W    R1,??DataTable9_19
   \   000000EA   0x8008             STRH     R0,[R1, #+0]
   \   000000EC   0x.... 0x....      LDR.W    R0,??DataTable9_19
   \   000000F0   0x8800             LDRH     R0,[R0, #+0]
   \   000000F2   0x2800             CMP      R0,#+0
   \   000000F4   0xD1EB             BNE.N    ??SdkEvalPmDigipotRead_7
   \   000000F6   0xF64F 0x70FF      MOVW     R0,#+65535
   \   000000FA   0x.... 0x....      LDR.W    R1,??DataTable9_19
   \   000000FE   0x8008             STRH     R0,[R1, #+0]
   \   00000100   0x2000             MOVS     R0,#+0
   \   00000102   0xE00F             B.N      ??SdkEvalPmDigipotRead_2
    232          
    233            /* Read a byte from DIGIPOT */
    234            *pcDValue = I2C_ReceiveData(DIGIPOT_I2C);
   \                     ??SdkEvalPmDigipotRead_8: (+1)
   \   00000104   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40005800
   \   00000108   0x.... 0x....      BL       I2C_ReceiveData
   \   0000010C   0x7028             STRB     R0,[R5, #+0]
    235          
    236            /* Sends STOP Condition */
    237            I2C_GenerateSTOP(DIGIPOT_I2C, ENABLE);
   \   0000010E   0x2101             MOVS     R1,#+1
   \   00000110   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40005800
   \   00000114   0x.... 0x....      BL       I2C_GenerateSTOP
    238          
    239            /* Enables acknowledgement to be ready for a new I2C operation */
    240            I2C_AcknowledgeConfig(DIGIPOT_I2C,ENABLE);
   \   00000118   0x2101             MOVS     R1,#+1
   \   0000011A   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40005800
   \   0000011E   0x.... 0x....      BL       I2C_AcknowledgeConfig
    241          
    242            /* Returns I2C operation OK value */
    243            return I2C_DIGIPOT_OK;
   \   00000122   0x2001             MOVS     R0,#+1
   \                     ??SdkEvalPmDigipotRead_2: (+1)
   \   00000124   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    244          
    245          }

   \                                 In section .data, align 2
   \                     ??s_nTimeout_6:
   \   00000000   0xFFFF             DC16 65535

   \                                 In section .data, align 2
   \                     ??s_nTimeout_7:
   \   00000000   0xFFFF             DC16 65535

   \                                 In section .data, align 2
   \                     ??s_nTimeout_8:
   \   00000000   0xFFFF             DC16 65535

   \                                 In section .data, align 2
   \                     ??s_nTimeout_9:
   \   00000000   0xFFFF             DC16 65535
    246          
    247          
    248          /**
    249           * @brief  Configures the Analog-to-Digital Converter and the correspondent GPIO pins.
    250           * @param  None.
    251           * @retval None.
    252           */

   \                                 In section .text, align 2, keep-with-next
    253          void SdkEvalPmADCInit(void)
    254          {
   \                     SdkEvalPmADCInit: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
    255            if(!SdkEvalGetVersion() ){
   \   00000004   0x.... 0x....      BL       SdkEvalGetVersion
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD131             BNE.N    ??SdkEvalPmADCInit_0
    256              ADC_InitTypeDef ADC_InitStructure;
    257              GPIO_InitTypeDef GPIO_InitStructure;
    258              
    259              /* Enables ADC1 and GPIO clocks */
    260              RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF44F 0x7000      MOV      R0,#+512
   \   00000012   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    261              RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOC, ENABLE);
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0x2004             MOVS     R0,#+4
   \   0000001A   0x.... 0x....      BL       RCC_AHBPeriphClockCmd
    262              
    263              /* Configures ADC pins */
    264              GPIO_InitStructure.GPIO_Pin = ADC_V_RF_Pin | ADC_V_5V_Pin | ADC_V_3V_Pin | ADC_I_R1_Pin | ADC_I_R2_Pin;
   \   0000001E   0x203B             MOVS     R0,#+59
   \   00000020   0x9000             STR      R0,[SP, #+0]
    265              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_40MHz;
   \   00000022   0x2003             MOVS     R0,#+3
   \   00000024   0xF88D 0x0005      STRB     R0,[SP, #+5]
    266              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF88D 0x0004      STRB     R0,[SP, #+4]
    267              GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF88D 0x0006      STRB     R0,[SP, #+6]
    268              GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF88D 0x0007      STRB     R0,[SP, #+7]
    269              
    270              GPIO_Init(GPIOC, &GPIO_InitStructure);
   \   0000003A   0xA900             ADD      R1,SP,#+0
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable9_20  ;; 0x40020800
   \   00000040   0x.... 0x....      BL       GPIO_Init
    271              
    272              /* Configures ADC periferial */
    273              ADC_InitStructure.ADC_ScanConvMode = DISABLE;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF88D 0x000C      STRB     R0,[SP, #+12]
    274              ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xF88D 0x000D      STRB     R0,[SP, #+13]
    275              ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConvEdge_None;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x9005             STR      R0,[SP, #+20]
    276              ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x9004             STR      R0,[SP, #+16]
    277              ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x9006             STR      R0,[SP, #+24]
    278              ADC_InitStructure.ADC_NbrOfConversion = 1;
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0xF88D 0x001C      STRB     R0,[SP, #+28]
    279              ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x9002             STR      R0,[SP, #+8]
    280              
    281              ADC_Init(ADC1, &ADC_InitStructure);
   \   00000066   0xA902             ADD      R1,SP,#+8
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable9_21  ;; 0x40012400
   \   0000006C   0x.... 0x....      BL       ADC_Init
    282            }
    283          }
   \                     ??SdkEvalPmADCInit_0: (+1)
   \   00000070   0xB009             ADD      SP,SP,#+36
   \   00000072   0xBD00             POP      {PC}             ;; return
    284          
    285          
    286          /**
    287           * @brief  Samples, converts and returns the voltage on the specified ADC channel.
    288           * @param  xAdcCh ADC channel.
    289           *         This parameter can be any value of @ref SdkEvalAdcChannel.
    290           * @retval uint16_t Converted voltage in an unsiged integer 16-bit format.
    291           */

   \                                 In section .text, align 2, keep-with-next
    292          uint16_t SdkEvalPmGetV(SdkEvalAdcChannel xAdcCh)
    293          {
   \                     SdkEvalPmGetV: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    294            uint16_t convValue=2785;
   \   00000004   0xF640 0x25E1      MOVW     R5,#+2785
    295            
    296            if( !SdkEvalGetVersion() ){
   \   00000008   0x.... 0x....      BL       SdkEvalGetVersion
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD12A             BNE.N    ??SdkEvalPmGetV_0
    297          
    298              /* ADC1 channel configuration */
    299              ADC_RegularChannelConfig(ADC1, xAdcCh, 1, ADC_SampleTime_48Cycles);
   \   00000010   0x2304             MOVS     R3,#+4
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0x0021             MOVS     R1,R4
   \   00000016   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable9_21  ;; 0x40012400
   \   0000001C   0x.... 0x....      BL       ADC_RegularChannelConfig
    300              
    301              /* Enables HSI clock */
    302              RCC_HSICmd(ENABLE);
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x.... 0x....      BL       RCC_HSICmd
    303              
    304              /* Enables ADC1 */
    305              ADC_Cmd(ADC1, ENABLE);
   \   00000026   0x2101             MOVS     R1,#+1
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable9_21  ;; 0x40012400
   \   0000002C   0x.... 0x....      BL       ADC_Cmd
    306              
    307              /* Waits until the ADC1 is ready */
    308              while(ADC_GetFlagStatus(ADC1, ADC_FLAG_ADONS) == RESET);
   \                     ??SdkEvalPmGetV_1: (+1)
   \   00000030   0x2140             MOVS     R1,#+64
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable9_21  ;; 0x40012400
   \   00000036   0x.... 0x....      BL       ADC_GetFlagStatus
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD0F8             BEQ.N    ??SdkEvalPmGetV_1
    309              
    310              /* Start ADC1 Software Conversion */
    311              ADC_SoftwareStartConv(ADC1);
   \   0000003E   0x....             LDR.N    R0,??DataTable9_21  ;; 0x40012400
   \   00000040   0x.... 0x....      BL       ADC_SoftwareStartConv
    312              
    313              /* Waits until the end of conversion */
    314              while(ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == RESET);
   \                     ??SdkEvalPmGetV_2: (+1)
   \   00000044   0x2102             MOVS     R1,#+2
   \   00000046   0x....             LDR.N    R0,??DataTable9_21  ;; 0x40012400
   \   00000048   0x.... 0x....      BL       ADC_GetFlagStatus
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD0F9             BEQ.N    ??SdkEvalPmGetV_2
    315              
    316              /* Gets the ADC conversion value */
    317              convValue = ADC_GetConversionValue(ADC1);
   \   00000050   0x....             LDR.N    R0,??DataTable9_21  ;; 0x40012400
   \   00000052   0x.... 0x....      BL       ADC_GetConversionValue
   \   00000056   0x0005             MOVS     R5,R0
    318              
    319              /* Disables ADC */
    320              ADC_Cmd(ADC1, DISABLE);
   \   00000058   0x2100             MOVS     R1,#+0
   \   0000005A   0x....             LDR.N    R0,??DataTable9_21  ;; 0x40012400
   \   0000005C   0x.... 0x....      BL       ADC_Cmd
    321              
    322              /* Disables HSI clock */
    323              RCC_HSICmd(DISABLE);
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x.... 0x....      BL       RCC_HSICmd
    324            }
    325            /* Return the converted value */
    326            return convValue;
   \                     ??SdkEvalPmGetV_0: (+1)
   \   00000066   0x0028             MOVS     R0,R5
   \   00000068   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000006A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    327          
    328          }
    329          
    330          /**
    331           * @brief  Samples, converts and returns the voltage on the specified ADC channel.
    332           *         It waits for the value to be constant (with a nError tolerance) before the conversion
    333           * @param  xAdcCh ADC channel.
    334           *         This parameter can be any value of @ref SdkEvalAdcChannel.
    335           * @param  nError tolerance to be used to consider settled the signal to be acquired.
    336           *         This parameter is a uint16_t.
    337           * @retval uint16_t Converted voltage in an unsiged integer 16-bit format.
    338           */

   \                                 In section .text, align 2, keep-with-next
    339          uint16_t SdkEvalPmGetSettledV(SdkEvalAdcChannel xAdcCh , uint16_t nError)
    340          {
   \                     SdkEvalPmGetSettledV: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    341            uint16_t valC, valP;
    342          
    343            /* Gets a first sample */
    344            valC=SdkEvalPmGetV(xAdcCh);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x.... 0x....      BL       SdkEvalPmGetV
   \   0000000E   0x0006             MOVS     R6,R0
    345          
    346            do{
    347              /* store the previous value */
    348              valP=valC;
   \                     ??SdkEvalPmGetSettledV_0: (+1)
   \   00000010   0x0037             MOVS     R7,R6
    349          
    350              /* get the value at this time */
    351              valC=SdkEvalPmGetV(xAdcCh);
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x.... 0x....      BL       SdkEvalPmGetV
   \   0000001A   0x0006             MOVS     R6,R0
    352          
    353              /* waits some cycles */
    354              for(uint16_t i=0 ; i<0x0FFF ; i++);
   \   0000001C   0x2000             MOVS     R0,#+0
   \                     ??SdkEvalPmGetSettledV_1: (+1)
   \   0000001E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000020   0xF640 0x71FF      MOVW     R1,#+4095
   \   00000024   0x4288             CMP      R0,R1
   \   00000026   0xDA01             BGE.N    ??SdkEvalPmGetSettledV_2
   \   00000028   0x1C40             ADDS     R0,R0,#+1
   \   0000002A   0xE7F8             B.N      ??SdkEvalPmGetSettledV_1
    355          
    356              /* exit when the residual error is less than nError */
    357            } while(ABS((int)valP-(int)valC)>(int)nError);
   \                     ??SdkEvalPmGetSettledV_2: (+1)
   \   0000002C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000002E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000030   0x1BB8             SUBS     R0,R7,R6
   \   00000032   0x2801             CMP      R0,#+1
   \   00000034   0xDB03             BLT.N    ??SdkEvalPmGetSettledV_3
   \   00000036   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000038   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000003A   0x1BB8             SUBS     R0,R7,R6
   \   0000003C   0xE003             B.N      ??SdkEvalPmGetSettledV_4
   \                     ??SdkEvalPmGetSettledV_3: (+1)
   \   0000003E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000040   0x4278             RSBS     R0,R7,#+0
   \   00000042   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000044   0x1B80             SUBS     R0,R0,R6
   \                     ??SdkEvalPmGetSettledV_4: (+1)
   \   00000046   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000048   0x4285             CMP      R5,R0
   \   0000004A   0xDBE1             BLT.N    ??SdkEvalPmGetSettledV_0
    358          
    359            /* Returns the last sample */
    360            return valC;
   \   0000004C   0x0030             MOVS     R0,R6
   \   0000004E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000050   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    361          
    362          }
    363          
    364          /**
    365           * @brief  Implements a control loop to make the specified voltage equal
    366           *         to a reference one (with a specified tolerance on the steady state).
    367           *         The control loop ends if the error value is less of cError or if
    368           *         a number of 7 zero crossing events have been reached by the error.
    369           * @param  xAdcCh ADC channel.
    370           *         This parameter can be any value of ADC_CH_V_RF or ADC_CH_V_MCU.
    371           * @param  fVref Reference voltage to be reached by the specified channel 3
    372           *         voltage expressed in Volt.
    373           *         This parameter is a float.
    374           * @param  cError Desired steady state error expressed in milliVolt.
    375           *         This parameter is an uint8_t.
    376           * @retval None.
    377           */

   \                                 In section .text, align 2, keep-with-next
    378          void SdkEvalPmRegulateVoltage(SdkEvalAdcChannel xAdcCh , float fVref , uint8_t cError)
    379          {
   \                     SdkEvalPmRegulateVoltage: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x4691             MOV      R9,R2
    380            uint8_t cD = 0x7F , nZeros = 0;
   \   0000000A   0x277F             MOVS     R7,#+127
   \   0000000C   0x2500             MOVS     R5,#+0
    381            int nVerrC , nVerrP;
    382            float fVcon;
    383          
    384            if(xAdcCh == ADC_CH_V_RF)
   \   0000000E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000012   0xF1B8 0x0F0D      CMP      R8,#+13
   \   00000016   0xD121             BNE.N    ??SdkEvalPmRegulateVoltage_0
    385            {
    386              /* sets the digipot value */
    387              SdkEvalPmDigipotWrite(DIGIPOT1, cD);
   \   00000018   0x0039             MOVS     R1,R7
   \   0000001A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x.... 0x....      BL       SdkEvalPmDigipotWrite
    388          
    389              /* waits for the steady state */
    390              for(uint32_t i=0 ; i<0x3FFF ; i++);
   \   00000022   0x2000             MOVS     R0,#+0
   \                     ??SdkEvalPmRegulateVoltage_1: (+1)
   \   00000024   0xF643 0x71FF      MOVW     R1,#+16383
   \   00000028   0x4288             CMP      R0,R1
   \   0000002A   0xD201             BCS.N    ??SdkEvalPmRegulateVoltage_2
   \   0000002C   0x1C40             ADDS     R0,R0,#+1
   \   0000002E   0xE7F9             B.N      ??SdkEvalPmRegulateVoltage_1
    391          
    392              /* gets the new output value */
    393              fVcon=SdkEvalPmGetVRf();
   \                     ??SdkEvalPmRegulateVoltage_2: (+1)
   \   00000030   0x200D             MOVS     R0,#+13
   \   00000032   0x.... 0x....      BL       SdkEvalPmGetV
   \   00000036   0x.... 0x....      BL       __aeabi_ui2f
   \   0000003A   0x.... 0x....      BL       __aeabi_f2d
   \   0000003E   0x2200             MOVS     R2,#+0
   \   00000040   0x....             LDR.N    R3,??DataTable9_22  ;; 0x40affe00
   \   00000042   0x.... 0x....      BL       __aeabi_ddiv
   \   00000046   0x....             LDR.N    R2,??DataTable9_23  ;; 0xe147ae14
   \   00000048   0x....             LDR.N    R3,??DataTable9_24  ;; 0x400a147a
   \   0000004A   0x.... 0x....      BL       __aeabi_dmul
   \   0000004E   0x....             LDR.N    R2,??DataTable9_25  ;; 0x5c28f5c3
   \   00000050   0x....             LDR.N    R3,??DataTable9_26  ;; 0x3fe5c28f
   \   00000052   0x.... 0x....      BL       __aeabi_ddiv
   \   00000056   0x.... 0x....      BL       __aeabi_d2f
   \   0000005A   0x4682             MOV      R10,R0
    394            }
    395          
    396            /* Computes the error for the first time */
    397            nVerrC = (int)((fVref - fVcon)*1000);
   \                     ??SdkEvalPmRegulateVoltage_0: (+1)
   \   0000005C   0x0020             MOVS     R0,R4
   \   0000005E   0x4651             MOV      R1,R10
   \   00000060   0x.... 0x....      BL       __aeabi_fsub
   \   00000064   0x....             LDR.N    R1,??DataTable9_27  ;; 0x447a0000
   \   00000066   0x.... 0x....      BL       __aeabi_fmul
   \   0000006A   0x.... 0x....      BL       __aeabi_f2iz
   \   0000006E   0x0006             MOVS     R6,R0
    398          
    399            /* stops the control loop if the current error is under cError or if the
    400              number of zero crossing events is 7 */
    401            while(!(ABS(nVerrC) < cError || nZeros == 7)){
   \                     ??SdkEvalPmRegulateVoltage_3: (+1)
   \   00000070   0x2E01             CMP      R6,#+1
   \   00000072   0xDB01             BLT.N    ??SdkEvalPmRegulateVoltage_4
   \   00000074   0x0030             MOVS     R0,R6
   \   00000076   0xE000             B.N      ??SdkEvalPmRegulateVoltage_5
   \                     ??SdkEvalPmRegulateVoltage_4: (+1)
   \   00000078   0x4270             RSBS     R0,R6,#+0
   \                     ??SdkEvalPmRegulateVoltage_5: (+1)
   \   0000007A   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000007E   0x4548             CMP      R0,R9
   \   00000080   0xDB45             BLT.N    ??SdkEvalPmRegulateVoltage_6
   \   00000082   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000084   0x2D07             CMP      R5,#+7
   \   00000086   0xD042             BEQ.N    ??SdkEvalPmRegulateVoltage_6
    402          
    403              /* uses the sign of the error to determine if increment or decrease the potentiometer value */
    404              if(nVerrC>0)
   \   00000088   0x2E01             CMP      R6,#+1
   \   0000008A   0xDB01             BLT.N    ??SdkEvalPmRegulateVoltage_7
    405                cD++;
   \   0000008C   0x1C7F             ADDS     R7,R7,#+1
   \   0000008E   0xE000             B.N      ??SdkEvalPmRegulateVoltage_8
    406              else
    407                cD--;
   \                     ??SdkEvalPmRegulateVoltage_7: (+1)
   \   00000090   0x1E7F             SUBS     R7,R7,#+1
    408          
    409              if(xAdcCh == ADC_CH_V_RF)
   \                     ??SdkEvalPmRegulateVoltage_8: (+1)
   \   00000092   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000096   0xF1B8 0x0F0D      CMP      R8,#+13
   \   0000009A   0xD121             BNE.N    ??SdkEvalPmRegulateVoltage_9
    410              {
    411                /* sets the digipot value */
    412                SdkEvalPmDigipotWrite(DIGIPOT1, cD);
   \   0000009C   0x0039             MOVS     R1,R7
   \   0000009E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0x.... 0x....      BL       SdkEvalPmDigipotWrite
    413          
    414                /* waits for the steady state */
    415                for(uint32_t i=0 ; i<0x3FFF ; i++);
   \   000000A6   0x2000             MOVS     R0,#+0
   \                     ??SdkEvalPmRegulateVoltage_10: (+1)
   \   000000A8   0xF643 0x71FF      MOVW     R1,#+16383
   \   000000AC   0x4288             CMP      R0,R1
   \   000000AE   0xD201             BCS.N    ??SdkEvalPmRegulateVoltage_11
   \   000000B0   0x1C40             ADDS     R0,R0,#+1
   \   000000B2   0xE7F9             B.N      ??SdkEvalPmRegulateVoltage_10
    416          
    417                /* gets the new output value */
    418                fVcon=SdkEvalPmGetVRf();
   \                     ??SdkEvalPmRegulateVoltage_11: (+1)
   \   000000B4   0x200D             MOVS     R0,#+13
   \   000000B6   0x.... 0x....      BL       SdkEvalPmGetV
   \   000000BA   0x.... 0x....      BL       __aeabi_ui2f
   \   000000BE   0x.... 0x....      BL       __aeabi_f2d
   \   000000C2   0x2200             MOVS     R2,#+0
   \   000000C4   0x....             LDR.N    R3,??DataTable9_22  ;; 0x40affe00
   \   000000C6   0x.... 0x....      BL       __aeabi_ddiv
   \   000000CA   0x....             LDR.N    R2,??DataTable9_23  ;; 0xe147ae14
   \   000000CC   0x....             LDR.N    R3,??DataTable9_24  ;; 0x400a147a
   \   000000CE   0x.... 0x....      BL       __aeabi_dmul
   \   000000D2   0x....             LDR.N    R2,??DataTable9_25  ;; 0x5c28f5c3
   \   000000D4   0x....             LDR.N    R3,??DataTable9_26  ;; 0x3fe5c28f
   \   000000D6   0x.... 0x....      BL       __aeabi_ddiv
   \   000000DA   0x.... 0x....      BL       __aeabi_d2f
   \   000000DE   0x4682             MOV      R10,R0
    419              }
    420              
    421          
    422              /* stores the previous error value */
    423              nVerrP = nVerrC;
   \                     ??SdkEvalPmRegulateVoltage_9: (+1)
   \   000000E0   0x46B3             MOV      R11,R6
    424          
    425              /* computes the new error value */
    426              nVerrC = (int)((fVref - fVcon)*1000);
   \   000000E2   0x0020             MOVS     R0,R4
   \   000000E4   0x4651             MOV      R1,R10
   \   000000E6   0x.... 0x....      BL       __aeabi_fsub
   \   000000EA   0x....             LDR.N    R1,??DataTable9_27  ;; 0x447a0000
   \   000000EC   0x.... 0x....      BL       __aeabi_fmul
   \   000000F0   0x.... 0x....      BL       __aeabi_f2iz
   \   000000F4   0x0006             MOVS     R6,R0
    427          
    428              /* counts the number of zero crossing events */
    429              if((nVerrC<0 && nVerrP>0) || (nVerrC>0 && nVerrP<0))
   \   000000F6   0x2E00             CMP      R6,#+0
   \   000000F8   0xD502             BPL.N    ??SdkEvalPmRegulateVoltage_12
   \   000000FA   0xF1BB 0x0F01      CMP      R11,#+1
   \   000000FE   0xDA04             BGE.N    ??SdkEvalPmRegulateVoltage_13
   \                     ??SdkEvalPmRegulateVoltage_12: (+1)
   \   00000100   0x2E01             CMP      R6,#+1
   \   00000102   0xDBB5             BLT.N    ??SdkEvalPmRegulateVoltage_3
   \   00000104   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000108   0xD5B2             BPL.N    ??SdkEvalPmRegulateVoltage_3
    430                nZeros++;
   \                     ??SdkEvalPmRegulateVoltage_13: (+1)
   \   0000010A   0x1C6D             ADDS     R5,R5,#+1
   \   0000010C   0xE7B0             B.N      ??SdkEvalPmRegulateVoltage_3
    431          
    432            }
    433          
    434          }
   \                     ??SdkEvalPmRegulateVoltage_6: (+1)
   \   0000010E   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
    435          
    436          /**
    437           * @brief  Implements a control loop to make the specified voltage equal
    438           *         to a reference one (with a specified tolerance on the steady state).
    439           *         The control loop vanishes an integral error and it ends when this error
    440           *         becomes constant.
    441           * @param  xAdcCh ADC channel.
    442           *         This parameter can be any value of ADC_CH_V_RF or ADC_CH_V_MCU.
    443           * @param  fVref Reference voltage to be reached by the specified channel 3
    444           *         voltage expressed in Volt.
    445           *         This parameter is a float.
    446           * @retval None.
    447           */

   \                                 In section .text, align 2, keep-with-next
    448          void SdkEvalPmRegulateVoltageI(SdkEvalAdcChannel xAdcCh , float fVref)
    449          {
   \                     SdkEvalPmRegulateVoltageI: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4680             MOV      R8,R0
   \   00000008   0x000C             MOVS     R4,R1
    450            if( !SdkEvalGetVersion() ){
   \   0000000A   0x.... 0x....      BL       SdkEvalGetVersion
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xF040 0x8084      BNE.W    ??SdkEvalPmRegulateVoltageI_0
    451              float fKi=0.13, fVcon;
   \   00000014   0x.... 0x....      LDR.W    R9,??DataTable9_28  ;; 0x3e051eb8
    452              int cD = 0x7F;
   \   00000018   0x277F             MOVS     R7,#+127
    453              int nVerrC, nVerrP=0;
   \   0000001A   0x2600             MOVS     R6,#+0
    454              
    455              if(xAdcCh == ADC_CH_V_RF)
   \   0000001C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000020   0xF1B8 0x0F0D      CMP      R8,#+13
   \   00000024   0xD125             BNE.N    ??SdkEvalPmRegulateVoltageI_1
    456              {
    457                /* sets the digipot value */
    458                SdkEvalPmDigipotWrite(DIGIPOT1, cD);
   \   00000026   0x0039             MOVS     R1,R7
   \   00000028   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x.... 0x....      BL       SdkEvalPmDigipotWrite
    459                
    460                /* waits for the steady state */
    461                for(volatile uint32_t i=0 ; i<0xFFFF ; i++);
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x9000             STR      R0,[SP, #+0]
   \                     ??SdkEvalPmRegulateVoltageI_2: (+1)
   \   00000034   0x9800             LDR      R0,[SP, #+0]
   \   00000036   0xF64F 0x71FF      MOVW     R1,#+65535
   \   0000003A   0x4288             CMP      R0,R1
   \   0000003C   0xD203             BCS.N    ??SdkEvalPmRegulateVoltageI_3
   \   0000003E   0x9800             LDR      R0,[SP, #+0]
   \   00000040   0x1C40             ADDS     R0,R0,#+1
   \   00000042   0x9000             STR      R0,[SP, #+0]
   \   00000044   0xE7F6             B.N      ??SdkEvalPmRegulateVoltageI_2
    462                
    463                /* gets the new output value */
    464                fVcon=SdkEvalPmGetVRf();
   \                     ??SdkEvalPmRegulateVoltageI_3: (+1)
   \   00000046   0x200D             MOVS     R0,#+13
   \   00000048   0x.... 0x....      BL       SdkEvalPmGetV
   \   0000004C   0x.... 0x....      BL       __aeabi_ui2f
   \   00000050   0x.... 0x....      BL       __aeabi_f2d
   \   00000054   0x2200             MOVS     R2,#+0
   \   00000056   0x....             LDR.N    R3,??DataTable9_22  ;; 0x40affe00
   \   00000058   0x.... 0x....      BL       __aeabi_ddiv
   \   0000005C   0x....             LDR.N    R2,??DataTable9_23  ;; 0xe147ae14
   \   0000005E   0x....             LDR.N    R3,??DataTable9_24  ;; 0x400a147a
   \   00000060   0x.... 0x....      BL       __aeabi_dmul
   \   00000064   0x....             LDR.N    R2,??DataTable9_25  ;; 0x5c28f5c3
   \   00000066   0x....             LDR.N    R3,??DataTable9_26  ;; 0x3fe5c28f
   \   00000068   0x.... 0x....      BL       __aeabi_ddiv
   \   0000006C   0x.... 0x....      BL       __aeabi_d2f
   \   00000070   0x4682             MOV      R10,R0
    465              }
    466              
    467              /* computes the new error value */
    468              nVerrC = (int)((fVref - fVcon)*1000);
   \                     ??SdkEvalPmRegulateVoltageI_1: (+1)
   \   00000072   0x0020             MOVS     R0,R4
   \   00000074   0x4651             MOV      R1,R10
   \   00000076   0x.... 0x....      BL       __aeabi_fsub
   \   0000007A   0x....             LDR.N    R1,??DataTable9_27  ;; 0x447a0000
   \   0000007C   0x.... 0x....      BL       __aeabi_fmul
   \   00000080   0x.... 0x....      BL       __aeabi_f2iz
   \   00000084   0x0005             MOVS     R5,R0
    469              
    470              while(nVerrC != nVerrP){
   \                     ??SdkEvalPmRegulateVoltageI_4: (+1)
   \   00000086   0x42B5             CMP      R5,R6
   \   00000088   0xD048             BEQ.N    ??SdkEvalPmRegulateVoltageI_0
    471                /* computes the new input value */
    472                cD += (int)(fKi*nVerrC);
   \   0000008A   0x0028             MOVS     R0,R5
   \   0000008C   0x.... 0x....      BL       __aeabi_i2f
   \   00000090   0x4649             MOV      R1,R9
   \   00000092   0x.... 0x....      BL       __aeabi_fmul
   \   00000096   0x.... 0x....      BL       __aeabi_f2iz
   \   0000009A   0x19C7             ADDS     R7,R0,R7
    473                
    474                /* Saturate cD to be into the range [0 , 255] */
    475                if(cD>255) cD=255;
   \   0000009C   0x2FFF             CMP      R7,#+255
   \   0000009E   0xDD02             BLE.N    ??SdkEvalPmRegulateVoltageI_5
   \   000000A0   0x20FF             MOVS     R0,#+255
   \   000000A2   0x0007             MOVS     R7,R0
   \   000000A4   0xE003             B.N      ??SdkEvalPmRegulateVoltageI_6
    476                else if(cD<0) cD=0;
   \                     ??SdkEvalPmRegulateVoltageI_5: (+1)
   \   000000A6   0x2F00             CMP      R7,#+0
   \   000000A8   0xD501             BPL.N    ??SdkEvalPmRegulateVoltageI_6
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x0007             MOVS     R7,R0
    477                
    478                if(xAdcCh == ADC_CH_V_RF)
   \                     ??SdkEvalPmRegulateVoltageI_6: (+1)
   \   000000AE   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000B2   0xF1B8 0x0F0D      CMP      R8,#+13
   \   000000B6   0xD125             BNE.N    ??SdkEvalPmRegulateVoltageI_7
    479                {
    480                  /* sets the digipot value */
    481                  SdkEvalPmDigipotWrite(DIGIPOT1, cD);
   \   000000B8   0x0039             MOVS     R1,R7
   \   000000BA   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x.... 0x....      BL       SdkEvalPmDigipotWrite
    482                  
    483                  /* waits for the steady state */
    484                  for(volatile uint32_t i=0 ; i<0x3FFF ; i++);
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0x9000             STR      R0,[SP, #+0]
   \                     ??SdkEvalPmRegulateVoltageI_8: (+1)
   \   000000C6   0x9800             LDR      R0,[SP, #+0]
   \   000000C8   0xF643 0x71FF      MOVW     R1,#+16383
   \   000000CC   0x4288             CMP      R0,R1
   \   000000CE   0xD203             BCS.N    ??SdkEvalPmRegulateVoltageI_9
   \   000000D0   0x9800             LDR      R0,[SP, #+0]
   \   000000D2   0x1C40             ADDS     R0,R0,#+1
   \   000000D4   0x9000             STR      R0,[SP, #+0]
   \   000000D6   0xE7F6             B.N      ??SdkEvalPmRegulateVoltageI_8
    485                  
    486                  /* gets the new output value */
    487                  fVcon=SdkEvalPmGetVRf();
   \                     ??SdkEvalPmRegulateVoltageI_9: (+1)
   \   000000D8   0x200D             MOVS     R0,#+13
   \   000000DA   0x.... 0x....      BL       SdkEvalPmGetV
   \   000000DE   0x.... 0x....      BL       __aeabi_ui2f
   \   000000E2   0x.... 0x....      BL       __aeabi_f2d
   \   000000E6   0x2200             MOVS     R2,#+0
   \   000000E8   0x....             LDR.N    R3,??DataTable9_22  ;; 0x40affe00
   \   000000EA   0x.... 0x....      BL       __aeabi_ddiv
   \   000000EE   0x....             LDR.N    R2,??DataTable9_23  ;; 0xe147ae14
   \   000000F0   0x....             LDR.N    R3,??DataTable9_24  ;; 0x400a147a
   \   000000F2   0x.... 0x....      BL       __aeabi_dmul
   \   000000F6   0x....             LDR.N    R2,??DataTable9_25  ;; 0x5c28f5c3
   \   000000F8   0x....             LDR.N    R3,??DataTable9_26  ;; 0x3fe5c28f
   \   000000FA   0x.... 0x....      BL       __aeabi_ddiv
   \   000000FE   0x.... 0x....      BL       __aeabi_d2f
   \   00000102   0x4682             MOV      R10,R0
    488                }
    489                
    490                /* stores the previous error value */
    491                nVerrP = nVerrC;
   \                     ??SdkEvalPmRegulateVoltageI_7: (+1)
   \   00000104   0x002E             MOVS     R6,R5
    492                
    493                /* computes the new error value */
    494                nVerrC = (int)((fVref - fVcon)*1000);
   \   00000106   0x0020             MOVS     R0,R4
   \   00000108   0x4651             MOV      R1,R10
   \   0000010A   0x.... 0x....      BL       __aeabi_fsub
   \   0000010E   0x....             LDR.N    R1,??DataTable9_27  ;; 0x447a0000
   \   00000110   0x.... 0x....      BL       __aeabi_fmul
   \   00000114   0x.... 0x....      BL       __aeabi_f2iz
   \   00000118   0x0005             MOVS     R5,R0
   \   0000011A   0xE7B4             B.N      ??SdkEvalPmRegulateVoltageI_4
    495                
    496              }}
    497          }
   \                     ??SdkEvalPmRegulateVoltageI_0: (+1)
   \   0000011C   0xE8BD 0x87F3      POP      {R0,R1,R4-R10,PC}  ;; return
    498          
    499          
    500          
    501          
    502          /**
    503           * @brief  Configures the RF supply voltage switch GPIO.
    504           * @param  None.
    505           * @retval None.
    506           */

   \                                 In section .text, align 2, keep-with-next
    507          void SdkEvalPmRfSwitchInit(void)
    508          {
   \                     SdkEvalPmRfSwitchInit: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    509            if(!SdkEvalGetVersion())
   \   00000004   0x.... 0x....      BL       SdkEvalGetVersion
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD115             BNE.N    ??SdkEvalPmRfSwitchInit_0
    510            {
    511            GPIO_InitTypeDef GPIO_InitStructure;
    512          
    513            /* Enables the switch and GPIO clocks */
    514            RCC_AHBPeriphClockCmd(RF_SWITCH_RCC, ENABLE);
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0x2010             MOVS     R0,#+16
   \   00000010   0x.... 0x....      BL       RCC_AHBPeriphClockCmd
    515          
    516          
    517            /* Configures the switch GPIO pins */
    518            GPIO_InitStructure.GPIO_Pin =  RF_SWITCH_Pin;
   \   00000014   0x2008             MOVS     R0,#+8
   \   00000016   0x9000             STR      R0,[SP, #+0]
    519            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_40MHz;
   \   00000018   0x2003             MOVS     R0,#+3
   \   0000001A   0xF88D 0x0005      STRB     R0,[SP, #+5]
    520            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xF88D 0x0004      STRB     R0,[SP, #+4]
    521            GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xF88D 0x0006      STRB     R0,[SP, #+6]
    522            GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xF88D 0x0007      STRB     R0,[SP, #+7]
    523          
    524            GPIO_Init(RF_SWITCH_Port, &GPIO_InitStructure);
   \   00000030   0xA900             ADD      R1,SP,#+0
   \   00000032   0x....             LDR.N    R0,??DataTable9_29  ;; 0x40021000
   \   00000034   0x.... 0x....      BL       GPIO_Init
    525            }
    526          }
   \                     ??SdkEvalPmRfSwitchInit_0: (+1)
   \   00000038   0xBD07             POP      {R0-R2,PC}       ;; return
    527          
    528          /**
    529           * @brief  Sets the switch to supply RF voltage.
    530           * @param  None.
    531           * @retval None.
    532           */

   \                                 In section .text, align 2, keep-with-next
    533          void SdkEvalPmRfSwitchToVRf(void)
    534          {
   \                     SdkEvalPmRfSwitchToVRf: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    535            if(!SdkEvalGetVersion() ){
   \   00000002   0x.... 0x....      BL       SdkEvalGetVersion
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD102             BNE.N    ??SdkEvalPmRfSwitchToVRf_0
    536            RF_SWITCH_Port->BSRRH = RF_SWITCH_Pin;
   \   0000000A   0x2008             MOVS     R0,#+8
   \   0000000C   0x....             LDR.N    R1,??DataTable9_30  ;; 0x4002101a
   \   0000000E   0x8008             STRH     R0,[R1, #+0]
    537            }
    538          }
   \                     ??SdkEvalPmRfSwitchToVRf_0: (+1)
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    539          
    540          /**
    541           * @brief  Sets the switch to supply voltage for the calibration resistor.
    542           * @param  None.
    543           * @retval None.
    544           */

   \                                 In section .text, align 2, keep-with-next
    545          void SdkEvalPmRfSwitchToRcal(void)
    546          {
    547            RF_SWITCH_Port->BSRRL = RF_SWITCH_Pin;
   \                     SdkEvalPmRfSwitchToRcal: (+1)
   \   00000000   0x2008             MOVS     R0,#+8
   \   00000002   0x....             LDR.N    R1,??DataTable9_31  ;; 0x40021018
   \   00000004   0x8008             STRH     R0,[R1, #+0]
    548          }
   \   00000006   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x40005800         DC32     0x40005800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x000186A0         DC32     0x186a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x........         DC32     ??s_nTimeout

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x00030001         DC32     0x30001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x........         DC32     ??s_nTimeout_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x........         DC32     s_vectxDigipotAddress

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x00070082         DC32     0x70082

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x........         DC32     ??s_nTimeout_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   0x10000080         DC32     0x10000080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_10:
   \   00000000   0x........         DC32     ??s_nTimeout_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_11:
   \   00000000   0x........         DC32     ??s_nTimeout_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_12:
   \   00000000   0x10000004         DC32     0x10000004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_13:
   \   00000000   0x........         DC32     ??s_nTimeout_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_14:
   \   00000000   0x........         DC32     ??s_nTimeout_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_15:
   \   00000000   0x........         DC32     ??s_nTimeout_7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_16:
   \   00000000   0x00030002         DC32     0x30002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_17:
   \   00000000   0x........         DC32     ??s_nTimeout_8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_18:
   \   00000000   0x00030040         DC32     0x30040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_19:
   \   00000000   0x........         DC32     ??s_nTimeout_9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_20:
   \   00000000   0x40020800         DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_21:
   \   00000000   0x40012400         DC32     0x40012400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_22:
   \   00000000   0x40AFFE00         DC32     0x40affe00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_23:
   \   00000000   0xE147AE14         DC32     0xe147ae14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_24:
   \   00000000   0x400A147A         DC32     0x400a147a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_25:
   \   00000000   0x5C28F5C3         DC32     0x5c28f5c3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_26:
   \   00000000   0x3FE5C28F         DC32     0x3fe5c28f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_27:
   \   00000000   0x447A0000         DC32     0x447a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_28:
   \   00000000   0x3E051EB8         DC32     0x3e051eb8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_29:
   \   00000000   0x40021000         DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_30:
   \   00000000   0x4002101A         DC32     0x4002101a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_31:
   \   00000000   0x40021018         DC32     0x40021018
    549          
    550          /**
    551           * @}
    552           */
    553          
    554          /**
    555           * @}
    556           */
    557          
    558          /**
    559           * @}
    560           */
    561          
    562          
    563          
    564          /******************* (C) COPYRIGHT 2012 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   SdkEvalPmADCInit
        40   -> ADC_Init
        40   -> GPIO_Init
        40   -> RCC_AHBPeriphClockCmd
        40   -> RCC_APB2PeriphClockCmd
        40   -> SdkEvalGetVersion
      16   SdkEvalPmDigipotRead
        16   -> I2C_AcknowledgeConfig
        16   -> I2C_CheckEvent
        16   -> I2C_GenerateSTART
        16   -> I2C_GenerateSTOP
        16   -> I2C_GetFlagStatus
        16   -> I2C_ReceiveData
        16   -> I2C_Send7bitAddress
      16   SdkEvalPmDigipotWrite
        16   -> I2C_CheckEvent
        16   -> I2C_GenerateSTART
        16   -> I2C_GenerateSTOP
        16   -> I2C_GetFlagStatus
        16   -> I2C_Send7bitAddress
        16   -> I2C_SendData
      24   SdkEvalPmGetSettledV
        24   -> SdkEvalPmGetV
      16   SdkEvalPmGetV
        16   -> ADC_Cmd
        16   -> ADC_GetConversionValue
        16   -> ADC_GetFlagStatus
        16   -> ADC_RegularChannelConfig
        16   -> ADC_SoftwareStartConv
        16   -> RCC_HSICmd
        16   -> SdkEvalGetVersion
      32   SdkEvalPmI2CInit
        32   -> GPIO_Init
        32   -> GPIO_PinAFConfig
        32   -> I2C_Cmd
        32   -> I2C_DeInit
        32   -> I2C_Init
        32   -> RCC_AHBPeriphClockCmd
        32   -> RCC_APB1PeriphClockCmd
        32   -> SdkEvalGetVersion
      40   SdkEvalPmRegulateVoltage
        40   -> SdkEvalPmDigipotWrite
        40   -> SdkEvalPmGetV
        40   -> __aeabi_d2f
        40   -> __aeabi_ddiv
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> __aeabi_f2iz
        40   -> __aeabi_fmul
        40   -> __aeabi_fsub
        40   -> __aeabi_ui2f
      40   SdkEvalPmRegulateVoltageI
        40   -> SdkEvalGetVersion
        40   -> SdkEvalPmDigipotWrite
        40   -> SdkEvalPmGetV
        40   -> __aeabi_d2f
        40   -> __aeabi_ddiv
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> __aeabi_f2iz
        40   -> __aeabi_fmul
        40   -> __aeabi_fsub
        40   -> __aeabi_i2f
        40   -> __aeabi_ui2f
      16   SdkEvalPmRfSwitchInit
        16   -> GPIO_Init
        16   -> RCC_AHBPeriphClockCmd
        16   -> SdkEvalGetVersion
       0   SdkEvalPmRfSwitchToRcal
       8   SdkEvalPmRfSwitchToVRf
         8   -> SdkEvalGetVersion


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_12
       4  ??DataTable9_13
       4  ??DataTable9_14
       4  ??DataTable9_15
       4  ??DataTable9_16
       4  ??DataTable9_17
       4  ??DataTable9_18
       4  ??DataTable9_19
       4  ??DataTable9_2
       4  ??DataTable9_20
       4  ??DataTable9_21
       4  ??DataTable9_22
       4  ??DataTable9_23
       4  ??DataTable9_24
       4  ??DataTable9_25
       4  ??DataTable9_26
       4  ??DataTable9_27
       4  ??DataTable9_28
       4  ??DataTable9_29
       4  ??DataTable9_3
       4  ??DataTable9_30
       4  ??DataTable9_31
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
     116  SdkEvalPmADCInit
     294  SdkEvalPmDigipotRead
     394  SdkEvalPmDigipotWrite
      82  SdkEvalPmGetSettledV
     108  SdkEvalPmGetV
     168  SdkEvalPmI2CInit
     274  SdkEvalPmRegulateVoltage
     288  SdkEvalPmRegulateVoltageI
      58  SdkEvalPmRfSwitchInit
       8  SdkEvalPmRfSwitchToRcal
      18  SdkEvalPmRfSwitchToVRf
       2  s_nTimeout
       2  s_nTimeout
       2  s_nTimeout
       2  s_nTimeout
       2  s_nTimeout
       2  s_nTimeout
       2  s_nTimeout
       2  s_nTimeout
       2  s_nTimeout
       2  s_nTimeout
       2  s_vectxDigipotAddress

 
    20 bytes in section .data
     2 bytes in section .rodata
 1 936 bytes in section .text
 
 1 936 bytes of CODE  memory
     2 bytes of CONST memory
    20 bytes of DATA  memory

Errors: none
Warnings: none
