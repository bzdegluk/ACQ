###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        20/Nov/2015  05:04:53
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_flash.c
#    Command line =  
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_flash.c
#        -D USE_STDPERIPH_DRIVER -D VECT_TAB_FLASH -D STM32L1XX_MD -D
#        IAR_ARM_CM3 -D USE_FULL_ASSERT -D SPIRIT_USE_FULL_ASSERT -D
#        USE_SYSTICK_DELAY -D SDK -lC
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\List\
#        -o
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\.\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\examples\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\runtime\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\SDK_Eval_STM32L\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\SPIRIT1_Library\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\SDK_Eval_Util\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\SDK_Virtual_Com\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32_USB-FS-Device_Lib\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\ACQ\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\CMSIS\Include\"
#    List file    =  
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\List\stm32l1xx_flash.lst
#    Object file  =  
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\Obj\stm32l1xx_flash.o
#
###############################################################################

E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_flash.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_flash.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    31-December-2010
      7            * @brief   This file provides all the Flash firmware functions. These functions 
      8            *          can be executed from Internal FLASH or Internal SRAM memories. 
      9            *          The functions that should be called from SRAM are defined inside 
     10            *          the "stm32l1xx_flash_ramfunc.c" file.
     11            *          This file provides firmware functions to manage the following 
     12            *          functionalities of the FLASH peripheral:
     13            *            - FLASH Interface configuration
     14            *            - FLASH Memory Programming
     15            *            - DATA EEPROM Programming
     16            *            - Option Bytes Programming
     17            *            - Interrupts and flags management
     18            *               
     19            *  @verbatim
     20            *  
     21            *          ===================================================================
     22            *                                 How to use this driver
     23            *          ===================================================================
     24            *                           
     25            *          This driver provides functions to configure and program the Flash 
     26            *          memory of all STM32L1xx devices
     27            *          These functions are split in 5 groups
     28            * 
     29            *           1. FLASH Interface configuration functions: this group includes 
     30            *              the management of following features:
     31            *                    - Set the latency
     32            *                    - Enable/Disable the prefetch buffer
     33            *                    - Enable/Disable the 64 bit Read Access 
     34            *                    - Enable/Disable the RUN PowerDown mode
     35            *                    - Enable/Disable the SLEEP PowerDown mode  
     36            *  
     37            *           2. FLASH Memory Programming functions: this group includes all 
     38            *              needed functions to erase and program the main memory:
     39            *                    - Lock and Unlock the Flash interface.
     40            *                    - Erase function: Erase Page.
     41            *                    - Program functions: Fast Word and Half Page(should be 
     42            *                      executed from internal SRAM).
     43            *   
     44            *           3. DATA EEPROM Programming functions: this group includes all 
     45            *              needed functions to erase and program the DATA EEPROM memory:
     46            *                    - Lock and Unlock the DATA EEPROM interface.
     47            *                    - Erase function: Erase Word, erase Double Word (should be 
     48            *                      executed from internal SRAM).
     49            *                    - Program functions: Fast Program Byte, Fast Program Half-Word, 
     50            *                      FastProgramWord, Program Byte, Program Half-Word, 
     51            *                      Program Word and Program Double-Word (should be executed 
     52            *                      from internal SRAM).
     53            *    
     54            *           4. FLASH Option Bytes Programming functions: this group includes 
     55            *              all needed functions to:
     56            *                    - Lock and Unlock the Flash Option bytes.  
     57            *                    - Set/Reset the write protection
     58            *                    - Set the Read protection Level
     59            *                    - Set the BOR level
     60            *                    - Program the user option Bytes 
     61            *                    - Launch the Option Bytes loader
     62            *                    - Get the Write protection
     63            *                    - Get the read protection status
     64            *                    - Get the BOR level
     65            *                    - Get the user option bytes        
     66            *  
     67            *           5. FLASH Interrupts and flag management functions: this group 
     68            *              includes all needed functions to:
     69            *                    - Enable/Disable the flash interrupt sources
     70            *                    - Get flags status
     71            *                    - Clear flags
     72            *                    - Get Flash operation status
     73            *                    - Wait for last flash operation   
     74            * 
     75            *  @endverbatim
     76            *                      
     77            ******************************************************************************
     78            * @attention
     79            *
     80            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     81            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     82            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     83            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     84            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     85            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     86            *
     87            * <h2><center>&copy; COPYRIGHT 2010 STMicroelectronics</center></h2>
     88            ******************************************************************************  
     89            */ 
     90          
     91          /* Includes ------------------------------------------------------------------*/
     92          #include "stm32l1xx_flash.h"
     93          
     94          /** @addtogroup STM32L1xx_StdPeriph_Driver
     95            * @{
     96            */
     97          
     98          /** @defgroup FLASH 
     99            * @brief FLASH driver modules
    100            * @{
    101            */ 
    102          
    103          /* Private typedef -----------------------------------------------------------*/
    104          /* Private define ------------------------------------------------------------*/
    105            
    106          /* FLASH Mask */
    107          #define RDPRT_MASK                 ((uint32_t)0x00000002)
    108          #define WRP01_MASK                 ((uint32_t)0x0000FFFF)
    109          #define WRP23_MASK                 ((uint32_t)0xFFFF0000)
    110          
    111          /* Private macro -------------------------------------------------------------*/
    112          /* Private variables ---------------------------------------------------------*/
    113          /* Private function prototypes -----------------------------------------------*/
    114          /* Private functions ---------------------------------------------------------*/
    115           
    116          /** @defgroup FLASH_Private_Functions
    117            * @{
    118            */ 
    119          
    120          /** @defgroup FLASH_Group1 FLASH Interface configuration functions
    121            *  @brief   FLASH Interface configuration functions 
    122           *
    123          @verbatim   
    124           ===============================================================================
    125                                 FLASH Interface configuration functions
    126           ===============================================================================  
    127          
    128             FLASH_Interface configuration_Functions, includes the following functions:
    129             - void FLASH_SetLatency(uint32_t FLASH_Latency):
    130               To correctly read data from Flash memory, the number of wait states (LATENCY) 
    131               must be correctly programmed according to the frequency of the CPU clock 
    132               (HCLK) and the supply voltage of the device.
    133            ----------------------------------------------------------------     
    134           |  Wait states  |                HCLK clock frequency (MHz)      |
    135           |               |------------------------------------------------|     
    136           |   (Latency)   |            voltage range       | voltage range | 
    137           |               |            1.65 V - 3.6 V      | 2.0 V - 3.6 V |
    138           |               |----------------|---------------|---------------| 
    139           |               |  VCORE = 1.2 V | VCORE = 1.5 V | VCORE = 1.8 V |
    140           |-------------- |----------------|---------------|---------------|             
    141           |0WS(1CPU cycle)|0 < HCLK <= 2   |0 < HCLK <= 8  |0 < HCLK <= 16 |
    142           |---------------|----------------|---------------|---------------|  
    143           |1WS(2CPU cycle)|2 < HCLK <= 4   |8 < HCLK <= 16 |16 < HCLK <= 32| 
    144            ----------------------------------------------------------------   
    145             
    146             - void FLASH_PrefetchBufferCmd(FunctionalState NewState);
    147             - void FLASH_ReadAccess64Cmd(FunctionalState NewState);
    148             - void FLASH_RUNPowerDownCmd(FunctionalState NewState);
    149             - void FLASH_SLEEPPowerDownCmd(FunctionalState NewState);
    150             - void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState);
    151             
    152            Here below the allowed configuration of Latency, 64Bit access and prefetch buffer
    153            --------------------------------------------------------------------------------              
    154           |               |              ACC64 = 0         |              ACC64 = 1        |
    155           |   Latency     |----------------|---------------|---------------|---------------|   
    156           |               |   PRFTEN = 0   |   PRFTEN = 1  |   PRFTEN = 0  |   PRFTEN = 1  | 
    157           |---------------|----------------|---------------|---------------|---------------|   
    158           |0WS(1CPU cycle)|     YES        |     NO        |     YES       |     YES       |
    159           |---------------|----------------|---------------|---------------|---------------| 
    160           |1WS(2CPU cycle)|     NO         |     NO        |     YES       |     YES       | 
    161            --------------------------------------------------------------------------------   
    162             All these functions don't need the unlock sequence.
    163          
    164          @endverbatim
    165            * @{
    166            */
    167          
    168          /**
    169            * @brief  Sets the code latency value.
    170            * @param  FLASH_Latency: specifies the FLASH Latency value.
    171            *   This parameter can be one of the following values:
    172            *     @arg FLASH_Latency_0: FLASH Zero Latency cycle
    173            *     @arg FLASH_Latency_1: FLASH One Latency cycle
    174            * @retval None
    175            */

   \                                 In section .text, align 2, keep-with-next
    176          void FLASH_SetLatency(uint32_t FLASH_Latency)
    177          {
   \                     FLASH_SetLatency: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    178             uint32_t tmpreg = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    179            
    180            /* Check the parameters */
    181            assert_param(IS_FLASH_LATENCY(FLASH_Latency));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD006             BEQ.N    ??FLASH_SetLatency_0
   \   0000000A   0x2C01             CMP      R4,#+1
   \   0000000C   0xD004             BEQ.N    ??FLASH_SetLatency_0
   \   0000000E   0x21B5             MOVS     R1,#+181
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000014   0x.... 0x....      BL       assert_failed
    182            
    183            /* Read the ACR register */
    184            tmpreg = FLASH->ACR;  
   \                     ??FLASH_SetLatency_0: (+1)
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable32_1  ;; 0x40023c00
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x0005             MOVS     R5,R0
    185            
    186            /* Sets the Latency value */
    187            tmpreg &= (uint32_t) (~((uint32_t)FLASH_ACR_LATENCY));
   \   00000020   0x086D             LSRS     R5,R5,#+1
   \   00000022   0x006D             LSLS     R5,R5,#+1
    188            tmpreg |= FLASH_Latency;
   \   00000024   0x4325             ORRS     R5,R4,R5
    189            
    190            /* Write the ACR register */
    191            FLASH->ACR = tmpreg;
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable32_1  ;; 0x40023c00
   \   0000002A   0x6005             STR      R5,[R0, #+0]
    192          }
   \   0000002C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    193          
    194          /**
    195            * @brief  Enables or disables the Prefetch Buffer.
    196            * @param  NewState: new state of the FLASH prefetch buffer.
    197            *              This parameter can be: ENABLE or DISABLE. 
    198            * @retval None
    199            */

   \                                 In section .text, align 2, keep-with-next
    200          void FLASH_PrefetchBufferCmd(FunctionalState NewState)
    201          {
   \                     FLASH_PrefetchBufferCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    202            /* Check the parameters */
    203            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??FLASH_PrefetchBufferCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD004             BEQ.N    ??FLASH_PrefetchBufferCmd_0
   \   00000010   0x21CB             MOVS     R1,#+203
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000016   0x.... 0x....      BL       assert_failed
    204             
    205            if(NewState != DISABLE)
   \                     ??FLASH_PrefetchBufferCmd_0: (+1)
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD008             BEQ.N    ??FLASH_PrefetchBufferCmd_1
    206            {
    207              FLASH->ACR |= FLASH_ACR_PRFTEN;
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable32_1  ;; 0x40023c00
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable32_1  ;; 0x40023c00
   \   0000002E   0x6008             STR      R0,[R1, #+0]
   \   00000030   0xE007             B.N      ??FLASH_PrefetchBufferCmd_2
    208            }
    209            else
    210            {
    211              FLASH->ACR &= (uint32_t)(~((uint32_t)FLASH_ACR_PRFTEN));
   \                     ??FLASH_PrefetchBufferCmd_1: (+1)
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable32_1  ;; 0x40023c00
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF030 0x0002      BICS     R0,R0,#0x2
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable32_1  ;; 0x40023c00
   \   00000040   0x6008             STR      R0,[R1, #+0]
    212            }
    213          }
   \                     ??FLASH_PrefetchBufferCmd_2: (+1)
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
    214          
    215          /**
    216            * @brief  Enables or disables read access to flash by 64 bits.
    217            * @param  NewState: new state of the FLASH read access mode.
    218            *              This parameter can be: ENABLE or DISABLE.  
    219            * @note   - If this bit is set, the Read access 64 bit is used.
    220            *         - If this bit is reset, the Read access 32 bit is used.
    221            * @note   - This bit cannot be written at the same time as the LATENCY and 
    222            *           PRFTEN bits. 
    223            *         - To reset this bit, the LATENCY should be zero wait state and the 
    224            *           prefetch off.
    225            * @retval None
    226            */

   \                                 In section .text, align 2, keep-with-next
    227          void FLASH_ReadAccess64Cmd(FunctionalState NewState)
    228          {
   \                     FLASH_ReadAccess64Cmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    229            /* Check the parameters */
    230            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??FLASH_ReadAccess64Cmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD004             BEQ.N    ??FLASH_ReadAccess64Cmd_0
   \   00000010   0x21E6             MOVS     R1,#+230
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000016   0x.... 0x....      BL       assert_failed
    231            
    232            if(NewState != DISABLE)
   \                     ??FLASH_ReadAccess64Cmd_0: (+1)
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD008             BEQ.N    ??FLASH_ReadAccess64Cmd_1
    233            {
    234              FLASH->ACR |= FLASH_ACR_ACC64;
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable32_1  ;; 0x40023c00
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable32_1  ;; 0x40023c00
   \   0000002E   0x6008             STR      R0,[R1, #+0]
   \   00000030   0xE007             B.N      ??FLASH_ReadAccess64Cmd_2
    235            }
    236            else
    237            {
    238              FLASH->ACR &= (uint32_t)(~((uint32_t)FLASH_ACR_ACC64));
   \                     ??FLASH_ReadAccess64Cmd_1: (+1)
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable32_1  ;; 0x40023c00
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF030 0x0004      BICS     R0,R0,#0x4
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable32_1  ;; 0x40023c00
   \   00000040   0x6008             STR      R0,[R1, #+0]
    239            }
    240          }
   \                     ??FLASH_ReadAccess64Cmd_2: (+1)
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
    241          
    242          /**
    243            * @brief  Enable or disable the power down mode during Sleep mode.
    244            * @note   This function is used to power down the FLASH when the system is in SLEEP LP mode.  
    245            * @param  NewState: new state of the power down mode during sleep mode.
    246            *   This parameter can be: ENABLE or DISABLE.
    247            * @retval None
    248            */

   \                                 In section .text, align 2, keep-with-next
    249          void FLASH_SLEEPPowerDownCmd(FunctionalState NewState)
    250          {
   \                     FLASH_SLEEPPowerDownCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    251            /* Check the parameters */
    252            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??FLASH_SLEEPPowerDownCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD004             BEQ.N    ??FLASH_SLEEPPowerDownCmd_0
   \   00000010   0x21FC             MOVS     R1,#+252
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000016   0x.... 0x....      BL       assert_failed
    253            
    254            if (NewState != DISABLE)
   \                     ??FLASH_SLEEPPowerDownCmd_0: (+1)
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD008             BEQ.N    ??FLASH_SLEEPPowerDownCmd_1
    255            {
    256              /* Set the SLEEP_PD bit to put Flash in power down mode during sleep mode */
    257              FLASH->ACR |= FLASH_ACR_SLEEP_PD;
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable32_1  ;; 0x40023c00
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable32_1  ;; 0x40023c00
   \   0000002E   0x6008             STR      R0,[R1, #+0]
   \   00000030   0xE007             B.N      ??FLASH_SLEEPPowerDownCmd_2
    258            }
    259            else
    260            {
    261              /* Clear the SLEEP_PD bit in to put Flash in idle mode during sleep mode */
    262              FLASH->ACR &= (uint32_t)(~((uint32_t)FLASH_ACR_SLEEP_PD));
   \                     ??FLASH_SLEEPPowerDownCmd_1: (+1)
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable32_1  ;; 0x40023c00
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF030 0x0008      BICS     R0,R0,#0x8
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable32_1  ;; 0x40023c00
   \   00000040   0x6008             STR      R0,[R1, #+0]
    263            }
    264          }
   \                     ??FLASH_SLEEPPowerDownCmd_2: (+1)
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
    265          
    266          /**
    267            * @}
    268            */
    269          
    270          /** @defgroup FLASH_Group2 FLASH Memory Programming functions
    271           *  @brief   FLASH Memory Programming functions
    272           *
    273          @verbatim   
    274           ===============================================================================
    275                                FLASH Memory Programming functions
    276           ===============================================================================  
    277          
    278             The FLASH Memory Programming functions, includes the following functions:
    279              - void FLASH_Unlock(void);
    280              - void FLASH_Lock(void);
    281              - FLASH_Status FLASH_ErasePage(uint32_t Page_Address);
    282              - FLASH_Status FLASH_FastProgramWord(uint32_t Address, uint32_t Data);
    283             
    284             Any operation of erase or program should follow these steps:
    285          
    286             1. Call the FLASH_Unlock() function to enable the flash control register and 
    287               program memory access
    288          
    289             2. Call the desired function to erase page or program data
    290          
    291             3. Call the FLASH_Lock() to disable the flash program memory access 
    292               (recommended to protect the FLASH memory against possible unwanted operation)
    293          
    294          @endverbatim
    295            * @{
    296            */
    297          
    298          /**
    299            * @brief  Unlocks the FLASH control register and program memory access.
    300            * @param  None
    301            * @retval None
    302            */

   \                                 In section .text, align 2, keep-with-next
    303          void FLASH_Unlock(void)
    304          {
   \                     FLASH_Unlock: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    305            if((FLASH->PECR & FLASH_PECR_PRGLOCK) != RESET)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable32_2  ;; 0x40023c04
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x0780             LSLS     R0,R0,#+30
   \   0000000A   0xD50B             BPL.N    ??FLASH_Unlock_0
    306            {
    307              /* Unlocking the data memory and FLASH_PECR register access */
    308              DATA_EEPROM_Unlock();
   \   0000000C   0x.... 0x....      BL       DATA_EEPROM_Unlock
    309            
    310              /* Unlocking the program memory access */
    311              FLASH->PRGKEYR = FLASH_PRGKEY1;
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable32_3  ;; 0x8c9daebf
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable32_4  ;; 0x40023c10
   \   00000018   0x6008             STR      R0,[R1, #+0]
    312              FLASH->PRGKEYR = FLASH_PRGKEY2;  
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable32_5  ;; 0x13141516
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable32_4  ;; 0x40023c10
   \   00000022   0x6008             STR      R0,[R1, #+0]
    313            }
    314          }
   \                     ??FLASH_Unlock_0: (+1)
   \   00000024   0xBD01             POP      {R0,PC}          ;; return
    315          
    316          /**
    317            * @brief  Locks the Program memory access.
    318            * @param  None
    319            * @retval None
    320            */

   \                                 In section .text, align 2, keep-with-next
    321          void FLASH_Lock(void)
    322          {
    323            /* Set the PRGLOCK Bit to lock the program memory access */
    324            FLASH->PECR |= FLASH_PECR_PRGLOCK;
   \                     FLASH_Lock: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable32_2  ;; 0x40023c04
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable32_2  ;; 0x40023c04
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    325          }
   \   00000010   0x4770             BX       LR               ;; return
    326          
    327          /**
    328            * @brief  Erases a specified page in program memory.
    329            * @note   - To correctly run this function, the FLASH_Unlock() function
    330            *           must be called before.
    331            *         - Call the FLASH_Lock() to disable the flash memory access 
    332            *          (recommended to protect the FLASH memory against possible unwanted operation)  
    333            * @param  Page_Address: The page address in program memory to be erased.
    334            * @note   A Page is erased in the Program memory only if the address to load 
    335            *         is the start address of a page (multiple of 256 bytes).  
    336            * @retval FLASH Status: The returned value can be: 
    337            *   FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
    338            */

   \                                 In section .text, align 2, keep-with-next
    339          FLASH_Status FLASH_ErasePage(uint32_t Page_Address)
    340          {
   \                     FLASH_ErasePage: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    341            FLASH_Status status = FLASH_COMPLETE;
   \   00000004   0x2504             MOVS     R5,#+4
    342          
    343            /* Check the parameters */
    344            assert_param(IS_FLASH_PROGRAM_ADDRESS(Page_Address));
   \   00000006   0xF1B4 0x6F00      CMP      R4,#+134217728
   \   0000000A   0xD303             BCC.N    ??FLASH_ErasePage_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable32_6  ;; 0x8020000
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD305             BCC.N    ??FLASH_ErasePage_1
   \                     ??FLASH_ErasePage_0: (+1)
   \   00000014   0xF44F 0x71AC      MOV      R1,#+344
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable32
   \   0000001C   0x.... 0x....      BL       assert_failed
    345           
    346            /* Wait for last operation to be completed */
    347            status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   \                     ??FLASH_ErasePage_1: (+1)
   \   00000020   0xF44F 0x4000      MOV      R0,#+32768
   \   00000024   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000028   0x0005             MOVS     R5,R0
    348            
    349            if(status == FLASH_COMPLETE)
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0x2D04             CMP      R5,#+4
   \   0000002E   0xD126             BNE.N    ??FLASH_ErasePage_2
    350            {
    351              /* If the previous operation is completed, proceed to erase the page */
    352          
    353              /* Set the ERASE bit */
    354              FLASH->PECR |= FLASH_PECR_ERASE;
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable32_2  ;; 0x40023c04
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable32_2  ;; 0x40023c04
   \   0000003E   0x6008             STR      R0,[R1, #+0]
    355          
    356              /* Set PROG bit */
    357              FLASH->PECR |= FLASH_PECR_PROG;
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable32_2  ;; 0x40023c04
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable32_2  ;; 0x40023c04
   \   0000004E   0x6008             STR      R0,[R1, #+0]
    358            
    359              /* Write 00000000h to the first word of the program page to erase */
    360              *(__IO uint32_t *)Page_Address = 0x00000000;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x6020             STR      R0,[R4, #+0]
    361           
    362              /* Wait for last operation to be completed */
    363              status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   \   00000054   0xF44F 0x4000      MOV      R0,#+32768
   \   00000058   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000005C   0x0005             MOVS     R5,R0
    364          
    365              /* If the erase operation is completed, disable the ERASE and PROG bits */
    366              FLASH->PECR &= (uint32_t)(~FLASH_PECR_PROG);
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable32_2  ;; 0x40023c04
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0xF030 0x0008      BICS     R0,R0,#0x8
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable32_2  ;; 0x40023c04
   \   0000006C   0x6008             STR      R0,[R1, #+0]
    367              FLASH->PECR &= (uint32_t)(~FLASH_PECR_ERASE);   
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable32_2  ;; 0x40023c04
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0xF430 0x7000      BICS     R0,R0,#0x200
   \   00000078   0x.... 0x....      LDR.W    R1,??DataTable32_2  ;; 0x40023c04
   \   0000007C   0x6008             STR      R0,[R1, #+0]
    368            }     
    369            /* Return the Erase Status */
    370            return status;
   \                     ??FLASH_ErasePage_2: (+1)
   \   0000007E   0x0028             MOVS     R0,R5
   \   00000080   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000082   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    371          }
    372          
    373          /**
    374            * @brief  Programs a word at a specified address in program memory.
    375            * @note   - To correctly run this function, the FLASH_Unlock() function
    376            *           must be called before.
    377            *         - Call the FLASH_Lock() to disable the flash memory access  
    378            *          (recommended to protect the FLASH memory against possible unwanted operation)  
    379            * @param  Address: specifies the address to be written.
    380            * @param  Data: specifies the data to be written.
    381            * @retval FLASH Status: The returned value can be:  
    382            *   FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
    383            */

   \                                 In section .text, align 2, keep-with-next
    384          FLASH_Status FLASH_FastProgramWord(uint32_t Address, uint32_t Data)
    385          {
   \                     FLASH_FastProgramWord: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    386            FLASH_Status status = FLASH_COMPLETE;
   \   00000006   0x2604             MOVS     R6,#+4
    387          
    388            /* Check the parameters */
    389            assert_param(IS_FLASH_PROGRAM_ADDRESS(Address));
   \   00000008   0xF1B4 0x6F00      CMP      R4,#+134217728
   \   0000000C   0xD303             BCC.N    ??FLASH_FastProgramWord_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable32_6  ;; 0x8020000
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD305             BCC.N    ??FLASH_FastProgramWord_1
   \                     ??FLASH_FastProgramWord_0: (+1)
   \   00000016   0xF240 0x1185      MOVW     R1,#+389
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable32
   \   0000001E   0x.... 0x....      BL       assert_failed
    390            
    391            /* Wait for last operation to be completed */
    392            status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   \                     ??FLASH_FastProgramWord_1: (+1)
   \   00000022   0xF44F 0x4000      MOV      R0,#+32768
   \   00000026   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000002A   0x0006             MOVS     R6,R0
    393            
    394            if(status == FLASH_COMPLETE)
   \   0000002C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002E   0x2E04             CMP      R6,#+4
   \   00000030   0xD105             BNE.N    ??FLASH_FastProgramWord_2
    395            {
    396              /* If the previous operation is completed, proceed to program the new  word */  
    397              *(__IO uint32_t *)Address = Data;
   \   00000032   0x6025             STR      R5,[R4, #+0]
    398              
    399              /* Wait for last operation to be completed */
    400              status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);       
   \   00000034   0xF44F 0x4000      MOV      R0,#+32768
   \   00000038   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000003C   0x0006             MOVS     R6,R0
    401            }
    402            /* Return the Write Status */
    403            return status;
   \                     ??FLASH_FastProgramWord_2: (+1)
   \   0000003E   0x0030             MOVS     R0,R6
   \   00000040   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000042   0xBD70             POP      {R4-R6,PC}       ;; return
    404          }
    405          
    406          /**
    407            * @}
    408            */
    409            
    410          /** @defgroup FLASH_Group3 DATA EEPROM Programming functions
    411           *  @brief   DATA EEPROM Programming functions
    412           *
    413          @verbatim   
    414           ===============================================================================
    415                                 DATA EEPROM Programming functions
    416           ===============================================================================  
    417          
    418             The DATA_EEPROM Programming_Functions, includes the following functions:
    419             - void DATA_EEPROM_Unlock(void);
    420             - void DATA_EEPROM_Lock(void);
    421             - FLASH_Status DATA_EEPROM_EraseWord(uint32_t Address);
    422             - FLASH_Status DATA_EEPROM_FastProgramByte(uint32_t Address, uint8_t Data);
    423             - FLASH_Status DATA_EEPROM_FastProgramHalfWord(uint32_t Address, uint16_t Data);
    424             - FLASH_Status DATA_EEPROM_FastProgramWord(uint32_t Address, uint32_t Data);
    425             - FLASH_Status DATA_EEPROM_ProgramByte(uint32_t Address, uint8_t Data);
    426             - FLASH_Status DATA_EEPROM_ProgramHalfWord(uint32_t Address, uint16_t Data);
    427             - FLASH_Status DATA_EEPROM_ProgramWord(uint32_t Address, uint32_t Data);
    428             
    429             Any operation of erase or program should follow these steps:
    430          
    431             1. Call the DATA_EEPROM_Unlock() function to enable the data EEPROM access
    432               and Flash program erase control register access.
    433          
    434             2. Call the desired function to erase or program data
    435          
    436             3. Call the DATA_EEPROM_Lock() to disable the data EEPROM access
    437               and Flash program erase control register access(recommended
    438               to protect the DATA_EEPROM against possible unwanted operation)
    439          
    440          @endverbatim
    441            * @{
    442            */
    443          
    444          /**
    445            * @brief  Unlocks the data memory and FLASH_PECR register access.
    446            * @param  None
    447            * @retval None
    448            */

   \                                 In section .text, align 2, keep-with-next
    449          void DATA_EEPROM_Unlock(void)
    450          {
    451            if((FLASH->PECR & FLASH_PECR_PELOCK) != RESET)
   \                     DATA_EEPROM_Unlock: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable32_2  ;; 0x40023c04
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x07C0             LSLS     R0,R0,#+31
   \   00000008   0xD509             BPL.N    ??DATA_EEPROM_Unlock_0
    452            {  
    453              /* Unlocking the Data memory and FLASH_PECR register access*/
    454              FLASH->PEKEYR = FLASH_PEKEY1;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable32_7  ;; 0x89abcdef
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable32_8  ;; 0x40023c0c
   \   00000012   0x6008             STR      R0,[R1, #+0]
    455              FLASH->PEKEYR = FLASH_PEKEY2;
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable32_9  ;; 0x2030405
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable32_8  ;; 0x40023c0c
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    456            }
    457          }
   \                     ??DATA_EEPROM_Unlock_0: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
    458          
    459          /**
    460            * @brief  Locks the Data memory and FLASH_PECR register access.
    461            * @param  None
    462            * @retval None
    463            */

   \                                 In section .text, align 2, keep-with-next
    464          void DATA_EEPROM_Lock(void)
    465          {
    466            /* Set the PELOCK Bit to lock the data memory and FLASH_PECR register access */
    467            FLASH->PECR |= FLASH_PECR_PELOCK;
   \                     DATA_EEPROM_Lock: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable32_2  ;; 0x40023c04
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable32_2  ;; 0x40023c04
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    468          }
   \   00000010   0x4770             BX       LR               ;; return
    469          
    470          /**
    471            * @brief  Enables or disables DATA EEPROM fixed Time programming (2*Tprog).
    472            * @param  NewState: new state of the DATA EEPROM fixed Time programming mode.
    473            *              This parameter can be: ENABLE or DISABLE.  
    474            * @retval None
    475            */

   \                                 In section .text, align 2, keep-with-next
    476          void DATA_EEPROM_FixedTimeProgramCmd(FunctionalState NewState)
    477          {
   \                     DATA_EEPROM_FixedTimeProgramCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    478            /* Check the parameters */
    479            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD008             BEQ.N    ??DATA_EEPROM_FixedTimeProgramCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD005             BEQ.N    ??DATA_EEPROM_FixedTimeProgramCmd_0
   \   00000010   0xF240 0x11DF      MOVW     R1,#+479
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000018   0x.... 0x....      BL       assert_failed
    480            
    481            if(NewState != DISABLE)
   \                     ??DATA_EEPROM_FixedTimeProgramCmd_0: (+1)
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD008             BEQ.N    ??DATA_EEPROM_FixedTimeProgramCmd_1
    482            {
    483              FLASH->PECR |= (uint32_t)FLASH_PECR_FTDW;
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable32_2  ;; 0x40023c04
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable32_2  ;; 0x40023c04
   \   00000030   0x6008             STR      R0,[R1, #+0]
   \   00000032   0xE007             B.N      ??DATA_EEPROM_FixedTimeProgramCmd_2
    484            }
    485            else
    486            {
    487              FLASH->PECR &= (uint32_t)(~((uint32_t)FLASH_PECR_FTDW));
   \                     ??DATA_EEPROM_FixedTimeProgramCmd_1: (+1)
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable32_2  ;; 0x40023c04
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0xF430 0x7080      BICS     R0,R0,#0x100
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable32_2  ;; 0x40023c04
   \   00000042   0x6008             STR      R0,[R1, #+0]
    488            }
    489          }
   \                     ??DATA_EEPROM_FixedTimeProgramCmd_2: (+1)
   \   00000044   0xBD10             POP      {R4,PC}          ;; return
    490          
    491          /**
    492            * @brief  Erase a word in data memory.
    493            * @param  Address: specifies the address to be erased
    494            * @note1  - A data memory word is erased in the data memory only if the address 
    495            *         to load is the start address of a word (multiple of a word).
    496            * @note2   - To correctly run this function, the DATA_EEPROM_Unlock() function
    497            *           must be called before.
    498            *          - Call the DATA_EEPROM_Lock() to he data EEPROM access
    499            *            and Flash program erase control register access(recommended to protect 
    500            *            the DATA_EEPROM against possible unwanted operation)    
    501            * @retval FLASH Status: The returned value can be: 
    502            *   FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
    503            */

   \                                 In section .text, align 2, keep-with-next
    504          FLASH_Status DATA_EEPROM_EraseWord(uint32_t Address)
    505          {
   \                     DATA_EEPROM_EraseWord: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    506            FLASH_Status status = FLASH_COMPLETE;
   \   00000004   0x2504             MOVS     R5,#+4
    507            
    508            /* Check the parameters */
    509            assert_param(IS_FLASH_DATA_ADDRESS(Address));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable32_10  ;; 0x8080000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD303             BCC.N    ??DATA_EEPROM_EraseWord_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable32_11  ;; 0x8081000
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD305             BCC.N    ??DATA_EEPROM_EraseWord_1
   \                     ??DATA_EEPROM_EraseWord_0: (+1)
   \   00000016   0xF240 0x11FD      MOVW     R1,#+509
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable32
   \   0000001E   0x.... 0x....      BL       assert_failed
    510            
    511            /* Wait for last operation to be completed */
    512            status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   \                     ??DATA_EEPROM_EraseWord_1: (+1)
   \   00000022   0xF44F 0x4000      MOV      R0,#+32768
   \   00000026   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000002A   0x0005             MOVS     R5,R0
    513            
    514            if(status == FLASH_COMPLETE)
   \   0000002C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002E   0x2D04             CMP      R5,#+4
   \   00000030   0xD101             BNE.N    ??DATA_EEPROM_EraseWord_2
    515            {
    516              /* Write "00000000h" to valid address in the data memory" */
    517              *(__IO uint32_t *) Address = 0x00000000;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x6020             STR      R0,[R4, #+0]
    518            }
    519             
    520            /* Return the erase status */
    521            return status;
   \                     ??DATA_EEPROM_EraseWord_2: (+1)
   \   00000036   0x0028             MOVS     R0,R5
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    522          }
    523          
    524          /**
    525            * @brief  Write a Byte at a specified address in data memory.
    526            * @note   - To correctly run this function, the DATA_EEPROM_Unlock() function
    527            *           must be called before.
    528            *         - Call the DATA_EEPROM_Lock() to he data EEPROM access
    529            *            and Flash program erase control register access(recommended to protect 
    530            *            the DATA_EEPROM against possible unwanted operation)  
    531            * @param  Address: specifies the address to be written.
    532            * @param  Data: specifies the data to be written.
    533            * @note This function assumes that the is data word is already erased.  
    534            * @retval FLASH Status: The returned value can be:  
    535            *   FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
    536            */

   \                                 In section .text, align 2, keep-with-next
    537          FLASH_Status DATA_EEPROM_FastProgramByte(uint32_t Address, uint8_t Data)
    538          {
   \                     DATA_EEPROM_FastProgramByte: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    539            FLASH_Status status = FLASH_COMPLETE;
   \   00000008   0x2604             MOVS     R6,#+4
    540            uint32_t tmp = 0, tmpaddr = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
    541            
    542            /* Check the parameters */
    543            assert_param(IS_FLASH_DATA_ADDRESS(Address)); 
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable32_10  ;; 0x8080000
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD303             BCC.N    ??DATA_EEPROM_FastProgramByte_0
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable32_11  ;; 0x8081000
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD305             BCC.N    ??DATA_EEPROM_FastProgramByte_1
   \                     ??DATA_EEPROM_FastProgramByte_0: (+1)
   \   00000020   0xF240 0x211F      MOVW     R1,#+543
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000028   0x.... 0x....      BL       assert_failed
    544          
    545            /* Wait for last operation to be completed */
    546            status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   \                     ??DATA_EEPROM_FastProgramByte_1: (+1)
   \   0000002C   0xF44F 0x4000      MOV      R0,#+32768
   \   00000030   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000034   0x0006             MOVS     R6,R0
    547              
    548            if(status == FLASH_COMPLETE)
   \   00000036   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000038   0x2E04             CMP      R6,#+4
   \   0000003A   0xD12B             BNE.N    ??DATA_EEPROM_FastProgramByte_2
    549            {
    550              /* Clear the FTDW bit */
    551              FLASH->PECR &= (uint32_t)(~((uint32_t)FLASH_PECR_FTDW));
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable32_2  ;; 0x40023c04
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0xF430 0x7080      BICS     R0,R0,#0x100
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable32_2  ;; 0x40023c04
   \   0000004A   0x6008             STR      R0,[R1, #+0]
    552              
    553              if(Data != (uint8_t)0x00) 
   \   0000004C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004E   0x2D00             CMP      R5,#+0
   \   00000050   0xD006             BEQ.N    ??DATA_EEPROM_FastProgramByte_3
    554              {
    555                /* If the previous operation is completed, proceed to write the new Data */        
    556                *(__IO uint8_t *)Address = Data;
   \   00000052   0x7025             STRB     R5,[R4, #+0]
    557                      
    558                /* Wait for last operation to be completed */
    559                status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);           
   \   00000054   0xF44F 0x4000      MOV      R0,#+32768
   \   00000058   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000005C   0x0006             MOVS     R6,R0
   \   0000005E   0xE019             B.N      ??DATA_EEPROM_FastProgramByte_2
    560              }
    561              else
    562              {
    563                tmpaddr = Address & 0xFFFFFFFC;
   \                     ??DATA_EEPROM_FastProgramByte_3: (+1)
   \   00000060   0x08A0             LSRS     R0,R4,#+2
   \   00000062   0x0080             LSLS     R0,R0,#+2
   \   00000064   0x4680             MOV      R8,R0
    564                tmp = * (__IO uint32_t *) tmpaddr;
   \   00000066   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000006A   0x0007             MOVS     R7,R0
    565                tmpaddr = 0xFF << ((uint32_t) (0x8 * (Address & 0x3)));
   \   0000006C   0x20FF             MOVS     R0,#+255
   \   0000006E   0xF014 0x0103      ANDS     R1,R4,#0x3
   \   00000072   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000074   0x00C9             LSLS     R1,R1,#+3
   \   00000076   0x4088             LSLS     R0,R0,R1
   \   00000078   0x4680             MOV      R8,R0
    566                tmp &= ~tmpaddr;
   \   0000007A   0xEA37 0x0708      BICS     R7,R7,R8
    567                status = DATA_EEPROM_EraseWord(Address & 0xFFFFFFFC);
   \   0000007E   0x08A0             LSRS     R0,R4,#+2
   \   00000080   0x0080             LSLS     R0,R0,#+2
   \   00000082   0x.... 0x....      BL       DATA_EEPROM_EraseWord
   \   00000086   0x0006             MOVS     R6,R0
    568                status = DATA_EEPROM_FastProgramWord((Address & 0xFFFFFFFC), tmp);         
   \   00000088   0x0039             MOVS     R1,R7
   \   0000008A   0x08A0             LSRS     R0,R4,#+2
   \   0000008C   0x0080             LSLS     R0,R0,#+2
   \   0000008E   0x.... 0x....      BL       DATA_EEPROM_FastProgramWord
   \   00000092   0x0006             MOVS     R6,R0
    569              }       
    570            }
    571            /* Return the Write Status */
    572            return status;
   \                     ??DATA_EEPROM_FastProgramByte_2: (+1)
   \   00000094   0x0030             MOVS     R0,R6
   \   00000096   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000098   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    573          }
    574          
    575          /**
    576            * @brief  Writes a half word at a specified address in data memory.
    577            * @note   - To correctly run this function, the DATA_EEPROM_Unlock() function
    578            *           must be called before.
    579            *         - Call the DATA_EEPROM_Lock() to he data EEPROM access
    580            *            and Flash program erase control register access(recommended to protect 
    581            *            the DATA_EEPROM against possible unwanted operation)    
    582            * @param  Address: specifies the address to be written.
    583            * @param  Data: specifies the data to be written.
    584            * @note This function assumes that the is data word is already erased.  
    585            * @retval FLASH Status: The returned value can be: 
    586            *   FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or  FLASH_TIMEOUT. 
    587            */

   \                                 In section .text, align 2, keep-with-next
    588          FLASH_Status DATA_EEPROM_FastProgramHalfWord(uint32_t Address, uint16_t Data)
    589          {
   \                     DATA_EEPROM_FastProgramHalfWord: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    590            FLASH_Status status = FLASH_COMPLETE;
   \   00000008   0x2604             MOVS     R6,#+4
    591            uint32_t tmp = 0, tmpaddr = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
    592            
    593            /* Check the parameters */
    594            assert_param(IS_FLASH_DATA_ADDRESS(Address));
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable32_10  ;; 0x8080000
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD303             BCC.N    ??DATA_EEPROM_FastProgramHalfWord_0
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable32_11  ;; 0x8081000
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD305             BCC.N    ??DATA_EEPROM_FastProgramHalfWord_1
   \                     ??DATA_EEPROM_FastProgramHalfWord_0: (+1)
   \   00000020   0xF240 0x2152      MOVW     R1,#+594
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000028   0x.... 0x....      BL       assert_failed
    595          
    596            /* Wait for last operation to be completed */
    597            status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   \                     ??DATA_EEPROM_FastProgramHalfWord_1: (+1)
   \   0000002C   0xF44F 0x4000      MOV      R0,#+32768
   \   00000030   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000034   0x0006             MOVS     R6,R0
    598              
    599            if(status == FLASH_COMPLETE)
   \   00000036   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000038   0x2E04             CMP      R6,#+4
   \   0000003A   0xD139             BNE.N    ??DATA_EEPROM_FastProgramHalfWord_2
    600            {
    601              /* Clear the FTDW bit */
    602              FLASH->PECR &= (uint32_t)(~((uint32_t)FLASH_PECR_FTDW));
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable32_2  ;; 0x40023c04
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0xF430 0x7080      BICS     R0,R0,#0x100
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable32_2  ;; 0x40023c04
   \   0000004A   0x6008             STR      R0,[R1, #+0]
    603            
    604              if(Data != (uint16_t)0x0000) 
   \   0000004C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004E   0x2D00             CMP      R5,#+0
   \   00000050   0xD006             BEQ.N    ??DATA_EEPROM_FastProgramHalfWord_3
    605              {
    606                /* If the previous operation is completed, proceed to write the new data */   
    607                *(__IO uint16_t *)Address = Data;
   \   00000052   0x8025             STRH     R5,[R4, #+0]
    608            
    609                /* Wait for last operation to be completed */
    610                status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   \   00000054   0xF44F 0x4000      MOV      R0,#+32768
   \   00000058   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000005C   0x0006             MOVS     R6,R0
   \   0000005E   0xE027             B.N      ??DATA_EEPROM_FastProgramHalfWord_2
    611              }
    612              else
    613              {
    614                if((Address & 0x3) != 0x3)
   \                     ??DATA_EEPROM_FastProgramHalfWord_3: (+1)
   \   00000060   0xF014 0x0003      ANDS     R0,R4,#0x3
   \   00000064   0x2803             CMP      R0,#+3
   \   00000066   0xD01B             BEQ.N    ??DATA_EEPROM_FastProgramHalfWord_4
    615                {        
    616                  tmpaddr = Address & 0xFFFFFFFC;
   \   00000068   0x08A0             LSRS     R0,R4,#+2
   \   0000006A   0x0080             LSLS     R0,R0,#+2
   \   0000006C   0x4680             MOV      R8,R0
    617                  tmp = * (__IO uint32_t *) tmpaddr;
   \   0000006E   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000072   0x0007             MOVS     R7,R0
    618                  tmpaddr = 0xFFFF << ((uint32_t) (0x8 * (Address & 0x3)));
   \   00000074   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000078   0xF014 0x0103      ANDS     R1,R4,#0x3
   \   0000007C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000007E   0x00C9             LSLS     R1,R1,#+3
   \   00000080   0x4088             LSLS     R0,R0,R1
   \   00000082   0x4680             MOV      R8,R0
    619                  tmp &= ~tmpaddr;        
   \   00000084   0xEA37 0x0708      BICS     R7,R7,R8
    620                  status = DATA_EEPROM_EraseWord(Address & 0xFFFFFFFC);
   \   00000088   0x08A0             LSRS     R0,R4,#+2
   \   0000008A   0x0080             LSLS     R0,R0,#+2
   \   0000008C   0x.... 0x....      BL       DATA_EEPROM_EraseWord
   \   00000090   0x0006             MOVS     R6,R0
    621                  status = DATA_EEPROM_FastProgramWord((Address & 0xFFFFFFFC), tmp);      
   \   00000092   0x0039             MOVS     R1,R7
   \   00000094   0x08A0             LSRS     R0,R4,#+2
   \   00000096   0x0080             LSLS     R0,R0,#+2
   \   00000098   0x.... 0x....      BL       DATA_EEPROM_FastProgramWord
   \   0000009C   0x0006             MOVS     R6,R0
   \   0000009E   0xE007             B.N      ??DATA_EEPROM_FastProgramHalfWord_2
    622                }
    623                else
    624                {
    625                  DATA_EEPROM_FastProgramByte(Address, 0x00);
   \                     ??DATA_EEPROM_FastProgramHalfWord_4: (+1)
   \   000000A0   0x2100             MOVS     R1,#+0
   \   000000A2   0x0020             MOVS     R0,R4
   \   000000A4   0x.... 0x....      BL       DATA_EEPROM_FastProgramByte
    626                  DATA_EEPROM_FastProgramByte(Address + 1, 0x00);          
   \   000000A8   0x2100             MOVS     R1,#+0
   \   000000AA   0x1C60             ADDS     R0,R4,#+1
   \   000000AC   0x.... 0x....      BL       DATA_EEPROM_FastProgramByte
    627                }      
    628              }      
    629            } 
    630            /* Return the Write Status */
    631            return status;
   \                     ??DATA_EEPROM_FastProgramHalfWord_2: (+1)
   \   000000B0   0x0030             MOVS     R0,R6
   \   000000B2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B4   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    632          }
    633          
    634          /**
    635            * @brief  Programs a word at a specified address in data memory.
    636            * @note   - To correctly run this function, the DATA_EEPROM_Unlock() function
    637            *           must be called before.
    638            *         - Call the DATA_EEPROM_Lock() to the data EEPROM access
    639            *            and Flash program erase control register access(recommended to protect 
    640            *            the DATA_EEPROM against possible unwanted operation)    
    641            * @param  Address: specifies the address to be written.
    642            * @param  Data: specifies the data to be written.
    643            * @note This function assumes that the is data word is already erased.    
    644            * @retval FLASH Status: The returned value can be: 
    645            *   FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
    646            */

   \                                 In section .text, align 2, keep-with-next
    647          FLASH_Status DATA_EEPROM_FastProgramWord(uint32_t Address, uint32_t Data)
    648          {
   \                     DATA_EEPROM_FastProgramWord: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    649            FLASH_Status status = FLASH_COMPLETE;
   \   00000006   0x2604             MOVS     R6,#+4
    650          
    651            /* Check the parameters */
    652            assert_param(IS_FLASH_DATA_ADDRESS(Address));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable32_10  ;; 0x8080000
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD303             BCC.N    ??DATA_EEPROM_FastProgramWord_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable32_11  ;; 0x8081000
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD305             BCC.N    ??DATA_EEPROM_FastProgramWord_1
   \                     ??DATA_EEPROM_FastProgramWord_0: (+1)
   \   00000018   0xF44F 0x7123      MOV      R1,#+652
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000020   0x.... 0x....      BL       assert_failed
    653            
    654            /* Wait for last operation to be completed */
    655            status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   \                     ??DATA_EEPROM_FastProgramWord_1: (+1)
   \   00000024   0xF44F 0x4000      MOV      R0,#+32768
   \   00000028   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000002C   0x0006             MOVS     R6,R0
    656            
    657            if(status == FLASH_COMPLETE)
   \   0000002E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000030   0x2E04             CMP      R6,#+4
   \   00000032   0xD10D             BNE.N    ??DATA_EEPROM_FastProgramWord_2
    658            {
    659              /* Clear the FTDW bit */
    660              FLASH->PECR &= (uint32_t)(~((uint32_t)FLASH_PECR_FTDW));
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable32_2  ;; 0x40023c04
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0xF430 0x7080      BICS     R0,R0,#0x100
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable32_2  ;; 0x40023c04
   \   00000042   0x6008             STR      R0,[R1, #+0]
    661            
    662              /* If the previous operation is completed, proceed to program the new data */    
    663              *(__IO uint32_t *)Address = Data;
   \   00000044   0x6025             STR      R5,[R4, #+0]
    664              
    665              /* Wait for last operation to be completed */
    666              status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);       
   \   00000046   0xF44F 0x4000      MOV      R0,#+32768
   \   0000004A   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000004E   0x0006             MOVS     R6,R0
    667            }
    668            /* Return the Write Status */
    669            return status;
   \                     ??DATA_EEPROM_FastProgramWord_2: (+1)
   \   00000050   0x0030             MOVS     R0,R6
   \   00000052   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000054   0xBD70             POP      {R4-R6,PC}       ;; return
    670          }
    671          
    672          /**
    673            * @brief  Write a Byte at a specified address in data memory without erase.
    674            * @note   - To correctly run this function, the DATA_EEPROM_Unlock() function
    675            *           must be called before.
    676            *         - Call the DATA_EEPROM_Lock() to he data EEPROM access
    677            *            and Flash program erase control register access(recommended to protect 
    678            *            the DATA_EEPROM against possible unwanted operation) 
    679            * @note   The function  DATA_EEPROM_FixedTimeProgramCmd() can be called before 
    680            *         this function to configure the Fixed Time Programming.      
    681            * @param  Address: specifies the address to be written.
    682            * @param  Data: specifies the data to be written.
    683            * @retval FLASH Status: The returned value can be: 
    684            *   FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
    685            */

   \                                 In section .text, align 2, keep-with-next
    686          FLASH_Status DATA_EEPROM_ProgramByte(uint32_t Address, uint8_t Data)
    687          {
   \                     DATA_EEPROM_ProgramByte: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    688            FLASH_Status status = FLASH_COMPLETE;
   \   00000008   0x2604             MOVS     R6,#+4
    689            uint32_t tmp = 0, tmpaddr = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
    690            
    691            /* Check the parameters */
    692            assert_param(IS_FLASH_DATA_ADDRESS(Address)); 
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable32_10  ;; 0x8080000
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD303             BCC.N    ??DATA_EEPROM_ProgramByte_0
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable32_11  ;; 0x8081000
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD305             BCC.N    ??DATA_EEPROM_ProgramByte_1
   \                     ??DATA_EEPROM_ProgramByte_0: (+1)
   \   00000020   0xF44F 0x712D      MOV      R1,#+692
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000028   0x.... 0x....      BL       assert_failed
    693          
    694            /* Wait for last operation to be completed */
    695            status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   \                     ??DATA_EEPROM_ProgramByte_1: (+1)
   \   0000002C   0xF44F 0x4000      MOV      R0,#+32768
   \   00000030   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000034   0x0006             MOVS     R6,R0
    696            
    697            if(status == FLASH_COMPLETE)
   \   00000036   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000038   0x2E04             CMP      R6,#+4
   \   0000003A   0xD123             BNE.N    ??DATA_EEPROM_ProgramByte_2
    698            {
    699              if(Data != (uint8_t) 0x00)
   \   0000003C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003E   0x2D00             CMP      R5,#+0
   \   00000040   0xD006             BEQ.N    ??DATA_EEPROM_ProgramByte_3
    700              {  
    701                *(__IO uint8_t *)Address = Data;
   \   00000042   0x7025             STRB     R5,[R4, #+0]
    702              
    703                /* Wait for last operation to be completed */
    704                status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   \   00000044   0xF44F 0x4000      MOV      R0,#+32768
   \   00000048   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000004C   0x0006             MOVS     R6,R0
   \   0000004E   0xE019             B.N      ??DATA_EEPROM_ProgramByte_2
    705          
    706              }
    707              else
    708              {
    709                tmpaddr = Address & 0xFFFFFFFC;
   \                     ??DATA_EEPROM_ProgramByte_3: (+1)
   \   00000050   0x08A0             LSRS     R0,R4,#+2
   \   00000052   0x0080             LSLS     R0,R0,#+2
   \   00000054   0x4680             MOV      R8,R0
    710                tmp = * (__IO uint32_t *) tmpaddr;
   \   00000056   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000005A   0x0007             MOVS     R7,R0
    711                tmpaddr = 0xFF << ((uint32_t) (0x8 * (Address & 0x3)));
   \   0000005C   0x20FF             MOVS     R0,#+255
   \   0000005E   0xF014 0x0103      ANDS     R1,R4,#0x3
   \   00000062   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000064   0x00C9             LSLS     R1,R1,#+3
   \   00000066   0x4088             LSLS     R0,R0,R1
   \   00000068   0x4680             MOV      R8,R0
    712                tmp &= ~tmpaddr;        
   \   0000006A   0xEA37 0x0708      BICS     R7,R7,R8
    713                status = DATA_EEPROM_EraseWord(Address & 0xFFFFFFFC);
   \   0000006E   0x08A0             LSRS     R0,R4,#+2
   \   00000070   0x0080             LSLS     R0,R0,#+2
   \   00000072   0x.... 0x....      BL       DATA_EEPROM_EraseWord
   \   00000076   0x0006             MOVS     R6,R0
    714                status = DATA_EEPROM_FastProgramWord((Address & 0xFFFFFFFC), tmp);        
   \   00000078   0x0039             MOVS     R1,R7
   \   0000007A   0x08A0             LSRS     R0,R4,#+2
   \   0000007C   0x0080             LSLS     R0,R0,#+2
   \   0000007E   0x.... 0x....      BL       DATA_EEPROM_FastProgramWord
   \   00000082   0x0006             MOVS     R6,R0
    715              }   
    716            }
    717            /* Return the Write Status */
    718            return status;
   \                     ??DATA_EEPROM_ProgramByte_2: (+1)
   \   00000084   0x0030             MOVS     R0,R6
   \   00000086   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000088   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    719          }
    720          
    721          /**
    722            * @brief  Writes a half word at a specified address in data memory without erase.
    723            * @note   - To correctly run this function, the DATA_EEPROM_Unlock() function
    724            *           must be called before.
    725            *         - Call the DATA_EEPROM_Lock() to he data EEPROM access
    726            *            and Flash program erase control register access(recommended to protect 
    727            *            the DATA_EEPROM against possible unwanted operation)
    728            * @note   The function  DATA_EEPROM_FixedTimeProgramCmd() can be called before 
    729            *         this function to configure the Fixed Time Programming                 
    730            * @param  Address: specifies the address to be written.
    731            * @param  Data: specifies the data to be written.
    732            * @retval FLASH Status: The returned value can be:  
    733            *   FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
    734            */

   \                                 In section .text, align 2, keep-with-next
    735          FLASH_Status DATA_EEPROM_ProgramHalfWord(uint32_t Address, uint16_t Data)
    736          {
   \                     DATA_EEPROM_ProgramHalfWord: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    737            FLASH_Status status = FLASH_COMPLETE;
   \   00000008   0x2604             MOVS     R6,#+4
    738            uint32_t tmp = 0, tmpaddr = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
    739            
    740            /* Check the parameters */
    741            assert_param(IS_FLASH_DATA_ADDRESS(Address));
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable32_10  ;; 0x8080000
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD303             BCC.N    ??DATA_EEPROM_ProgramHalfWord_0
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable32_11  ;; 0x8081000
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD305             BCC.N    ??DATA_EEPROM_ProgramHalfWord_1
   \                     ??DATA_EEPROM_ProgramHalfWord_0: (+1)
   \   00000020   0xF240 0x21E5      MOVW     R1,#+741
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000028   0x.... 0x....      BL       assert_failed
    742          
    743            /* Wait for last operation to be completed */
    744            status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   \                     ??DATA_EEPROM_ProgramHalfWord_1: (+1)
   \   0000002C   0xF44F 0x4000      MOV      R0,#+32768
   \   00000030   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000034   0x0006             MOVS     R6,R0
    745            
    746            if(status == FLASH_COMPLETE)
   \   00000036   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000038   0x2E04             CMP      R6,#+4
   \   0000003A   0xD131             BNE.N    ??DATA_EEPROM_ProgramHalfWord_2
    747            {
    748              if(Data != (uint16_t)0x0000)
   \   0000003C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000003E   0x2D00             CMP      R5,#+0
   \   00000040   0xD006             BEQ.N    ??DATA_EEPROM_ProgramHalfWord_3
    749              {
    750                *(__IO uint16_t *)Address = Data;
   \   00000042   0x8025             STRH     R5,[R4, #+0]
    751             
    752                /* Wait for last operation to be completed */
    753                status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);     
   \   00000044   0xF44F 0x4000      MOV      R0,#+32768
   \   00000048   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000004C   0x0006             MOVS     R6,R0
   \   0000004E   0xE027             B.N      ??DATA_EEPROM_ProgramHalfWord_2
    754              }
    755              else
    756              {
    757                if((Address & 0x3) != 0x3)
   \                     ??DATA_EEPROM_ProgramHalfWord_3: (+1)
   \   00000050   0xF014 0x0003      ANDS     R0,R4,#0x3
   \   00000054   0x2803             CMP      R0,#+3
   \   00000056   0xD01B             BEQ.N    ??DATA_EEPROM_ProgramHalfWord_4
    758                {
    759                  tmpaddr = Address & 0xFFFFFFFC;
   \   00000058   0x08A0             LSRS     R0,R4,#+2
   \   0000005A   0x0080             LSLS     R0,R0,#+2
   \   0000005C   0x4680             MOV      R8,R0
    760                  tmp = * (__IO uint32_t *) tmpaddr;
   \   0000005E   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000062   0x0007             MOVS     R7,R0
    761                  tmpaddr = 0xFFFF << ((uint32_t) (0x8 * (Address & 0x3)));
   \   00000064   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000068   0xF014 0x0103      ANDS     R1,R4,#0x3
   \   0000006C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000006E   0x00C9             LSLS     R1,R1,#+3
   \   00000070   0x4088             LSLS     R0,R0,R1
   \   00000072   0x4680             MOV      R8,R0
    762                  tmp &= ~tmpaddr;          
   \   00000074   0xEA37 0x0708      BICS     R7,R7,R8
    763                  status = DATA_EEPROM_EraseWord(Address & 0xFFFFFFFC);
   \   00000078   0x08A0             LSRS     R0,R4,#+2
   \   0000007A   0x0080             LSLS     R0,R0,#+2
   \   0000007C   0x.... 0x....      BL       DATA_EEPROM_EraseWord
   \   00000080   0x0006             MOVS     R6,R0
    764                  status = DATA_EEPROM_FastProgramWord((Address & 0xFFFFFFFC), tmp);  
   \   00000082   0x0039             MOVS     R1,R7
   \   00000084   0x08A0             LSRS     R0,R4,#+2
   \   00000086   0x0080             LSLS     R0,R0,#+2
   \   00000088   0x.... 0x....      BL       DATA_EEPROM_FastProgramWord
   \   0000008C   0x0006             MOVS     R6,R0
   \   0000008E   0xE007             B.N      ??DATA_EEPROM_ProgramHalfWord_2
    765                }
    766                else
    767                {
    768                  DATA_EEPROM_FastProgramByte(Address, 0x00);
   \                     ??DATA_EEPROM_ProgramHalfWord_4: (+1)
   \   00000090   0x2100             MOVS     R1,#+0
   \   00000092   0x0020             MOVS     R0,R4
   \   00000094   0x.... 0x....      BL       DATA_EEPROM_FastProgramByte
    769                  DATA_EEPROM_FastProgramByte(Address + 1, 0x00);          
   \   00000098   0x2100             MOVS     R1,#+0
   \   0000009A   0x1C60             ADDS     R0,R4,#+1
   \   0000009C   0x.... 0x....      BL       DATA_EEPROM_FastProgramByte
    770                }              
    771              }    
    772            } 
    773            /* Return the Write Status */
    774            return status;
   \                     ??DATA_EEPROM_ProgramHalfWord_2: (+1)
   \   000000A0   0x0030             MOVS     R0,R6
   \   000000A2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A4   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    775          }
    776          
    777          /**
    778            * @brief  Programs a word at a specified address in data memory without erase.
    779            * @note   - To correctly run this function, the DATA_EEPROM_Unlock() function
    780            *           must be called before.
    781            *         - Call the DATA_EEPROM_Lock() to he data EEPROM access
    782            *            and Flash program erase control register access(recommended to protect 
    783            *            the DATA_EEPROM against possible unwanted operation)  
    784            * @note   The function  DATA_EEPROM_FixedTimeProgramCmd() can be called before 
    785            *         this function to configure the Fixed Time Programming.               
    786            * @param  Address: specifies the address to be written.
    787            * @param  Data: specifies the data to be written.
    788            * @retval FLASH Status: The returned value can be:  
    789            *   FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or  FLASH_TIMEOUT. 
    790            */

   \                                 In section .text, align 2, keep-with-next
    791          FLASH_Status DATA_EEPROM_ProgramWord(uint32_t Address, uint32_t Data)
    792          {
   \                     DATA_EEPROM_ProgramWord: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    793            FLASH_Status status = FLASH_COMPLETE;
   \   00000006   0x2604             MOVS     R6,#+4
    794            
    795            /* Check the parameters */
    796            assert_param(IS_FLASH_DATA_ADDRESS(Address));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable32_10  ;; 0x8080000
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD303             BCC.N    ??DATA_EEPROM_ProgramWord_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable32_11  ;; 0x8081000
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD305             BCC.N    ??DATA_EEPROM_ProgramWord_1
   \                     ??DATA_EEPROM_ProgramWord_0: (+1)
   \   00000018   0xF44F 0x7147      MOV      R1,#+796
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000020   0x.... 0x....      BL       assert_failed
    797            
    798            /* Wait for last operation to be completed */
    799            status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   \                     ??DATA_EEPROM_ProgramWord_1: (+1)
   \   00000024   0xF44F 0x4000      MOV      R0,#+32768
   \   00000028   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000002C   0x0006             MOVS     R6,R0
    800            
    801            if(status == FLASH_COMPLETE)
   \   0000002E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000030   0x2E04             CMP      R6,#+4
   \   00000032   0xD105             BNE.N    ??DATA_EEPROM_ProgramWord_2
    802            {
    803              *(__IO uint32_t *)Address = Data;
   \   00000034   0x6025             STR      R5,[R4, #+0]
    804          
    805              /* Wait for last operation to be completed */
    806              status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);        
   \   00000036   0xF44F 0x4000      MOV      R0,#+32768
   \   0000003A   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000003E   0x0006             MOVS     R6,R0
    807            }
    808            /* Return the Write Status */
    809            return status;
   \                     ??DATA_EEPROM_ProgramWord_2: (+1)
   \   00000040   0x0030             MOVS     R0,R6
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0xBD70             POP      {R4-R6,PC}       ;; return
    810          }
    811          
    812          /**
    813            * @}
    814            */
    815          
    816          /** @defgroup FLASH_Group4 Option Bytes Programming functions
    817           *  @brief   Option Bytes Programming functions 
    818           *
    819          @verbatim   
    820           ===============================================================================
    821                                  Option Bytes Programming functions
    822           ===============================================================================  
    823          
    824             The FLASH_Option Bytes Programming_functions, includes the following functions:
    825             - void FLASH_OB_Unlock(void);
    826             - void FLASH_OB_Lock(void);
    827             - void FLASH_OB_Launch(void);
    828             - FLASH_Status FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState);
    829             - FLASH_Status FLASH_OB_RDPConfig(uint8_t OB_RDP);
    830             - FLASH_Status FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY);
    831             - FLASH_Status FLASH_OB_BORConfig(uint8_t OB_BOR);
    832             - uint8_t FLASH_OB_GetUser(void);
    833             - uint32_t FLASH_OB_GetWRP(void);
    834             - FlagStatus FLASH_OB_GetRDP(void);
    835             - uint8_t FLASH_OB_GetBOR(void);
    836             
    837             Any operation of erase or program should follow these steps:
    838             
    839             1. Call the FLASH_OB_Unlock() function to enable the Flash option control register access
    840             
    841             2. Call one or several functions to program the desired option bytes 
    842                - void FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState) => to Enable/Disable 
    843                  the desired sector write protection
    844                - void FLASH_OB_RDPConfig(uint8_t OB_RDP) => to set the desired read Protection Level
    845                - void FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY) => to configure 
    846                  the user option Bytes: IWDG, STOP and the Standby.
    847                - void FLASH_OB_BORConfig(uint8_t OB_BOR) => to Set the BOR level 
    848                - FLASH_Status FLASH_ProgramOTP(uint32_t Address, uint32_t Data) => to program the OTP bytes			 
    849             
    850             3. Once all needed option bytes to be programmed are correctly written, call the
    851               FLASH_OB_Launch(void) function to launch the Option Bytes programming process.  
    852             
    853             4. Call the FLASH_OB_Lock() to disable the Flash option control register access (recommended
    854                to protect the option Bytes against possible unwanted operations)
    855          
    856          @endverbatim
    857            * @{
    858            */
    859          
    860          /**
    861            * @brief  Unlocks the option bytes block access.
    862            * @param  None
    863            * @retval None
    864            */

   \                                 In section .text, align 2, keep-with-next
    865          void FLASH_OB_Unlock(void)
    866          {
   \                     FLASH_OB_Unlock: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    867            if((FLASH->PECR & FLASH_PECR_OPTLOCK) != RESET)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable32_2  ;; 0x40023c04
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x0740             LSLS     R0,R0,#+29
   \   0000000A   0xD50B             BPL.N    ??FLASH_OB_Unlock_0
    868            {
    869              /* Unlocking the data memory and FLASH_PECR register access */
    870              DATA_EEPROM_Unlock();
   \   0000000C   0x.... 0x....      BL       DATA_EEPROM_Unlock
    871            
    872              /* Unlocking the option bytes block access */
    873              FLASH->OPTKEYR = FLASH_OPTKEY1;
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable32_12  ;; 0xfbead9c8
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable32_13  ;; 0x40023c14
   \   00000018   0x6008             STR      R0,[R1, #+0]
    874              FLASH->OPTKEYR = FLASH_OPTKEY2;
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable32_14  ;; 0x24252627
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable32_13  ;; 0x40023c14
   \   00000022   0x6008             STR      R0,[R1, #+0]
    875            }
    876          }
   \                     ??FLASH_OB_Unlock_0: (+1)
   \   00000024   0xBD01             POP      {R0,PC}          ;; return
    877          
    878          /**
    879            * @brief  Locks the option bytes block access.
    880            * @param  None
    881            * @retval None
    882            */

   \                                 In section .text, align 2, keep-with-next
    883          void FLASH_OB_Lock(void)
    884          {
    885            /* Set the OPTLOCK Bit to lock the option bytes block access */
    886            FLASH->PECR |= FLASH_PECR_OPTLOCK;
   \                     FLASH_OB_Lock: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable32_2  ;; 0x40023c04
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable32_2  ;; 0x40023c04
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    887          }
   \   00000010   0x4770             BX       LR               ;; return
    888          
    889          /**
    890            * @brief  Launch the option byte loading.
    891            * @param  None
    892            * @retval None
    893            */

   \                                 In section .text, align 2, keep-with-next
    894          void FLASH_OB_Launch(void)
    895          {
    896            /* Set the OBL_Launch bit to lauch the option byte loading */
    897            FLASH->PECR |= FLASH_PECR_OBL_LAUNCH;
   \                     FLASH_OB_Launch: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable32_2  ;; 0x40023c04
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF450 0x2080      ORRS     R0,R0,#0x40000
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable32_2  ;; 0x40023c04
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    898          }
   \   00000010   0x4770             BX       LR               ;; return
    899          
    900          /**
    901            * @brief  Write protects the desired pages
    902            * @note   - To correctly run this function, the FLASH_OB_Unlock() function
    903            *           must be called before.
    904            *         - Call the FLASH_OB_Lock() to disable the flash control register access and the option bytes 
    905            *          (recommended to protect the FLASH memory against possible unwanted operation)    
    906            * @param  OB_WRP: specifies the address of the pages to be write protected.
    907            *   This parameter can be:
    908            *     @arg  value between OB_WRP_Pages0to15 and OB_WRP_Pages496to511
    909            *     @arg OB_WRP_AllPages
    910            * @param  NewState: new state of the specified FLASH Pages Wtite protection.
    911            *   This parameter can be: ENABLE or DISABLE.
    912            * @retval FLASH Status: The returned value can be: 
    913            * FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
    914            */

   \                                 In section .text, align 2, keep-with-next
    915          FLASH_Status FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState)
    916          {
   \                     FLASH_OB_WRPConfig: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    917            uint32_t WRP01_Data = 0, WRP23_Data = 0;
   \   00000008   0x2600             MOVS     R6,#+0
   \   0000000A   0x2700             MOVS     R7,#+0
    918            
    919            FLASH_Status status = FLASH_COMPLETE;
   \   0000000C   0xF05F 0x0804      MOVS     R8,#+4
    920            uint32_t tmp1 = 0, tmp2 = 0;
   \   00000010   0xF05F 0x0900      MOVS     R9,#+0
   \   00000014   0xF05F 0x0A00      MOVS     R10,#+0
    921            
    922            /* Check the parameters */
    923            assert_param(IS_OB_WRP(OB_WRP));
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0xD105             BNE.N    ??FLASH_OB_WRPConfig_0
   \   0000001C   0xF240 0x319B      MOVW     R1,#+923
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable32
   \   00000024   0x.... 0x....      BL       assert_failed
    924            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??FLASH_OB_WRPConfig_0: (+1)
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD008             BEQ.N    ??FLASH_OB_WRPConfig_1
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0x2D01             CMP      R5,#+1
   \   00000032   0xD005             BEQ.N    ??FLASH_OB_WRPConfig_1
   \   00000034   0xF44F 0x7167      MOV      R1,#+924
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable32
   \   0000003C   0x.... 0x....      BL       assert_failed
    925               
    926            /* Wait for last operation to be completed */
    927            status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   \                     ??FLASH_OB_WRPConfig_1: (+1)
   \   00000040   0xF44F 0x4000      MOV      R0,#+32768
   \   00000044   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000048   0x4680             MOV      R8,R0
    928           
    929            if(status == FLASH_COMPLETE)
   \   0000004A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000004E   0xF1B8 0x0F04      CMP      R8,#+4
   \   00000052   0xD142             BNE.N    ??FLASH_OB_WRPConfig_2
    930            {
    931              if (NewState != DISABLE)
   \   00000054   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000056   0x2D00             CMP      R5,#+0
   \   00000058   0xD01C             BEQ.N    ??FLASH_OB_WRPConfig_3
    932              {
    933                WRP01_Data = (uint16_t)(((OB_WRP & WRP01_MASK) | OB->WRP01));
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable32_15  ;; 0x1ff80008
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0x4320             ORRS     R0,R0,R4
   \   00000062   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000064   0x0006             MOVS     R6,R0
    934                WRP23_Data = (uint16_t)((((OB_WRP & WRP23_MASK)>>16 | OB->WRP23))); 
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable32_16  ;; 0x1ff8000c
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0xEA50 0x4014      ORRS     R0,R0,R4, LSR #+16
   \   00000070   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000072   0x0007             MOVS     R7,R0
    935                tmp1 = (uint32_t)(~(WRP01_Data) << 16)|(WRP01_Data);
   \   00000074   0x43F0             MVNS     R0,R6
   \   00000076   0xEA56 0x4000      ORRS     R0,R6,R0, LSL #+16
   \   0000007A   0x4681             MOV      R9,R0
    936                OB->WRP01 = tmp1;
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable32_15  ;; 0x1ff80008
   \   00000080   0xF8C0 0x9000      STR      R9,[R0, #+0]
    937                
    938                tmp2 = (uint32_t)(~(WRP23_Data) << 16)|(WRP23_Data);
   \   00000084   0x43F8             MVNS     R0,R7
   \   00000086   0xEA57 0x4000      ORRS     R0,R7,R0, LSL #+16
   \   0000008A   0x4682             MOV      R10,R0
    939                OB->WRP23 = tmp2;      
   \   0000008C   0x....             LDR.N    R0,??DataTable32_16  ;; 0x1ff8000c
   \   0000008E   0xF8C0 0xA000      STR      R10,[R0, #+0]
   \   00000092   0xE01D             B.N      ??FLASH_OB_WRPConfig_4
    940              }             
    941              
    942              else
    943              {
    944                WRP01_Data = (uint16_t)(~OB_WRP & (WRP01_MASK & OB->WRP01));
   \                     ??FLASH_OB_WRPConfig_3: (+1)
   \   00000094   0x....             LDR.N    R0,??DataTable32_15  ;; 0x1ff80008
   \   00000096   0x6800             LDR      R0,[R0, #+0]
   \   00000098   0x43A0             BICS     R0,R0,R4
   \   0000009A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000009C   0x0006             MOVS     R6,R0
    945                WRP23_Data = (uint16_t)((((~OB_WRP & WRP23_MASK)>>16 & OB->WRP23))); 
   \   0000009E   0xF3C4 0x400F      UBFX     R0,R4,#+16,#+16
   \   000000A2   0xF480 0x407F      EOR      R0,R0,#0xFF00
   \   000000A6   0xF090 0x00FF      EORS     R0,R0,#0xFF
   \   000000AA   0x....             LDR.N    R1,??DataTable32_16  ;; 0x1ff8000c
   \   000000AC   0x6809             LDR      R1,[R1, #+0]
   \   000000AE   0x4008             ANDS     R0,R1,R0
   \   000000B0   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000B2   0x0007             MOVS     R7,R0
    946          
    947                tmp1 = (uint32_t)((~WRP01_Data) << 16)|(WRP01_Data);
   \   000000B4   0x43F0             MVNS     R0,R6
   \   000000B6   0xEA56 0x4000      ORRS     R0,R6,R0, LSL #+16
   \   000000BA   0x4681             MOV      R9,R0
    948                OB->WRP01 = tmp1;
   \   000000BC   0x....             LDR.N    R0,??DataTable32_15  ;; 0x1ff80008
   \   000000BE   0xF8C0 0x9000      STR      R9,[R0, #+0]
    949                
    950                tmp2 = (uint32_t)((~WRP23_Data) << 16)|(WRP23_Data);
   \   000000C2   0x43F8             MVNS     R0,R7
   \   000000C4   0xEA57 0x4000      ORRS     R0,R7,R0, LSL #+16
   \   000000C8   0x4682             MOV      R10,R0
    951                OB->WRP23 = tmp2;
   \   000000CA   0x....             LDR.N    R0,??DataTable32_16  ;; 0x1ff8000c
   \   000000CC   0xF8C0 0xA000      STR      R10,[R0, #+0]
    952              }
    953              /* Wait for last operation to be completed */
    954              status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   \                     ??FLASH_OB_WRPConfig_4: (+1)
   \   000000D0   0xF44F 0x4000      MOV      R0,#+32768
   \   000000D4   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   000000D8   0x4680             MOV      R8,R0
    955            }
    956          
    957            /* Return the write protection operation Status */
    958            return status;      
   \                     ??FLASH_OB_WRPConfig_2: (+1)
   \   000000DA   0x4640             MOV      R0,R8
   \   000000DC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000DE   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    959          }
    960          
    961          /**
    962            * @brief  Enables or disables the read out protection.
    963            * @note   - To correctly run this function, the FLASH_OB_Unlock() function
    964            *           must be called before.
    965            *         - Call the FLASH_OB_Lock() to disable the flash control register access and the option bytes 
    966            *          (recommended to protect the FLASH memory against possible unwanted operation)   
    967            * @param  FLASH_ReadProtection_Level: specifies the read protection level. 
    968            *   This parameter can be:
    969            *     @arg OB_RDP_Level_0: No protection
    970            *     @arg OB_RDP_Level_1: Read protection of the memory                     
    971            *     @arg OB_RDP_Level_2: Chip protection
    972            *     @retval FLASH Status: The returned value can be: 
    973            * FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
    974            */

   \                                 In section .text, align 2, keep-with-next
    975          FLASH_Status FLASH_OB_RDPConfig(uint8_t OB_RDP)
    976          {
   \                     FLASH_OB_RDPConfig: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    977            FLASH_Status status = FLASH_COMPLETE;
   \   00000004   0x2504             MOVS     R5,#+4
    978            uint8_t tmp1 = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    979            uint32_t tmp2 = 0;
   \   00000008   0x2700             MOVS     R7,#+0
    980            
    981            /* Check the parameters */
    982            assert_param(IS_OB_RDP(OB_RDP));
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2CAA             CMP      R4,#+170
   \   0000000E   0xD007             BEQ.N    ??FLASH_OB_RDPConfig_0
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2CBB             CMP      R4,#+187
   \   00000014   0xD004             BEQ.N    ??FLASH_OB_RDPConfig_0
   \   00000016   0xF240 0x31D6      MOVW     R1,#+982
   \   0000001A   0x....             LDR.N    R0,??DataTable32
   \   0000001C   0x.... 0x....      BL       assert_failed
    983            status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   \                     ??FLASH_OB_RDPConfig_0: (+1)
   \   00000020   0xF44F 0x4000      MOV      R0,#+32768
   \   00000024   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000028   0x0005             MOVS     R5,R0
    984            
    985            /* calculate the option byte to write */
    986            tmp1 = (uint8_t)(~(OB_RDP ));
   \   0000002A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002C   0x43E0             MVNS     R0,R4
   \   0000002E   0x0006             MOVS     R6,R0
    987            tmp2 = (uint32_t)(((uint32_t)((uint32_t)(tmp1) << 16)) | ((uint32_t)OB_RDP));
   \   00000030   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000032   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000034   0xEA54 0x4006      ORRS     R0,R4,R6, LSL #+16
   \   00000038   0x0007             MOVS     R7,R0
    988            
    989            if(status == FLASH_COMPLETE)
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x2D04             CMP      R5,#+4
   \   0000003E   0xD101             BNE.N    ??FLASH_OB_RDPConfig_1
    990            {         
    991             /* program read protection level */
    992              OB->RDP = tmp2;
   \   00000040   0x....             LDR.N    R0,??DataTable32_17  ;; 0x1ff80000
   \   00000042   0x6007             STR      R7,[R0, #+0]
    993            }
    994            
    995            /* Wait for last operation to be completed */
    996              status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   \                     ??FLASH_OB_RDPConfig_1: (+1)
   \   00000044   0xF44F 0x4000      MOV      R0,#+32768
   \   00000048   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000004C   0x0005             MOVS     R5,R0
    997               
    998            /* Return the Read protection operation Status */
    999            return status;            
   \   0000004E   0x0028             MOVS     R0,R5
   \   00000050   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000052   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1000          }
   1001          
   1002          /**
   1003            * @brief  Programs the FLASH User Option Byte: IWDG_SW / RST_STOP / RST_STDBY.
   1004            * @note   - To correctly run this function, the FLASH_OB_Unlock() function
   1005            *           must be called before.
   1006            *         - Call the FLASH_OB_Lock() to disable the flash control register access and the option bytes 
   1007            *          (recommended to protect the FLASH memory against possible unwanted operation)   
   1008            * @param  OB_IWDG: Selects the WDG mode
   1009            *   This parameter can be one of the following values:
   1010            *     @arg OB_IWDG_SW: Software WDG selected
   1011            *     @arg OB_IWDG_HW: Hardware WDG selected
   1012            * @param  OB_STOP: Reset event when entering STOP mode.
   1013            *   This parameter can be one of the following values:
   1014            *     @arg OB_STOP_NoRST: No reset generated when entering in STOP
   1015            *     @arg OB_STOP_RST: Reset generated when entering in STOP
   1016            * @param  OB_STDBY: Reset event when entering Standby mode.
   1017            *   This parameter can be one of the following values:
   1018            *     @arg OB_STDBY_NoRST: No reset generated when entering in STANDBY
   1019            *     @arg OB_STDBY_RST: Reset generated when entering in STANDBY
   1020            * @retval FLASH Status: The returned value can be: 
   1021            * FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
   1022            */

   \                                 In section .text, align 2, keep-with-next
   1023          FLASH_Status FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY)
   1024          {
   \                     FLASH_OB_UserConfig: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1025            FLASH_Status status = FLASH_COMPLETE; 
   \   0000000A   0x2704             MOVS     R7,#+4
   1026            uint32_t tmp = 0, tmp1 = 0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   \   00000010   0xF05F 0x0900      MOVS     R9,#+0
   1027          
   1028            /* Check the parameters */
   1029            assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
   \   00000014   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000016   0x2C10             CMP      R4,#+16
   \   00000018   0xD007             BEQ.N    ??FLASH_OB_UserConfig_0
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD004             BEQ.N    ??FLASH_OB_UserConfig_0
   \   00000020   0xF240 0x4105      MOVW     R1,#+1029
   \   00000024   0x....             LDR.N    R0,??DataTable32
   \   00000026   0x.... 0x....      BL       assert_failed
   1030            assert_param(IS_OB_STOP_SOURCE(OB_STOP));
   \                     ??FLASH_OB_UserConfig_0: (+1)
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0x2D20             CMP      R5,#+32
   \   0000002E   0xD007             BEQ.N    ??FLASH_OB_UserConfig_1
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD004             BEQ.N    ??FLASH_OB_UserConfig_1
   \   00000036   0xF240 0x4106      MOVW     R1,#+1030
   \   0000003A   0x....             LDR.N    R0,??DataTable32
   \   0000003C   0x.... 0x....      BL       assert_failed
   1031            assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
   \                     ??FLASH_OB_UserConfig_1: (+1)
   \   00000040   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000042   0x2E40             CMP      R6,#+64
   \   00000044   0xD007             BEQ.N    ??FLASH_OB_UserConfig_2
   \   00000046   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000048   0x2E00             CMP      R6,#+0
   \   0000004A   0xD004             BEQ.N    ??FLASH_OB_UserConfig_2
   \   0000004C   0xF240 0x4107      MOVW     R1,#+1031
   \   00000050   0x....             LDR.N    R0,??DataTable32
   \   00000052   0x.... 0x....      BL       assert_failed
   1032          
   1033            /* Get the User Option byte register */
   1034            tmp1 = (FLASH->OBR & 0x000F0000) >> 16;
   \                     ??FLASH_OB_UserConfig_2: (+1)
   \   00000056   0x....             LDR.N    R0,??DataTable32_18  ;; 0x40023c1c
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0xF3C0 0x4003      UBFX     R0,R0,#+16,#+4
   \   0000005E   0x4681             MOV      R9,R0
   1035              
   1036            /* Calculate the user option byte to write */ 
   1037            tmp = (uint32_t)(((uint32_t)~((uint32_t)((uint32_t)(OB_IWDG) | (uint32_t)(OB_STOP) | (uint32_t)(OB_STDBY) | tmp1))) << ((uint32_t)0x10));
   \   00000060   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000062   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000064   0xEA55 0x0004      ORRS     R0,R5,R4
   \   00000068   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000006A   0x4330             ORRS     R0,R6,R0
   \   0000006C   0xEA59 0x0000      ORRS     R0,R9,R0
   \   00000070   0x43C0             MVNS     R0,R0
   \   00000072   0x0400             LSLS     R0,R0,#+16
   \   00000074   0x4680             MOV      R8,R0
   1038            tmp |= ((uint32_t)(OB_IWDG) | ((uint32_t)OB_STOP) | (uint32_t)(OB_STDBY) | tmp1);
   \   00000076   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000078   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000007A   0xEA55 0x0004      ORRS     R0,R5,R4
   \   0000007E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000080   0x4330             ORRS     R0,R6,R0
   \   00000082   0xEA59 0x0000      ORRS     R0,R9,R0
   \   00000086   0xEA50 0x0808      ORRS     R8,R0,R8
   1039            
   1040            /* Wait for last operation to be completed */
   1041            status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   \   0000008A   0xF44F 0x4000      MOV      R0,#+32768
   \   0000008E   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000092   0x0007             MOVS     R7,R0
   1042            
   1043            if(status == FLASH_COMPLETE)
   \   00000094   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000096   0x2F04             CMP      R7,#+4
   \   00000098   0xD102             BNE.N    ??FLASH_OB_UserConfig_3
   1044            {  
   1045              /* Write the User Option Byte */              
   1046              OB->USER = tmp; 
   \   0000009A   0x....             LDR.N    R0,??DataTable32_19  ;; 0x1ff80004
   \   0000009C   0xF8C0 0x8000      STR      R8,[R0, #+0]
   1047            }
   1048            
   1049            /* Wait for last operation to be completed */
   1050              status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   \                     ??FLASH_OB_UserConfig_3: (+1)
   \   000000A0   0xF44F 0x4000      MOV      R0,#+32768
   \   000000A4   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   000000A8   0x0007             MOVS     R7,R0
   1051                 
   1052            /* Return the Option Byte program Status */
   1053            return status;
   \   000000AA   0x0038             MOVS     R0,R7
   \   000000AC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AE   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1054          }
   1055          
   1056          /**
   1057            * @brief  Programs the FLASH brownout reset threshold level Option Byte.
   1058            * @note   - To correctly run this function, the FLASH_OB_Unlock() function
   1059            *           must be called before.
   1060            *         - Call the FLASH_OB_Lock() to disable the flash control register access and the option bytes 
   1061            *          (recommended to protect the FLASH memory against possible unwanted operation)   
   1062            * @param  OB_BOR: Selects the brownout reset threshold level
   1063            *   This parameter can be one of the following values:
   1064            *     @arg OB_BOR_OFF: BOR is disabled at power down, the reset is asserted when the VDD 
   1065            *                      power supply reaches the PDR(Power Down Reset) threshold (1.5V)
   1066            *     @arg OB_BOR_LEVEL1: BOR Reset threshold levels for 1.7V - 1.8V VDD power supply
   1067            *     @arg OB_BOR_LEVEL2: BOR Reset threshold levels for 1.9V - 2.0V VDD power supply
   1068            *     @arg OB_BOR_LEVEL3: BOR Reset threshold levels for 2.3V - 2.4V VDD power supply
   1069            *     @arg OB_BOR_LEVEL4: BOR Reset threshold levels for 2.55V - 2.65V VDD power supply
   1070            *     @arg OB_BOR_LEVEL5: BOR Reset threshold levels for 2.8V - 2.9V VDD power supply
   1071            * @retval FLASH Status: The returned value can be: 
   1072            * FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
   1073            */

   \                                 In section .text, align 2, keep-with-next
   1074          FLASH_Status FLASH_OB_BORConfig(uint8_t OB_BOR)
   1075          {
   \                     FLASH_OB_BORConfig: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1076            FLASH_Status status = FLASH_COMPLETE;
   \   00000004   0x2504             MOVS     R5,#+4
   1077            uint32_t tmp = 0, tmp1 = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0x2700             MOVS     R7,#+0
   1078          
   1079            /* Check the parameters */
   1080            assert_param(IS_OB_BOR_LEVEL(OB_BOR));
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD013             BEQ.N    ??FLASH_OB_BORConfig_0
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C08             CMP      R4,#+8
   \   00000014   0xD010             BEQ.N    ??FLASH_OB_BORConfig_0
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0x2C09             CMP      R4,#+9
   \   0000001A   0xD00D             BEQ.N    ??FLASH_OB_BORConfig_0
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x2C0A             CMP      R4,#+10
   \   00000020   0xD00A             BEQ.N    ??FLASH_OB_BORConfig_0
   \   00000022   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000024   0x2C0B             CMP      R4,#+11
   \   00000026   0xD007             BEQ.N    ??FLASH_OB_BORConfig_0
   \   00000028   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002A   0x2C0C             CMP      R4,#+12
   \   0000002C   0xD004             BEQ.N    ??FLASH_OB_BORConfig_0
   \   0000002E   0xF44F 0x6187      MOV      R1,#+1080
   \   00000032   0x....             LDR.N    R0,??DataTable32
   \   00000034   0x.... 0x....      BL       assert_failed
   1081          
   1082            /* Get the User Option byte register */
   1083            tmp1 = (FLASH->OBR & 0x00700000) >> 16;
   \                     ??FLASH_OB_BORConfig_0: (+1)
   \   00000038   0x....             LDR.N    R0,??DataTable32_18  ;; 0x40023c1c
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x0C00             LSRS     R0,R0,#+16
   \   0000003E   0xF010 0x0070      ANDS     R0,R0,#0x70
   \   00000042   0x0007             MOVS     R7,R0
   1084               
   1085            /* Calculate the option byte to write */
   1086            tmp = (uint32_t)~(OB_BOR | tmp1)<<16;
   \   00000044   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000046   0xEA57 0x0004      ORRS     R0,R7,R4
   \   0000004A   0x43C0             MVNS     R0,R0
   \   0000004C   0x0400             LSLS     R0,R0,#+16
   \   0000004E   0x0006             MOVS     R6,R0
   1087            tmp |= (OB_BOR | tmp1);
   \   00000050   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000052   0xEA57 0x0004      ORRS     R0,R7,R4
   \   00000056   0x4306             ORRS     R6,R0,R6
   1088              
   1089            /* Wait for last operation to be completed */
   1090            status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   \   00000058   0xF44F 0x4000      MOV      R0,#+32768
   \   0000005C   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000060   0x0005             MOVS     R5,R0
   1091            
   1092            if(status == FLASH_COMPLETE)
   \   00000062   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000064   0x2D04             CMP      R5,#+4
   \   00000066   0xD101             BNE.N    ??FLASH_OB_BORConfig_1
   1093            {  
   1094              /* Write the BOR Option Byte */            
   1095              OB->USER = tmp; 
   \   00000068   0x....             LDR.N    R0,??DataTable32_19  ;; 0x1ff80004
   \   0000006A   0x6006             STR      R6,[R0, #+0]
   1096            }
   1097            
   1098            /* Wait for last operation to be completed */
   1099              status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   \                     ??FLASH_OB_BORConfig_1: (+1)
   \   0000006C   0xF44F 0x4000      MOV      R0,#+32768
   \   00000070   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000074   0x0005             MOVS     R5,R0
   1100                  
   1101            /* Return the Option Byte program Status */
   1102            return status;
   \   00000076   0x0028             MOVS     R0,R5
   \   00000078   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1103          }
   1104          
   1105          /**
   1106            * @brief  Returns the FLASH User Option Bytes values.
   1107            * @param  None
   1108            * @retval The FLASH User Option Bytes .
   1109            */

   \                                 In section .text, align 2, keep-with-next
   1110          uint8_t FLASH_OB_GetUser(void)
   1111          {
   1112            /* Return the User Option Byte */
   1113            return (uint8_t)(FLASH->OBR >> 20);
   \                     FLASH_OB_GetUser: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable32_18  ;; 0x40023c1c
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0D00             LSRS     R0,R0,#+20
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x4770             BX       LR               ;; return
   1114          }
   1115          
   1116          /**
   1117            * @brief  Returns the FLASH Write Protection Option Bytes value.
   1118            * @param  None
   1119            * @retval The FLASH Write Protection Option Bytes value
   1120            */

   \                                 In section .text, align 2, keep-with-next
   1121          uint32_t FLASH_OB_GetWRP(void)
   1122          {
   1123            /* Return the FLASH write protection Register value */
   1124            return (uint32_t)(FLASH->WRPR);
   \                     FLASH_OB_GetWRP: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable32_20  ;; 0x40023c20
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   1125          }
   1126          
   1127          /**
   1128            * @brief  Checks whether the FLASH Read out Protection Status is set or not.
   1129            * @param  None
   1130            * @retval FLASH ReadOut Protection Status(SET or RESET)
   1131            */

   \                                 In section .text, align 2, keep-with-next
   1132          FlagStatus FLASH_OB_GetRDP(void)
   1133          {
   1134            FlagStatus readstatus = RESET;
   \                     FLASH_OB_GetRDP: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   1135            
   1136            if ((uint8_t)(FLASH->OBR) != (uint8_t)OB_RDP_Level_0)
   \   00000002   0x....             LDR.N    R1,??DataTable32_18  ;; 0x40023c1c
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000008   0x29AA             CMP      R1,#+170
   \   0000000A   0xD002             BEQ.N    ??FLASH_OB_GetRDP_0
   1137            {
   1138              readstatus = SET;
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0x0008             MOVS     R0,R1
   \   00000010   0xE001             B.N      ??FLASH_OB_GetRDP_1
   1139            }
   1140            else
   1141            {
   1142              readstatus = RESET;
   \                     ??FLASH_OB_GetRDP_0: (+1)
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x0008             MOVS     R0,R1
   1143            }
   1144            return readstatus;
   \                     ??FLASH_OB_GetRDP_1: (+1)
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0x4770             BX       LR               ;; return
   1145          }
   1146          
   1147          /**
   1148            * @brief  Returns the FLASH BOR level.
   1149            * @param  None
   1150            * @retval The FLASH User Option Bytes .
   1151            */

   \                                 In section .text, align 2, keep-with-next
   1152          uint8_t FLASH_OB_GetBOR(void)
   1153          {
   1154            /* Return the BOR level */
   1155            return (uint8_t)((FLASH->OBR & (uint32_t)0x000F0000) >> 16);
   \                     FLASH_OB_GetBOR: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable32_18  ;; 0x40023c1c
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0C00             LSRS     R0,R0,#+16
   \   00000006   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   0000000A   0x4770             BX       LR               ;; return
   1156          }
   1157          
   1158          /**
   1159            * @}
   1160            */
   1161          
   1162          /** @defgroup FLASH_Group5 Interrupts and flags management functions
   1163           *  @brief   Interrupts and flags management functions
   1164           *
   1165          @verbatim   
   1166           ===============================================================================
   1167                            Interrupts and flags management functions
   1168           ===============================================================================  
   1169          
   1170          @endverbatim
   1171            * @{
   1172            */
   1173          
   1174          /**
   1175            * @brief  Enables or disables the specified FLASH interrupts.
   1176            * @param  FLASH_IT: specifies the FLASH interrupt sources to be enabled or 
   1177            *         disabled.
   1178            *   This parameter can be any combination of the following values:     
   1179            *     @arg FLASH_IT_EOP: FLASH end of programming Interrupt
   1180            *     @arg FLASH_IT_ERR: FLASH Error Interrupt  
   1181            * @retval None 
   1182            */

   \                                 In section .text, align 2, keep-with-next
   1183          void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState)
   1184          {
   \                     FLASH_ITConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1185            /* Check the parameters */
   1186            assert_param(IS_FLASH_IT(FLASH_IT)); 
   \   00000006   0xF434 0x3040      BICS     R0,R4,#0x30000
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE.N    ??FLASH_ITConfig_0
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD104             BNE.N    ??FLASH_ITConfig_1
   \                     ??FLASH_ITConfig_0: (+1)
   \   00000012   0xF240 0x41A2      MOVW     R1,#+1186
   \   00000016   0x....             LDR.N    R0,??DataTable32
   \   00000018   0x.... 0x....      BL       assert_failed
   1187            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??FLASH_ITConfig_1: (+1)
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD007             BEQ.N    ??FLASH_ITConfig_2
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D01             CMP      R5,#+1
   \   00000026   0xD004             BEQ.N    ??FLASH_ITConfig_2
   \   00000028   0xF240 0x41A3      MOVW     R1,#+1187
   \   0000002C   0x....             LDR.N    R0,??DataTable32
   \   0000002E   0x.... 0x....      BL       assert_failed
   1188            
   1189            if(NewState != DISABLE)
   \                     ??FLASH_ITConfig_2: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD005             BEQ.N    ??FLASH_ITConfig_3
   1190            {
   1191              /* Enable the interrupt sources */
   1192              FLASH->PECR |= FLASH_IT;
   \   00000038   0x....             LDR.N    R0,??DataTable32_2  ;; 0x40023c04
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x4320             ORRS     R0,R4,R0
   \   0000003E   0x....             LDR.N    R1,??DataTable32_2  ;; 0x40023c04
   \   00000040   0x6008             STR      R0,[R1, #+0]
   \   00000042   0xE004             B.N      ??FLASH_ITConfig_4
   1193            }
   1194            else
   1195            {
   1196              /* Disable the interrupt sources */
   1197              FLASH->PECR &= ~(uint32_t)FLASH_IT;
   \                     ??FLASH_ITConfig_3: (+1)
   \   00000044   0x....             LDR.N    R0,??DataTable32_2  ;; 0x40023c04
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0x43A0             BICS     R0,R0,R4
   \   0000004A   0x....             LDR.N    R1,??DataTable32_2  ;; 0x40023c04
   \   0000004C   0x6008             STR      R0,[R1, #+0]
   1198            }
   1199          }
   \                     ??FLASH_ITConfig_4: (+1)
   \   0000004E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1200          
   1201          /**
   1202            * @brief  Checks whether the specified FLASH flag is set or not.
   1203            * @param  FLASH_FLAG: specifies the FLASH flag to check.
   1204            *   This parameter can be one of the following values:
   1205            *     @arg FLASH_FLAG_BSY: FLASH write/erase operations in progress flag 
   1206            *     @arg FLASH_FLAG_EOP: FLASH End of Operation flag
   1207            *     @arg FLASH_FLAG_READY: FLASH Ready flag after low power mode
   1208            *     @arg FLASH_FLAG_ENDHV: FLASH End of high voltage flag
   1209            *     @arg FLASH_FLAG_WRPERR: FLASH Write protected error flag 
   1210            *     @arg FLASH_FLAG_PGAERR: FLASH Programming Alignment error flag
   1211            *     @arg FLASH_FLAG_SIZERR: FLASH size error flag    
   1212            *     @arg FLASH_FLAG_OPTVERR: FLASH Option validity error flag         
   1213            * @retval The new state of FLASH_FLAG (SET or RESET).
   1214            */

   \                                 In section .text, align 2, keep-with-next
   1215          FlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG)
   1216          {
   \                     FLASH_GetFlagStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1217            FlagStatus bitstatus = RESET;
   \   00000004   0x2500             MOVS     R5,#+0
   1218          
   1219            /* Check the parameters */
   1220            assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG));
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD016             BEQ.N    ??FLASH_GetFlagStatus_0
   \   0000000A   0x2C02             CMP      R4,#+2
   \   0000000C   0xD014             BEQ.N    ??FLASH_GetFlagStatus_0
   \   0000000E   0x2C04             CMP      R4,#+4
   \   00000010   0xD012             BEQ.N    ??FLASH_GetFlagStatus_0
   \   00000012   0x2C08             CMP      R4,#+8
   \   00000014   0xD010             BEQ.N    ??FLASH_GetFlagStatus_0
   \   00000016   0xF5B4 0x7F80      CMP      R4,#+256
   \   0000001A   0xD00D             BEQ.N    ??FLASH_GetFlagStatus_0
   \   0000001C   0xF5B4 0x7F00      CMP      R4,#+512
   \   00000020   0xD00A             BEQ.N    ??FLASH_GetFlagStatus_0
   \   00000022   0xF5B4 0x6F80      CMP      R4,#+1024
   \   00000026   0xD007             BEQ.N    ??FLASH_GetFlagStatus_0
   \   00000028   0xF5B4 0x6F00      CMP      R4,#+2048
   \   0000002C   0xD004             BEQ.N    ??FLASH_GetFlagStatus_0
   \   0000002E   0xF240 0x41C4      MOVW     R1,#+1220
   \   00000032   0x....             LDR.N    R0,??DataTable32
   \   00000034   0x.... 0x....      BL       assert_failed
   1221          
   1222            if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
   \                     ??FLASH_GetFlagStatus_0: (+1)
   \   00000038   0x....             LDR.N    R0,??DataTable32_21  ;; 0x40023c18
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x4220             TST      R0,R4
   \   0000003E   0xD002             BEQ.N    ??FLASH_GetFlagStatus_1
   1223            {
   1224              bitstatus = SET;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x0005             MOVS     R5,R0
   \   00000044   0xE001             B.N      ??FLASH_GetFlagStatus_2
   1225            }
   1226            else
   1227            {
   1228              bitstatus = RESET;
   \                     ??FLASH_GetFlagStatus_1: (+1)
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x0005             MOVS     R5,R0
   1229            }
   1230            /* Return the new state of FLASH_FLAG (SET or RESET) */
   1231            return bitstatus; 
   \                     ??FLASH_GetFlagStatus_2: (+1)
   \   0000004A   0x0028             MOVS     R0,R5
   \   0000004C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1232          }
   1233          
   1234          /**
   1235            * @brief  Clears the FLASHs pending flags.
   1236            * @param  FLASH_FLAG: specifies the FLASH flags to clear.
   1237            *   This parameter can be any combination of the following values:
   1238            *     @arg FLASH_FLAG_EOP: FLASH End of Operation flag
   1239            *     @arg FLASH_FLAG_WRPERR: FLASH Write protected error flag 
   1240            *     @arg FLASH_FLAG_PGAERR: FLASH Programming Alignment error flag 
   1241            *     @arg FLASH_FLAG_SIZERR: FLASH size error flag    
   1242            *     @arg FLASH_FLAG_OPTVERR: FLASH Option validity error flag              
   1243            * @retval None
   1244            */

   \                                 In section .text, align 2, keep-with-next
   1245          void FLASH_ClearFlag(uint32_t FLASH_FLAG)
   1246          {
   \                     FLASH_ClearFlag: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1247            /* Check the parameters */
   1248            assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG));
   \   00000004   0x....             LDR.N    R0,??DataTable32_22  ;; 0xfffff0fd
   \   00000006   0x4204             TST      R4,R0
   \   00000008   0xD101             BNE.N    ??FLASH_ClearFlag_0
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD104             BNE.N    ??FLASH_ClearFlag_1
   \                     ??FLASH_ClearFlag_0: (+1)
   \   0000000E   0xF44F 0x619C      MOV      R1,#+1248
   \   00000012   0x....             LDR.N    R0,??DataTable32
   \   00000014   0x.... 0x....      BL       assert_failed
   1249            
   1250            /* Clear the flags */
   1251            FLASH->SR = FLASH_FLAG;
   \                     ??FLASH_ClearFlag_1: (+1)
   \   00000018   0x....             LDR.N    R0,??DataTable32_21  ;; 0x40023c18
   \   0000001A   0x6004             STR      R4,[R0, #+0]
   1252          }
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
   1253          
   1254          /**
   1255            * @brief  Returns the FLASH Status.
   1256            * @param  None
   1257            * @retval FLASH Status: The returned value can be: 
   1258            *   FLASH_BUSY, FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP or FLASH_COMPLETE.
   1259            */

   \                                 In section .text, align 2, keep-with-next
   1260          FLASH_Status FLASH_GetStatus(void)
   1261          {
   1262            FLASH_Status FLASHstatus = FLASH_COMPLETE;
   \                     FLASH_GetStatus: (+1)
   \   00000000   0x2004             MOVS     R0,#+4
   1263            
   1264            if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
   \   00000002   0x....             LDR.N    R1,??DataTable32_21  ;; 0x40023c18
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x07C9             LSLS     R1,R1,#+31
   \   00000008   0xD502             BPL.N    ??FLASH_GetStatus_0
   1265            {
   1266              FLASHstatus = FLASH_BUSY;
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x0008             MOVS     R0,R1
   \   0000000E   0xE011             B.N      ??FLASH_GetStatus_1
   1267            }
   1268            else 
   1269            {  
   1270              if((FLASH->SR & (uint32_t)FLASH_FLAG_WRPERR)!= (uint32_t)0x00)
   \                     ??FLASH_GetStatus_0: (+1)
   \   00000010   0x....             LDR.N    R1,??DataTable32_21  ;; 0x40023c18
   \   00000012   0x6809             LDR      R1,[R1, #+0]
   \   00000014   0x05C9             LSLS     R1,R1,#+23
   \   00000016   0xD502             BPL.N    ??FLASH_GetStatus_2
   1271              { 
   1272                FLASHstatus = FLASH_ERROR_WRP;
   \   00000018   0x2102             MOVS     R1,#+2
   \   0000001A   0x0008             MOVS     R0,R1
   \   0000001C   0xE00A             B.N      ??FLASH_GetStatus_1
   1273              }
   1274              else 
   1275              {
   1276                if((FLASH->SR & (uint32_t)0xFEF0) != (uint32_t)0x00)
   \                     ??FLASH_GetStatus_2: (+1)
   \   0000001E   0x....             LDR.N    R1,??DataTable32_21  ;; 0x40023c18
   \   00000020   0x6809             LDR      R1,[R1, #+0]
   \   00000022   0xF64F 0x62F0      MOVW     R2,#+65264
   \   00000026   0x4211             TST      R1,R2
   \   00000028   0xD002             BEQ.N    ??FLASH_GetStatus_3
   1277                {
   1278                  FLASHstatus = FLASH_ERROR_PROGRAM; 
   \   0000002A   0x2103             MOVS     R1,#+3
   \   0000002C   0x0008             MOVS     R0,R1
   \   0000002E   0xE001             B.N      ??FLASH_GetStatus_1
   1279                }
   1280                else
   1281                {
   1282                  FLASHstatus = FLASH_COMPLETE;
   \                     ??FLASH_GetStatus_3: (+1)
   \   00000030   0x2104             MOVS     R1,#+4
   \   00000032   0x0008             MOVS     R0,R1
   1283                }
   1284              }
   1285            }
   1286            /* Return the FLASH Status */
   1287            return FLASHstatus;
   \                     ??FLASH_GetStatus_1: (+1)
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0x4770             BX       LR               ;; return
   1288          }
   1289          
   1290          
   1291          /**
   1292            * @brief  Waits for a FLASH operation to complete or a TIMEOUT to occur.
   1293            * @param  Timeout: FLASH programming Timeout
   1294            * @retval FLASH Status: The returned value can be: FLASH_BUSY, 
   1295            *   FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
   1296            */

   \                                 In section .text, align 2, keep-with-next
   1297          FLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout)
   1298          { 
   \                     FLASH_WaitForLastOperation: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1299            FLASH_Status status = FLASH_COMPLETE;
   \   00000004   0x2504             MOVS     R5,#+4
   1300             
   1301            /* Check for the FLASH Status */
   1302            status = FLASH_GetStatus();
   \   00000006   0x.... 0x....      BL       FLASH_GetStatus
   \   0000000A   0x0005             MOVS     R5,R0
   1303            
   1304            /* Wait for a FLASH operation to complete or a TIMEOUT to occur */
   1305            while((status == FLASH_BUSY) && (Timeout != 0x00))
   \                     ??FLASH_WaitForLastOperation_0: (+1)
   \   0000000C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   0x2D01             CMP      R5,#+1
   \   00000010   0xD106             BNE.N    ??FLASH_WaitForLastOperation_1
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD004             BEQ.N    ??FLASH_WaitForLastOperation_1
   1306            {
   1307              status = FLASH_GetStatus();
   \   00000016   0x.... 0x....      BL       FLASH_GetStatus
   \   0000001A   0x0005             MOVS     R5,R0
   1308              Timeout--;
   \   0000001C   0x1E64             SUBS     R4,R4,#+1
   \   0000001E   0xE7F5             B.N      ??FLASH_WaitForLastOperation_0
   1309            }
   1310            
   1311            if(Timeout == 0x00 )
   \                     ??FLASH_WaitForLastOperation_1: (+1)
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD101             BNE.N    ??FLASH_WaitForLastOperation_2
   1312            {
   1313              status = FLASH_TIMEOUT;
   \   00000024   0x2005             MOVS     R0,#+5
   \   00000026   0x0005             MOVS     R5,R0
   1314            }
   1315            /* Return the operation status */
   1316            return status;
   \                     ??FLASH_WaitForLastOperation_2: (+1)
   \   00000028   0x0028             MOVS     R0,R5
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1317          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_1:
   \   00000000   0x40023C00         DC32     0x40023c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_2:
   \   00000000   0x40023C04         DC32     0x40023c04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_3:
   \   00000000   0x8C9DAEBF         DC32     0x8c9daebf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_4:
   \   00000000   0x40023C10         DC32     0x40023c10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_5:
   \   00000000   0x13141516         DC32     0x13141516

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_6:
   \   00000000   0x08020000         DC32     0x8020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_7:
   \   00000000   0x89ABCDEF         DC32     0x89abcdef

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_8:
   \   00000000   0x40023C0C         DC32     0x40023c0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_9:
   \   00000000   0x02030405         DC32     0x2030405

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_10:
   \   00000000   0x08080000         DC32     0x8080000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_11:
   \   00000000   0x08081000         DC32     0x8081000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_12:
   \   00000000   0xFBEAD9C8         DC32     0xfbead9c8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_13:
   \   00000000   0x40023C14         DC32     0x40023c14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_14:
   \   00000000   0x24252627         DC32     0x24252627

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_15:
   \   00000000   0x1FF80008         DC32     0x1ff80008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_16:
   \   00000000   0x1FF8000C         DC32     0x1ff8000c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_17:
   \   00000000   0x1FF80000         DC32     0x1ff80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_18:
   \   00000000   0x40023C1C         DC32     0x40023c1c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_19:
   \   00000000   0x1FF80004         DC32     0x1ff80004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_20:
   \   00000000   0x40023C20         DC32     0x40023c20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_21:
   \   00000000   0x40023C18         DC32     0x40023c18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_22:
   \   00000000   0xFFFFF0FD         DC32     0xfffff0fd

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x45 0x3A          DC8 45H, 3AH, 5CH, 41H, 43H, 51H, 5CH, 50H
   \              0x5C 0x41    
   \              0x43 0x51    
   \              0x5C 0x50    
   \   00000008   0x72 0x6F          DC8 72H, 6FH, 6AH, 5FH, 76H, 65H, 72H, 30H
   \              0x6A 0x5F    
   \              0x76 0x65    
   \              0x72 0x30    
   \   00000010   0x39 0x61          DC8 39H, 61H, 5FH, 31H, 35H, 31H, 30H, 32H
   \              0x5F 0x31    
   \              0x35 0x31    
   \              0x30 0x32    
   \   00000018   0x30 0x31          DC8 30H, 31H, 35H, 5CH, 45H, 6EH, 64H, 5FH
   \              0x35 0x5C    
   \              0x45 0x6E    
   \              0x64 0x5F    
   \   00000020   0x30 0x32          DC8 30H, 32H, 5CH, 32H, 30H, 31H, 33H, 5FH
   \              0x5C 0x32    
   \              0x30 0x31    
   \              0x33 0x5F    
   \   00000028   0x31 0x31          DC8 31H, 31H, 5FH, 32H, 35H, 5FH, 53H, 70H
   \              0x5F 0x32    
   \              0x35 0x5F    
   \              0x53 0x70    
   \   00000030   0x69 0x72          DC8 69H, 72H, 69H, 74H, 31H, 5FH, 45H, 6CH
   \              0x69 0x74    
   \              0x31 0x5F    
   \              0x45 0x6C    
   \   00000038   0x65 0x6B          DC8 65H, 6BH, 74H, 72H, 6FH, 6CH, 75H, 78H
   \              0x74 0x72    
   \              0x6F 0x6C    
   \              0x75 0x78    
   \   00000040   0x5C 0x53          DC8 5CH, 53H, 54H, 4DH, 33H, 32H, 4CH, 5CH
   \              0x54 0x4D    
   \              0x33 0x32    
   \              0x4C 0x5C    
   \   00000048   0x53 0x54          DC8 53H, 54H, 4DH, 33H, 32H, 4CH, 31H, 78H
   \              0x4D 0x33    
   \              0x32 0x4C    
   \              0x31 0x78    
   \   00000050   0x78 0x5F          DC8 78H, 5FH, 53H, 74H, 64H, 50H, 65H, 72H
   \              0x53 0x74    
   \              0x64 0x50    
   \              0x65 0x72    
   \   00000058   0x69 0x70          DC8 69H, 70H, 68H, 5FH, 4CH, 69H, 62H, 5CH
   \              0x68 0x5F    
   \              0x4C 0x69    
   \              0x62 0x5C    
   \   00000060   0x53 0x6F          DC8 53H, 6FH, 75H, 72H, 63H, 65H, 5CH, 53H
   \              0x75 0x72    
   \              0x63 0x65    
   \              0x5C 0x53    
   \   00000068   0x54 0x4D          DC8 54H, 4DH, 33H, 32H, 4CH, 31H, 78H, 78H
   \              0x33 0x32    
   \              0x4C 0x31    
   \              0x78 0x78    
   \   00000070   0x5F 0x53          DC8 5FH, 53H, 74H, 64H, 50H, 65H, 72H, 69H
   \              0x74 0x64    
   \              0x50 0x65    
   \              0x72 0x69    
   \   00000078   0x70 0x68          DC8 70H, 68H, 5FH, 44H, 72H, 69H, 76H, 65H
   \              0x5F 0x44    
   \              0x72 0x69    
   \              0x76 0x65    
   \   00000080   0x72 0x5C          DC8 72H, 5CH, 73H, 72H, 63H, 5CH, 73H, 74H
   \              0x73 0x72    
   \              0x63 0x5C    
   \              0x73 0x74    
   \   00000088   0x6D 0x33          DC8 6DH, 33H, 32H, 6CH, 31H, 78H, 78H, 5FH
   \              0x32 0x6C    
   \              0x31 0x78    
   \              0x78 0x5F    
   \   00000090   0x66 0x6C          DC8 66H, 6CH, 61H, 73H, 68H, 2EH, 63H, 0
   \              0x61 0x73    
   \              0x68 0x2E    
   \              0x63 0x00    
   1318          
   1319          /**
   1320            * @}
   1321            */
   1322          
   1323          /**
   1324            * @}
   1325            */
   1326             
   1327            /**
   1328            * @}
   1329            */ 
   1330          
   1331          /**
   1332            * @}
   1333            */ 
   1334          
   1335          /******************* (C) COPYRIGHT 2010 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   DATA_EEPROM_EraseWord
        16   -> FLASH_WaitForLastOperation
        16   -> assert_failed
      24   DATA_EEPROM_FastProgramByte
        24   -> DATA_EEPROM_EraseWord
        24   -> DATA_EEPROM_FastProgramWord
        24   -> FLASH_WaitForLastOperation
        24   -> assert_failed
      24   DATA_EEPROM_FastProgramHalfWord
        24   -> DATA_EEPROM_EraseWord
        24   -> DATA_EEPROM_FastProgramByte
        24   -> DATA_EEPROM_FastProgramWord
        24   -> FLASH_WaitForLastOperation
        24   -> assert_failed
      16   DATA_EEPROM_FastProgramWord
        16   -> FLASH_WaitForLastOperation
        16   -> assert_failed
       8   DATA_EEPROM_FixedTimeProgramCmd
         8   -> assert_failed
       0   DATA_EEPROM_Lock
      24   DATA_EEPROM_ProgramByte
        24   -> DATA_EEPROM_EraseWord
        24   -> DATA_EEPROM_FastProgramWord
        24   -> FLASH_WaitForLastOperation
        24   -> assert_failed
      24   DATA_EEPROM_ProgramHalfWord
        24   -> DATA_EEPROM_EraseWord
        24   -> DATA_EEPROM_FastProgramByte
        24   -> DATA_EEPROM_FastProgramWord
        24   -> FLASH_WaitForLastOperation
        24   -> assert_failed
      16   DATA_EEPROM_ProgramWord
        16   -> FLASH_WaitForLastOperation
        16   -> assert_failed
       0   DATA_EEPROM_Unlock
       8   FLASH_ClearFlag
         8   -> assert_failed
      16   FLASH_ErasePage
        16   -> FLASH_WaitForLastOperation
        16   -> assert_failed
      16   FLASH_FastProgramWord
        16   -> FLASH_WaitForLastOperation
        16   -> assert_failed
      16   FLASH_GetFlagStatus
        16   -> assert_failed
       0   FLASH_GetStatus
      16   FLASH_ITConfig
        16   -> assert_failed
       0   FLASH_Lock
      24   FLASH_OB_BORConfig
        24   -> FLASH_WaitForLastOperation
        24   -> assert_failed
       0   FLASH_OB_GetBOR
       0   FLASH_OB_GetRDP
       0   FLASH_OB_GetUser
       0   FLASH_OB_GetWRP
       0   FLASH_OB_Launch
       0   FLASH_OB_Lock
      24   FLASH_OB_RDPConfig
        24   -> FLASH_WaitForLastOperation
        24   -> assert_failed
       8   FLASH_OB_Unlock
         8   -> DATA_EEPROM_Unlock
      32   FLASH_OB_UserConfig
        32   -> FLASH_WaitForLastOperation
        32   -> assert_failed
      32   FLASH_OB_WRPConfig
        32   -> FLASH_WaitForLastOperation
        32   -> assert_failed
       8   FLASH_PrefetchBufferCmd
         8   -> assert_failed
       8   FLASH_ReadAccess64Cmd
         8   -> assert_failed
       8   FLASH_SLEEPPowerDownCmd
         8   -> assert_failed
      16   FLASH_SetLatency
        16   -> assert_failed
       8   FLASH_Unlock
         8   -> DATA_EEPROM_Unlock
      16   FLASH_WaitForLastOperation
        16   -> FLASH_GetStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable32
       4  ??DataTable32_1
       4  ??DataTable32_10
       4  ??DataTable32_11
       4  ??DataTable32_12
       4  ??DataTable32_13
       4  ??DataTable32_14
       4  ??DataTable32_15
       4  ??DataTable32_16
       4  ??DataTable32_17
       4  ??DataTable32_18
       4  ??DataTable32_19
       4  ??DataTable32_2
       4  ??DataTable32_20
       4  ??DataTable32_21
       4  ??DataTable32_22
       4  ??DataTable32_3
       4  ??DataTable32_4
       4  ??DataTable32_5
       4  ??DataTable32_6
       4  ??DataTable32_7
       4  ??DataTable32_8
       4  ??DataTable32_9
     152  ?_0
      60  DATA_EEPROM_EraseWord
     156  DATA_EEPROM_FastProgramByte
     184  DATA_EEPROM_FastProgramHalfWord
      86  DATA_EEPROM_FastProgramWord
      70  DATA_EEPROM_FixedTimeProgramCmd
      18  DATA_EEPROM_Lock
     140  DATA_EEPROM_ProgramByte
     168  DATA_EEPROM_ProgramHalfWord
      70  DATA_EEPROM_ProgramWord
      32  DATA_EEPROM_Unlock
      30  FLASH_ClearFlag
     132  FLASH_ErasePage
      68  FLASH_FastProgramWord
      80  FLASH_GetFlagStatus
      56  FLASH_GetStatus
      80  FLASH_ITConfig
      18  FLASH_Lock
     124  FLASH_OB_BORConfig
      12  FLASH_OB_GetBOR
      26  FLASH_OB_GetRDP
      10  FLASH_OB_GetUser
       6  FLASH_OB_GetWRP
      18  FLASH_OB_Launch
      18  FLASH_OB_Lock
      84  FLASH_OB_RDPConfig
      38  FLASH_OB_Unlock
     178  FLASH_OB_UserConfig
     226  FLASH_OB_WRPConfig
      68  FLASH_PrefetchBufferCmd
      68  FLASH_ReadAccess64Cmd
      68  FLASH_SLEEPPowerDownCmd
      46  FLASH_SetLatency
      38  FLASH_Unlock
      46  FLASH_WaitForLastOperation

 
   152 bytes in section .rodata
 2 614 bytes in section .text
 
 2 614 bytes of CODE  memory
   152 bytes of CONST memory

Errors: none
Warnings: none
