###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        20/Nov/2015  05:04:53
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_flash_ramfunc.c
#    Command line =  
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_flash_ramfunc.c
#        -D USE_STDPERIPH_DRIVER -D VECT_TAB_FLASH -D STM32L1XX_MD -D
#        IAR_ARM_CM3 -D USE_FULL_ASSERT -D SPIRIT_USE_FULL_ASSERT -D
#        USE_SYSTICK_DELAY -D SDK -lC
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\List\
#        -o
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\.\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\examples\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\runtime\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\SDK_Eval_STM32L\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\SPIRIT1_Library\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\SDK_Eval_Util\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\SDK_Virtual_Com\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32_USB-FS-Device_Lib\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\ACQ\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\CMSIS\Include\"
#    List file    =  
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\List\stm32l1xx_flash_ramfunc.lst
#    Object file  =  
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\Obj\stm32l1xx_flash_ramfunc.o
#
###############################################################################

E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_flash_ramfunc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_flash_ramfunc.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    31-December-2010
      7            * @brief   This file provides all the Flash firmware functions which should be
      8            *          executed from the internal SRAM. This file should be placed in 
      9            *          internal SRAM. 
     10            *          Other FLASH memory functions that can be used from the FLASH are 
     11            *          defined in the "stm32l1xx_flash.c" file. 
     12            *  @verbatim   
     13            *    
     14            *          ARM Compiler
     15            *          ------------
     16            *          RAM functions are defined using the toolchain options. 
     17            *          Functions that are be executed in RAM should reside in a separate
     18            *          source module. Using the 'Options for File' dialog you can simply change
     19            *          the 'Code / Const' area of a module to a memory space in physical RAM.
     20            *          Available memory areas are declared in the 'Target' tab of the 
     21            *          'Options for Target' dialog.
     22            *          
     23            *          ICCARM Compiler
     24            *          ---------------
     25            *          RAM functions are defined using a specific toolchain keyword "__ramfunc".  
     26            *          
     27            *          GNU Compiler
     28            *          ------------
     29            *          RAM functions are defined using a specific toolchain attribute
     30            *          "__attribute__((section(".data")))".
     31            *          
     32            *          TASKING Compiler
     33            *          ----------------
     34            *          RAM functions are defined using a specific toolchain pragma. This 
     35            *          pragma is defined inside this file.  
     36            *          
     37            *  @endverbatim     
     38            *
     39            ******************************************************************************
     40            * @attention
     41            *
     42            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     43            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     44            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     45            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     46            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     47            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     48            *
     49            * <h2><center>&copy; COPYRIGHT 2010 STMicroelectronics</center></h2>
     50            ******************************************************************************  
     51            */ 
     52          
     53          /* Includes ------------------------------------------------------------------*/
     54          #include "stm32l1xx_flash.h"
     55          
     56          /** @addtogroup STM32L1xx_StdPeriph_Driver
     57            * @{
     58            */
     59          
     60          /** @defgroup FLASH 
     61            * @brief FLASH driver modules
     62            * @{
     63            */ 
     64          
     65          /* Private typedef -----------------------------------------------------------*/
     66          /* Private define ------------------------------------------------------------*/
     67          /* Private macro -------------------------------------------------------------*/
     68          /* Private variables ---------------------------------------------------------*/
     69          /* Private function prototypes -----------------------------------------------*/
     70          static __RAM_FUNC GetStatus(void);
     71          static __RAM_FUNC WaitForLastOperation(uint32_t Timeout);
     72          
     73          /* Private functions ---------------------------------------------------------*/
     74           
     75          /** @defgroup FLASH_Private_Functions
     76            * @{
     77            */ 
     78          
     79          /** @addtogroup FLASH_Group1
     80           *
     81          @verbatim  
     82          @endverbatim
     83            * @{
     84            */  
     85          #if defined (  __TASKING__  )
     86          #pragma section_code_init on
     87          #endif
     88          
     89          /**
     90            * @brief  Enable or disable the power down mode during RUN mode.
     91            * @note: This function can be used only when the user code is running from Internal SRAM
     92            * @param  NewState: new state of the power down mode during RUN mode.
     93            *   This parameter can be: ENABLE or DISABLE.
     94            * @retval None
     95            */

   \                                 In section .textrw, align 2, keep-with-next
     96          __RAM_FUNC FLASH_RUNPowerDownCmd(FunctionalState NewState)
     97          {
   \                     FLASH_RUNPowerDownCmd: (+1)
   \   00000000   0x0001             MOVS     R1,R0
     98            FLASH_Status status = FLASH_COMPLETE;
   \   00000002   0x2004             MOVS     R0,#+4
     99           
    100            if (NewState != DISABLE)
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD012             BEQ.N    ??FLASH_RUNPowerDownCmd_0
    101            {
    102               /* Unlock the RUN_PD bit */
    103               FLASH->PDKEYR = FLASH_PDKEY1;
   \   0000000A   0x....             LDR.N    R2,??DataTable4  ;; 0x4152637
   \   0000000C   0x....             LDR.N    R3,??DataTable4_1  ;; 0x40023c08
   \   0000000E   0x601A             STR      R2,[R3, #+0]
    104               FLASH->PDKEYR = FLASH_PDKEY2;
   \   00000010   0x....             LDR.N    R2,??DataTable4_2  ;; 0xfafbfcfd
   \   00000012   0x....             LDR.N    R3,??DataTable4_1  ;; 0x40023c08
   \   00000014   0x601A             STR      R2,[R3, #+0]
    105               
    106               /* Set the RUN_PD bit in  FLASH_ACR register to put Flash in power down mode */
    107               FLASH->ACR |= (uint32_t)FLASH_ACR_RUN_PD;
   \   00000016   0x....             LDR.N    R2,??DataTable4_3  ;; 0x40023c00
   \   00000018   0x6812             LDR      R2,[R2, #+0]
   \   0000001A   0xF052 0x0210      ORRS     R2,R2,#0x10
   \   0000001E   0x....             LDR.N    R3,??DataTable4_3  ;; 0x40023c00
   \   00000020   0x601A             STR      R2,[R3, #+0]
    108          
    109               if((FLASH->ACR & FLASH_ACR_RUN_PD) != FLASH_ACR_RUN_PD)
   \   00000022   0x....             LDR.N    R2,??DataTable4_3  ;; 0x40023c00
   \   00000024   0x6812             LDR      R2,[R2, #+0]
   \   00000026   0x06D2             LSLS     R2,R2,#+27
   \   00000028   0xD408             BMI.N    ??FLASH_RUNPowerDownCmd_1
    110               {
    111                 status = FLASH_ERROR_PROGRAM;
   \   0000002A   0x2203             MOVS     R2,#+3
   \   0000002C   0x0010             MOVS     R0,R2
   \   0000002E   0xE005             B.N      ??FLASH_RUNPowerDownCmd_1
    112               }
    113            }
    114            else
    115            {
    116              /* Clear the RUN_PD bit in  FLASH_ACR register to put Flash in idle  mode */
    117              FLASH->ACR &= (uint32_t)(~(uint32_t)FLASH_ACR_RUN_PD);
   \                     ??FLASH_RUNPowerDownCmd_0: (+1)
   \   00000030   0x....             LDR.N    R2,??DataTable4_3  ;; 0x40023c00
   \   00000032   0x6812             LDR      R2,[R2, #+0]
   \   00000034   0xF032 0x0210      BICS     R2,R2,#0x10
   \   00000038   0x....             LDR.N    R3,??DataTable4_3  ;; 0x40023c00
   \   0000003A   0x601A             STR      R2,[R3, #+0]
    118            }
    119          
    120            /* Return the Write Status */
    121            return status;  
   \                     ??FLASH_RUNPowerDownCmd_1: (+1)
   \   0000003C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003E   0x4770             BX       LR               ;; return
    122          }
    123          
    124          /**
    125            * @}
    126            */
    127          
    128          /** @addtogroup FLASH_Group2
    129           *
    130          @verbatim  
    131          @endverbatim
    132            * @{
    133            */
    134          
    135          /**
    136            * @brief  Programs a half page in program memory.
    137            * @param  Address: specifies the address to be written.
    138            * @param  pBuffer: pointer to the buffer  containing the data to be  written to 
    139            *         the half page.
    140            * @note   - To correctly run this function, the FLASH_Unlock() function
    141            *           must be called before.
    142            *         - Call the FLASH_Lock() to disable the flash memory access  
    143            *          (recommended to protect the FLASH memory against possible unwanted operation)
    144            * @note   Half page write is possible only from SRAM.
    145            * @note   If there are more than 32 words to write, after 32 words another 
    146            *         Half Page programming operation starts and has to be finished.
    147            * @note   A half page is written to the program memory only if the first 
    148            *         address to load is the start address of a half page (multiple of 128 
    149            *         bytes) and the 31 remaining words to load are in the same half page.
    150            * @note   During the Program memory half page write all read operations are 
    151            *         forbidden (this includes DMA read operations and debugger read 
    152            *         operations such as breakpoints, periodic updates, etc.)
    153            * @note   If a PGAERR is set during a Program memory half page write, the 
    154            *         complete write operation is aborted. Software should then reset the 
    155            *         FPRG and PROG/DATA bits and restart the write operation from the 
    156            *         beginning.                             
    157            * @retval FLASH Status: The returned value can be:  
    158            *   FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
    159            */

   \                                 In section .textrw, align 2, keep-with-next
    160          __RAM_FUNC FLASH_ProgramHalfPage(uint32_t Address, uint32_t* pBuffer)
    161          {
   \                     FLASH_ProgramHalfPage: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    162            uint32_t count = 0; 
   \   00000006   0x2600             MOVS     R6,#+0
    163             
    164            FLASH_Status status = FLASH_COMPLETE;
   \   00000008   0x2704             MOVS     R7,#+4
    165          
    166            /* Wait for last operation to be completed */
    167            status = WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   \   0000000A   0xF44F 0x4000      MOV      R0,#+32768
   \   0000000E   0x.... 0x....      BL       WaitForLastOperation
   \   00000012   0x0007             MOVS     R7,R0
    168            
    169            if(status == FLASH_COMPLETE)
   \   00000014   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000016   0x2F04             CMP      R7,#+4
   \   00000018   0xD124             BNE.N    ??FLASH_ProgramHalfPage_0
    170            {
    171              /* if the previous operation is completed, proceed to program the new  
    172              half page */
    173              FLASH->PECR |= FLASH_PECR_FPRG;
   \   0000001A   0x....             LDR.N    R0,??DataTable4_4  ;; 0x40023c04
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000022   0x....             LDR.N    R1,??DataTable4_4  ;; 0x40023c04
   \   00000024   0x6008             STR      R0,[R1, #+0]
    174              FLASH->PECR |= FLASH_PECR_PROG;
   \   00000026   0x....             LDR.N    R0,??DataTable4_4  ;; 0x40023c04
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000002E   0x....             LDR.N    R1,??DataTable4_4  ;; 0x40023c04
   \   00000030   0x6008             STR      R0,[R1, #+0]
    175              
    176              /* Write one half page directly with 32 different words */
    177              while(count < 32)
   \                     ??FLASH_ProgramHalfPage_1: (+1)
   \   00000032   0x2E20             CMP      R6,#+32
   \   00000034   0xD205             BCS.N    ??FLASH_ProgramHalfPage_2
    178              {
    179                *(__IO uint32_t*) (Address + (4 * count)) = *(pBuffer++);
   \   00000036   0x6828             LDR      R0,[R5, #+0]
   \   00000038   0xF844 0x0026      STR      R0,[R4, R6, LSL #+2]
   \   0000003C   0x1D2D             ADDS     R5,R5,#+4
    180                count ++;  
   \   0000003E   0x1C76             ADDS     R6,R6,#+1
   \   00000040   0xE7F7             B.N      ??FLASH_ProgramHalfPage_1
    181              }
    182              /* Wait for last operation to be completed */
    183              status = WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   \                     ??FLASH_ProgramHalfPage_2: (+1)
   \   00000042   0xF44F 0x4000      MOV      R0,#+32768
   \   00000046   0x.... 0x....      BL       WaitForLastOperation
   \   0000004A   0x0007             MOVS     R7,R0
    184           
    185              /* if the write operation is completed, disable the PROG and FPRG bits */
    186              FLASH->PECR &= (uint32_t)(~FLASH_PECR_PROG);
   \   0000004C   0x....             LDR.N    R0,??DataTable4_4  ;; 0x40023c04
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0xF030 0x0008      BICS     R0,R0,#0x8
   \   00000054   0x....             LDR.N    R1,??DataTable4_4  ;; 0x40023c04
   \   00000056   0x6008             STR      R0,[R1, #+0]
    187              FLASH->PECR &= (uint32_t)(~FLASH_PECR_FPRG);
   \   00000058   0x....             LDR.N    R0,??DataTable4_4  ;; 0x40023c04
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0xF430 0x6080      BICS     R0,R0,#0x400
   \   00000060   0x....             LDR.N    R1,??DataTable4_4  ;; 0x40023c04
   \   00000062   0x6008             STR      R0,[R1, #+0]
    188            }
    189            /* Return the Write Status */
    190            return status;
   \                     ??FLASH_ProgramHalfPage_0: (+1)
   \   00000064   0x0038             MOVS     R0,R7
   \   00000066   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000068   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    191          }
    192          
    193          /**
    194            * @}
    195            */
    196          
    197          /** @addtogroup FLASH_Group3
    198           *
    199          @verbatim  
    200          @endverbatim
    201            * @{
    202            */
    203          
    204          /**
    205            * @brief  Erase a double word in data memory.
    206            * @param  Address: specifies the address to be erased
    207            * @note   - To correctly run this function, the DATA_EEPROM_Unlock() function
    208            *           must be called before.
    209            *         - Call the DATA_EEPROM_Lock() to he data EEPROM access
    210            *           and Flash program erase control register access(recommended to protect 
    211            *           the DATA_EEPROM against possible unwanted operation)   
    212            * @note   Data memory double word erase is possible only from SRAM.
    213            * @note   A double word is erased to the data memory only if the first address 
    214            *         to load is the start address of a double word (multiple of 8 bytes)  
    215            * @note   During the Data memory double word erase, all read operations are 
    216            *         forbidden (this includes DMA read operations and debugger read 
    217            *         operations such as breakpoints, periodic updates, etc.)  
    218            * @retval FLASH Status: The returned value can be: 
    219            *   FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
    220            */
    221          

   \                                 In section .textrw, align 2, keep-with-next
    222          __RAM_FUNC DATA_EEPROM_EraseDoubleWord(uint32_t Address)
    223          {
   \                     DATA_EEPROM_EraseDoubleWord: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    224            FLASH_Status status = FLASH_COMPLETE;
   \   00000004   0x2504             MOVS     R5,#+4
    225              
    226            /* Wait for last operation to be completed */
    227            status = WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   \   00000006   0xF44F 0x4000      MOV      R0,#+32768
   \   0000000A   0x.... 0x....      BL       WaitForLastOperation
   \   0000000E   0x0005             MOVS     R5,R0
    228            
    229            if(status == FLASH_COMPLETE)
   \   00000010   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000012   0x2D04             CMP      R5,#+4
   \   00000014   0xD120             BNE.N    ??DATA_EEPROM_EraseDoubleWord_0
    230            {
    231              /* If the previous operation is completed, proceed to erase the next double word */
    232              /* Set the ERASE bit */
    233              FLASH->PECR |= FLASH_PECR_ERASE;
   \   00000016   0x....             LDR.N    R0,??DataTable4_4  ;; 0x40023c04
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   0000001E   0x....             LDR.N    R1,??DataTable4_4  ;; 0x40023c04
   \   00000020   0x6008             STR      R0,[R1, #+0]
    234          
    235              /* Set DATA bit */
    236              FLASH->PECR |= FLASH_PECR_DATA;
   \   00000022   0x....             LDR.N    R0,??DataTable4_4  ;; 0x40023c04
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000002A   0x....             LDR.N    R1,??DataTable4_4  ;; 0x40023c04
   \   0000002C   0x6008             STR      R0,[R1, #+0]
    237             
    238              /* Write 00000000h to the 2 words to erase */
    239              *(__IO uint64_t *)Address = 0x00000000;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0xE9C4 0x0100      STRD     R0,R1,[R4, #+0]
    240           
    241              /* Wait for last operation to be completed */
    242              status = WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   \   00000036   0xF44F 0x4000      MOV      R0,#+32768
   \   0000003A   0x.... 0x....      BL       WaitForLastOperation
   \   0000003E   0x0005             MOVS     R5,R0
    243              
    244              /* If the erase operation is completed, disable the ERASE and DATA bits */
    245              FLASH->PECR &= (uint32_t)(~FLASH_PECR_ERASE);
   \   00000040   0x....             LDR.N    R0,??DataTable4_4  ;; 0x40023c04
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0xF430 0x7000      BICS     R0,R0,#0x200
   \   00000048   0x....             LDR.N    R1,??DataTable4_4  ;; 0x40023c04
   \   0000004A   0x6008             STR      R0,[R1, #+0]
    246              FLASH->PECR &= (uint32_t)(~FLASH_PECR_DATA);
   \   0000004C   0x....             LDR.N    R0,??DataTable4_4  ;; 0x40023c04
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0xF030 0x0010      BICS     R0,R0,#0x10
   \   00000054   0x....             LDR.N    R1,??DataTable4_4  ;; 0x40023c04
   \   00000056   0x6008             STR      R0,[R1, #+0]
    247            }  
    248            /* Return the erase status */
    249            return status;
   \                     ??DATA_EEPROM_EraseDoubleWord_0: (+1)
   \   00000058   0x0028             MOVS     R0,R5
   \   0000005A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    250          }
    251          
    252          /**
    253            * @brief  Write a double word in data memory without erase.
    254            * @param  Address: specifies the address to be written.
    255            * @param  Data: specifies the data to be written.
    256            * @note   - To correctly run this function, the DATA_EEPROM_Unlock() function
    257            *           must be called before.
    258            *         - Call the DATA_EEPROM_Lock() to he data EEPROM access
    259            *           and Flash program erase control register access(recommended to protect 
    260            *           the DATA_EEPROM against possible unwanted operation)   
    261            * @note   Data memory double word write is possible only from SRAM.
    262            * @note   A data memory double word is written to the data memory only if the 
    263            *         first address to load is the start address of a double word (multiple 
    264            *         of double word).  
    265            * @note   During the Data memory double word write, all read operations are 
    266            *         forbidden (this includes DMA read operations and debugger read 
    267            *         operations such as breakpoints, periodic updates, etc.)    
    268            * @retval FLASH Status: The returned value can be: 
    269            *   FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
    270            */ 

   \                                 In section .textrw, align 2, keep-with-next
    271          __RAM_FUNC DATA_EEPROM_ProgramDoubleWord(uint32_t Address, uint64_t Data)
    272          {
   \                     DATA_EEPROM_ProgramDoubleWord: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x0014             MOVS     R4,R2
   \   00000006   0x001D             MOVS     R5,R3
    273            FLASH_Status status = FLASH_COMPLETE;
   \   00000008   0x2704             MOVS     R7,#+4
    274              
    275            /* Wait for last operation to be completed */
    276            status = WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   \   0000000A   0xF44F 0x4000      MOV      R0,#+32768
   \   0000000E   0x.... 0x....      BL       WaitForLastOperation
   \   00000012   0x0007             MOVS     R7,R0
    277            
    278            if(status == FLASH_COMPLETE)
   \   00000014   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000016   0x2F04             CMP      R7,#+4
   \   00000018   0xD11F             BNE.N    ??DATA_EEPROM_ProgramDoubleWord_0
    279            {
    280              /* If the previous operation is completed, proceed to program the new data*/
    281              FLASH->PECR |= FLASH_PECR_FPRG;
   \   0000001A   0x....             LDR.N    R0,??DataTable4_4  ;; 0x40023c04
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000022   0x....             LDR.N    R1,??DataTable4_4  ;; 0x40023c04
   \   00000024   0x6008             STR      R0,[R1, #+0]
    282              FLASH->PECR |= FLASH_PECR_DATA;
   \   00000026   0x....             LDR.N    R0,??DataTable4_4  ;; 0x40023c04
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000002E   0x....             LDR.N    R1,??DataTable4_4  ;; 0x40023c04
   \   00000030   0x6008             STR      R0,[R1, #+0]
    283              
    284              /* Write the 2 words */  
    285               *(__IO uint32_t *)Address = (uint32_t) Data;
   \   00000032   0x6034             STR      R4,[R6, #+0]
    286               Address += 4;
   \   00000034   0x1D36             ADDS     R6,R6,#+4
    287               *(__IO uint32_t *)Address = (uint32_t) (Data >> 32);
   \   00000036   0x6035             STR      R5,[R6, #+0]
    288              
    289              /* Wait for last operation to be completed */
    290              status = WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
   \   00000038   0xF44F 0x4000      MOV      R0,#+32768
   \   0000003C   0x.... 0x....      BL       WaitForLastOperation
   \   00000040   0x0007             MOVS     R7,R0
    291              
    292              /* If the write operation is completed, disable the FPRG and DATA bits */
    293              FLASH->PECR &= (uint32_t)(~FLASH_PECR_FPRG);
   \   00000042   0x....             LDR.N    R0,??DataTable4_4  ;; 0x40023c04
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0xF430 0x6080      BICS     R0,R0,#0x400
   \   0000004A   0x....             LDR.N    R1,??DataTable4_4  ;; 0x40023c04
   \   0000004C   0x6008             STR      R0,[R1, #+0]
    294              FLASH->PECR &= (uint32_t)(~FLASH_PECR_DATA);     
   \   0000004E   0x....             LDR.N    R0,??DataTable4_4  ;; 0x40023c04
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0xF030 0x0010      BICS     R0,R0,#0x10
   \   00000056   0x....             LDR.N    R1,??DataTable4_4  ;; 0x40023c04
   \   00000058   0x6008             STR      R0,[R1, #+0]
    295            }
    296            /* Return the Write Status */
    297            return status;
   \                     ??DATA_EEPROM_ProgramDoubleWord_0: (+1)
   \   0000005A   0x0038             MOVS     R0,R7
   \   0000005C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    298          }
    299          
    300          /**
    301            * @}
    302            */
    303          
    304          /**
    305            * @brief  Returns the FLASH Status.
    306            * @param  None
    307            * @retval FLASH Status: The returned value can be: FLASH_BUSY, 
    308            *   FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP or FLASH_COMPLETE
    309            */

   \                                 In section .textrw, align 2, keep-with-next
    310          static __RAM_FUNC GetStatus(void)
    311          {
    312            FLASH_Status FLASHstatus = FLASH_COMPLETE;
   \                     GetStatus: (+1)
   \   00000000   0x2004             MOVS     R0,#+4
    313            
    314            if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
   \   00000002   0x....             LDR.N    R1,??DataTable4_5  ;; 0x40023c18
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x07C9             LSLS     R1,R1,#+31
   \   00000008   0xD502             BPL.N    ??GetStatus_0
    315            {
    316              FLASHstatus = FLASH_BUSY;
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x0008             MOVS     R0,R1
   \   0000000E   0xE011             B.N      ??GetStatus_1
    317            }
    318            else 
    319            {  
    320              if((FLASH->SR & (uint32_t)FLASH_FLAG_WRPERR)!= (uint32_t)0x00)
   \                     ??GetStatus_0: (+1)
   \   00000010   0x....             LDR.N    R1,??DataTable4_5  ;; 0x40023c18
   \   00000012   0x6809             LDR      R1,[R1, #+0]
   \   00000014   0x05C9             LSLS     R1,R1,#+23
   \   00000016   0xD502             BPL.N    ??GetStatus_2
    321              { 
    322                FLASHstatus = FLASH_ERROR_WRP;
   \   00000018   0x2102             MOVS     R1,#+2
   \   0000001A   0x0008             MOVS     R0,R1
   \   0000001C   0xE00A             B.N      ??GetStatus_1
    323              }
    324              else 
    325              {
    326                if((FLASH->SR & (uint32_t)0xFEF0) != (uint32_t)0x00)
   \                     ??GetStatus_2: (+1)
   \   0000001E   0x....             LDR.N    R1,??DataTable4_5  ;; 0x40023c18
   \   00000020   0x6809             LDR      R1,[R1, #+0]
   \   00000022   0xF64F 0x62F0      MOVW     R2,#+65264
   \   00000026   0x4211             TST      R1,R2
   \   00000028   0xD002             BEQ.N    ??GetStatus_3
    327                {
    328                  FLASHstatus = FLASH_ERROR_PROGRAM; 
   \   0000002A   0x2103             MOVS     R1,#+3
   \   0000002C   0x0008             MOVS     R0,R1
   \   0000002E   0xE001             B.N      ??GetStatus_1
    329                }
    330                else
    331                {
    332                  FLASHstatus = FLASH_COMPLETE;
   \                     ??GetStatus_3: (+1)
   \   00000030   0x2104             MOVS     R1,#+4
   \   00000032   0x0008             MOVS     R0,R1
    333                }
    334              }
    335            }
    336            /* Return the FLASH Status */
    337            return FLASHstatus;
   \                     ??GetStatus_1: (+1)
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0x4770             BX       LR               ;; return
    338          }
    339          
    340          /**
    341            * @brief  Waits for a FLASH operation to complete or a TIMEOUT to occur.
    342            * @param  Timeout: FLASH programming Timeout
    343            * @retval FLASH Status: The returned value can be: FLASH_BUSY, 
    344            *   FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or 
    345            *   FLASH_TIMEOUT.
    346            */

   \                                 In section .textrw, align 2, keep-with-next
    347          static __RAM_FUNC  WaitForLastOperation(uint32_t Timeout)
    348          { 
   \                     WaitForLastOperation: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    349            FLASH_Status status = FLASH_COMPLETE;
   \   00000004   0x2504             MOVS     R5,#+4
    350             
    351            /* Check for the FLASH Status */
    352            status = GetStatus();
   \   00000006   0x.... 0x....      BL       GetStatus
   \   0000000A   0x0005             MOVS     R5,R0
    353            
    354            /* Wait for a FLASH operation to complete or a TIMEOUT to occur */
    355            while((status == FLASH_BUSY) && (Timeout != 0x00))
   \                     ??WaitForLastOperation_0: (+1)
   \   0000000C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   0x2D01             CMP      R5,#+1
   \   00000010   0xD106             BNE.N    ??WaitForLastOperation_1
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD004             BEQ.N    ??WaitForLastOperation_1
    356            {
    357              status = GetStatus();
   \   00000016   0x.... 0x....      BL       GetStatus
   \   0000001A   0x0005             MOVS     R5,R0
    358              Timeout--;
   \   0000001C   0x1E64             SUBS     R4,R4,#+1
   \   0000001E   0xE7F5             B.N      ??WaitForLastOperation_0
    359            }
    360            
    361            if(Timeout == 0x00 )
   \                     ??WaitForLastOperation_1: (+1)
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD101             BNE.N    ??WaitForLastOperation_2
    362            {
    363              status = FLASH_TIMEOUT;
   \   00000024   0x2005             MOVS     R0,#+5
   \   00000026   0x0005             MOVS     R5,R0
    364            }
    365            /* Return the operation status */
    366            return status;
   \                     ??WaitForLastOperation_2: (+1)
   \   00000028   0x0028             MOVS     R0,R5
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    367          }

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x04152637         DC32     0x4152637

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x40023C08         DC32     0x40023c08

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0xFAFBFCFD         DC32     0xfafbfcfd

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x40023C00         DC32     0x40023c00

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x40023C04         DC32     0x40023c04

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x40023C18         DC32     0x40023c18
    368          
    369          #if defined (  __TASKING__  )
    370          #pragma section_code_init restore
    371          #endif
    372          
    373          /**
    374            * @}
    375            */
    376             
    377            /**
    378            * @}
    379            */ 
    380          
    381          /**
    382            * @}
    383            */ 
    384          
    385          /******************* (C) COPYRIGHT 2010 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   DATA_EEPROM_EraseDoubleWord
        16   -> WaitForLastOperation
      24   DATA_EEPROM_ProgramDoubleWord
        24   -> WaitForLastOperation
      24   FLASH_ProgramHalfPage
        24   -> WaitForLastOperation
       0   FLASH_RUNPowerDownCmd
       0   GetStatus
      16   WaitForLastOperation
        16   -> GetStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
      94  DATA_EEPROM_EraseDoubleWord
      96  DATA_EEPROM_ProgramDoubleWord
     106  FLASH_ProgramHalfPage
      64  FLASH_RUNPowerDownCmd
      56  GetStatus
      46  WaitForLastOperation

 
 486 bytes in section .textrw
 
 486 bytes of CODE memory

Errors: none
Warnings: none
