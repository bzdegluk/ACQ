###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        20/Nov/2015  05:04:40
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\SPIRIT1_Library\Source\src\SPIRIT_Csma.c
#    Command line =  
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\SPIRIT1_Library\Source\src\SPIRIT_Csma.c
#        -D USE_STDPERIPH_DRIVER -D VECT_TAB_FLASH -D STM32L1XX_MD -D
#        IAR_ARM_CM3 -D USE_FULL_ASSERT -D SPIRIT_USE_FULL_ASSERT -D
#        USE_SYSTICK_DELAY -D SDK -lC
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\List\
#        -o
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\.\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\examples\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\runtime\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\SDK_Eval_STM32L\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\SPIRIT1_Library\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\SDK_Eval_Util\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\SDK_Virtual_Com\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32_USB-FS-Device_Lib\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\ACQ\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\CMSIS\Include\"
#    List file    =  
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\List\SPIRIT_Csma.lst
#    Object file  =  
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\Obj\SPIRIT_Csma.o
#
###############################################################################

E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\SPIRIT1_Library\Source\src\SPIRIT_Csma.c
      1          /**
      2           * @file    SPIRIT_Csma.c
      3           * @author  High End Analog & RF BU - AMS / ART Team IMS-Systems Lab
      4           * @version V3.0.1
      5           * @date    November 19, 2012
      6           * @brief   Configuration and management of SPIRIT CSMA.
      7           * @details
      8           *
      9           * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     10           * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     11           * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     12           * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     13           * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     14           * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     15           *
     16           * THIS SOURCE CODE IS PROTECTED BY A LICENSE.
     17           * FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED
     18           * IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
     19           *
     20           * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     21           */
     22          
     23          
     24          /* Includes ------------------------------------------------------------------*/
     25          #include "SPIRIT_Csma.h"
     26          #include "MCU_Interface.h"
     27          
     28          
     29          /**
     30           * @addtogroup SPIRIT_Libraries
     31           * @{
     32           */
     33          
     34          
     35          /**
     36           * @addtogroup SPIRIT_Csma
     37           * @{
     38           */
     39          
     40          
     41          /**
     42           * @defgroup Csma_Private_TypesDefinitions      CSMA Private TypesDefinitions
     43           * @{
     44           */
     45          
     46          
     47          /**
     48           *@}
     49           */
     50          
     51          
     52          /**
     53           * @defgroup Csma_Private_Defines               CSMA Private Defines
     54           * @{
     55           */
     56          
     57          /**
     58           *@}
     59           */
     60          
     61          
     62          /**
     63           * @defgroup Csma_Private_Macros               CSMA Private Macros
     64           * @{
     65           */
     66          
     67          /**
     68           *@}
     69           */
     70          
     71          
     72          /**
     73           * @defgroup Csma_Private_Variables             CSMA Private Variables
     74           * @{
     75           */
     76          
     77          /**
     78           *@}
     79           */
     80          
     81          
     82          
     83          /**
     84           * @defgroup Csma_Private_FunctionPrototypes    CSMA Private FunctionPrototypes
     85           * @{
     86           */
     87          
     88          /**
     89           *@}
     90           */
     91          
     92          
     93          /**
     94           * @defgroup Csma_Private_Functions             CSMA Private Functions
     95           * @{
     96           */
     97          
     98          
     99          /**
    100           * @brief  Initializes the SPIRIT CSMA according to the specified parameters in the CsmaInit.
    101           * @param  pxCsmaInit Csma init structure.
    102           *         This parameter is a pointer to @ref CsmaInit.
    103           * @retval None.
    104           */

   \                                 In section .text, align 2, keep-with-next
    105          void SpiritCsmaInit(CsmaInit* pxCsmaInit)
    106          {
   \                     SpiritCsmaInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x0004             MOVS     R4,R0
    107            uint8_t tempRegValue[5];
    108          
    109            /* Check the parameters */
    110            s_assert_param(IS_SPIRIT_FUNCTIONAL_STATE(pxCsmaInit->xCsmaPersistentMode));
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD007             BEQ.N    ??SpiritCsmaInit_0
   \   0000000C   0x7820             LDRB     R0,[R4, #+0]
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD004             BEQ.N    ??SpiritCsmaInit_0
   \   00000012   0x216E             MOVS     R1,#+110
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000018   0x.... 0x....      BL       s_assert_failed
    111            s_assert_param(IS_CCA_PERIOD(pxCsmaInit->xMultiplierTbit));
   \                     ??SpiritCsmaInit_0: (+1)
   \   0000001C   0x7860             LDRB     R0,[R4, #+1]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD00D             BEQ.N    ??SpiritCsmaInit_1
   \   00000022   0x7860             LDRB     R0,[R4, #+1]
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD00A             BEQ.N    ??SpiritCsmaInit_1
   \   00000028   0x7860             LDRB     R0,[R4, #+1]
   \   0000002A   0x2802             CMP      R0,#+2
   \   0000002C   0xD007             BEQ.N    ??SpiritCsmaInit_1
   \   0000002E   0x7860             LDRB     R0,[R4, #+1]
   \   00000030   0x2803             CMP      R0,#+3
   \   00000032   0xD004             BEQ.N    ??SpiritCsmaInit_1
   \   00000034   0x216F             MOVS     R1,#+111
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable17
   \   0000003A   0x.... 0x....      BL       s_assert_failed
    112            s_assert_param(IS_CSMA_LENGTH(pxCsmaInit->xCcaLength));
   \                     ??SpiritCsmaInit_1: (+1)
   \   0000003E   0x78A0             LDRB     R0,[R4, #+2]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD031             BEQ.N    ??SpiritCsmaInit_2
   \   00000044   0x78A0             LDRB     R0,[R4, #+2]
   \   00000046   0x2810             CMP      R0,#+16
   \   00000048   0xD02E             BEQ.N    ??SpiritCsmaInit_2
   \   0000004A   0x78A0             LDRB     R0,[R4, #+2]
   \   0000004C   0x2820             CMP      R0,#+32
   \   0000004E   0xD02B             BEQ.N    ??SpiritCsmaInit_2
   \   00000050   0x78A0             LDRB     R0,[R4, #+2]
   \   00000052   0x2830             CMP      R0,#+48
   \   00000054   0xD028             BEQ.N    ??SpiritCsmaInit_2
   \   00000056   0x78A0             LDRB     R0,[R4, #+2]
   \   00000058   0x2840             CMP      R0,#+64
   \   0000005A   0xD025             BEQ.N    ??SpiritCsmaInit_2
   \   0000005C   0x78A0             LDRB     R0,[R4, #+2]
   \   0000005E   0x2850             CMP      R0,#+80
   \   00000060   0xD022             BEQ.N    ??SpiritCsmaInit_2
   \   00000062   0x78A0             LDRB     R0,[R4, #+2]
   \   00000064   0x2860             CMP      R0,#+96
   \   00000066   0xD01F             BEQ.N    ??SpiritCsmaInit_2
   \   00000068   0x78A0             LDRB     R0,[R4, #+2]
   \   0000006A   0x2870             CMP      R0,#+112
   \   0000006C   0xD01C             BEQ.N    ??SpiritCsmaInit_2
   \   0000006E   0x78A0             LDRB     R0,[R4, #+2]
   \   00000070   0x2880             CMP      R0,#+128
   \   00000072   0xD019             BEQ.N    ??SpiritCsmaInit_2
   \   00000074   0x78A0             LDRB     R0,[R4, #+2]
   \   00000076   0x2890             CMP      R0,#+144
   \   00000078   0xD016             BEQ.N    ??SpiritCsmaInit_2
   \   0000007A   0x78A0             LDRB     R0,[R4, #+2]
   \   0000007C   0x28A0             CMP      R0,#+160
   \   0000007E   0xD013             BEQ.N    ??SpiritCsmaInit_2
   \   00000080   0x78A0             LDRB     R0,[R4, #+2]
   \   00000082   0x28B0             CMP      R0,#+176
   \   00000084   0xD010             BEQ.N    ??SpiritCsmaInit_2
   \   00000086   0x78A0             LDRB     R0,[R4, #+2]
   \   00000088   0x28C0             CMP      R0,#+192
   \   0000008A   0xD00D             BEQ.N    ??SpiritCsmaInit_2
   \   0000008C   0x78A0             LDRB     R0,[R4, #+2]
   \   0000008E   0x28D0             CMP      R0,#+208
   \   00000090   0xD00A             BEQ.N    ??SpiritCsmaInit_2
   \   00000092   0x78A0             LDRB     R0,[R4, #+2]
   \   00000094   0x28E0             CMP      R0,#+224
   \   00000096   0xD007             BEQ.N    ??SpiritCsmaInit_2
   \   00000098   0x78A0             LDRB     R0,[R4, #+2]
   \   0000009A   0x28F0             CMP      R0,#+240
   \   0000009C   0xD004             BEQ.N    ??SpiritCsmaInit_2
   \   0000009E   0x2170             MOVS     R1,#+112
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable17
   \   000000A4   0x.... 0x....      BL       s_assert_failed
    113            s_assert_param(IS_BU_COUNTER_SEED(pxCsmaInit->nBuCounterSeed));
   \                     ??SpiritCsmaInit_2: (+1)
   \   000000A8   0x88A0             LDRH     R0,[R4, #+4]
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xD104             BNE.N    ??SpiritCsmaInit_3
   \   000000AE   0x2171             MOVS     R1,#+113
   \   000000B0   0x.... 0x....      LDR.W    R0,??DataTable17
   \   000000B4   0x.... 0x....      BL       s_assert_failed
    114            s_assert_param(IS_BU_PRESCALER(pxCsmaInit->cBuPrescaler));
   \                     ??SpiritCsmaInit_3: (+1)
   \   000000B8   0x79A0             LDRB     R0,[R4, #+6]
   \   000000BA   0x2840             CMP      R0,#+64
   \   000000BC   0xDB04             BLT.N    ??SpiritCsmaInit_4
   \   000000BE   0x2172             MOVS     R1,#+114
   \   000000C0   0x.... 0x....      LDR.W    R0,??DataTable17
   \   000000C4   0x.... 0x....      BL       s_assert_failed
    115            s_assert_param(IS_CMAX_NB(pxCsmaInit->cMaxNb));
   \                     ??SpiritCsmaInit_4: (+1)
   \   000000C8   0x78E0             LDRB     R0,[R4, #+3]
   \   000000CA   0x2808             CMP      R0,#+8
   \   000000CC   0xDB04             BLT.N    ??SpiritCsmaInit_5
   \   000000CE   0x2173             MOVS     R1,#+115
   \   000000D0   0x.... 0x....      LDR.W    R0,??DataTable17
   \   000000D4   0x.... 0x....      BL       s_assert_failed
    116          
    117            /* CSMA BU counter seed (MSB) config */
    118            tempRegValue[0] = (uint8_t)(pxCsmaInit->nBuCounterSeed >> 8);
   \                     ??SpiritCsmaInit_5: (+1)
   \   000000D8   0x88A0             LDRH     R0,[R4, #+4]
   \   000000DA   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000DC   0x0A00             LSRS     R0,R0,#+8
   \   000000DE   0xF88D 0x0004      STRB     R0,[SP, #+4]
    119          
    120            /* CSMA BU counter seed (LSB) config */
    121            tempRegValue[1] = (uint8_t) pxCsmaInit->nBuCounterSeed;
   \   000000E2   0x88A0             LDRH     R0,[R4, #+4]
   \   000000E4   0xF88D 0x0005      STRB     R0,[SP, #+5]
    122          
    123            /* CSMA BU prescaler config and CCA period config */
    124            tempRegValue[2] = (pxCsmaInit->cBuPrescaler << 2) | pxCsmaInit->xMultiplierTbit;
   \   000000E8   0x79A0             LDRB     R0,[R4, #+6]
   \   000000EA   0x7861             LDRB     R1,[R4, #+1]
   \   000000EC   0xEA51 0x0080      ORRS     R0,R1,R0, LSL #+2
   \   000000F0   0xF88D 0x0006      STRB     R0,[SP, #+6]
    125          
    126            /* CSMA CCA length config and max number of back-off */
    127            tempRegValue[3] = (pxCsmaInit->xCcaLength | pxCsmaInit->cMaxNb);
   \   000000F4   0x78A0             LDRB     R0,[R4, #+2]
   \   000000F6   0x78E1             LDRB     R1,[R4, #+3]
   \   000000F8   0x4308             ORRS     R0,R1,R0
   \   000000FA   0xF88D 0x0007      STRB     R0,[SP, #+7]
    128          
    129            /* Reads the PROTOCOL1_BASE register value, to write the SEED_RELOAD and CSMA_PERS_ON fields */
    130            g_xStatus = SpiritSpiReadRegisters(PROTOCOL1_BASE, 1, &tempRegValue[4]);
   \   000000FE   0xAA02             ADD      R2,SP,#+8
   \   00000100   0x2101             MOVS     R1,#+1
   \   00000102   0x2051             MOVS     R0,#+81
   \   00000104   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   00000108   0x9000             STR      R0,[SP, #+0]
   \   0000010A   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   0000010E   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   00000112   0x8001             STRH     R1,[R0, #+0]
    131          
    132            /* Writes the new value for persistent mode */
    133            if(pxCsmaInit->xCsmaPersistentMode==S_ENABLE)
   \   00000114   0x7820             LDRB     R0,[R4, #+0]
   \   00000116   0x2801             CMP      R0,#+1
   \   00000118   0xD106             BNE.N    ??SpiritCsmaInit_6
    134            {
    135              tempRegValue[4] |= PROTOCOL1_CSMA_PERS_ON_MASK;
   \   0000011A   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   0000011E   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000122   0xF88D 0x0008      STRB     R0,[SP, #+8]
   \   00000126   0xE005             B.N      ??SpiritCsmaInit_7
    136            }
    137            else
    138            {
    139              tempRegValue[4] &= ~PROTOCOL1_CSMA_PERS_ON_MASK;
   \                     ??SpiritCsmaInit_6: (+1)
   \   00000128   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   0000012C   0xF010 0x00FD      ANDS     R0,R0,#0xFD
   \   00000130   0xF88D 0x0008      STRB     R0,[SP, #+8]
    140            }
    141          
    142            /* Writes PROTOCOL1_BASE register */
    143            g_xStatus = SpiritSpiWriteRegisters(PROTOCOL1_BASE, 1, &tempRegValue[4]);
   \                     ??SpiritCsmaInit_7: (+1)
   \   00000134   0xAA02             ADD      R2,SP,#+8
   \   00000136   0x2101             MOVS     R1,#+1
   \   00000138   0x2051             MOVS     R0,#+81
   \   0000013A   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   0000013E   0x9000             STR      R0,[SP, #+0]
   \   00000140   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000144   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   00000148   0x8001             STRH     R1,[R0, #+0]
    144          
    145            /* Writes CSMA_CONFIGx_BASE registers */
    146            g_xStatus = SpiritSpiWriteRegisters(CSMA_CONFIG3_BASE, 4, tempRegValue);
   \   0000014A   0xAA01             ADD      R2,SP,#+4
   \   0000014C   0x2104             MOVS     R1,#+4
   \   0000014E   0x2064             MOVS     R0,#+100
   \   00000150   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000154   0x9000             STR      R0,[SP, #+0]
   \   00000156   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   0000015A   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   0000015E   0x8001             STRH     R1,[R0, #+0]
    147          
    148          }
   \   00000160   0xBD1F             POP      {R0-R4,PC}       ;; return
    149          
    150          
    151           /**
    152            * @brief  Returns the fitted structure CsmaInit starting from the registers values.
    153            * @param  pxCsmaInit Csma structure to be fitted.
    154            *         This parameter is a pointer to @ref CsmaInit.
    155            * @retval None.
    156            */

   \                                 In section .text, align 2, keep-with-next
    157          void SpiritCsmaGetInfo(CsmaInit* pxCsmaInit)
    158          {
   \                     SpiritCsmaGetInfo: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x0004             MOVS     R4,R0
    159             uint8_t tempRegValue[5];
    160          
    161             /* Reads PROTOCOL1_BASE register */
    162             g_xStatus = SpiritSpiReadRegisters(PROTOCOL1_BASE, 1, &tempRegValue[4]);
   \   00000006   0xAA01             ADD      R2,SP,#+4
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0x2051             MOVS     R0,#+81
   \   0000000C   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   00000010   0x9002             STR      R0,[SP, #+8]
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000016   0xF8BD 0x1008      LDRH     R1,[SP, #+8]
   \   0000001A   0x8001             STRH     R1,[R0, #+0]
    163          
    164             /* Reads CSMA_CONFIGx_BASE registers */
    165             g_xStatus = SpiritSpiReadRegisters(CSMA_CONFIG3_BASE, 4, tempRegValue);
   \   0000001C   0xAA00             ADD      R2,SP,#+0
   \   0000001E   0x2104             MOVS     R1,#+4
   \   00000020   0x2064             MOVS     R0,#+100
   \   00000022   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   00000026   0x9002             STR      R0,[SP, #+8]
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   0000002C   0xF8BD 0x1008      LDRH     R1,[SP, #+8]
   \   00000030   0x8001             STRH     R1,[R0, #+0]
    166          
    167             /* Reads the bu counter seed */
    168             pxCsmaInit->nBuCounterSeed = (uint16_t)tempRegValue[1] | ((uint16_t)(tempRegValue[0] << 8));
   \   00000032   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000036   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   0000003A   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   0000003E   0x80A0             STRH     R0,[R4, #+4]
    169          
    170             /* Reads the bu prescaler */
    171             pxCsmaInit->cBuPrescaler = tempRegValue[2]>>2;
   \   00000040   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0x0880             LSRS     R0,R0,#+2
   \   00000048   0x71A0             STRB     R0,[R4, #+6]
    172          
    173             /* Reads the Cca period */
    174             pxCsmaInit->xMultiplierTbit = (CcaPeriod)(tempRegValue[2] & 0x03);
   \   0000004A   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   0000004E   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   00000052   0x7060             STRB     R0,[R4, #+1]
    175          
    176             /* Reads the Cca length */
    177             pxCsmaInit->xCcaLength = (CsmaLength)(tempRegValue[3]&0xF0);
   \   00000054   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   00000058   0xF010 0x00F0      ANDS     R0,R0,#0xF0
   \   0000005C   0x70A0             STRB     R0,[R4, #+2]
    178          
    179             /* Reads the max number of back off */
    180             pxCsmaInit->cMaxNb = tempRegValue[3] & 0x07;
   \   0000005E   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   00000062   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000066   0x70E0             STRB     R0,[R4, #+3]
    181          
    182             /* Reads the persistent mode enable bit */
    183             pxCsmaInit->xCsmaPersistentMode = (SpiritFunctionalState)((tempRegValue[4]>>1) & 0x01);
   \   00000068   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000006C   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   00000070   0x7020             STRB     R0,[R4, #+0]
    184          
    185          }
   \   00000072   0xBD1F             POP      {R0-R4,PC}       ;; return
    186          
    187          
    188          /**
    189           * @brief  Enables or Disables the CSMA.
    190           * @param  xNewState the state of the CSMA mode.
    191           *         This parameter can be: S_ENABLE or S_DISABLE.
    192           * @retval None.
    193           */

   \                                 In section .text, align 2, keep-with-next
    194          void SpiritCsma(SpiritFunctionalState xNewState)
    195          {
   \                     SpiritCsma: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    196            uint8_t tempRegValue;
    197          
    198            /* Check the parameters */
    199            s_assert_param(IS_SPIRIT_FUNCTIONAL_STATE(xNewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??SpiritCsma_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD004             BEQ.N    ??SpiritCsma_0
   \   00000010   0x21C7             MOVS     R1,#+199
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000016   0x.... 0x....      BL       s_assert_failed
    200          
    201            /* Reads the PROTOCOL1 register value */
    202            g_xStatus = SpiritSpiReadRegisters(PROTOCOL1_BASE, 1, &tempRegValue);
   \                     ??SpiritCsma_0: (+1)
   \   0000001A   0xAA00             ADD      R2,SP,#+0
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x2051             MOVS     R0,#+81
   \   00000020   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   00000024   0x9001             STR      R0,[SP, #+4]
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   0000002A   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   0000002E   0x8001             STRH     R1,[R0, #+0]
    203          
    204            /* Sets or resets the CSMA enable bit */
    205            if(xNewState==S_ENABLE)
   \   00000030   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000032   0x2C01             CMP      R4,#+1
   \   00000034   0xD106             BNE.N    ??SpiritCsma_1
    206            {
    207              tempRegValue |= PROTOCOL1_CSMA_ON_MASK;
   \   00000036   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000003A   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000003E   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000042   0xE005             B.N      ??SpiritCsma_2
    208            }
    209            else
    210            {
    211              tempRegValue &= ~PROTOCOL1_CSMA_ON_MASK;
   \                     ??SpiritCsma_1: (+1)
   \   00000044   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000048   0xF010 0x00FB      ANDS     R0,R0,#0xFB
   \   0000004C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    212            }
    213          
    214            /* Writes the new value on the PROTOCOL1 register */
    215            g_xStatus = SpiritSpiWriteRegisters(PROTOCOL1_BASE, 1, &tempRegValue);
   \                     ??SpiritCsma_2: (+1)
   \   00000050   0xAA00             ADD      R2,SP,#+0
   \   00000052   0x2101             MOVS     R1,#+1
   \   00000054   0x2051             MOVS     R0,#+81
   \   00000056   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   0000005A   0x9001             STR      R0,[SP, #+4]
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000060   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000064   0x8001             STRH     R1,[R0, #+0]
    216          
    217          }
   \   00000066   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    218          
    219          /**
    220           * @brief  Gets the CSMA mode. Says if it is enabled or disabled.
    221           * @param  None.
    222           * @retval SpiritFunctionalState: CSMA mode.
    223           */

   \                                 In section .text, align 2, keep-with-next
    224          SpiritFunctionalState SpiritCsmaGetCsma(void)
    225          {
   \                     SpiritCsmaGetCsma: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    226            uint8_t tempRegValue;
    227          
    228            /* Reads the PROTOCOL1 register value */
    229            g_xStatus = SpiritSpiReadRegisters(PROTOCOL1_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2051             MOVS     R0,#+81
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000014   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000018   0x8001             STRH     R1,[R0, #+0]
    230          
    231            /* Return if set or reset */
    232            if(tempRegValue & PROTOCOL1_CSMA_ON_MASK)
   \   0000001A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001E   0x0740             LSLS     R0,R0,#+29
   \   00000020   0xD501             BPL.N    ??SpiritCsmaGetCsma_0
    233            {
    234              return S_ENABLE;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xE000             B.N      ??SpiritCsmaGetCsma_1
    235            }
    236            else
    237            {
    238              return S_DISABLE;
   \                     ??SpiritCsmaGetCsma_0: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \                     ??SpiritCsmaGetCsma_1: (+1)
   \   00000028   0xBD0E             POP      {R1-R3,PC}       ;; return
    239            }
    240          
    241          }
    242          
    243          /**
    244           * @brief  Enables or Disables the persistent CSMA mode.
    245           * @param  xNewState the state of the persistent CSMA mode.
    246           *         This parameter can be: S_ENABLE or S_DISABLE.
    247           * @retval None.
    248           */

   \                                 In section .text, align 2, keep-with-next
    249          void SpiritCsmaPersistentMode(SpiritFunctionalState xNewState)
    250          {
   \                     SpiritCsmaPersistentMode: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    251            uint8_t tempRegValue;
    252          
    253            /* Check the parameters */
    254            s_assert_param(IS_SPIRIT_FUNCTIONAL_STATE(xNewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??SpiritCsmaPersistentMode_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD004             BEQ.N    ??SpiritCsmaPersistentMode_0
   \   00000010   0x21FE             MOVS     R1,#+254
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000016   0x.... 0x....      BL       s_assert_failed
    255          
    256            /* Reads the PROTOCOL1 register value */
    257            g_xStatus = SpiritSpiReadRegisters(PROTOCOL1_BASE, 1, &tempRegValue);
   \                     ??SpiritCsmaPersistentMode_0: (+1)
   \   0000001A   0xAA00             ADD      R2,SP,#+0
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x2051             MOVS     R0,#+81
   \   00000020   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   00000024   0x9001             STR      R0,[SP, #+4]
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   0000002A   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   0000002E   0x8001             STRH     R1,[R0, #+0]
    258          
    259            /* Enables/disables the CSMA persistent mode */
    260            if(xNewState==S_ENABLE)
   \   00000030   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000032   0x2C01             CMP      R4,#+1
   \   00000034   0xD106             BNE.N    ??SpiritCsmaPersistentMode_1
    261            {
    262              tempRegValue |= PROTOCOL1_CSMA_PERS_ON_MASK;
   \   00000036   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000003A   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000003E   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000042   0xE005             B.N      ??SpiritCsmaPersistentMode_2
    263            }
    264            else
    265            {
    266              tempRegValue &= ~PROTOCOL1_CSMA_PERS_ON_MASK;
   \                     ??SpiritCsmaPersistentMode_1: (+1)
   \   00000044   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000048   0xF010 0x00FD      ANDS     R0,R0,#0xFD
   \   0000004C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    267            }
    268          
    269            /* Writes the new vaue on the PROTOCOL1 register */
    270            g_xStatus = SpiritSpiWriteRegisters(PROTOCOL1_BASE, 1, &tempRegValue);
   \                     ??SpiritCsmaPersistentMode_2: (+1)
   \   00000050   0xAA00             ADD      R2,SP,#+0
   \   00000052   0x2101             MOVS     R1,#+1
   \   00000054   0x2051             MOVS     R0,#+81
   \   00000056   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   0000005A   0x9001             STR      R0,[SP, #+4]
   \   0000005C   0x....             LDR.N    R0,??DataTable17_1
   \   0000005E   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000062   0x8001             STRH     R1,[R0, #+0]
    271          
    272          }
   \   00000064   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    273          
    274          
    275          /**
    276           * @brief  Gets the persistent CSMA mode.
    277           * @param  None.
    278           * @retval SpiritFunctionalState: CSMA persistent mode.
    279           */

   \                                 In section .text, align 2, keep-with-next
    280          SpiritFunctionalState SpiritCsmaGetPersistentMode(void)
    281          {
   \                     SpiritCsmaGetPersistentMode: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    282            uint8_t tempRegValue;
    283          
    284            /* Reads the PROTOCOL1 register value */
    285            g_xStatus = SpiritSpiReadRegisters(PROTOCOL1_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2051             MOVS     R0,#+81
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x....             LDR.N    R0,??DataTable17_1
   \   00000012   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000016   0x8001             STRH     R1,[R0, #+0]
    286          
    287            /* Return if set or reset */
    288            if(tempRegValue & PROTOCOL1_CSMA_PERS_ON_MASK)
   \   00000018   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001C   0x0780             LSLS     R0,R0,#+30
   \   0000001E   0xD501             BPL.N    ??SpiritCsmaGetPersistentMode_0
    289            {
    290              return S_ENABLE;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xE000             B.N      ??SpiritCsmaGetPersistentMode_1
    291            }
    292            else
    293            {
    294              return S_DISABLE;
   \                     ??SpiritCsmaGetPersistentMode_0: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \                     ??SpiritCsmaGetPersistentMode_1: (+1)
   \   00000026   0xBD0E             POP      {R1-R3,PC}       ;; return
    295            }
    296          
    297          }
    298          
    299          
    300          /**
    301           * @brief  Enables or Disables the seed reload mode (if enabled it reloads the back-off generator seed using the value written in the BU_COUNTER_SEED register).
    302           * @param  xNewState the state of the seed reload mode.
    303           *	   This parameter can be: S_ENABLE or S_DISABLE.
    304           * @retval None.
    305           */

   \                                 In section .text, align 2, keep-with-next
    306          void SpiritCsmaSeedReloadMode(SpiritFunctionalState xNewState)
    307          {
   \                     SpiritCsmaSeedReloadMode: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    308            uint8_t tempRegValue;
    309          
    310            /* Check the parameters */
    311            s_assert_param(IS_SPIRIT_FUNCTIONAL_STATE(xNewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??SpiritCsmaSeedReloadMode_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD004             BEQ.N    ??SpiritCsmaSeedReloadMode_0
   \   00000010   0xF240 0x1137      MOVW     R1,#+311
   \   00000014   0x....             LDR.N    R0,??DataTable17
   \   00000016   0x.... 0x....      BL       s_assert_failed
    312          
    313            /* Reads the PROTOCOL1 register value */
    314            g_xStatus = SpiritSpiReadRegisters(PROTOCOL1_BASE, 1, &tempRegValue);
   \                     ??SpiritCsmaSeedReloadMode_0: (+1)
   \   0000001A   0xAA00             ADD      R2,SP,#+0
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x2051             MOVS     R0,#+81
   \   00000020   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   00000024   0x9001             STR      R0,[SP, #+4]
   \   00000026   0x....             LDR.N    R0,??DataTable17_1
   \   00000028   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   0000002C   0x8001             STRH     R1,[R0, #+0]
    315          
    316            /* Enables/disables the seed reload mode */
    317            if(xNewState==S_ENABLE)
   \   0000002E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000030   0x2C01             CMP      R4,#+1
   \   00000032   0xD106             BNE.N    ??SpiritCsmaSeedReloadMode_1
    318            {
    319              tempRegValue |= PROTOCOL1_SEED_RELOAD_MASK;
   \   00000034   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000038   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000003C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000040   0xE005             B.N      ??SpiritCsmaSeedReloadMode_2
    320            }
    321            else
    322            {
    323              tempRegValue &= ~PROTOCOL1_SEED_RELOAD_MASK;
   \                     ??SpiritCsmaSeedReloadMode_1: (+1)
   \   00000042   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000046   0xF010 0x00F7      ANDS     R0,R0,#0xF7
   \   0000004A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    324            }
    325          
    326            /* Writes the new value on the PROTOCOL1 register */
    327            g_xStatus = SpiritSpiWriteRegisters(PROTOCOL1_BASE, 1, &tempRegValue);
   \                     ??SpiritCsmaSeedReloadMode_2: (+1)
   \   0000004E   0xAA00             ADD      R2,SP,#+0
   \   00000050   0x2101             MOVS     R1,#+1
   \   00000052   0x2051             MOVS     R0,#+81
   \   00000054   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000058   0x9001             STR      R0,[SP, #+4]
   \   0000005A   0x....             LDR.N    R0,??DataTable17_1
   \   0000005C   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000060   0x8001             STRH     R1,[R0, #+0]
    328          
    329          }
   \   00000062   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    330          
    331          
    332          /**
    333           * @brief  Gets the seed reload mode.
    334           * @param  None.
    335           * @retval SpiritFunctionalState: CSMA seed reload mode.
    336           */

   \                                 In section .text, align 2, keep-with-next
    337          SpiritFunctionalState SpiritCsmaGetSeedReloadMode(void)
    338          {
   \                     SpiritCsmaGetSeedReloadMode: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    339            uint8_t tempRegValue;
    340          
    341            /* Reads the PROTOCOL1 register value */
    342            g_xStatus = SpiritSpiReadRegisters(PROTOCOL1_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2051             MOVS     R0,#+81
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x....             LDR.N    R0,??DataTable17_1
   \   00000012   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000016   0x8001             STRH     R1,[R0, #+0]
    343          
    344            /* Return if set or reset */
    345            if(tempRegValue & PROTOCOL1_SEED_RELOAD_MASK)
   \   00000018   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001C   0x0700             LSLS     R0,R0,#+28
   \   0000001E   0xD501             BPL.N    ??SpiritCsmaGetSeedReloadMode_0
    346            {
    347              return S_ENABLE;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xE000             B.N      ??SpiritCsmaGetSeedReloadMode_1
    348            }
    349            else
    350            {
    351              return S_DISABLE;
   \                     ??SpiritCsmaGetSeedReloadMode_0: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \                     ??SpiritCsmaGetSeedReloadMode_1: (+1)
   \   00000026   0xBD0E             POP      {R1-R3,PC}       ;; return
    352            }
    353          }
    354          
    355          
    356          /**
    357           * @brief  Sets the BU counter seed (BU_COUNTER_SEED register). The CSMA back off time is given by the formula: BO = rand(2^NB)*BU.
    358           * @param  nBuCounterSeed seed of the random number generator used to apply the BBE algorithm.
    359           *	   This parameter is an uint16_t.
    360           * @retval None.
    361           */

   \                                 In section .text, align 2, keep-with-next
    362          void SpiritCsmaSetBuCounterSeed(uint16_t nBuCounterSeed)
    363          {
   \                     SpiritCsmaSetBuCounterSeed: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    364            uint8_t tempRegValue[2];
    365          
    366            /* Check parameters */
    367            s_assert_param(IS_BU_COUNTER_SEED(nBuCounterSeed));
   \   00000004   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD104             BNE.N    ??SpiritCsmaSetBuCounterSeed_0
   \   0000000A   0xF240 0x116F      MOVW     R1,#+367
   \   0000000E   0x....             LDR.N    R0,??DataTable17
   \   00000010   0x.... 0x....      BL       s_assert_failed
    368          
    369            /* Build value (MSB)*/
    370            tempRegValue[0]=(uint8_t)(nBuCounterSeed>>8);
   \                     ??SpiritCsmaSetBuCounterSeed_0: (+1)
   \   00000014   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000016   0x0A20             LSRS     R0,R4,#+8
   \   00000018   0xF88D 0x0000      STRB     R0,[SP, #+0]
    371            /* Build value (LSB) */
    372            tempRegValue[1]=(uint8_t)nBuCounterSeed;
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0xF88D 0x0001      STRB     R0,[SP, #+1]
    373          
    374            /* Writes the CSMA_CONFIG3 registers */
    375            g_xStatus = SpiritSpiWriteRegisters(CSMA_CONFIG3_BASE, 2, tempRegValue);
   \   00000022   0xAA00             ADD      R2,SP,#+0
   \   00000024   0x2102             MOVS     R1,#+2
   \   00000026   0x2064             MOVS     R0,#+100
   \   00000028   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   0000002C   0x9001             STR      R0,[SP, #+4]
   \   0000002E   0x....             LDR.N    R0,??DataTable17_1
   \   00000030   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000034   0x8001             STRH     R1,[R0, #+0]
    376          
    377          }
   \   00000036   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    378          
    379          /**
    380           * @brief  Returns the BU counter seed (BU_COUNTER_SEED register).
    381           * @param  None.
    382           * @retval uint16_t Seed of the random number generator used to apply the BBE algorithm.
    383           */

   \                                 In section .text, align 2, keep-with-next
    384          uint16_t SpiritCsmaGetBuCounterSeed(void)
    385          {
   \                     SpiritCsmaGetBuCounterSeed: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    386            uint8_t tempRegValue[2];
    387          
    388            /* Reads the CSMA_CONFIGx registers value */
    389            g_xStatus = SpiritSpiReadRegisters(CSMA_CONFIG3_BASE, 2, tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2102             MOVS     R1,#+2
   \   00000008   0x2064             MOVS     R0,#+100
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x....             LDR.N    R0,??DataTable17_1
   \   00000012   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000016   0x8001             STRH     R1,[R0, #+0]
    390          
    391            /* Build the counter seed and return it */
    392            return ((uint16_t)tempRegValue[1] + (((uint16_t)tempRegValue[0])<<8));
   \   00000018   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000001C   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000020   0xEB10 0x2001      ADDS     R0,R0,R1, LSL #+8
   \   00000024   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000026   0xBD0E             POP      {R1-R3,PC}       ;; return
    393          
    394          }
    395          
    396          
    397          /**
    398           * @brief  Sets the BU prescaler. The CSMA back off time is given by the formula: BO = rand(2^NB)*BU.
    399           * @param  cBuPrescaler used to program the back-off unit BU.
    400           * 	   This parameter is an uint8_t.
    401           * @retval None.
    402           */

   \                                 In section .text, align 2, keep-with-next
    403          void SpiritCsmaSetBuPrescaler(uint8_t cBuPrescaler)
    404          {
   \                     SpiritCsmaSetBuPrescaler: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    405            uint8_t tempRegValue;
    406          
    407            /* Check parameters */
    408            s_assert_param(IS_BU_PRESCALER(cBuPrescaler));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C40             CMP      R4,#+64
   \   00000008   0xDB04             BLT.N    ??SpiritCsmaSetBuPrescaler_0
   \   0000000A   0xF44F 0x71CC      MOV      R1,#+408
   \   0000000E   0x....             LDR.N    R0,??DataTable17
   \   00000010   0x.... 0x....      BL       s_assert_failed
    409          
    410            /* Reads the CSMA_CONFIG1 register value */
    411            g_xStatus = SpiritSpiReadRegisters(CSMA_CONFIG1_BASE, 1, &tempRegValue);
   \                     ??SpiritCsmaSetBuPrescaler_0: (+1)
   \   00000014   0xAA00             ADD      R2,SP,#+0
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0x2066             MOVS     R0,#+102
   \   0000001A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000001E   0x9001             STR      R0,[SP, #+4]
   \   00000020   0x....             LDR.N    R0,??DataTable17_1
   \   00000022   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000026   0x8001             STRH     R1,[R0, #+0]
    412          
    413            /* Build the new value for the BU prescaler */
    414            tempRegValue &= 0x03;
   \   00000028   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000002C   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   00000030   0xF88D 0x0000      STRB     R0,[SP, #+0]
    415            tempRegValue |= (cBuPrescaler<<2);
   \   00000034   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000038   0xEA50 0x0084      ORRS     R0,R0,R4, LSL #+2
   \   0000003C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    416          
    417            /* Writes the new value on the CSMA_CONFIG1_BASE register */
    418            g_xStatus = SpiritSpiWriteRegisters(CSMA_CONFIG1_BASE, 1, &tempRegValue);
   \   00000040   0xAA00             ADD      R2,SP,#+0
   \   00000042   0x2101             MOVS     R1,#+1
   \   00000044   0x2066             MOVS     R0,#+102
   \   00000046   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   0000004A   0x9001             STR      R0,[SP, #+4]
   \   0000004C   0x....             LDR.N    R0,??DataTable17_1
   \   0000004E   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000052   0x8001             STRH     R1,[R0, #+0]
    419          
    420          }
   \   00000054   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    421          
    422          
    423          /**
    424           * @brief  Returns the BU prescaler.
    425           * @param  None.
    426           * @retval uint8_t Value back-off unit (BU).
    427           */

   \                                 In section .text, align 2, keep-with-next
    428          uint8_t SpiritCsmaGetBuPrescaler(void)
    429          {
   \                     SpiritCsmaGetBuPrescaler: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    430            uint8_t tempRegValue;
    431          
    432            /* Reads the CSMA_CONFIG1 register value */
    433            g_xStatus = SpiritSpiReadRegisters(CSMA_CONFIG1_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2066             MOVS     R0,#+102
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x....             LDR.N    R0,??DataTable17_1
   \   00000012   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000016   0x8001             STRH     R1,[R0, #+0]
    434          
    435            /* Build and return the BU prescaler value */
    436            return (tempRegValue >> 2);
   \   00000018   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0x0880             LSRS     R0,R0,#+2
   \   00000020   0xBD0E             POP      {R1-R3,PC}       ;; return
    437          
    438          }
    439          
    440          
    441          /**
    442           * @brief  Sets the CCA period.
    443           * @param  xMultiplierTbit value of CCA period to store.
    444           * 	   This parameter can be a value of @ref CcaPeriod.
    445           * @retval None.
    446           */

   \                                 In section .text, align 2, keep-with-next
    447          void SpiritCsmaSetCcaPeriod(CcaPeriod xMultiplierTbit)
    448          {
   \                     SpiritCsmaSetCcaPeriod: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    449            uint8_t tempRegValue;
    450          
    451            /* Check the parameters */
    452            s_assert_param(IS_CCA_PERIOD(xMultiplierTbit));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD00D             BEQ.N    ??SpiritCsmaSetCcaPeriod_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD00A             BEQ.N    ??SpiritCsmaSetCcaPeriod_0
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C02             CMP      R4,#+2
   \   00000014   0xD007             BEQ.N    ??SpiritCsmaSetCcaPeriod_0
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0x2C03             CMP      R4,#+3
   \   0000001A   0xD004             BEQ.N    ??SpiritCsmaSetCcaPeriod_0
   \   0000001C   0xF44F 0x71E2      MOV      R1,#+452
   \   00000020   0x....             LDR.N    R0,??DataTable17
   \   00000022   0x.... 0x....      BL       s_assert_failed
    453          
    454            /* Reads the CSMA_CONFIG1 register value */
    455            g_xStatus = SpiritSpiReadRegisters(CSMA_CONFIG1_BASE, 1, &tempRegValue);
   \                     ??SpiritCsmaSetCcaPeriod_0: (+1)
   \   00000026   0xAA00             ADD      R2,SP,#+0
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0x2066             MOVS     R0,#+102
   \   0000002C   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   00000030   0x9001             STR      R0,[SP, #+4]
   \   00000032   0x....             LDR.N    R0,??DataTable17_1
   \   00000034   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000038   0x8001             STRH     R1,[R0, #+0]
    456          
    457            /* Build the new value setting the the CCA period */
    458            tempRegValue &= 0xFC;
   \   0000003A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000003E   0xF010 0x00FC      ANDS     R0,R0,#0xFC
   \   00000042   0xF88D 0x0000      STRB     R0,[SP, #+0]
    459            tempRegValue |= xMultiplierTbit;
   \   00000046   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000004A   0x4320             ORRS     R0,R4,R0
   \   0000004C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    460          
    461            /* Writes the new value on the CSMA_CONFIG1 register */
    462            g_xStatus = SpiritSpiWriteRegisters(CSMA_CONFIG1_BASE, 1, &tempRegValue);
   \   00000050   0xAA00             ADD      R2,SP,#+0
   \   00000052   0x2101             MOVS     R1,#+1
   \   00000054   0x2066             MOVS     R0,#+102
   \   00000056   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   0000005A   0x9001             STR      R0,[SP, #+4]
   \   0000005C   0x....             LDR.N    R0,??DataTable17_1
   \   0000005E   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000062   0x8001             STRH     R1,[R0, #+0]
    463          
    464          }
   \   00000064   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    465          
    466          
    467          /**
    468           * @brief  Returns the CCA period.
    469           * @param  None.
    470           * @retval CcaPeriod CCA period.
    471           */

   \                                 In section .text, align 2, keep-with-next
    472          CcaPeriod SpiritCsmaGetCcaPeriod(void)
    473          {
   \                     SpiritCsmaGetCcaPeriod: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    474            uint8_t tempRegValue;
    475          
    476            /* Reads the CSMA_CONFIG1 register value */
    477            g_xStatus = SpiritSpiReadRegisters(CSMA_CONFIG1_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2066             MOVS     R0,#+102
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x....             LDR.N    R0,??DataTable17_1
   \   00000012   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000016   0x8001             STRH     R1,[R0, #+0]
    478          
    479            /* Build and return the CCA period value */
    480            return (CcaPeriod)(tempRegValue & 0x03);
   \   00000018   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001C   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   00000020   0xBD0E             POP      {R1-R3,PC}       ;; return
    481          
    482          }
    483          
    484          
    485          /**
    486           * @brief  Sets the CCA length.
    487           * @param  xCcaLength the CCA length (a value between 1 and 15 that multiplies the CCA period).
    488           *	   This parameter can be any value of @ref CsmaLength.
    489           * @retval None.
    490           */

   \                                 In section .text, align 2, keep-with-next
    491          void SpiritCsmaSetCcaLength(CsmaLength xCcaLength)
    492          {
   \                     SpiritCsmaSetCcaLength: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    493            uint8_t tempRegValue;
    494          
    495            /* Check the parameters */
    496            s_assert_param(IS_CSMA_LENGTH(xCcaLength));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD031             BEQ.N    ??SpiritCsmaSetCcaLength_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C10             CMP      R4,#+16
   \   0000000E   0xD02E             BEQ.N    ??SpiritCsmaSetCcaLength_0
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C20             CMP      R4,#+32
   \   00000014   0xD02B             BEQ.N    ??SpiritCsmaSetCcaLength_0
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0x2C30             CMP      R4,#+48
   \   0000001A   0xD028             BEQ.N    ??SpiritCsmaSetCcaLength_0
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x2C40             CMP      R4,#+64
   \   00000020   0xD025             BEQ.N    ??SpiritCsmaSetCcaLength_0
   \   00000022   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000024   0x2C50             CMP      R4,#+80
   \   00000026   0xD022             BEQ.N    ??SpiritCsmaSetCcaLength_0
   \   00000028   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002A   0x2C60             CMP      R4,#+96
   \   0000002C   0xD01F             BEQ.N    ??SpiritCsmaSetCcaLength_0
   \   0000002E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000030   0x2C70             CMP      R4,#+112
   \   00000032   0xD01C             BEQ.N    ??SpiritCsmaSetCcaLength_0
   \   00000034   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000036   0x2C80             CMP      R4,#+128
   \   00000038   0xD019             BEQ.N    ??SpiritCsmaSetCcaLength_0
   \   0000003A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003C   0x2C90             CMP      R4,#+144
   \   0000003E   0xD016             BEQ.N    ??SpiritCsmaSetCcaLength_0
   \   00000040   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000042   0x2CA0             CMP      R4,#+160
   \   00000044   0xD013             BEQ.N    ??SpiritCsmaSetCcaLength_0
   \   00000046   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000048   0x2CB0             CMP      R4,#+176
   \   0000004A   0xD010             BEQ.N    ??SpiritCsmaSetCcaLength_0
   \   0000004C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004E   0x2CC0             CMP      R4,#+192
   \   00000050   0xD00D             BEQ.N    ??SpiritCsmaSetCcaLength_0
   \   00000052   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000054   0x2CD0             CMP      R4,#+208
   \   00000056   0xD00A             BEQ.N    ??SpiritCsmaSetCcaLength_0
   \   00000058   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000005A   0x2CE0             CMP      R4,#+224
   \   0000005C   0xD007             BEQ.N    ??SpiritCsmaSetCcaLength_0
   \   0000005E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000060   0x2CF0             CMP      R4,#+240
   \   00000062   0xD004             BEQ.N    ??SpiritCsmaSetCcaLength_0
   \   00000064   0xF44F 0x71F8      MOV      R1,#+496
   \   00000068   0x....             LDR.N    R0,??DataTable17
   \   0000006A   0x.... 0x....      BL       s_assert_failed
    497          
    498            /* Reads the CSMA_CONFIG0 register value */
    499            g_xStatus = SpiritSpiReadRegisters(CSMA_CONFIG0_BASE, 1, &tempRegValue);
   \                     ??SpiritCsmaSetCcaLength_0: (+1)
   \   0000006E   0xAA00             ADD      R2,SP,#+0
   \   00000070   0x2101             MOVS     R1,#+1
   \   00000072   0x2067             MOVS     R0,#+103
   \   00000074   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   00000078   0x9001             STR      R0,[SP, #+4]
   \   0000007A   0x....             LDR.N    R0,??DataTable17_1
   \   0000007C   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000080   0x8001             STRH     R1,[R0, #+0]
    500          
    501            /* Build the value of CCA length to be set */
    502            tempRegValue &= 0x0F;
   \   00000082   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000086   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   0000008A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    503            tempRegValue |= xCcaLength;
   \   0000008E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000092   0x4320             ORRS     R0,R4,R0
   \   00000094   0xF88D 0x0000      STRB     R0,[SP, #+0]
    504          
    505            /* Writes the new value on the CSMA_CONFIG0 register */
    506            g_xStatus = SpiritSpiWriteRegisters(CSMA_CONFIG0_BASE, 1, &tempRegValue);
   \   00000098   0xAA00             ADD      R2,SP,#+0
   \   0000009A   0x2101             MOVS     R1,#+1
   \   0000009C   0x2067             MOVS     R0,#+103
   \   0000009E   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   000000A2   0x9001             STR      R0,[SP, #+4]
   \   000000A4   0x....             LDR.N    R0,??DataTable17_1
   \   000000A6   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   000000AA   0x8001             STRH     R1,[R0, #+0]
    507          
    508          }
   \   000000AC   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    509          
    510          
    511          /**
    512           * @brief  Returns the CCA length.
    513           * @param  None.
    514           * @retval uint8_t CCA length.
    515           */

   \                                 In section .text, align 2, keep-with-next
    516          uint8_t SpiritCsmaGetCcaLength(void)
    517          {
   \                     SpiritCsmaGetCcaLength: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    518            uint8_t tempRegValue;
    519          
    520            /* Reads the CSMA_CONFIG0 register value */
    521            g_xStatus = SpiritSpiReadRegisters(CSMA_CONFIG0_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2067             MOVS     R0,#+103
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x....             LDR.N    R0,??DataTable17_1
   \   00000012   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000016   0x8001             STRH     R1,[R0, #+0]
    522          
    523            /* Build and return the CCA length */
    524            return tempRegValue >> 4;
   \   00000018   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0x0900             LSRS     R0,R0,#+4
   \   00000020   0xBD0E             POP      {R1-R3,PC}       ;; return
    525          
    526          }
    527          
    528          
    529          /**
    530           * @brief  Sets the max number of back-off. If reached Spirit stops the transmission.
    531           * @param  cMaxNb the max number of back-off.
    532           *         This parameter is an uint8_t.
    533           * @retval None.
    534           */

   \                                 In section .text, align 2, keep-with-next
    535          void SpiritCsmaSetMaxNumberBackoff(uint8_t cMaxNb)
    536          {
   \                     SpiritCsmaSetMaxNumberBackoff: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    537            uint8_t tempRegValue;
    538          
    539            /* Check the parameters */
    540            s_assert_param(IS_CMAX_NB(cMaxNb));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C08             CMP      R4,#+8
   \   00000008   0xDB04             BLT.N    ??SpiritCsmaSetMaxNumberBackoff_0
   \   0000000A   0xF44F 0x7107      MOV      R1,#+540
   \   0000000E   0x....             LDR.N    R0,??DataTable17
   \   00000010   0x.... 0x....      BL       s_assert_failed
    541          
    542            /* Reads the CSMA_CONFIG0 register value */
    543            g_xStatus = SpiritSpiReadRegisters(CSMA_CONFIG0_BASE, 1, &tempRegValue);
   \                     ??SpiritCsmaSetMaxNumberBackoff_0: (+1)
   \   00000014   0xAA00             ADD      R2,SP,#+0
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0x2067             MOVS     R0,#+103
   \   0000001A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000001E   0x9001             STR      R0,[SP, #+4]
   \   00000020   0x....             LDR.N    R0,??DataTable17_1
   \   00000022   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000026   0x8001             STRH     R1,[R0, #+0]
    544          
    545            /* Build the value of max back off to be set */
    546            tempRegValue &= 0xF8;
   \   00000028   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000002C   0xF010 0x00F8      ANDS     R0,R0,#0xF8
   \   00000030   0xF88D 0x0000      STRB     R0,[SP, #+0]
    547            tempRegValue |= cMaxNb;
   \   00000034   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000038   0x4320             ORRS     R0,R4,R0
   \   0000003A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    548          
    549            /* Writes the new value on the CSMA_CONFIG0 register */
    550            g_xStatus = SpiritSpiWriteRegisters(CSMA_CONFIG0_BASE, 1, &tempRegValue);
   \   0000003E   0xAA00             ADD      R2,SP,#+0
   \   00000040   0x2101             MOVS     R1,#+1
   \   00000042   0x2067             MOVS     R0,#+103
   \   00000044   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000048   0x9001             STR      R0,[SP, #+4]
   \   0000004A   0x....             LDR.N    R0,??DataTable17_1
   \   0000004C   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000050   0x8001             STRH     R1,[R0, #+0]
    551          }
   \   00000052   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    552          
    553          /**
    554           * @brief  Returns the max number of back-off.
    555           * @param  None.
    556           * @retval uint8_t Max number of back-off.
    557           */

   \                                 In section .text, align 2, keep-with-next
    558          uint8_t SpiritCsmaGetMaxNumberBackoff(void)
    559          {
   \                     SpiritCsmaGetMaxNumberBackoff: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    560            uint8_t tempRegValue;
    561          
    562            /* Reads the CSMA_CONFIG0 register value */
    563            g_xStatus = SpiritSpiReadRegisters(CSMA_CONFIG0_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2067             MOVS     R0,#+103
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x....             LDR.N    R0,??DataTable17_1
   \   00000012   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000016   0x8001             STRH     R1,[R0, #+0]
    564          
    565            /* Build and return the max number of back-off */
    566            return (tempRegValue & 0x07);
   \   00000018   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001C   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000020   0xBD0E             POP      {R1-R3,PC}       ;; return
    567          
    568          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x........         DC32     g_xStatus

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x45 0x3A          DC8 45H, 3AH, 5CH, 41H, 43H, 51H, 5CH, 50H
   \              0x5C 0x41    
   \              0x43 0x51    
   \              0x5C 0x50    
   \   00000008   0x72 0x6F          DC8 72H, 6FH, 6AH, 5FH, 76H, 65H, 72H, 30H
   \              0x6A 0x5F    
   \              0x76 0x65    
   \              0x72 0x30    
   \   00000010   0x39 0x61          DC8 39H, 61H, 5FH, 31H, 35H, 31H, 30H, 32H
   \              0x5F 0x31    
   \              0x35 0x31    
   \              0x30 0x32    
   \   00000018   0x30 0x31          DC8 30H, 31H, 35H, 5CH, 45H, 6EH, 64H, 5FH
   \              0x35 0x5C    
   \              0x45 0x6E    
   \              0x64 0x5F    
   \   00000020   0x30 0x32          DC8 30H, 32H, 5CH, 32H, 30H, 31H, 33H, 5FH
   \              0x5C 0x32    
   \              0x30 0x31    
   \              0x33 0x5F    
   \   00000028   0x31 0x31          DC8 31H, 31H, 5FH, 32H, 35H, 5FH, 53H, 70H
   \              0x5F 0x32    
   \              0x35 0x5F    
   \              0x53 0x70    
   \   00000030   0x69 0x72          DC8 69H, 72H, 69H, 74H, 31H, 5FH, 45H, 6CH
   \              0x69 0x74    
   \              0x31 0x5F    
   \              0x45 0x6C    
   \   00000038   0x65 0x6B          DC8 65H, 6BH, 74H, 72H, 6FH, 6CH, 75H, 78H
   \              0x74 0x72    
   \              0x6F 0x6C    
   \              0x75 0x78    
   \   00000040   0x5C 0x53          DC8 5CH, 53H, 50H, 49H, 52H, 49H, 54H, 31H
   \              0x50 0x49    
   \              0x52 0x49    
   \              0x54 0x31    
   \   00000048   0x5F 0x4C          DC8 5FH, 4CH, 69H, 62H, 72H, 61H, 72H, 79H
   \              0x69 0x62    
   \              0x72 0x61    
   \              0x72 0x79    
   \   00000050   0x5F 0x50          DC8 5FH, 50H, 72H, 6FH, 6AH, 65H, 63H, 74H
   \              0x72 0x6F    
   \              0x6A 0x65    
   \              0x63 0x74    
   \   00000058   0x5C 0x53          DC8 5CH, 53H, 50H, 49H, 52H, 49H, 54H, 31H
   \              0x50 0x49    
   \              0x52 0x49    
   \              0x54 0x31    
   \   00000060   0x5F 0x4C          DC8 5FH, 4CH, 69H, 62H, 72H, 61H, 72H, 79H
   \              0x69 0x62    
   \              0x72 0x61    
   \              0x72 0x79    
   \   00000068   0x5C 0x53          DC8 5CH, 53H, 6FH, 75H, 72H, 63H, 65H, 5CH
   \              0x6F 0x75    
   \              0x72 0x63    
   \              0x65 0x5C    
   \   00000070   0x73 0x72          DC8 73H, 72H, 63H, 5CH, 53H, 50H, 49H, 52H
   \              0x63 0x5C    
   \              0x53 0x50    
   \              0x49 0x52    
   \   00000078   0x49 0x54          DC8 49H, 54H, 5FH, 43H, 73H, 6DH, 61H, 2EH
   \              0x5F 0x43    
   \              0x73 0x6D    
   \              0x61 0x2E    
   \   00000080   0x63 0x00          DC8 63H, 0
   \   00000082   0x00 0x00          DC8 0, 0
    569          
    570          
    571          /**
    572           *@}
    573           */
    574          
    575          /**
    576           *@}
    577           */
    578          
    579          
    580          /**
    581           *@}
    582           */
    583          
    584          
    585          
    586          /******************* (C) COPYRIGHT 2012 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   SpiritCsma
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      16   SpiritCsmaGetBuCounterSeed
        16   -> SdkEvalSpiReadRegisters
      16   SpiritCsmaGetBuPrescaler
        16   -> SdkEvalSpiReadRegisters
      16   SpiritCsmaGetCcaLength
        16   -> SdkEvalSpiReadRegisters
      16   SpiritCsmaGetCcaPeriod
        16   -> SdkEvalSpiReadRegisters
      16   SpiritCsmaGetCsma
        16   -> SdkEvalSpiReadRegisters
      24   SpiritCsmaGetInfo
        24   -> SdkEvalSpiReadRegisters
      16   SpiritCsmaGetMaxNumberBackoff
        16   -> SdkEvalSpiReadRegisters
      16   SpiritCsmaGetPersistentMode
        16   -> SdkEvalSpiReadRegisters
      16   SpiritCsmaGetSeedReloadMode
        16   -> SdkEvalSpiReadRegisters
      24   SpiritCsmaInit
        24   -> SdkEvalSpiReadRegisters
        24   -> SdkEvalSpiWriteRegisters
        24   -> s_assert_failed
      16   SpiritCsmaPersistentMode
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      16   SpiritCsmaSeedReloadMode
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      16   SpiritCsmaSetBuCounterSeed
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      16   SpiritCsmaSetBuPrescaler
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      16   SpiritCsmaSetCcaLength
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      16   SpiritCsmaSetCcaPeriod
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      16   SpiritCsmaSetMaxNumberBackoff
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable17
       4  ??DataTable17_1
     132  ?_0
     104  SpiritCsma
      40  SpiritCsmaGetBuCounterSeed
      34  SpiritCsmaGetBuPrescaler
      34  SpiritCsmaGetCcaLength
      34  SpiritCsmaGetCcaPeriod
      42  SpiritCsmaGetCsma
     116  SpiritCsmaGetInfo
      34  SpiritCsmaGetMaxNumberBackoff
      40  SpiritCsmaGetPersistentMode
      40  SpiritCsmaGetSeedReloadMode
     354  SpiritCsmaInit
     102  SpiritCsmaPersistentMode
     100  SpiritCsmaSeedReloadMode
      56  SpiritCsmaSetBuCounterSeed
      86  SpiritCsmaSetBuPrescaler
     174  SpiritCsmaSetCcaLength
     102  SpiritCsmaSetCcaPeriod
      84  SpiritCsmaSetMaxNumberBackoff

 
   132 bytes in section .rodata
 1 584 bytes in section .text
 
 1 584 bytes of CODE  memory
   132 bytes of CONST memory

Errors: none
Warnings: none
