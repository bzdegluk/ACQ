###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.70.1.5641/W32 for ARM      22/Feb/2014  21:59:39 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\bzdegluk.PLY\Desktop\ACQ_SYS\Projekt_po_poprawi #
#                    e\2013_11_25_Spirit1_Elektrolux\STM32L\SDK_Virtual_Com\S #
#                    ource\src\SDK_EVAL_VC_General.c                          #
#    Command line =  C:\Users\bzdegluk.PLY\Desktop\ACQ_SYS\Projekt_po_poprawi #
#                    e\2013_11_25_Spirit1_Elektrolux\STM32L\SDK_Virtual_Com\S #
#                    ource\src\SDK_EVAL_VC_General.c -D USE_STDPERIPH_DRIVER  #
#                    -D VECT_TAB_FLASH -D STM32L1XX_MD -D IAR_ARM_CM3 -D      #
#                    USE_FULL_ASSERT -D SPIRIT_USE_FULL_ASSERT -D             #
#                    USE_SYSTICK_DELAY -D SDK -lC                             #
#                    C:\Users\bzdegluk.PLY\Desktop\ACQ_SYS\Projekt_po_poprawi #
#                    e\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\ #
#                    EWARM\DZ-SB-DISC01\List\ -o                              #
#                    C:\Users\bzdegluk.PLY\Desktop\ACQ_SYS\Projekt_po_poprawi #
#                    e\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\ #
#                    EWARM\DZ-SB-DISC01\Obj\ --no_cse --no_unroll             #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I C:\Users\bzdegluk.PLY\Desktop\ACQ_SYS\Projekt_ #
#                    po_poprawie\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Librar #
#                    y_Project\EWARM\.\ -I C:\Users\bzdegluk.PLY\Desktop\ACQ_ #
#                    SYS\Projekt_po_poprawie\2013_11_25_Spirit1_Elektrolux\SP #
#                    IRIT1_Library_Project\EWARM\..\Application\ -I           #
#                    C:\Users\bzdegluk.PLY\Desktop\ACQ_SYS\Projekt_po_poprawi #
#                    e\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\ #
#                    EWARM\..\Application\examples\ -I                        #
#                    C:\Users\bzdegluk.PLY\Desktop\ACQ_SYS\Projekt_po_poprawi #
#                    e\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\ #
#                    EWARM\..\Application\runtime\ -I                         #
#                    C:\Users\bzdegluk.PLY\Desktop\ACQ_SYS\Projekt_po_poprawi #
#                    e\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\ #
#                    EWARM\..\..\STM32L\SDK_Eval_STM32L\Source\inc\ -I        #
#                    C:\Users\bzdegluk.PLY\Desktop\ACQ_SYS\Projekt_po_poprawi #
#                    e\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\ #
#                    EWARM\..\SPIRIT1_Library\Source\inc\ -I                  #
#                    C:\Users\bzdegluk.PLY\Desktop\ACQ_SYS\Projekt_po_poprawi #
#                    e\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\ #
#                    EWARM\..\SDK_Eval_Util\Source\inc\ -I                    #
#                    C:\Users\bzdegluk.PLY\Desktop\ACQ_SYS\Projekt_po_poprawi #
#                    e\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\ #
#                    EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\CMSIS\ #
#                    CM3\DeviceSupport\ST\STM32L1xx\ -I                       #
#                    C:\Users\bzdegluk.PLY\Desktop\ACQ_SYS\Projekt_po_poprawi #
#                    e\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\ #
#                    EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L #
#                    1xx_StdPeriph_Driver\inc\ -I                             #
#                    C:\Users\bzdegluk.PLY\Desktop\ACQ_SYS\Projekt_po_poprawi #
#                    e\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\ #
#                    EWARM\..\..\STM32L\SDK_Virtual_Com\Source\inc\ -I        #
#                    C:\Users\bzdegluk.PLY\Desktop\ACQ_SYS\Projekt_po_poprawi #
#                    e\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\ #
#                    EWARM\..\..\STM32L\STM32_USB-FS-Device_Lib\Source\inc\   #
#                    -On --use_c++_inline -I "C:\Program Files (x86)\IAR      #
#                    Systems\Embedded Workbench 6.5\arm\CMSIS\Include\"       #
#    List file    =  C:\Users\bzdegluk.PLY\Desktop\ACQ_SYS\Projekt_po_poprawi #
#                    e\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\ #
#                    EWARM\DZ-SB-DISC01\List\SDK_EVAL_VC_General.lst          #
#    Object file  =  C:\Users\bzdegluk.PLY\Desktop\ACQ_SYS\Projekt_po_poprawi #
#                    e\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\ #
#                    EWARM\DZ-SB-DISC01\Obj\SDK_EVAL_VC_General.o             #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\bzdegluk.PLY\Desktop\ACQ_SYS\Projekt_po_poprawie\2013_11_25_Spirit1_Elektrolux\STM32L\SDK_Virtual_Com\Source\src\SDK_EVAL_VC_General.c
      1          /**
      2          * @file     SDK_EVAL_VC_General.c
      3          * @author   MSH RF/ART Team IMS-Systems Lab
      4          * @version  V1.0.0
      5          * @date     August 4, 2011
      6          * @brief    SDK EVAL Virtual Com Setup & API.
      7          * @details
      8          *
      9          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     10          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     11          * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     12          * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     13          * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     14          * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     15          *
     16          * THIS SOURCE CODE IS PROTECTED BY A LICENSE.
     17          * FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED
     18          * IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
     19          *
     20          * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     21          *
     22          */
     23          
     24          /* Includes ------------------------------------------------------------------*/
     25          #include <yfuns.h>
     26          #include "SDK_EVAL_VC_General.h"
     27          
     28          
     29          /** @addtogroup SDK_EVAL_Virtual_Com
     30          * @{
     31          */
     32          
     33          
     34          /** @addtogroup SDK_EVAL_VC_General
     35          * @{
     36          */
     37          
     38          
     39          /** @defgroup SDK_EVAL_VC_General_Private_TypesDefinitions    SDK EVAL VC General Private TypesDefinitions
     40          * @{
     41          */
     42          
     43          
     44          /**
     45          * @}
     46          */
     47          
     48          
     49          /** @defgroup SDK_EVAL_VC_General_Private_Macros    SDK EVAL VC General Private Macros
     50          * @{
     51          */
     52          
     53          
     54          #define USB_ENTER_CRITICAL()              {NVIC_InitTypeDef NVIC_InitStructure = {USB_LP_IRQn, 1, 0,  DISABLE}; \
     55            NVIC_Init(&NVIC_InitStructure);} \
     56              
     57          #define USB_EXIT_CRITICAL()              {NVIC_InitTypeDef NVIC_InitStructure = {USB_LP_IRQn, 1, 0,  ENABLE}; \
     58            NVIC_Init(&NVIC_InitStructure);} \
     59              
     60          #define USB_OUT_BUFFER_IS_FULL() (s_lVCTxBufferInIndex == s_lVCTxBufferOutIndex - 1 || (s_lVCTxBufferInIndex == VC_TX_BUFFER_DATA_SIZE && s_lVCTxBufferOutIndex == 0))
     61          #define USB_OUT_BUFFER_IS_EMPTY() (s_lVCTxBufferInIndex == s_lVCTxBufferOutIndex)
     62          
     63          /**
     64          * @}
     65          */
     66          
     67          
     68          /** @defgroup SDK_EVAL_VC_General_Private_Variables     SDK EVAL VC General Private Variables
     69          * @{
     70          */
     71          

   \                                 In section .bss, align 4
     72          uint8_t  s_vectcVCTxBuffer [VC_TX_BUFFER_DATA_SIZE];
   \                     s_vectcVCTxBuffer:
   \   00000000                      DS8 1024

   \                                 In section .bss, align 4
     73          uint32_t s_lVCTxBufferInIndex = 0;
   \                     s_lVCTxBufferInIndex:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     74          uint32_t s_lVCTxBufferOutIndex = 0;
   \                     s_lVCTxBufferOutIndex:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     75          uint32_t s_lVCTxDataLength  = 0;
   \                     s_lVCTxDataLength:
   \   00000000                      DS8 4
     76          

   \                                 In section .bss, align 1
     77          uint8_t  USB_Tx_State = 0;
   \                     USB_Tx_State:
   \   00000000                      DS8 1
     78          
     79          
     80          #define RECEIVE_QUEUE_SIZE VC_TX_BUFFER_DATA_SIZE 
     81          

   \                                 In section .bss, align 4
     82          uint8_t rxQ[RECEIVE_QUEUE_SIZE];
   \                     rxQ:
   \   00000000                      DS8 1024

   \                                 In section .bss, align 2
     83          uint16_t rxHead = 0;
   \                     rxHead:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     84          uint16_t rxTail = 0;
   \                     rxTail:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     85          volatile uint16_t rxUsed = 0;
   \                     rxUsed:
   \   00000000                      DS8 2
     86          
     87          
     88          /**
     89          * @}
     90          */
     91          
     92          
     93          /** @defgroup SDK_EVAL_VC_General_Private_FunctionPrototypes      SDK EVAL VC General Private FunctionPrototypes
     94          * @{
     95          */
     96          static void IntToUnicode (uint32_t lValue , uint8_t* pcBuffer , uint8_t cLength);
     97          /**
     98          * @}
     99          */
    100          
    101          
    102          /** @defgroup SDK_EVAL_VC_General_Private_Functions     SDK EVAL VC General Private Functions
    103          * @{
    104          */
    105          
    106          
    107          /**
    108          * @brief  Configures main system clocks, USB clock, USB interrupt and GPIO pin for USB pull-up if defined.
    109          * @param  None.
    110          * @retval None.
    111          */

   \                                 In section .text, align 2, keep-with-next
    112          void SdkEvalVCInit(void)
    113          {
   \                     SdkEvalVCInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    114            NVIC_InitTypeDef NVIC_InitStructure;
    115          #if defined(USB_USE_EXTERNAL_PULLUP)
    116            GPIO_InitTypeDef  GPIO_InitStructure;
    117          #endif /* USB_USE_EXTERNAL_PULLUP */
    118            
    119            /* At this stage the microcontroller clock setting is already configured,
    120            this is done through SystemInit() function which is called from startup
    121            file (startup_stm32l1x_xx.s) before to branch to application main.
    122            To reconfigure the default setting of SystemInit() function, refer to
    123            system_stm32l1xx.c file */
    124            
    125            /* Enable the SYSCFG module clock */
    126            RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    127            
    128            
    129          #if defined(USB_USE_EXTERNAL_PULLUP)
    130            /* Enable the USB disconnect GPIO clock */
    131            RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIO_DISCONNECT, ENABLE);
    132            
    133            /* USB_DISCONNECT used as USB pull-up */
    134            GPIO_InitStructure.GPIO_Pin = USB_DISCONNECT_PIN;
    135            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    136            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
    137            GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    138            GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    139            GPIO_Init(USB_DISCONNECT, &GPIO_InitStructure);
    140          #endif /* USB_USE_EXTERNAL_PULLUP */
    141            
    142            /* Enables USB clock */
    143            RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB, ENABLE);
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0xF45F 0x0000      MOVS     R0,#+8388608
   \   00000010   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
    144            
    145            /* Configures USB interrupt */
    146            NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);
   \   00000014   0xF44F 0x7040      MOV      R0,#+768
   \   00000018   0x.... 0x....      BL       NVIC_PriorityGroupConfig
    147            
    148            NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQn;
   \   0000001C   0x2014             MOVS     R0,#+20
   \   0000001E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    149            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 12;
   \   00000022   0x200C             MOVS     R0,#+12
   \   00000024   0xF88D 0x0001      STRB     R0,[SP, #+1]
    150            NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF88D 0x0002      STRB     R0,[SP, #+2]
    151            NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF88D 0x0003      STRB     R0,[SP, #+3]
    152            NVIC_Init(&NVIC_InitStructure);
   \   00000034   0xA800             ADD      R0,SP,#+0
   \   00000036   0x.... 0x....      BL       NVIC_Init
    153            
    154            /* Initializes USB system */
    155            USB_Init();
   \   0000003A   0x.... 0x....      BL       USB_Init
    156            
    157          }
   \   0000003E   0xBD01             POP      {R0,PC}          ;; return
    158          
    159          
    160          /**
    161          * @brief  Power-off system clocks and power while entering suspend mode.
    162          * @param  None.
    163          * @retval None.
    164          */

   \                                 In section .text, align 2, keep-with-next
    165          void SdkEvalVCEnterLowPowerMode(void)
    166          {
    167            /* Sets the device state to suspend */
    168            bDeviceState = SUSPENDED;
   \                     SdkEvalVCEnterLowPowerMode: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable9
   \   00000004   0x2103             MOVS     R1,#+3
   \   00000006   0x6001             STR      R1,[R0, #+0]
    169            
    170          }
   \   00000008   0x4770             BX       LR               ;; return
    171          
    172          
    173          /**
    174          * @brief  Restores system clocks and power while exiting suspend mode.
    175          * @param  None.
    176          * @retval None.
    177          */

   \                                 In section .text, align 2, keep-with-next
    178          void SdkEvalVCLeaveLowPowerMode(void)
    179          {
    180            DEVICE_INFO *pInfo = &Device_Info;
   \                     SdkEvalVCLeaveLowPowerMode: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable9_1
    181            
    182            /* Sets the device state to the correct state */
    183            if (pInfo->Current_Configuration != 0)
   \   00000004   0x7A81             LDRB     R1,[R0, #+10]
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD003             BEQ.N    ??SdkEvalVCLeaveLowPowerMode_0
    184            {
    185              /* Device configured */
    186              bDeviceState = CONFIGURED;
   \   0000000A   0x....             LDR.N    R1,??DataTable9
   \   0000000C   0x2205             MOVS     R2,#+5
   \   0000000E   0x600A             STR      R2,[R1, #+0]
   \   00000010   0xE002             B.N      ??SdkEvalVCLeaveLowPowerMode_1
    187            }
    188            else
    189            {
    190              bDeviceState = ATTACHED;
   \                     ??SdkEvalVCLeaveLowPowerMode_0: (+1)
   \   00000012   0x....             LDR.N    R1,??DataTable9
   \   00000014   0x2201             MOVS     R2,#+1
   \   00000016   0x600A             STR      R2,[R1, #+0]
    191            }
    192            
    193          }
   \                     ??SdkEvalVCLeaveLowPowerMode_1: (+1)
   \   00000018   0x4770             BX       LR               ;; return
    194          
    195          
    196          /**
    197          * @brief  Software Connection/Disconnection of USB Cable.
    198          * @param  xNewState new state for cable connection.
    199          *         This parameter can be ENABLE or DISABLE.
    200          * @retval None.
    201          */

   \                                 In section .text, align 2, keep-with-next
    202          void SdkEvalVCCableConfig (FunctionalState xNewState)
    203          {
   \                     SdkEvalVCCableConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    204            if (xNewState != DISABLE)
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD003             BEQ.N    ??SdkEvalVCCableConfig_0
    205            {
    206              STM32L15_USB_CONNECT;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x.... 0x....      BL       SYSCFG_USBPuCmd
   \   00000010   0xE002             B.N      ??SdkEvalVCCableConfig_1
    207            }
    208            else
    209            {
    210              STM32L15_USB_DISCONNECT;
   \                     ??SdkEvalVCCableConfig_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      BL       SYSCFG_USBPuCmd
    211            }
    212            
    213          }
   \                     ??SdkEvalVCCableConfig_1: (+1)
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
    214          
    215          /**
    216          * @brief  Puts in the circular buffer the data to transfer through USB.
    217          * @param  pcDataBuffer pointer to the buffer containing the bytes to put in the circular buffer.
    218          * @param  nNbBytes the number of bytes to write in the buffer.
    219          * @retval None.
    220          */

   \                                 In section .text, align 2, keep-with-next
    221          void SdkEvalVCWriteTxBuffer(uint8_t* pcDataBuffer, uint16_t nNbBytes)
    222          {
   \                     SdkEvalVCWriteTxBuffer: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    223            uint32_t inIndex = s_lVCTxBufferInIndex;
   \   00000002   0x....             LDR.N    R2,??DataTable9_2
   \   00000004   0x6812             LDR      R2,[R2, #+0]
    224            
    225            for(uint16_t i=0; i<nNbBytes; i++)
   \   00000006   0x2300             MOVS     R3,#+0
   \                     ??SdkEvalVCWriteTxBuffer_0: (+1)
   \   00000008   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000000A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000C   0x428B             CMP      R3,R1
   \   0000000E   0xD20B             BCS.N    ??SdkEvalVCWriteTxBuffer_1
    226            {
    227              s_vectcVCTxBuffer[inIndex] = *pcDataBuffer;
   \   00000010   0x....             LDR.N    R4,??DataTable9_3
   \   00000012   0x7805             LDRB     R5,[R0, #+0]
   \   00000014   0x5515             STRB     R5,[R2, R4]
    228              inIndex++;
   \   00000016   0x1C52             ADDS     R2,R2,#+1
    229              /* To avoid buffer overflow */
    230              if(inIndex == VC_TX_BUFFER_DATA_SIZE)
   \   00000018   0xF5B2 0x6F80      CMP      R2,#+1024
   \   0000001C   0xD101             BNE.N    ??SdkEvalVCWriteTxBuffer_2
    231              {
    232                inIndex = 0;
   \   0000001E   0x2400             MOVS     R4,#+0
   \   00000020   0x0022             MOVS     R2,R4
    233              }
    234              pcDataBuffer++;
   \                     ??SdkEvalVCWriteTxBuffer_2: (+1)
   \   00000022   0x1C40             ADDS     R0,R0,#+1
    235            }
   \   00000024   0x1C5B             ADDS     R3,R3,#+1
   \   00000026   0xE7EF             B.N      ??SdkEvalVCWriteTxBuffer_0
    236            s_lVCTxBufferInIndex = inIndex;
   \                     ??SdkEvalVCWriteTxBuffer_1: (+1)
   \   00000028   0x....             LDR.N    R3,??DataTable9_2
   \   0000002A   0x601A             STR      R2,[R3, #+0]
    237          }
   \   0000002C   0xBC30             POP      {R4,R5}
   \   0000002E   0x4770             BX       LR               ;; return
    238          
    239          //////////////////////////////////////////////////////////////////////////////
    240          // Transmit
    241          
    242          // IAR Standard library hook for serial output

   \                                 In section .text, align 2, keep-with-next
    243          size_t __write(int handle, const unsigned char * buffer, size_t size)
    244          {
   \                     __write: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0003             MOVS     R3,R0
    245            
    246            /* This template only writes to "standard out" and "standard err",
    247            * for all other file handles it returns failure. */
    248            if (handle != _LLIO_STDOUT && handle != _LLIO_STDERR) {
   \   00000004   0x2B01             CMP      R3,#+1
   \   00000006   0xD004             BEQ.N    ??__write_0
   \   00000008   0x2B02             CMP      R3,#+2
   \   0000000A   0xD002             BEQ.N    ??__write_0
    249              return _LLIO_ERROR;
   \   0000000C   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000010   0xE01D             B.N      ??__write_1
    250            }
    251            if (buffer == 0) {
   \                     ??__write_0: (+1)
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xD101             BNE.N    ??__write_2
    252              
    253              return 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE019             B.N      ??__write_1
    254            }
    255            
    256            
    257            
    258            for(uint16_t i=0; i<size; i++)
   \                     ??__write_2: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \                     ??__write_3: (+1)
   \   0000001C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000001E   0x4290             CMP      R0,R2
   \   00000020   0xD214             BCS.N    ??__write_4
    259            {
    260              s_vectcVCTxBuffer[s_lVCTxBufferInIndex++] = *buffer;
   \   00000022   0x....             LDR.N    R4,??DataTable9_2
   \   00000024   0x6824             LDR      R4,[R4, #+0]
   \   00000026   0x....             LDR.N    R5,??DataTable9_3
   \   00000028   0x780E             LDRB     R6,[R1, #+0]
   \   0000002A   0x5566             STRB     R6,[R4, R5]
   \   0000002C   0x....             LDR.N    R4,??DataTable9_2
   \   0000002E   0x6824             LDR      R4,[R4, #+0]
   \   00000030   0x1C64             ADDS     R4,R4,#+1
   \   00000032   0x....             LDR.N    R5,??DataTable9_2
   \   00000034   0x602C             STR      R4,[R5, #+0]
    261              
    262              //while(USB_OUT_BUFFER_IS_FULL()) ;
    263              
    264              /* To avoid buffer overflow */
    265              if(s_lVCTxBufferInIndex == VC_TX_BUFFER_DATA_SIZE)
   \   00000036   0x....             LDR.N    R4,??DataTable9_2
   \   00000038   0x6824             LDR      R4,[R4, #+0]
   \   0000003A   0xF5B4 0x6F80      CMP      R4,#+1024
   \   0000003E   0xD102             BNE.N    ??__write_5
    266              {
    267                s_lVCTxBufferInIndex = 0;
   \   00000040   0x....             LDR.N    R4,??DataTable9_2
   \   00000042   0x2500             MOVS     R5,#+0
   \   00000044   0x6025             STR      R5,[R4, #+0]
    268              }
    269              buffer++;
   \                     ??__write_5: (+1)
   \   00000046   0x1C49             ADDS     R1,R1,#+1
    270            }
   \   00000048   0x1C40             ADDS     R0,R0,#+1
   \   0000004A   0xE7E7             B.N      ??__write_3
    271            
    272            return size;
   \                     ??__write_4: (+1)
   \   0000004C   0x0010             MOVS     R0,R2
   \                     ??__write_1: (+1)
   \   0000004E   0xBC70             POP      {R4-R6}
   \   00000050   0x4770             BX       LR               ;; return
    273          }
    274          

   \                                 In section .text, align 2, keep-with-next
    275          size_t fflush(int handle)
    276          {
   \                     fflush: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    277            return __write(_LLIO_STDOUT, NULL, 0);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x.... 0x....      BL       __write
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
    278          }
    279          
    280          

   \                                 In section .text, align 2, keep-with-next
    281          size_t __read(int handle, unsigned char * buffer, size_t size)
    282          {
   \                     __read: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    283            int nChars = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
    284            
    285            /* This template only reads from "standard in", for all other file
    286            * handles it returns failure. */
    287            if (handle != _LLIO_STDIN)
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD002             BEQ.N    ??__read_0
    288            {
    289              return _LLIO_ERROR;
   \   00000010   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000014   0xE02C             B.N      ??__read_1
    290            }
    291            
    292            USB_ENTER_CRITICAL();
   \                     ??__read_0: (+1)
   \   00000016   0x....             LDR.N    R0,??DataTable9_4
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x9001             STR      R0,[SP, #+4]
   \   0000001C   0xA801             ADD      R0,SP,#+4
   \   0000001E   0x.... 0x....      BL       NVIC_Init
    293            
    294            for(nChars = 0; (rxUsed>0) && (nChars < size); nChars++) {
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x0007             MOVS     R7,R0
   \                     ??__read_2: (+1)
   \   00000026   0x....             LDR.N    R0,??DataTable9_5
   \   00000028   0x8800             LDRH     R0,[R0, #+0]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD019             BEQ.N    ??__read_3
   \   0000002E   0x42B7             CMP      R7,R6
   \   00000030   0xD217             BCS.N    ??__read_3
    295              *buffer++ = rxQ[rxTail];
   \   00000032   0x....             LDR.N    R0,??DataTable9_6
   \   00000034   0x8800             LDRH     R0,[R0, #+0]
   \   00000036   0x....             LDR.N    R1,??DataTable9_7
   \   00000038   0x5C40             LDRB     R0,[R0, R1]
   \   0000003A   0x7028             STRB     R0,[R5, #+0]
   \   0000003C   0x1C6D             ADDS     R5,R5,#+1
    296              rxTail = (rxTail+1) % RECEIVE_QUEUE_SIZE;
   \   0000003E   0x....             LDR.N    R0,??DataTable9_6
   \   00000040   0x8800             LDRH     R0,[R0, #+0]
   \   00000042   0x1C40             ADDS     R0,R0,#+1
   \   00000044   0xF44F 0x6180      MOV      R1,#+1024
   \   00000048   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \   0000004C   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   00000050   0x....             LDR.N    R0,??DataTable9_6
   \   00000052   0x8002             STRH     R2,[R0, #+0]
    297              rxUsed--;
   \   00000054   0x....             LDR.N    R0,??DataTable9_5
   \   00000056   0x8800             LDRH     R0,[R0, #+0]
   \   00000058   0x1E40             SUBS     R0,R0,#+1
   \   0000005A   0x....             LDR.N    R1,??DataTable9_5
   \   0000005C   0x8008             STRH     R0,[R1, #+0]
    298              
    299            }
   \   0000005E   0x1C7F             ADDS     R7,R7,#+1
   \   00000060   0xE7E1             B.N      ??__read_2
    300            
    301            USB_EXIT_CRITICAL();     
   \                     ??__read_3: (+1)
   \   00000062   0x....             LDR.N    R0,??DataTable9_8
   \   00000064   0x6800             LDR      R0,[R0, #+0]
   \   00000066   0x9000             STR      R0,[SP, #+0]
   \   00000068   0xA800             ADD      R0,SP,#+0
   \   0000006A   0x.... 0x....      BL       NVIC_Init
    302            
    303            return nChars;
   \   0000006E   0x0038             MOVS     R0,R7
   \                     ??__read_1: (+1)
   \   00000070   0xBDFE             POP      {R1-R7,PC}       ;; return
    304          }
    305          

   \                                 In section .text, align 2, keep-with-next
    306          uint8_t __io_getcharNonBlocking(uint8_t *data)
    307          {
   \                     __io_getcharNonBlocking: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    308            if (__read(_LLIO_STDIN,data,1))
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x0021             MOVS     R1,R4
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x.... 0x....      BL       __read
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD001             BEQ.N    ??__io_getcharNonBlocking_0
    309              return TRUE;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xE000             B.N      ??__io_getcharNonBlocking_1
    310            else
    311              return FALSE;
   \                     ??__io_getcharNonBlocking_0: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \                     ??__io_getcharNonBlocking_1: (+1)
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
    312          }/* end serialReadByte() */
    313          

   \                                 In section .text, align 2, keep-with-next
    314          void __io_putchar( char c )
    315          {
   \                     __io_putchar: (+1)
   \   00000000   0xB501             PUSH     {R0,LR}
    316            __write(_LLIO_STDOUT, (unsigned char *)&c, 1);
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0xA900             ADD      R1,SP,#+0
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x.... 0x....      BL       __write
    317          }
   \   0000000C   0xBD01             POP      {R0,PC}          ;; return
    318          

   \                                 In section .text, align 2, keep-with-next
    319          int __io_getchar()
    320          {
   \                     __io_getchar: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    321            unsigned char c;
    322            
    323            __read(_LLIO_STDIN, &c, 1);
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0xA900             ADD      R1,SP,#+0
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x.... 0x....      BL       __read
    324            return (int)(c);
   \   0000000C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000010   0xBD02             POP      {R1,PC}          ;; return
    325          }
    326          

   \                                 In section .text, align 2, keep-with-next
    327          void __io_flush( void )
    328          {
   \                     __io_flush: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    329            __write(_LLIO_STDOUT, NULL, 0);
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x.... 0x....      BL       __write
    330          }
   \   0000000C   0xBD01             POP      {R0,PC}          ;; return
    331          
    332          /**
    333          * @brief  Transfers available data through USB.
    334          * @param  None.
    335          * @retval None.
    336          */

   \                                 In section .text, align 2, keep-with-next
    337          void SdkEvalVCSendData(void)
    338          {
   \                     SdkEvalVCSendData: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    339            uint16_t USB_Tx_ptr;
    340            uint16_t USB_Tx_length;
    341            
    342            if(USB_Tx_State != 1)
   \   00000002   0x....             LDR.N    R0,??DataTable9_9
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD05C             BEQ.N    ??SdkEvalVCSendData_0
    343            {
    344              if (s_lVCTxBufferOutIndex == VC_TX_BUFFER_DATA_SIZE)
   \   0000000A   0x....             LDR.N    R0,??DataTable9_10
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000012   0xD102             BNE.N    ??SdkEvalVCSendData_1
    345              {
    346                s_lVCTxBufferOutIndex = 0;
   \   00000014   0x....             LDR.N    R0,??DataTable9_10
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x6001             STR      R1,[R0, #+0]
    347              }
    348              
    349              if(s_lVCTxBufferOutIndex == s_lVCTxBufferInIndex)
   \                     ??SdkEvalVCSendData_1: (+1)
   \   0000001A   0x....             LDR.N    R0,??DataTable9_10
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x....             LDR.N    R1,??DataTable9_2
   \   00000020   0x6809             LDR      R1,[R1, #+0]
   \   00000022   0x4288             CMP      R0,R1
   \   00000024   0xD103             BNE.N    ??SdkEvalVCSendData_2
    350              {
    351                USB_Tx_State = 0; 
   \   00000026   0x....             LDR.N    R0,??DataTable9_9
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x7001             STRB     R1,[R0, #+0]
    352                return;
   \   0000002C   0xE04A             B.N      ??SdkEvalVCSendData_3
    353              }
    354              if(s_lVCTxBufferOutIndex > s_lVCTxBufferInIndex) /* rollback */
   \                     ??SdkEvalVCSendData_2: (+1)
   \   0000002E   0x....             LDR.N    R0,??DataTable9_2
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x....             LDR.N    R1,??DataTable9_10
   \   00000034   0x6809             LDR      R1,[R1, #+0]
   \   00000036   0x4288             CMP      R0,R1
   \   00000038   0xD206             BCS.N    ??SdkEvalVCSendData_4
    355              {
    356                s_lVCTxDataLength = VC_TX_BUFFER_DATA_SIZE - s_lVCTxBufferOutIndex;
   \   0000003A   0x....             LDR.N    R0,??DataTable9_10
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0xF5D0 0x6080      RSBS     R0,R0,#+1024
   \   00000042   0x....             LDR.N    R1,??DataTable9_11
   \   00000044   0x6008             STR      R0,[R1, #+0]
   \   00000046   0xE006             B.N      ??SdkEvalVCSendData_5
    357              }
    358              else
    359              {
    360                s_lVCTxDataLength = s_lVCTxBufferInIndex - s_lVCTxBufferOutIndex;
   \                     ??SdkEvalVCSendData_4: (+1)
   \   00000048   0x....             LDR.N    R0,??DataTable9_2
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x....             LDR.N    R1,??DataTable9_10
   \   0000004E   0x6809             LDR      R1,[R1, #+0]
   \   00000050   0x1A40             SUBS     R0,R0,R1
   \   00000052   0x....             LDR.N    R1,??DataTable9_11
   \   00000054   0x6008             STR      R0,[R1, #+0]
    361              }
    362              if (s_lVCTxDataLength > VIRTUAL_COM_PORT_DATA_SIZE)
   \                     ??SdkEvalVCSendData_5: (+1)
   \   00000056   0x....             LDR.N    R0,??DataTable9_11
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0x2841             CMP      R0,#+65
   \   0000005C   0xD30F             BCC.N    ??SdkEvalVCSendData_6
    363              {
    364                USB_Tx_ptr = s_lVCTxBufferOutIndex;
   \   0000005E   0x....             LDR.N    R0,??DataTable9_10
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x0004             MOVS     R4,R0
    365                USB_Tx_length = VIRTUAL_COM_PORT_DATA_SIZE;
   \   00000064   0x2040             MOVS     R0,#+64
   \   00000066   0x0005             MOVS     R5,R0
    366                
    367                s_lVCTxBufferOutIndex += VIRTUAL_COM_PORT_DATA_SIZE;
   \   00000068   0x....             LDR.N    R0,??DataTable9_10
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x3040             ADDS     R0,R0,#+64
   \   0000006E   0x....             LDR.N    R1,??DataTable9_10
   \   00000070   0x6008             STR      R0,[R1, #+0]
    368                s_lVCTxDataLength -= VIRTUAL_COM_PORT_DATA_SIZE;
   \   00000072   0x....             LDR.N    R0,??DataTable9_11
   \   00000074   0x6800             LDR      R0,[R0, #+0]
   \   00000076   0x3840             SUBS     R0,R0,#+64
   \   00000078   0x....             LDR.N    R1,??DataTable9_11
   \   0000007A   0x6008             STR      R0,[R1, #+0]
   \   0000007C   0xE00F             B.N      ??SdkEvalVCSendData_7
    369                
    370              }
    371              else
    372              {
    373                USB_Tx_ptr = s_lVCTxBufferOutIndex;
   \                     ??SdkEvalVCSendData_6: (+1)
   \   0000007E   0x....             LDR.N    R0,??DataTable9_10
   \   00000080   0x6800             LDR      R0,[R0, #+0]
   \   00000082   0x0004             MOVS     R4,R0
    374                USB_Tx_length = s_lVCTxDataLength;
   \   00000084   0x....             LDR.N    R0,??DataTable9_11
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0x0005             MOVS     R5,R0
    375                
    376                s_lVCTxBufferOutIndex += s_lVCTxDataLength;
   \   0000008A   0x....             LDR.N    R0,??DataTable9_10
   \   0000008C   0x6800             LDR      R0,[R0, #+0]
   \   0000008E   0x....             LDR.N    R1,??DataTable9_11
   \   00000090   0x6809             LDR      R1,[R1, #+0]
   \   00000092   0x1808             ADDS     R0,R1,R0
   \   00000094   0x....             LDR.N    R1,??DataTable9_10
   \   00000096   0x6008             STR      R0,[R1, #+0]
    377                s_lVCTxDataLength = 0;
   \   00000098   0x....             LDR.N    R0,??DataTable9_11
   \   0000009A   0x2100             MOVS     R1,#+0
   \   0000009C   0x6001             STR      R1,[R0, #+0]
    378                
    379              }
    380              
    381              USB_Tx_State = 1;
   \                     ??SdkEvalVCSendData_7: (+1)
   \   0000009E   0x....             LDR.N    R0,??DataTable9_9
   \   000000A0   0x2101             MOVS     R1,#+1
   \   000000A2   0x7001             STRB     R1,[R0, #+0]
    382              UserToPMABufferCopy(&s_vectcVCTxBuffer[USB_Tx_ptr], ENDP1_TXADDR, USB_Tx_length);
   \   000000A4   0x002A             MOVS     R2,R5
   \   000000A6   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000A8   0x21C0             MOVS     R1,#+192
   \   000000AA   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000AC   0x....             LDR.N    R0,??DataTable9_3
   \   000000AE   0x1820             ADDS     R0,R4,R0
   \   000000B0   0x.... 0x....      BL       UserToPMABufferCopy
    383              SetEPTxCount(ENDP1, USB_Tx_length);
   \   000000B4   0x0029             MOVS     R1,R5
   \   000000B6   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000B8   0x2001             MOVS     R0,#+1
   \   000000BA   0x.... 0x....      BL       SetEPTxCount
    384              SetEPTxValid(ENDP1);
   \   000000BE   0x2001             MOVS     R0,#+1
   \   000000C0   0x.... 0x....      BL       SetEPTxValid
    385              
    386            }
    387            
    388          }
   \                     ??SdkEvalVCSendData_0: (+1)
   \                     ??SdkEvalVCSendData_3: (+1)
   \   000000C4   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    389          
    390          
    391          /**
    392          * @brief  Creates the serial number string descriptor.
    393          * @param  None.
    394          * @retval None.
    395          */

   \                                 In section .text, align 2, keep-with-next
    396          void SdkEvalVCGetSerialNum(void)
    397          {
   \                     SdkEvalVCGetSerialNum: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    398            uint32_t Device_Serial0, Device_Serial1, Device_Serial2;
    399            
    400            Device_Serial0 = *(uint32_t*)(0x1FF80050);
   \   00000002   0x....             LDR.N    R0,??DataTable9_12  ;; 0x1ff80050
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x0004             MOVS     R4,R0
    401            Device_Serial1 = *(uint32_t*)(0x1FF80054);
   \   00000008   0x....             LDR.N    R0,??DataTable9_13  ;; 0x1ff80054
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x0005             MOVS     R5,R0
    402            Device_Serial2 = *(uint32_t*)(0x1FF80064);
   \   0000000E   0x....             LDR.N    R0,??DataTable9_14  ;; 0x1ff80064
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x0006             MOVS     R6,R0
    403            
    404            Device_Serial0 += Device_Serial2;
   \   00000014   0x1934             ADDS     R4,R6,R4
    405            
    406            if (Device_Serial0 != 0)
   \   00000016   0x2C00             CMP      R4,#+0
   \   00000018   0xD009             BEQ.N    ??SdkEvalVCGetSerialNum_0
    407            {
    408              IntToUnicode (Device_Serial0, &g_vectcVCPortStringSerial[2] , 8);
   \   0000001A   0x2208             MOVS     R2,#+8
   \   0000001C   0x....             LDR.N    R1,??DataTable9_15
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       IntToUnicode
    409              IntToUnicode (Device_Serial1, &g_vectcVCPortStringSerial[18], 4);
   \   00000024   0x2204             MOVS     R2,#+4
   \   00000026   0x....             LDR.N    R1,??DataTable9_16
   \   00000028   0x0028             MOVS     R0,R5
   \   0000002A   0x.... 0x....      BL       IntToUnicode
    410            }
    411            
    412          }
   \                     ??SdkEvalVCGetSerialNum_0: (+1)
   \   0000002E   0xBD70             POP      {R4-R6,PC}       ;; return
    413          
    414          
    415          /**
    416          * @brief  Converts Hex 32Bits value into char.
    417          * @param  lValue the HEX words to convert.
    418          * @param  pcBuffer the buffer in whic put the converted values.
    419          * @param  cLength the number of byte to convert.
    420          * @retval None.
    421          */

   \                                 In section .text, align 2, keep-with-next
    422          static void IntToUnicode (uint32_t lValue , uint8_t* pcBuffer , uint8_t cLength)
    423          {
   \                     IntToUnicode: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    424            uint8_t idx = 0;
   \   00000002   0x2300             MOVS     R3,#+0
    425            
    426            for( idx = 0 ; idx < cLength ; idx ++)
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0x0023             MOVS     R3,R4
   \                     ??IntToUnicode_0: (+1)
   \   00000008   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000000A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000C   0x4293             CMP      R3,R2
   \   0000000E   0xD215             BCS.N    ??IntToUnicode_1
    427            {
    428              if( ((lValue >> 28)) < 0xA )
   \   00000010   0x0F04             LSRS     R4,R0,#+28
   \   00000012   0x2C0A             CMP      R4,#+10
   \   00000014   0xD205             BCS.N    ??IntToUnicode_2
    429              {
    430                pcBuffer[ 2* idx] = (lValue >> 28) + '0';
   \   00000016   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000018   0x0F04             LSRS     R4,R0,#+28
   \   0000001A   0x3430             ADDS     R4,R4,#+48
   \   0000001C   0xF801 0x4013      STRB     R4,[R1, R3, LSL #+1]
   \   00000020   0xE004             B.N      ??IntToUnicode_3
    431              }
    432              else
    433              {
    434                pcBuffer[2* idx] = (lValue >> 28) + 'A' - 10;
   \                     ??IntToUnicode_2: (+1)
   \   00000022   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000024   0x0F04             LSRS     R4,R0,#+28
   \   00000026   0x3437             ADDS     R4,R4,#+55
   \   00000028   0xF801 0x4013      STRB     R4,[R1, R3, LSL #+1]
    435              }
    436              
    437              lValue = lValue << 4;
   \                     ??IntToUnicode_3: (+1)
   \   0000002C   0x0100             LSLS     R0,R0,#+4
    438              
    439              pcBuffer[ 2* idx + 1] = 0;
   \   0000002E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000030   0xEB11 0x0443      ADDS     R4,R1,R3, LSL #+1
   \   00000034   0x2500             MOVS     R5,#+0
   \   00000036   0x7065             STRB     R5,[R4, #+1]
    440            }
   \   00000038   0x1C5B             ADDS     R3,R3,#+1
   \   0000003A   0xE7E5             B.N      ??IntToUnicode_0
    441            
    442          }
   \                     ??IntToUnicode_1: (+1)
   \   0000003C   0xBC30             POP      {R4,R5}
   \   0000003E   0x4770             BX       LR               ;; return
    443          
    444          
    445          /**
    446          * @brief  Resets the static variable only for test purpose.
    447          * @param  None.
    448          * @retval None.
    449          */

   \                                 In section .text, align 2, keep-with-next
    450          void SdkEvalVCResetCounter(void)
    451          {
    452            s_lVCTxBufferInIndex = 0;
   \                     SdkEvalVCResetCounter: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable9_2
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x6001             STR      R1,[R0, #+0]
    453            s_lVCTxBufferOutIndex = 0;
   \   00000006   0x....             LDR.N    R0,??DataTable9_10
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    454          }
   \   0000000C   0x4770             BX       LR               ;; return
    455          
    456          
    457          /**
    458          * @brief  Sets the static variable only for test purpose.
    459          * @param  None.
    460          * @retval None.
    461          */

   \                                 In section .text, align 2, keep-with-next
    462          void SdkEvalVCSetCounter(uint32_t lInIndex, uint32_t lOutIndex)
    463          {
    464            s_lVCTxBufferInIndex = lInIndex;
   \                     SdkEvalVCSetCounter: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable9_2
   \   00000002   0x6010             STR      R0,[R2, #+0]
    465            s_lVCTxBufferOutIndex = lOutIndex;
   \   00000004   0x....             LDR.N    R2,??DataTable9_10
   \   00000006   0x6011             STR      R1,[R2, #+0]
    466          }
   \   00000008   0x4770             BX       LR               ;; return
    467          
    468          

   \                                 In section .text, align 2, keep-with-next
    469          void enqueueRxChars(unsigned char * buffer, uint16_t size)
    470          {
   \                     enqueueRxChars: (+1)
   \   00000000   0xB410             PUSH     {R4}
    471            // Enqueue chars received from USB into a RX buffer
    472            while (( size > 0 ) && (rxUsed < (RECEIVE_QUEUE_SIZE-1))) {
   \                     ??enqueueRxChars_0: (+1)
   \   00000002   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD01D             BEQ.N    ??enqueueRxChars_1
   \   00000008   0x....             LDR.N    R2,??DataTable9_5
   \   0000000A   0x8812             LDRH     R2,[R2, #+0]
   \   0000000C   0xF240 0x33FF      MOVW     R3,#+1023
   \   00000010   0x429A             CMP      R2,R3
   \   00000012   0xDA17             BGE.N    ??enqueueRxChars_1
    473              rxQ[rxHead] = *buffer++;
   \   00000014   0x....             LDR.N    R2,??DataTable9_17
   \   00000016   0x8812             LDRH     R2,[R2, #+0]
   \   00000018   0x....             LDR.N    R3,??DataTable9_7
   \   0000001A   0x7804             LDRB     R4,[R0, #+0]
   \   0000001C   0x54D4             STRB     R4,[R2, R3]
   \   0000001E   0x1C40             ADDS     R0,R0,#+1
    474              rxHead = (rxHead+1) % RECEIVE_QUEUE_SIZE;
   \   00000020   0x....             LDR.N    R2,??DataTable9_17
   \   00000022   0x8812             LDRH     R2,[R2, #+0]
   \   00000024   0x1C52             ADDS     R2,R2,#+1
   \   00000026   0xF44F 0x6380      MOV      R3,#+1024
   \   0000002A   0xFB92 0xF4F3      SDIV     R4,R2,R3
   \   0000002E   0xFB04 0x2413      MLS      R4,R4,R3,R2
   \   00000032   0x....             LDR.N    R2,??DataTable9_17
   \   00000034   0x8014             STRH     R4,[R2, #+0]
    475              rxUsed++;
   \   00000036   0x....             LDR.N    R2,??DataTable9_5
   \   00000038   0x8812             LDRH     R2,[R2, #+0]
   \   0000003A   0x1C52             ADDS     R2,R2,#+1
   \   0000003C   0x....             LDR.N    R3,??DataTable9_5
   \   0000003E   0x801A             STRH     R2,[R3, #+0]
    476              size--;
   \   00000040   0x1E49             SUBS     R1,R1,#+1
   \   00000042   0xE7DE             B.N      ??enqueueRxChars_0
    477            }
    478          }
   \                     ??enqueueRxChars_1: (+1)
   \   00000044   0xBC10             POP      {R4}
   \   00000046   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     bDeviceState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x........         DC32     Device_Info

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x........         DC32     s_lVCTxBufferInIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x........         DC32     s_vectcVCTxBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x........         DC32     `?<Constant {20, 1, 0, 0}>`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x........         DC32     rxUsed

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x........         DC32     rxTail

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x........         DC32     rxQ

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x........         DC32     `?<Constant {20, 1, 0, 1}>`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   0x........         DC32     USB_Tx_State

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_10:
   \   00000000   0x........         DC32     s_lVCTxBufferOutIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_11:
   \   00000000   0x........         DC32     s_lVCTxDataLength

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_12:
   \   00000000   0x1FF80050         DC32     0x1ff80050

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_13:
   \   00000000   0x1FF80054         DC32     0x1ff80054

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_14:
   \   00000000   0x1FF80064         DC32     0x1ff80064

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_15:
   \   00000000   0x........         DC32     g_vectcVCPortStringSerial+0x2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_16:
   \   00000000   0x........         DC32     g_vectcVCPortStringSerial+0x12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_17:
   \   00000000   0x........         DC32     rxHead

   \                                 In section .rodata, align 4
   \                     `?<Constant {20, 1, 0, 0}>`:
   \   00000000   0x14 0x01          DC8 20, 1, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant {20, 1, 0, 1}>`:
   \   00000000   0x14 0x01          DC8 20, 1, 0, 1
   \              0x00 0x01    
    479          
    480          /**
    481          * @}
    482          */
    483          
    484          
    485          /**
    486          * @}
    487          */
    488          
    489          
    490          /**
    491          * @}
    492          */
    493          
    494          
    495          
    496          
    497          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   IntToUnicode
       8   SdkEvalVCCableConfig
         8   -> SYSCFG_USBPuCmd
       0   SdkEvalVCEnterLowPowerMode
      16   SdkEvalVCGetSerialNum
        16   -> IntToUnicode
       8   SdkEvalVCInit
         8   -> NVIC_Init
         8   -> NVIC_PriorityGroupConfig
         8   -> RCC_APB1PeriphClockCmd
         8   -> RCC_APB2PeriphClockCmd
         8   -> USB_Init
       0   SdkEvalVCLeaveLowPowerMode
       0   SdkEvalVCResetCounter
      16   SdkEvalVCSendData
        16   -> SetEPTxCount
        16   -> SetEPTxValid
        16   -> UserToPMABufferCopy
       0   SdkEvalVCSetCounter
       8   SdkEvalVCWriteTxBuffer
       8   __io_flush
         8   -> __write
       8   __io_getchar
         8   -> __read
       8   __io_getcharNonBlocking
         8   -> __read
       8   __io_putchar
         8   -> __write
      32   __read
        32   -> NVIC_Init
      12   __write
       4   enqueueRxChars
       8   fflush
         8   -> __write


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ?<Constant {20, 1, 0, 0}>
       4  ?<Constant {20, 1, 0, 1}>
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_12
       4  ??DataTable9_13
       4  ??DataTable9_14
       4  ??DataTable9_15
       4  ??DataTable9_16
       4  ??DataTable9_17
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
      64  IntToUnicode
      26  SdkEvalVCCableConfig
      10  SdkEvalVCEnterLowPowerMode
      48  SdkEvalVCGetSerialNum
      64  SdkEvalVCInit
      26  SdkEvalVCLeaveLowPowerMode
      14  SdkEvalVCResetCounter
     198  SdkEvalVCSendData
      10  SdkEvalVCSetCounter
      48  SdkEvalVCWriteTxBuffer
       1  USB_Tx_State
      14  __io_flush
      18  __io_getchar
      26  __io_getcharNonBlocking
      14  __io_putchar
     114  __read
      82  __write
      72  enqueueRxChars
      16  fflush
       2  rxHead
    1024  rxQ
       2  rxTail
       2  rxUsed
       4  s_lVCTxBufferInIndex
       4  s_lVCTxBufferOutIndex
       4  s_lVCTxDataLength
    1024  s_vectcVCTxBuffer

 
 2 067 bytes in section .bss
     8 bytes in section .rodata
   936 bytes in section .text
 
   936 bytes of CODE  memory
     8 bytes of CONST memory
 2 067 bytes of DATA  memory

Errors: none
Warnings: none
