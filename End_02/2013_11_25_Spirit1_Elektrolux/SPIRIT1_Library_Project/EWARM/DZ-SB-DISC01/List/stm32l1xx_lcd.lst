###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        20/Nov/2015  05:04:56
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_lcd.c
#    Command line =  
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_lcd.c
#        -D USE_STDPERIPH_DRIVER -D VECT_TAB_FLASH -D STM32L1XX_MD -D
#        IAR_ARM_CM3 -D USE_FULL_ASSERT -D SPIRIT_USE_FULL_ASSERT -D
#        USE_SYSTICK_DELAY -D SDK -lC
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\List\
#        -o
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\.\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\examples\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\runtime\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\SDK_Eval_STM32L\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\SPIRIT1_Library\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\SDK_Eval_Util\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\SDK_Virtual_Com\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32_USB-FS-Device_Lib\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\ACQ\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\CMSIS\Include\"
#    List file    =  
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\List\stm32l1xx_lcd.lst
#    Object file  =  
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\Obj\stm32l1xx_lcd.o
#
###############################################################################

E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_lcd.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_lcd.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    31-December-2010
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the LCD controller (LCD) peripheral:           
      9            *           - Initialization and configuration
     10            *           - LCD RAM memory write
     11            *           - Interrupts and flags management   
     12            *           
     13            *  @verbatim
     14            *      
     15            *          ===================================================================      
     16            *                                    LCD Clock
     17            *          ===================================================================    
     18            *          LCDCLK is the same as RTCCLK. 
     19            *          To configure the RTCCLK/LCDCLK, proceed as follows:
     20            *            - Enable the Power Controller (PWR) APB1 interface clock using the
     21            *              RCC_APB1PeriphClockCmd() function.
     22            *            - Enable access to RTC domain using the PWR_RTCAccessCmd() function.
     23            *            - Select the RTC clock source using the RCC_RTCCLKConfig() function.    
     24            *          
     25            *          The frequency generator allows you to achieve various LCD frame rates 
     26            *          starting from an LCD input clock frequency (LCDCLK) which can vary 
     27            *          from 32 kHz up to 1 MHz.
     28            *            
     29            *          ===================================================================      
     30            *                                  LCD and low power modes
     31            *          =================================================================== 
     32            *          The LCD still active during STOP mode.
     33            *              
     34            *          ===================================================================
     35            *                                 How to use this driver
     36            *          =================================================================== 
     37            *          1. Enable LCD clock using RCC_APB1PeriphClockCmd(RCC_APB1Periph_LCD, ENABLE) function
     38            *            
     39            *          2. Configure the LCD prescaler, divider, duty, bias and voltage source
     40            *             using LCD_Init() function     
     41            *            
     42            *          3. Optionally you can enable/configure:
     43            *              -  LCD High Drive using the LCD_HighDriveCmd() function
     44            *              -  LCD High Drive using the LCD_MuxSegmentCmd() function  
     45            *              -  LCD Pulse ON Duration using the LCD_PulseOnDurationConfig() function
     46            *              -  LCD Dead Time using the LCD_DeadTimeConfig() function  
     47            *              -  The LCD Blink mode and frequency using the LCD_BlinkConfig() function
     48            *              -  The LCD Contrast using the LCD_ContrastConfig() function  
     49            *
     50            *          4. Call the LCD_WaitForSynchro() function to wait for LCD_FCR register
     51            *             synchronization.
     52            *           
     53            *          5. Call the LCD_Cmd() to enable the LCD controller
     54            *          
     55            *          6. Wait until the LCD Controller status is enabled and the step-up
     56            *             converter is ready using the LCD_GetFlagStatus() and
     57            *             LCD_FLAG_ENS and LCD_FLAG_RDY flags.               
     58            *  
     59            *          7. Write to the LCD RAM memory using the LCD_Write() function.
     60            *          
     61            *          8. Request an update display using the LCD_UpdateDisplayRequest()
     62            *             function.
     63            *             
     64            *          9. Wait until the update display is finished by checking the UDD
     65            *             flag status using the LCD_GetFlagStatus(LCD_FLAG_UDD)
     66            *                                  
     67            *                     
     68            *  @endverbatim
     69            *           
     70            ******************************************************************************
     71            * @attention
     72            *
     73            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     74            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     75            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     76            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     77            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     78            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     79            *
     80            * <h2><center>&copy; COPYRIGHT 2010 STMicroelectronics</center></h2>
     81            ******************************************************************************  
     82            */ 
     83          
     84          /* Includes ------------------------------------------------------------------*/
     85          #include "stm32l1xx_lcd.h"
     86          #include "stm32l1xx_rcc.h"
     87          
     88          /** @addtogroup STM32L1xx_StdPeriph_Driver
     89            * @{
     90            */
     91          
     92          /** @defgroup LCD 
     93            * @brief LCD driver modules
     94            * @{
     95            */
     96          
     97          /* Private typedef -----------------------------------------------------------*/
     98          /* Private define ------------------------------------------------------------*/
     99          /* ------------ LCD registers bit address in the alias region --------------- */
    100          #define LCD_OFFSET                   (LCD_BASE - PERIPH_BASE)
    101          
    102          /* --- CR Register ---*/
    103          
    104          /* Alias word address of LCDEN bit */
    105          #define CR_OFFSET                    (LCD_OFFSET + 0x00)
    106          #define LCDEN_BitNumber              0x00
    107          #define CR_LCDEN_BB                  (PERIPH_BB_BASE + (CR_OFFSET * 32) + (LCDEN_BitNumber * 4))
    108          
    109          /* Alias word address of MUX_SEG bit */
    110          #define MUX_SEG_BitNumber            0x07
    111          #define CR_MUX_SEG_BB                (PERIPH_BB_BASE + (CR_OFFSET * 32) + (MUX_SEG_BitNumber * 4))
    112          
    113          
    114          /* --- FCR Register ---*/
    115          
    116          /* Alias word address of HD bit */
    117          #define FCR_OFFSET                   (LCD_OFFSET + 0x04)
    118          #define HD_BitNumber                 0x00
    119          #define FCR_HD_BB                    (PERIPH_BB_BASE + (FCR_OFFSET * 32) + (HD_BitNumber * 4))
    120          
    121          /* --- SR Register ---*/
    122          
    123          /* Alias word address of UDR bit */
    124          #define SR_OFFSET                    (LCD_OFFSET + 0x08)
    125          #define UDR_BitNumber                0x02
    126          #define SR_UDR_BB                    (PERIPH_BB_BASE + (SR_OFFSET * 32) + (UDR_BitNumber * 4))
    127          
    128          #define FCR_MASK                     ((uint32_t)0xFC03FFFF)  /* LCD FCR Mask */
    129          #define CR_MASK                      ((uint32_t)0xFFFFFF81)  /* LCD CR Mask */
    130          #define PON_MASK                     ((uint32_t)0xFFFFFF8F)  /* LCD PON Mask */
    131          #define DEAD_MASK                    ((uint32_t)0xFFFFFC7F)  /* LCD DEAD Mask */
    132          #define BLINK_MASK                   ((uint32_t)0xFFFC1FFF)  /* LCD BLINK Mask */
    133          #define CONTRAST_MASK                ((uint32_t)0xFFFFE3FF)  /* LCD CONTRAST Mask */
    134          
    135          /* Private macro -------------------------------------------------------------*/
    136          /* Private variables ---------------------------------------------------------*/
    137          /* Private function prototypes -----------------------------------------------*/
    138          /* Private functions ---------------------------------------------------------*/
    139          
    140          /** @defgroup LCD_Private_Functions
    141            * @{
    142            */
    143          
    144          /** @defgroup LCD_Group1 Initialization and Configuration functions
    145           *  @brief   Initialization and Configuration functions 
    146           *
    147          @verbatim   
    148           ===============================================================================
    149                              Initialization and Configuration functions
    150           ===============================================================================  
    151          
    152          @endverbatim
    153            * @{
    154            */
    155          
    156          /**
    157            * @brief  Deinitializes the LCD peripheral registers to their default reset 
    158            *         values.
    159            * @param  None
    160            * @retval None
    161            */

   \                                 In section .text, align 2, keep-with-next
    162          void LCD_DeInit(void)
    163          {
   \                     LCD_DeInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    164            /* Enable LCD reset state */
    165            RCC_APB1PeriphResetCmd(RCC_APB1Periph_LCD, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0xF44F 0x7000      MOV      R0,#+512
   \   00000008   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    166            /* Release LCD from reset state */
    167            RCC_APB1PeriphResetCmd(RCC_APB1Periph_LCD, DISABLE);
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0xF44F 0x7000      MOV      R0,#+512
   \   00000012   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    168          }
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    169          
    170          /**
    171            * @brief  Initializes the LCD peripheral according to the specified parameters 
    172            *         in the LCD_InitStruct.
    173            * @note   This function can be used only when the LCD is disabled.  
    174            * @param  LCD_InitStruct: pointer to a LCD_InitTypeDef structure that contains 
    175            *         the configuration information for the specified LCD peripheral.
    176            * @retval None
    177            */

   \                                 In section .text, align 2, keep-with-next
    178          void LCD_Init(LCD_InitTypeDef* LCD_InitStruct)
    179          {
   \                     LCD_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    180            /* Check function parameters */
    181            assert_param(IS_LCD_PRESCALER(LCD_InitStruct->LCD_Prescaler));
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD040             BEQ.N    ??LCD_Init_0
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0xF5B0 0x0F80      CMP      R0,#+4194304
   \   00000010   0xD03C             BEQ.N    ??LCD_Init_0
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0xF5B0 0x0F00      CMP      R0,#+8388608
   \   00000018   0xD038             BEQ.N    ??LCD_Init_0
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0xF5B0 0x0F40      CMP      R0,#+12582912
   \   00000020   0xD034             BEQ.N    ??LCD_Init_0
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0xF1B0 0x7F80      CMP      R0,#+16777216
   \   00000028   0xD030             BEQ.N    ??LCD_Init_0
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0xF1B0 0x7FA0      CMP      R0,#+20971520
   \   00000030   0xD02C             BEQ.N    ??LCD_Init_0
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0xF1B0 0x7FC0      CMP      R0,#+25165824
   \   00000038   0xD028             BEQ.N    ??LCD_Init_0
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0xF1B0 0x7FE0      CMP      R0,#+29360128
   \   00000040   0xD024             BEQ.N    ??LCD_Init_0
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0xF1B0 0x7F00      CMP      R0,#+33554432
   \   00000048   0xD020             BEQ.N    ??LCD_Init_0
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0xF1B0 0x7F10      CMP      R0,#+37748736
   \   00000050   0xD01C             BEQ.N    ??LCD_Init_0
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0xF1B0 0x7F20      CMP      R0,#+41943040
   \   00000058   0xD018             BEQ.N    ??LCD_Init_0
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0xF1B0 0x7F30      CMP      R0,#+46137344
   \   00000060   0xD014             BEQ.N    ??LCD_Init_0
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0xF1B0 0x7F40      CMP      R0,#+50331648
   \   00000068   0xD010             BEQ.N    ??LCD_Init_0
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0xF1B0 0x7F50      CMP      R0,#+54525952
   \   00000070   0xD00C             BEQ.N    ??LCD_Init_0
   \   00000072   0x6820             LDR      R0,[R4, #+0]
   \   00000074   0xF1B0 0x7F60      CMP      R0,#+58720256
   \   00000078   0xD008             BEQ.N    ??LCD_Init_0
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0xF1B0 0x7F70      CMP      R0,#+62914560
   \   00000080   0xD004             BEQ.N    ??LCD_Init_0
   \   00000082   0x21B5             MOVS     R1,#+181
   \   00000084   0x.... 0x....      LDR.W    R0,??DataTable15
   \   00000088   0x.... 0x....      BL       assert_failed
    182            assert_param(IS_LCD_DIVIDER(LCD_InitStruct->LCD_Divider));
   \                     ??LCD_Init_0: (+1)
   \   0000008C   0x6860             LDR      R0,[R4, #+4]
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD040             BEQ.N    ??LCD_Init_1
   \   00000092   0x6860             LDR      R0,[R4, #+4]
   \   00000094   0xF5B0 0x2F80      CMP      R0,#+262144
   \   00000098   0xD03C             BEQ.N    ??LCD_Init_1
   \   0000009A   0x6860             LDR      R0,[R4, #+4]
   \   0000009C   0xF5B0 0x2F00      CMP      R0,#+524288
   \   000000A0   0xD038             BEQ.N    ??LCD_Init_1
   \   000000A2   0x6860             LDR      R0,[R4, #+4]
   \   000000A4   0xF5B0 0x2F40      CMP      R0,#+786432
   \   000000A8   0xD034             BEQ.N    ??LCD_Init_1
   \   000000AA   0x6860             LDR      R0,[R4, #+4]
   \   000000AC   0xF5B0 0x1F80      CMP      R0,#+1048576
   \   000000B0   0xD030             BEQ.N    ??LCD_Init_1
   \   000000B2   0x6860             LDR      R0,[R4, #+4]
   \   000000B4   0xF5B0 0x1FA0      CMP      R0,#+1310720
   \   000000B8   0xD02C             BEQ.N    ??LCD_Init_1
   \   000000BA   0x6860             LDR      R0,[R4, #+4]
   \   000000BC   0xF5B0 0x1FC0      CMP      R0,#+1572864
   \   000000C0   0xD028             BEQ.N    ??LCD_Init_1
   \   000000C2   0x6860             LDR      R0,[R4, #+4]
   \   000000C4   0xF5B0 0x1FE0      CMP      R0,#+1835008
   \   000000C8   0xD024             BEQ.N    ??LCD_Init_1
   \   000000CA   0x6860             LDR      R0,[R4, #+4]
   \   000000CC   0xF5B0 0x1F00      CMP      R0,#+2097152
   \   000000D0   0xD020             BEQ.N    ??LCD_Init_1
   \   000000D2   0x6860             LDR      R0,[R4, #+4]
   \   000000D4   0xF5B0 0x1F10      CMP      R0,#+2359296
   \   000000D8   0xD01C             BEQ.N    ??LCD_Init_1
   \   000000DA   0x6860             LDR      R0,[R4, #+4]
   \   000000DC   0xF5B0 0x1F20      CMP      R0,#+2621440
   \   000000E0   0xD018             BEQ.N    ??LCD_Init_1
   \   000000E2   0x6860             LDR      R0,[R4, #+4]
   \   000000E4   0xF5B0 0x1F30      CMP      R0,#+2883584
   \   000000E8   0xD014             BEQ.N    ??LCD_Init_1
   \   000000EA   0x6860             LDR      R0,[R4, #+4]
   \   000000EC   0xF5B0 0x1F40      CMP      R0,#+3145728
   \   000000F0   0xD010             BEQ.N    ??LCD_Init_1
   \   000000F2   0x6860             LDR      R0,[R4, #+4]
   \   000000F4   0xF5B0 0x1F50      CMP      R0,#+3407872
   \   000000F8   0xD00C             BEQ.N    ??LCD_Init_1
   \   000000FA   0x6860             LDR      R0,[R4, #+4]
   \   000000FC   0xF5B0 0x1F60      CMP      R0,#+3670016
   \   00000100   0xD008             BEQ.N    ??LCD_Init_1
   \   00000102   0x6860             LDR      R0,[R4, #+4]
   \   00000104   0xF5B0 0x1F70      CMP      R0,#+3932160
   \   00000108   0xD004             BEQ.N    ??LCD_Init_1
   \   0000010A   0x21B6             MOVS     R1,#+182
   \   0000010C   0x.... 0x....      LDR.W    R0,??DataTable15
   \   00000110   0x.... 0x....      BL       assert_failed
    183            assert_param(IS_LCD_DUTY(LCD_InitStruct->LCD_Duty));
   \                     ??LCD_Init_1: (+1)
   \   00000114   0x68A0             LDR      R0,[R4, #+8]
   \   00000116   0x2800             CMP      R0,#+0
   \   00000118   0xD010             BEQ.N    ??LCD_Init_2
   \   0000011A   0x68A0             LDR      R0,[R4, #+8]
   \   0000011C   0x2804             CMP      R0,#+4
   \   0000011E   0xD00D             BEQ.N    ??LCD_Init_2
   \   00000120   0x68A0             LDR      R0,[R4, #+8]
   \   00000122   0x2808             CMP      R0,#+8
   \   00000124   0xD00A             BEQ.N    ??LCD_Init_2
   \   00000126   0x68A0             LDR      R0,[R4, #+8]
   \   00000128   0x280C             CMP      R0,#+12
   \   0000012A   0xD007             BEQ.N    ??LCD_Init_2
   \   0000012C   0x68A0             LDR      R0,[R4, #+8]
   \   0000012E   0x2810             CMP      R0,#+16
   \   00000130   0xD004             BEQ.N    ??LCD_Init_2
   \   00000132   0x21B7             MOVS     R1,#+183
   \   00000134   0x.... 0x....      LDR.W    R0,??DataTable15
   \   00000138   0x.... 0x....      BL       assert_failed
    184            assert_param(IS_LCD_BIAS(LCD_InitStruct->LCD_Bias));  
   \                     ??LCD_Init_2: (+1)
   \   0000013C   0x68E0             LDR      R0,[R4, #+12]
   \   0000013E   0x2800             CMP      R0,#+0
   \   00000140   0xD00A             BEQ.N    ??LCD_Init_3
   \   00000142   0x68E0             LDR      R0,[R4, #+12]
   \   00000144   0x2820             CMP      R0,#+32
   \   00000146   0xD007             BEQ.N    ??LCD_Init_3
   \   00000148   0x68E0             LDR      R0,[R4, #+12]
   \   0000014A   0x2840             CMP      R0,#+64
   \   0000014C   0xD004             BEQ.N    ??LCD_Init_3
   \   0000014E   0x21B8             MOVS     R1,#+184
   \   00000150   0x.... 0x....      LDR.W    R0,??DataTable15
   \   00000154   0x.... 0x....      BL       assert_failed
    185            assert_param(IS_LCD_VOLTAGE_SOURCE(LCD_InitStruct->LCD_VoltageSource));
   \                     ??LCD_Init_3: (+1)
   \   00000158   0x6920             LDR      R0,[R4, #+16]
   \   0000015A   0x2800             CMP      R0,#+0
   \   0000015C   0xD007             BEQ.N    ??LCD_Init_4
   \   0000015E   0x6920             LDR      R0,[R4, #+16]
   \   00000160   0x2802             CMP      R0,#+2
   \   00000162   0xD004             BEQ.N    ??LCD_Init_4
   \   00000164   0x21B9             MOVS     R1,#+185
   \   00000166   0x.... 0x....      LDR.W    R0,??DataTable15
   \   0000016A   0x.... 0x....      BL       assert_failed
    186          
    187            LCD->FCR &= (uint32_t)FCR_MASK;
   \                     ??LCD_Init_4: (+1)
   \   0000016E   0x.... 0x....      LDR.W    R0,??DataTable15_1  ;; 0x40002404
   \   00000172   0x6800             LDR      R0,[R0, #+0]
   \   00000174   0xF030 0x707F      BICS     R0,R0,#0x3FC0000
   \   00000178   0x.... 0x....      LDR.W    R1,??DataTable15_1  ;; 0x40002404
   \   0000017C   0x6008             STR      R0,[R1, #+0]
    188            LCD->FCR |= (uint32_t)(LCD_InitStruct->LCD_Prescaler | LCD_InitStruct->LCD_Divider);
   \   0000017E   0x.... 0x....      LDR.W    R0,??DataTable15_1  ;; 0x40002404
   \   00000182   0x6800             LDR      R0,[R0, #+0]
   \   00000184   0x6821             LDR      R1,[R4, #+0]
   \   00000186   0x6862             LDR      R2,[R4, #+4]
   \   00000188   0x4311             ORRS     R1,R2,R1
   \   0000018A   0x4308             ORRS     R0,R1,R0
   \   0000018C   0x.... 0x....      LDR.W    R1,??DataTable15_1  ;; 0x40002404
   \   00000190   0x6008             STR      R0,[R1, #+0]
    189          
    190            LCD_WaitForSynchro();
   \   00000192   0x.... 0x....      BL       LCD_WaitForSynchro
    191          
    192            LCD->CR &= (uint32_t)CR_MASK;
   \   00000196   0x.... 0x....      LDR.W    R0,??DataTable15_2  ;; 0x40002400
   \   0000019A   0x6800             LDR      R0,[R0, #+0]
   \   0000019C   0xF030 0x007E      BICS     R0,R0,#0x7E
   \   000001A0   0x.... 0x....      LDR.W    R1,??DataTable15_2  ;; 0x40002400
   \   000001A4   0x6008             STR      R0,[R1, #+0]
    193            LCD->CR |= (uint32_t)(LCD_InitStruct->LCD_Duty | LCD_InitStruct->LCD_Bias | \
    194                                  LCD_InitStruct->LCD_VoltageSource);
   \   000001A6   0x.... 0x....      LDR.W    R0,??DataTable15_2  ;; 0x40002400
   \   000001AA   0x6800             LDR      R0,[R0, #+0]
   \   000001AC   0x68A1             LDR      R1,[R4, #+8]
   \   000001AE   0x68E2             LDR      R2,[R4, #+12]
   \   000001B0   0x4311             ORRS     R1,R2,R1
   \   000001B2   0x6922             LDR      R2,[R4, #+16]
   \   000001B4   0x4311             ORRS     R1,R2,R1
   \   000001B6   0x4308             ORRS     R0,R1,R0
   \   000001B8   0x.... 0x....      LDR.W    R1,??DataTable15_2  ;; 0x40002400
   \   000001BC   0x6008             STR      R0,[R1, #+0]
    195          
    196          }
   \   000001BE   0xBD10             POP      {R4,PC}          ;; return
    197          
    198          /**
    199            * @brief  Fills each LCD_InitStruct member with its default value.
    200            * @param  LCD_InitStruct: pointer to a LCD_InitTypeDef structure which will 
    201            *         be initialized.
    202            * @retval None
    203            */

   \                                 In section .text, align 2, keep-with-next
    204          void LCD_StructInit(LCD_InitTypeDef* LCD_InitStruct)
    205          {
    206          /*--------------- Reset LCD init structure parameters values -----------------*/
    207            LCD_InitStruct->LCD_Prescaler = LCD_Prescaler_1; /*!< Initialize the LCD_Prescaler member */
   \                     LCD_StructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    208            
    209            LCD_InitStruct->LCD_Divider = LCD_Divider_16; /*!< Initialize the LCD_Divider member */
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6041             STR      R1,[R0, #+4]
    210            
    211            LCD_InitStruct->LCD_Duty = LCD_Duty_Static; /*!< Initialize the LCD_Duty member */
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6081             STR      R1,[R0, #+8]
    212            
    213            LCD_InitStruct->LCD_Bias = LCD_Bias_1_4; /*!< Initialize the LCD_Bias member */
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x60C1             STR      R1,[R0, #+12]
    214            
    215            LCD_InitStruct->LCD_VoltageSource = LCD_VoltageSource_Internal; /*!< Initialize the LCD_VoltageSource member */
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6101             STR      R1,[R0, #+16]
    216          }
   \   00000014   0x4770             BX       LR               ;; return
    217          
    218          /**
    219            * @brief  Enables or disables the LCD Controller.
    220            * @param  NewState: new state of the LCD peripheral.
    221            *   This parameter can be: ENABLE or DISABLE.
    222            * @retval None
    223            */

   \                                 In section .text, align 2, keep-with-next
    224          void LCD_Cmd(FunctionalState NewState)
    225          {
   \                     LCD_Cmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    226            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??LCD_Cmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD004             BEQ.N    ??LCD_Cmd_0
   \   00000010   0x21E2             MOVS     R1,#+226
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable15
   \   00000016   0x.... 0x....      BL       assert_failed
    227          
    228            /* Check the parameters */
    229            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??LCD_Cmd_0: (+1)
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD007             BEQ.N    ??LCD_Cmd_1
   \   00000020   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000022   0x2C01             CMP      R4,#+1
   \   00000024   0xD004             BEQ.N    ??LCD_Cmd_1
   \   00000026   0x21E5             MOVS     R1,#+229
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable15
   \   0000002C   0x.... 0x....      BL       assert_failed
    230          
    231            *(__IO uint32_t *) CR_LCDEN_BB = (uint32_t)NewState;
   \                     ??LCD_Cmd_1: (+1)
   \   00000030   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable15_3  ;; 0x42048000
   \   00000036   0x6004             STR      R4,[R0, #+0]
    232          }
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
    233          
    234          /**
    235            * @brief  Waits until the LCD FCR register is synchronized in the LCDCLK domain.
    236            *   This function must be called after any write operation to LCD_FCR register.
    237            * @param  None
    238            * @retval None
    239            */

   \                                 In section .text, align 2, keep-with-next
    240          void LCD_WaitForSynchro(void)
    241          {
    242            /* Loop until FCRSF flag is set */
    243            while ((LCD->SR & LCD_FLAG_FCRSF) == (uint32_t)RESET)
   \                     LCD_WaitForSynchro: (+1)
   \                     ??LCD_WaitForSynchro_0: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable15_4  ;; 0x40002408
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x0680             LSLS     R0,R0,#+26
   \   00000008   0xD5FA             BPL.N    ??LCD_WaitForSynchro_0
    244            {
    245            }
    246          }
   \   0000000A   0x4770             BX       LR               ;; return
    247          
    248          /**
    249            * @brief  Enables or disables the low resistance divider. Displays with high 
    250            *         internal resistance may need a longer drive time to achieve 
    251            *         satisfactory contrast. This function is useful in this case if some 
    252            *         additional power consumption can be tolerated.
    253            * @note   When this mode is enabled, the PulseOn Duration (PON) have to be 
    254            *         programmed to 1/CK_PS (LCD_PulseOnDuration_1).    
    255            * @param  NewState: new state of the low resistance divider.
    256            *   This parameter can be: ENABLE or DISABLE.
    257            * @retval None
    258            */

   \                                 In section .text, align 2, keep-with-next
    259          void LCD_HighDriveCmd(FunctionalState NewState)
    260          {
   \                     LCD_HighDriveCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    261            /* Check the parameters */
    262            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD008             BEQ.N    ??LCD_HighDriveCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD005             BEQ.N    ??LCD_HighDriveCmd_0
   \   00000010   0xF44F 0x7183      MOV      R1,#+262
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable15
   \   00000018   0x.... 0x....      BL       assert_failed
    263          
    264            *(__IO uint32_t *) FCR_HD_BB = (uint32_t)NewState;
   \                     ??LCD_HighDriveCmd_0: (+1)
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable15_5  ;; 0x42048080
   \   00000022   0x6004             STR      R4,[R0, #+0]
    265          }
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    266          
    267          /**
    268            * @brief  Enables or disables the Mux Segment.
    269            * @note   This function can be used only when the LCD is disabled.  
    270            * @param  NewState: new state of the Mux Segment.
    271            *   This parameter can be: ENABLE or DISABLE.
    272            * @retval None
    273            */

   \                                 In section .text, align 2, keep-with-next
    274          void LCD_MuxSegmentCmd(FunctionalState NewState)
    275          {
   \                     LCD_MuxSegmentCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    276            /* Check the parameters */
    277            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??LCD_MuxSegmentCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD004             BEQ.N    ??LCD_MuxSegmentCmd_0
   \   00000010   0xF240 0x1115      MOVW     R1,#+277
   \   00000014   0x....             LDR.N    R0,??DataTable15
   \   00000016   0x.... 0x....      BL       assert_failed
    278          
    279            *(__IO uint32_t *) CR_MUX_SEG_BB = (uint32_t)NewState;
   \                     ??LCD_MuxSegmentCmd_0: (+1)
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable15_6  ;; 0x4204801c
   \   00000020   0x6004             STR      R4,[R0, #+0]
    280          }
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    281          
    282          /**
    283            * @brief  Configures the LCD pulses on duration.
    284            * @param  LCD_PulseOnDuration: specifies the LCD pulse on duration in terms of 
    285            *         CK_PS (prescaled LCD clock period) pulses.
    286            *   This parameter can be one of the following values:
    287            *     @arg LCD_PulseOnDuration_0: 0 pulse
    288            *     @arg LCD_PulseOnDuration_1: Pulse ON duration = 1/CK_PS
    289            *     @arg LCD_PulseOnDuration_2: Pulse ON duration = 2/CK_PS
    290            *     @arg LCD_PulseOnDuration_3: Pulse ON duration = 3/CK_PS
    291            *     @arg LCD_PulseOnDuration_4: Pulse ON duration = 4/CK_PS
    292            *     @arg LCD_PulseOnDuration_5: Pulse ON duration = 5/CK_PS
    293            *     @arg LCD_PulseOnDuration_6: Pulse ON duration = 6/CK_PS
    294            *     @arg LCD_PulseOnDuration_7: Pulse ON duration = 7/CK_PS
    295            * @retval None
    296            */

   \                                 In section .text, align 2, keep-with-next
    297          void LCD_PulseOnDurationConfig(uint32_t LCD_PulseOnDuration)
    298          {
   \                     LCD_PulseOnDurationConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    299            /* Check the parameters */
    300            assert_param(IS_LCD_PULSE_ON_DURATION(LCD_PulseOnDuration));
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD012             BEQ.N    ??LCD_PulseOnDurationConfig_0
   \   00000008   0x2C10             CMP      R4,#+16
   \   0000000A   0xD010             BEQ.N    ??LCD_PulseOnDurationConfig_0
   \   0000000C   0x2C20             CMP      R4,#+32
   \   0000000E   0xD00E             BEQ.N    ??LCD_PulseOnDurationConfig_0
   \   00000010   0x2C30             CMP      R4,#+48
   \   00000012   0xD00C             BEQ.N    ??LCD_PulseOnDurationConfig_0
   \   00000014   0x2C40             CMP      R4,#+64
   \   00000016   0xD00A             BEQ.N    ??LCD_PulseOnDurationConfig_0
   \   00000018   0x2C50             CMP      R4,#+80
   \   0000001A   0xD008             BEQ.N    ??LCD_PulseOnDurationConfig_0
   \   0000001C   0x2C60             CMP      R4,#+96
   \   0000001E   0xD006             BEQ.N    ??LCD_PulseOnDurationConfig_0
   \   00000020   0x2C70             CMP      R4,#+112
   \   00000022   0xD004             BEQ.N    ??LCD_PulseOnDurationConfig_0
   \   00000024   0xF44F 0x7196      MOV      R1,#+300
   \   00000028   0x....             LDR.N    R0,??DataTable15
   \   0000002A   0x.... 0x....      BL       assert_failed
    301          
    302            LCD->FCR &= (uint32_t)PON_MASK;
   \                     ??LCD_PulseOnDurationConfig_0: (+1)
   \   0000002E   0x....             LDR.N    R0,??DataTable15_1  ;; 0x40002404
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0xF030 0x0070      BICS     R0,R0,#0x70
   \   00000036   0x....             LDR.N    R1,??DataTable15_1  ;; 0x40002404
   \   00000038   0x6008             STR      R0,[R1, #+0]
    303            LCD->FCR |= (uint32_t)(LCD_PulseOnDuration);
   \   0000003A   0x....             LDR.N    R0,??DataTable15_1  ;; 0x40002404
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x4320             ORRS     R0,R4,R0
   \   00000040   0x....             LDR.N    R1,??DataTable15_1  ;; 0x40002404
   \   00000042   0x6008             STR      R0,[R1, #+0]
    304          }
   \   00000044   0xBD10             POP      {R4,PC}          ;; return
    305          
    306          /**
    307            * @brief  Configures the LCD dead time.
    308            * @param  LCD_DeadTime: specifies the LCD dead time.
    309            *   This parameter can be one of the following values:
    310            *     @arg LCD_DeadTime_0: No dead Time
    311            *     @arg LCD_DeadTime_1: One Phase between different couple of Frame
    312            *     @arg LCD_DeadTime_2: Two Phase between different couple of Frame
    313            *     @arg LCD_DeadTime_3: Three Phase between different couple of Frame
    314            *     @arg LCD_DeadTime_4: Four Phase between different couple of Frame
    315            *     @arg LCD_DeadTime_5: Five Phase between different couple of Frame
    316            *     @arg LCD_DeadTime_6: Six Phase between different couple of Frame 
    317            *     @arg LCD_DeadTime_7: Seven Phase between different couple of Frame
    318            * @retval None
    319            */

   \                                 In section .text, align 2, keep-with-next
    320          void LCD_DeadTimeConfig(uint32_t LCD_DeadTime)
    321          {
   \                     LCD_DeadTimeConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    322            /* Check the parameters */
    323            assert_param(IS_LCD_DEAD_TIME(LCD_DeadTime));
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD018             BEQ.N    ??LCD_DeadTimeConfig_0
   \   00000008   0x2C80             CMP      R4,#+128
   \   0000000A   0xD016             BEQ.N    ??LCD_DeadTimeConfig_0
   \   0000000C   0xF5B4 0x7F80      CMP      R4,#+256
   \   00000010   0xD013             BEQ.N    ??LCD_DeadTimeConfig_0
   \   00000012   0xF5B4 0x7FC0      CMP      R4,#+384
   \   00000016   0xD010             BEQ.N    ??LCD_DeadTimeConfig_0
   \   00000018   0xF5B4 0x7F00      CMP      R4,#+512
   \   0000001C   0xD00D             BEQ.N    ??LCD_DeadTimeConfig_0
   \   0000001E   0xF5B4 0x7F20      CMP      R4,#+640
   \   00000022   0xD00A             BEQ.N    ??LCD_DeadTimeConfig_0
   \   00000024   0xF5B4 0x7F40      CMP      R4,#+768
   \   00000028   0xD007             BEQ.N    ??LCD_DeadTimeConfig_0
   \   0000002A   0xF5B4 0x7F60      CMP      R4,#+896
   \   0000002E   0xD004             BEQ.N    ??LCD_DeadTimeConfig_0
   \   00000030   0xF240 0x1143      MOVW     R1,#+323
   \   00000034   0x....             LDR.N    R0,??DataTable15
   \   00000036   0x.... 0x....      BL       assert_failed
    324          
    325            LCD->FCR &= (uint32_t)DEAD_MASK;
   \                     ??LCD_DeadTimeConfig_0: (+1)
   \   0000003A   0x....             LDR.N    R0,??DataTable15_1  ;; 0x40002404
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0xF430 0x7060      BICS     R0,R0,#0x380
   \   00000042   0x....             LDR.N    R1,??DataTable15_1  ;; 0x40002404
   \   00000044   0x6008             STR      R0,[R1, #+0]
    326            LCD->FCR |= (uint32_t)(LCD_DeadTime);
   \   00000046   0x....             LDR.N    R0,??DataTable15_1  ;; 0x40002404
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x4320             ORRS     R0,R4,R0
   \   0000004C   0x....             LDR.N    R1,??DataTable15_1  ;; 0x40002404
   \   0000004E   0x6008             STR      R0,[R1, #+0]
    327          }
   \   00000050   0xBD10             POP      {R4,PC}          ;; return
    328          
    329          /**
    330            * @brief  Configures the LCD Blink mode and Blink frequency.
    331            * @param  LCD_BlinkMode: specifies the LCD blink mode.
    332            *   This parameter can be one of the following values:
    333            *     @arg LCD_BlinkMode_Off:           Blink disabled
    334            *     @arg LCD_BlinkMode_SEG0_COM0:     Blink enabled on SEG[0], COM[0] (1 pixel)
    335            *     @arg LCD_BlinkMode_SEG0_AllCOM:   Blink enabled on SEG[0], all COM (up to 8 
    336            *                                       pixels according to the programmed duty)
    337            *     @arg LCD_BlinkMode_AllSEG_AllCOM: Blink enabled on all SEG and all COM 
    338            *                                       (all pixels)
    339            * @param  LCD_BlinkFrequency: specifies the LCD blink frequency.
    340            *   This parameter can be one of the following values:
    341            *     @arg LCD_BlinkFrequency_Div8:    The Blink frequency = fLcd/8
    342            *     @arg LCD_BlinkFrequency_Div16:   The Blink frequency = fLcd/16
    343            *     @arg LCD_BlinkFrequency_Div32:   The Blink frequency = fLcd/32
    344            *     @arg LCD_BlinkFrequency_Div64:   The Blink frequency = fLcd/64 
    345            *     @arg LCD_BlinkFrequency_Div128:  The Blink frequency = fLcd/128
    346            *     @arg LCD_BlinkFrequency_Div256:  The Blink frequency = fLcd/256
    347            *     @arg LCD_BlinkFrequency_Div512:  The Blink frequency = fLcd/512
    348            *     @arg LCD_BlinkFrequency_Div1024: The Blink frequency = fLcd/1024
    349            * @retval None
    350            */

   \                                 In section .text, align 2, keep-with-next
    351          void LCD_BlinkConfig(uint32_t LCD_BlinkMode, uint32_t LCD_BlinkFrequency)
    352          {
   \                     LCD_BlinkConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    353            /* Check the parameters */
    354            assert_param(IS_LCD_BLINK_MODE(LCD_BlinkMode));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD00D             BEQ.N    ??LCD_BlinkConfig_0
   \   0000000A   0xF5B4 0x3F80      CMP      R4,#+65536
   \   0000000E   0xD00A             BEQ.N    ??LCD_BlinkConfig_0
   \   00000010   0xF5B4 0x3F00      CMP      R4,#+131072
   \   00000014   0xD007             BEQ.N    ??LCD_BlinkConfig_0
   \   00000016   0xF5B4 0x3F40      CMP      R4,#+196608
   \   0000001A   0xD004             BEQ.N    ??LCD_BlinkConfig_0
   \   0000001C   0xF44F 0x71B1      MOV      R1,#+354
   \   00000020   0x....             LDR.N    R0,??DataTable15
   \   00000022   0x.... 0x....      BL       assert_failed
    355            assert_param(IS_LCD_BLINK_FREQUENCY(LCD_BlinkFrequency));
   \                     ??LCD_BlinkConfig_0: (+1)
   \   00000026   0x2D00             CMP      R5,#+0
   \   00000028   0xD019             BEQ.N    ??LCD_BlinkConfig_1
   \   0000002A   0xF5B5 0x5F00      CMP      R5,#+8192
   \   0000002E   0xD016             BEQ.N    ??LCD_BlinkConfig_1
   \   00000030   0xF5B5 0x4F80      CMP      R5,#+16384
   \   00000034   0xD013             BEQ.N    ??LCD_BlinkConfig_1
   \   00000036   0xF5B5 0x4FC0      CMP      R5,#+24576
   \   0000003A   0xD010             BEQ.N    ??LCD_BlinkConfig_1
   \   0000003C   0xF5B5 0x4F00      CMP      R5,#+32768
   \   00000040   0xD00D             BEQ.N    ??LCD_BlinkConfig_1
   \   00000042   0xF5B5 0x4F20      CMP      R5,#+40960
   \   00000046   0xD00A             BEQ.N    ??LCD_BlinkConfig_1
   \   00000048   0xF5B5 0x4F40      CMP      R5,#+49152
   \   0000004C   0xD007             BEQ.N    ??LCD_BlinkConfig_1
   \   0000004E   0xF5B5 0x4F60      CMP      R5,#+57344
   \   00000052   0xD004             BEQ.N    ??LCD_BlinkConfig_1
   \   00000054   0xF240 0x1163      MOVW     R1,#+355
   \   00000058   0x....             LDR.N    R0,??DataTable15
   \   0000005A   0x.... 0x....      BL       assert_failed
    356            
    357            LCD->FCR &= (uint32_t)BLINK_MASK;
   \                     ??LCD_BlinkConfig_1: (+1)
   \   0000005E   0x....             LDR.N    R0,??DataTable15_1  ;; 0x40002404
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0xF430 0x3078      BICS     R0,R0,#0x3E000
   \   00000066   0x....             LDR.N    R1,??DataTable15_1  ;; 0x40002404
   \   00000068   0x6008             STR      R0,[R1, #+0]
    358            LCD->FCR |= (uint32_t)(LCD_BlinkMode | LCD_BlinkFrequency);
   \   0000006A   0x....             LDR.N    R0,??DataTable15_1  ;; 0x40002404
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0xEA55 0x0104      ORRS     R1,R5,R4
   \   00000072   0x4308             ORRS     R0,R1,R0
   \   00000074   0x....             LDR.N    R1,??DataTable15_1  ;; 0x40002404
   \   00000076   0x6008             STR      R0,[R1, #+0]
    359          }
   \   00000078   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    360          
    361          /**
    362            * @brief  Configures the LCD Contrast.
    363            * @param  LCD_Contrast: specifies the LCD Contrast.
    364            *   This parameter can be one of the following values:
    365            *     @arg LCD_Contrast_Level_0: Maximum Voltage = 2.60V
    366            *     @arg LCD_Contrast_Level_1: Maximum Voltage = 2.73V
    367            *     @arg LCD_Contrast_Level_2: Maximum Voltage = 2.86V
    368            *     @arg LCD_Contrast_Level_3: Maximum Voltage = 2.99V
    369            *     @arg LCD_Contrast_Level_4: Maximum Voltage = 3.12V
    370            *     @arg LCD_Contrast_Level_5: Maximum Voltage = 3.25V
    371            *     @arg LCD_Contrast_Level_6: Maximum Voltage = 3.38V
    372            *     @arg LCD_Contrast_Level_7: Maximum Voltage = 3.51V
    373            * @retval None
    374            */

   \                                 In section .text, align 2, keep-with-next
    375          void LCD_ContrastConfig(uint32_t LCD_Contrast)
    376          {
   \                     LCD_ContrastConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    377            /* Check the parameters */
    378            assert_param(IS_LCD_CONTRAST(LCD_Contrast));
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD019             BEQ.N    ??LCD_ContrastConfig_0
   \   00000008   0xF5B4 0x6F80      CMP      R4,#+1024
   \   0000000C   0xD016             BEQ.N    ??LCD_ContrastConfig_0
   \   0000000E   0xF5B4 0x6F00      CMP      R4,#+2048
   \   00000012   0xD013             BEQ.N    ??LCD_ContrastConfig_0
   \   00000014   0xF5B4 0x6F40      CMP      R4,#+3072
   \   00000018   0xD010             BEQ.N    ??LCD_ContrastConfig_0
   \   0000001A   0xF5B4 0x5F80      CMP      R4,#+4096
   \   0000001E   0xD00D             BEQ.N    ??LCD_ContrastConfig_0
   \   00000020   0xF5B4 0x5FA0      CMP      R4,#+5120
   \   00000024   0xD00A             BEQ.N    ??LCD_ContrastConfig_0
   \   00000026   0xF5B4 0x5FC0      CMP      R4,#+6144
   \   0000002A   0xD007             BEQ.N    ??LCD_ContrastConfig_0
   \   0000002C   0xF5B4 0x5FE0      CMP      R4,#+7168
   \   00000030   0xD004             BEQ.N    ??LCD_ContrastConfig_0
   \   00000032   0xF44F 0x71BD      MOV      R1,#+378
   \   00000036   0x....             LDR.N    R0,??DataTable15
   \   00000038   0x.... 0x....      BL       assert_failed
    379          
    380            LCD->FCR &= (uint32_t)CONTRAST_MASK;
   \                     ??LCD_ContrastConfig_0: (+1)
   \   0000003C   0x....             LDR.N    R0,??DataTable15_1  ;; 0x40002404
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0xF430 0x50E0      BICS     R0,R0,#0x1C00
   \   00000044   0x....             LDR.N    R1,??DataTable15_1  ;; 0x40002404
   \   00000046   0x6008             STR      R0,[R1, #+0]
    381            LCD->FCR |= (uint32_t)(LCD_Contrast);
   \   00000048   0x....             LDR.N    R0,??DataTable15_1  ;; 0x40002404
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x4320             ORRS     R0,R4,R0
   \   0000004E   0x....             LDR.N    R1,??DataTable15_1  ;; 0x40002404
   \   00000050   0x6008             STR      R0,[R1, #+0]
    382          }
   \   00000052   0xBD10             POP      {R4,PC}          ;; return
    383          
    384          /**
    385            * @}
    386            */
    387          
    388          /** @defgroup LCD_Group2  LCD RAM memory write functions
    389           *  @brief    LCD RAM memory write functions 
    390           *
    391          @verbatim   
    392           ===============================================================================
    393                                     LCD RAM memory write functions
    394           ===============================================================================  
    395          
    396           Using its double buffer memory the LCD controller ensures the coherency of the 
    397           displayed information without having to use interrupts to control LCD_RAM 
    398           modification.
    399           The application software can access the first buffer level (LCD_RAM) through 
    400           the APB interface. Once it has modified the LCD_RAM, it sets the UDR flag in 
    401           the LCD_SR register using the LCD_UpdateDisplayRequest() function.
    402           This UDR flag (update display request) requests the updated information to be 
    403           moved into the second buffer level (LCD_DISPLAY).
    404           This operation is done synchronously with the frame (at the beginning of the 
    405           next frame), until the update is completed, the LCD_RAM is write protected and 
    406           the UDR flag stays high.
    407           Once the update is completed another flag (UDD - Update Display Done) is set and
    408           generates an interrupt if the UDDIE bit in the LCD_FCR register is set.
    409           The time it takes to update LCD_DISPLAY is, in the worst case, one odd and one 
    410           even frame.
    411           The update will not occur (UDR = 1 and UDD = 0) until the display is 
    412           enabled (LCDEN = 1).
    413          
    414          @endverbatim
    415            * @{
    416            */
    417          
    418          /**
    419            * @brief  Writes a word in the specific LCD RAM.
    420            * @param  LCD_RAMRegister: specifies the LCD Contrast.
    421            *   This parameter can be one of the following values:
    422            *     @arg LCD_RAMRegister_0: LCD RAM Register 0
    423            *     @arg LCD_RAMRegister_1: LCD RAM Register 1
    424            *     @arg LCD_RAMRegister_2: LCD RAM Register 2
    425            *     @arg LCD_RAMRegister_3: LCD RAM Register 3
    426            *     @arg LCD_RAMRegister_4: LCD RAM Register 4
    427            *     @arg LCD_RAMRegister_5: LCD RAM Register 5
    428            *     @arg LCD_RAMRegister_6: LCD RAM Register 6 
    429            *     @arg LCD_RAMRegister_7: LCD RAM Register 7  
    430            *     @arg LCD_RAMRegister_8: LCD RAM Register 8
    431            *     @arg LCD_RAMRegister_9: LCD RAM Register 9
    432            *     @arg LCD_RAMRegister_10: LCD RAM Register 10
    433            *     @arg LCD_RAMRegister_11: LCD RAM Register 11
    434            *     @arg LCD_RAMRegister_12: LCD RAM Register 12 
    435            *     @arg LCD_RAMRegister_13: LCD RAM Register 13 
    436            *     @arg LCD_RAMRegister_14: LCD RAM Register 14 
    437            *     @arg LCD_RAMRegister_15: LCD RAM Register 15 
    438            * @param  LCD_Data: specifies LCD Data Value to be written.
    439            * @retval None
    440            */

   \                                 In section .text, align 2, keep-with-next
    441          void LCD_Write(uint32_t LCD_RAMRegister, uint32_t LCD_Data)
    442          {
   \                     LCD_Write: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    443            /* Check the parameters */
    444            assert_param(IS_LCD_RAM_REGISTER(LCD_RAMRegister));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD022             BEQ.N    ??LCD_Write_0
   \   0000000A   0x2C01             CMP      R4,#+1
   \   0000000C   0xD020             BEQ.N    ??LCD_Write_0
   \   0000000E   0x2C02             CMP      R4,#+2
   \   00000010   0xD01E             BEQ.N    ??LCD_Write_0
   \   00000012   0x2C03             CMP      R4,#+3
   \   00000014   0xD01C             BEQ.N    ??LCD_Write_0
   \   00000016   0x2C04             CMP      R4,#+4
   \   00000018   0xD01A             BEQ.N    ??LCD_Write_0
   \   0000001A   0x2C05             CMP      R4,#+5
   \   0000001C   0xD018             BEQ.N    ??LCD_Write_0
   \   0000001E   0x2C06             CMP      R4,#+6
   \   00000020   0xD016             BEQ.N    ??LCD_Write_0
   \   00000022   0x2C07             CMP      R4,#+7
   \   00000024   0xD014             BEQ.N    ??LCD_Write_0
   \   00000026   0x2C08             CMP      R4,#+8
   \   00000028   0xD012             BEQ.N    ??LCD_Write_0
   \   0000002A   0x2C09             CMP      R4,#+9
   \   0000002C   0xD010             BEQ.N    ??LCD_Write_0
   \   0000002E   0x2C0A             CMP      R4,#+10
   \   00000030   0xD00E             BEQ.N    ??LCD_Write_0
   \   00000032   0x2C0B             CMP      R4,#+11
   \   00000034   0xD00C             BEQ.N    ??LCD_Write_0
   \   00000036   0x2C0C             CMP      R4,#+12
   \   00000038   0xD00A             BEQ.N    ??LCD_Write_0
   \   0000003A   0x2C0D             CMP      R4,#+13
   \   0000003C   0xD008             BEQ.N    ??LCD_Write_0
   \   0000003E   0x2C0E             CMP      R4,#+14
   \   00000040   0xD006             BEQ.N    ??LCD_Write_0
   \   00000042   0x2C0F             CMP      R4,#+15
   \   00000044   0xD004             BEQ.N    ??LCD_Write_0
   \   00000046   0xF44F 0x71DE      MOV      R1,#+444
   \   0000004A   0x....             LDR.N    R0,??DataTable15
   \   0000004C   0x.... 0x....      BL       assert_failed
    445          
    446            /* Copy data bytes to RAM register */
    447            LCD->RAM[LCD_RAMRegister] = (uint32_t)LCD_Data;
   \                     ??LCD_Write_0: (+1)
   \   00000050   0x....             LDR.N    R0,??DataTable15_7  ;; 0x40002414
   \   00000052   0xF840 0x5024      STR      R5,[R0, R4, LSL #+2]
    448          }
   \   00000056   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    449          
    450          /**
    451            * @brief  Enables the Update Display Request.
    452            * @note   Each time software modifies the LCD_RAM it must set the UDR bit to 
    453            *         transfer the updated data to the second level buffer. 
    454            *         The UDR bit stays set until the end of the update and during this 
    455            *         time the LCD_RAM is write protected. 
    456            * @note   When the display is disabled, the update is performed for all 
    457            *         LCD_DISPLAY locations.
    458            *         When the display is enabled, the update is performed only for locations 
    459            *         for which commons are active (depending on DUTY). For example if 
    460            *         DUTY = 1/2, only the LCD_DISPLAY of COM0 and COM1 will be updated.    
    461            * @param  None
    462            * @retval None
    463            */

   \                                 In section .text, align 2, keep-with-next
    464          void LCD_UpdateDisplayRequest(void)
    465          {
    466            *(__IO uint32_t *) SR_UDR_BB = (uint32_t)0x01;
   \                     LCD_UpdateDisplayRequest: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x....             LDR.N    R1,??DataTable15_8  ;; 0x42048108
   \   00000004   0x6008             STR      R0,[R1, #+0]
    467          }
   \   00000006   0x4770             BX       LR               ;; return
    468          
    469          /**
    470            * @}
    471            */
    472          
    473          /** @defgroup LCD_Group3 Interrupts and flags management functions
    474           *  @brief   Interrupts and flags management functions 
    475           *
    476          @verbatim   
    477           ===============================================================================
    478                             Interrupts and flags management functions
    479           ===============================================================================  
    480          
    481          @endverbatim
    482            * @{
    483            */
    484          
    485          /**
    486            * @brief  Enables or disables the specified LCD interrupts.
    487            * @param  LCD_IT: specifies the LCD interrupts sources to be enabled or disabled.
    488            *   This parameter can be any combination of the following values:
    489            *     @arg LCD_IT_SOF: Start of Frame Interrupt
    490            *     @arg LCD_IT_UDD: Update Display Done Interrupt
    491            * @param NewState: new state of the specified LCD interrupts.
    492            *   This parameter can be: ENABLE or DISABLE.
    493            * @retval None
    494            */

   \                                 In section .text, align 2, keep-with-next
    495          void LCD_ITConfig(uint32_t LCD_IT, FunctionalState NewState)
    496          {
   \                     LCD_ITConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    497            /* Check the parameters */
    498            assert_param(IS_LCD_IT(LCD_IT));  
   \   00000006   0xF034 0x000A      BICS     R0,R4,#0xA
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE.N    ??LCD_ITConfig_0
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD104             BNE.N    ??LCD_ITConfig_1
   \                     ??LCD_ITConfig_0: (+1)
   \   00000012   0xF44F 0x71F9      MOV      R1,#+498
   \   00000016   0x....             LDR.N    R0,??DataTable15
   \   00000018   0x.... 0x....      BL       assert_failed
    499            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??LCD_ITConfig_1: (+1)
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD007             BEQ.N    ??LCD_ITConfig_2
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D01             CMP      R5,#+1
   \   00000026   0xD004             BEQ.N    ??LCD_ITConfig_2
   \   00000028   0xF240 0x11F3      MOVW     R1,#+499
   \   0000002C   0x....             LDR.N    R0,??DataTable15
   \   0000002E   0x.... 0x....      BL       assert_failed
    500            
    501            if (NewState != DISABLE)
   \                     ??LCD_ITConfig_2: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD005             BEQ.N    ??LCD_ITConfig_3
    502            {
    503              LCD->FCR |= LCD_IT;
   \   00000038   0x....             LDR.N    R0,??DataTable15_1  ;; 0x40002404
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x4320             ORRS     R0,R4,R0
   \   0000003E   0x....             LDR.N    R1,??DataTable15_1  ;; 0x40002404
   \   00000040   0x6008             STR      R0,[R1, #+0]
   \   00000042   0xE004             B.N      ??LCD_ITConfig_4
    504            }
    505            else
    506            {
    507              LCD->FCR &= (uint32_t)~LCD_IT;
   \                     ??LCD_ITConfig_3: (+1)
   \   00000044   0x....             LDR.N    R0,??DataTable15_1  ;; 0x40002404
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0x43A0             BICS     R0,R0,R4
   \   0000004A   0x....             LDR.N    R1,??DataTable15_1  ;; 0x40002404
   \   0000004C   0x6008             STR      R0,[R1, #+0]
    508            }
    509          }
   \                     ??LCD_ITConfig_4: (+1)
   \   0000004E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    510          
    511          /**
    512            * @brief  Checks whether the specified LCD flag is set or not.
    513            * @param  LCD_FLAG: specifies the flag to check.
    514            *   This parameter can be one of the following values:
    515            *     @arg LCD_FLAG_ENS: LCD Enabled flag. It indicates the LCD controller status.
    516            *      @note  The ENS bit is set immediately when the LCDEN bit in the LCD_CR 
    517            *             goes from 0 to 1. On deactivation it reflects the real status of 
    518            *             LCD so it becomes 0 at the end of the last displayed frame.  
    519            *     @arg LCD_FLAG_SOF: Start of Frame flag. This flag is set by hardware at 
    520            *       the beginning of a new frame, at the same time as the display data is 
    521            *       updated.
    522            *     @arg LCD_FLAG_UDR: Update Display Request flag.
    523            *     @arg LCD_FLAG_UDD: Update Display Done flag. 
    524            *     @arg LCD_FLAG_RDY: Step_up converter Ready flag. It indicates the status 
    525            *                        of the step-up converter.
    526            *     @arg LCD_FLAG_FCRSF: LCD Frame Control Register Synchronization Flag. 
    527            *       This flag is set by hardware each time the LCD_FCR register is updated 
    528            *       in the LCDCLK domain.   
    529            * @retval The new state of LCD_FLAG (SET or RESET).
    530            */

   \                                 In section .text, align 2, keep-with-next
    531          FlagStatus LCD_GetFlagStatus(uint32_t LCD_FLAG)
    532          {
   \                     LCD_GetFlagStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    533            FlagStatus bitstatus = RESET;
   \   00000004   0x2500             MOVS     R5,#+0
    534            
    535            /* Check the parameters */
    536            assert_param(IS_LCD_GET_FLAG(LCD_FLAG));
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD00E             BEQ.N    ??LCD_GetFlagStatus_0
   \   0000000A   0x2C02             CMP      R4,#+2
   \   0000000C   0xD00C             BEQ.N    ??LCD_GetFlagStatus_0
   \   0000000E   0x2C04             CMP      R4,#+4
   \   00000010   0xD00A             BEQ.N    ??LCD_GetFlagStatus_0
   \   00000012   0x2C08             CMP      R4,#+8
   \   00000014   0xD008             BEQ.N    ??LCD_GetFlagStatus_0
   \   00000016   0x2C10             CMP      R4,#+16
   \   00000018   0xD006             BEQ.N    ??LCD_GetFlagStatus_0
   \   0000001A   0x2C20             CMP      R4,#+32
   \   0000001C   0xD004             BEQ.N    ??LCD_GetFlagStatus_0
   \   0000001E   0xF44F 0x7106      MOV      R1,#+536
   \   00000022   0x....             LDR.N    R0,??DataTable15
   \   00000024   0x.... 0x....      BL       assert_failed
    537            
    538            if ((LCD->SR & LCD_FLAG) != (uint32_t)RESET)
   \                     ??LCD_GetFlagStatus_0: (+1)
   \   00000028   0x....             LDR.N    R0,??DataTable15_4  ;; 0x40002408
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x4220             TST      R0,R4
   \   0000002E   0xD002             BEQ.N    ??LCD_GetFlagStatus_1
    539            {
    540              bitstatus = SET;
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x0005             MOVS     R5,R0
   \   00000034   0xE001             B.N      ??LCD_GetFlagStatus_2
    541            }
    542            else
    543            {
    544              bitstatus = RESET;
   \                     ??LCD_GetFlagStatus_1: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x0005             MOVS     R5,R0
    545            }
    546            return bitstatus;
   \                     ??LCD_GetFlagStatus_2: (+1)
   \   0000003A   0x0028             MOVS     R0,R5
   \   0000003C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    547          }
    548          
    549          /**
    550            * @brief  Clears the LCD's pending flags.
    551            * @param  LCD_FLAG: specifies the flag to clear.
    552            *   This parameter can be any combination of the following values:
    553            *     @arg LCD_FLAG_SOF: Start of Frame Interrupt
    554            *     @arg LCD_FLAG_UDD: Update Display Done Interrupt
    555            * @retval None
    556            */

   \                                 In section .text, align 2, keep-with-next
    557          void LCD_ClearFlag(uint32_t LCD_FLAG)
    558          {
   \                     LCD_ClearFlag: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    559            /* Check the parameters */
    560            assert_param(IS_LCD_CLEAR_FLAG(LCD_FLAG));
   \   00000004   0xF034 0x000A      BICS     R0,R4,#0xA
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD101             BNE.N    ??LCD_ClearFlag_0
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD104             BNE.N    ??LCD_ClearFlag_1
   \                     ??LCD_ClearFlag_0: (+1)
   \   00000010   0xF44F 0x710C      MOV      R1,#+560
   \   00000014   0x....             LDR.N    R0,??DataTable15
   \   00000016   0x.... 0x....      BL       assert_failed
    561              
    562            /* Clear the corresponding LCD flag */
    563            LCD->CLR = (uint32_t)LCD_FLAG;
   \                     ??LCD_ClearFlag_1: (+1)
   \   0000001A   0x....             LDR.N    R0,??DataTable15_9  ;; 0x4000240c
   \   0000001C   0x6004             STR      R4,[R0, #+0]
    564          }
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    565          
    566          /**
    567            * @brief  Checks whether the specified RTC interrupt has occurred or not.
    568            * @param  RTC_IT: specifies the RTC interrupts sources to check.
    569            *   This parameter can be one of the following values:
    570            *     @arg LCD_IT_SOF: Start of Frame Interrupt
    571            *     @arg LCD_IT_UDD: Update Display Done Interrupt.
    572            *     @note If the device is in STOP mode (PCLK not provided) UDD will not 
    573            *          generate an interrupt even if UDDIE = 1. 
    574            *          If the display is not enabled the UDD interrupt will never occur.    
    575            * @retval The new state of the LCD_IT (SET or RESET).
    576            */

   \                                 In section .text, align 2, keep-with-next
    577          ITStatus LCD_GetITStatus(uint32_t LCD_IT)
    578          {
   \                     LCD_GetITStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    579            ITStatus bitstatus = RESET;
   \   00000004   0x2500             MOVS     R5,#+0
    580            
    581            /* Check the parameters */
    582            assert_param(IS_LCD_GET_IT(LCD_IT));
   \   00000006   0x2C02             CMP      R4,#+2
   \   00000008   0xD006             BEQ.N    ??LCD_GetITStatus_0
   \   0000000A   0x2C08             CMP      R4,#+8
   \   0000000C   0xD004             BEQ.N    ??LCD_GetITStatus_0
   \   0000000E   0xF240 0x2146      MOVW     R1,#+582
   \   00000012   0x....             LDR.N    R0,??DataTable15
   \   00000014   0x.... 0x....      BL       assert_failed
    583              
    584            if ((LCD->SR & LCD_IT) != (uint16_t)RESET) 
   \                     ??LCD_GetITStatus_0: (+1)
   \   00000018   0x....             LDR.N    R0,??DataTable15_4  ;; 0x40002408
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x4220             TST      R0,R4
   \   0000001E   0xD002             BEQ.N    ??LCD_GetITStatus_1
    585            {
    586              bitstatus = SET;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x0005             MOVS     R5,R0
   \   00000024   0xE001             B.N      ??LCD_GetITStatus_2
    587            }
    588            else
    589            {
    590              bitstatus = RESET;
   \                     ??LCD_GetITStatus_1: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x0005             MOVS     R5,R0
    591            }
    592            
    593            if (((LCD->FCR & LCD_IT) != (uint16_t)RESET) && (bitstatus != (uint32_t)RESET))
   \                     ??LCD_GetITStatus_2: (+1)
   \   0000002A   0x....             LDR.N    R0,??DataTable15_1  ;; 0x40002404
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x4220             TST      R0,R4
   \   00000030   0xD005             BEQ.N    ??LCD_GetITStatus_3
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD002             BEQ.N    ??LCD_GetITStatus_3
    594            {
    595              bitstatus = SET;
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0x0005             MOVS     R5,R0
   \   0000003C   0xE001             B.N      ??LCD_GetITStatus_4
    596            }
    597            else
    598            {
    599              bitstatus = RESET;
   \                     ??LCD_GetITStatus_3: (+1)
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x0005             MOVS     R5,R0
    600            }
    601            return bitstatus;
   \                     ??LCD_GetITStatus_4: (+1)
   \   00000042   0x0028             MOVS     R0,R5
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    602          }
    603          
    604          /**
    605            * @brief  Clears the LCD's interrupt pending bits.
    606            * @param  LCD_IT: specifies the interrupt pending bit to clear.
    607            *   This parameter can be any combination of the following values:
    608            *     @arg LCD_IT_SOF: Start of Frame Interrupt
    609            *     @arg LCD_IT_UDD: Update Display Done Interrupt
    610            * @retval None
    611            */

   \                                 In section .text, align 2, keep-with-next
    612          void LCD_ClearITPendingBit(uint32_t LCD_IT)
    613          {
   \                     LCD_ClearITPendingBit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    614            /* Check the parameters */
    615            assert_param(IS_LCD_IT(LCD_IT));
   \   00000004   0xF034 0x000A      BICS     R0,R4,#0xA
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD101             BNE.N    ??LCD_ClearITPendingBit_0
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD104             BNE.N    ??LCD_ClearITPendingBit_1
   \                     ??LCD_ClearITPendingBit_0: (+1)
   \   00000010   0xF240 0x2167      MOVW     R1,#+615
   \   00000014   0x....             LDR.N    R0,??DataTable15
   \   00000016   0x.... 0x....      BL       assert_failed
    616            
    617            /* Clear the corresponding LCD pending bit */
    618            LCD->CLR = (uint32_t)LCD_IT;
   \                     ??LCD_ClearITPendingBit_1: (+1)
   \   0000001A   0x....             LDR.N    R0,??DataTable15_9  ;; 0x4000240c
   \   0000001C   0x6004             STR      R4,[R0, #+0]
    619          }
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x40002404         DC32     0x40002404

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0x40002400         DC32     0x40002400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   0x42048000         DC32     0x42048000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \   00000000   0x40002408         DC32     0x40002408

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \   00000000   0x42048080         DC32     0x42048080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_6:
   \   00000000   0x4204801C         DC32     0x4204801c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_7:
   \   00000000   0x40002414         DC32     0x40002414

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_8:
   \   00000000   0x42048108         DC32     0x42048108

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_9:
   \   00000000   0x4000240C         DC32     0x4000240c

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x45 0x3A          DC8 45H, 3AH, 5CH, 41H, 43H, 51H, 5CH, 50H
   \              0x5C 0x41    
   \              0x43 0x51    
   \              0x5C 0x50    
   \   00000008   0x72 0x6F          DC8 72H, 6FH, 6AH, 5FH, 76H, 65H, 72H, 30H
   \              0x6A 0x5F    
   \              0x76 0x65    
   \              0x72 0x30    
   \   00000010   0x39 0x61          DC8 39H, 61H, 5FH, 31H, 35H, 31H, 30H, 32H
   \              0x5F 0x31    
   \              0x35 0x31    
   \              0x30 0x32    
   \   00000018   0x30 0x31          DC8 30H, 31H, 35H, 5CH, 45H, 6EH, 64H, 5FH
   \              0x35 0x5C    
   \              0x45 0x6E    
   \              0x64 0x5F    
   \   00000020   0x30 0x32          DC8 30H, 32H, 5CH, 32H, 30H, 31H, 33H, 5FH
   \              0x5C 0x32    
   \              0x30 0x31    
   \              0x33 0x5F    
   \   00000028   0x31 0x31          DC8 31H, 31H, 5FH, 32H, 35H, 5FH, 53H, 70H
   \              0x5F 0x32    
   \              0x35 0x5F    
   \              0x53 0x70    
   \   00000030   0x69 0x72          DC8 69H, 72H, 69H, 74H, 31H, 5FH, 45H, 6CH
   \              0x69 0x74    
   \              0x31 0x5F    
   \              0x45 0x6C    
   \   00000038   0x65 0x6B          DC8 65H, 6BH, 74H, 72H, 6FH, 6CH, 75H, 78H
   \              0x74 0x72    
   \              0x6F 0x6C    
   \              0x75 0x78    
   \   00000040   0x5C 0x53          DC8 5CH, 53H, 54H, 4DH, 33H, 32H, 4CH, 5CH
   \              0x54 0x4D    
   \              0x33 0x32    
   \              0x4C 0x5C    
   \   00000048   0x53 0x54          DC8 53H, 54H, 4DH, 33H, 32H, 4CH, 31H, 78H
   \              0x4D 0x33    
   \              0x32 0x4C    
   \              0x31 0x78    
   \   00000050   0x78 0x5F          DC8 78H, 5FH, 53H, 74H, 64H, 50H, 65H, 72H
   \              0x53 0x74    
   \              0x64 0x50    
   \              0x65 0x72    
   \   00000058   0x69 0x70          DC8 69H, 70H, 68H, 5FH, 4CH, 69H, 62H, 5CH
   \              0x68 0x5F    
   \              0x4C 0x69    
   \              0x62 0x5C    
   \   00000060   0x53 0x6F          DC8 53H, 6FH, 75H, 72H, 63H, 65H, 5CH, 53H
   \              0x75 0x72    
   \              0x63 0x65    
   \              0x5C 0x53    
   \   00000068   0x54 0x4D          DC8 54H, 4DH, 33H, 32H, 4CH, 31H, 78H, 78H
   \              0x33 0x32    
   \              0x4C 0x31    
   \              0x78 0x78    
   \   00000070   0x5F 0x53          DC8 5FH, 53H, 74H, 64H, 50H, 65H, 72H, 69H
   \              0x74 0x64    
   \              0x50 0x65    
   \              0x72 0x69    
   \   00000078   0x70 0x68          DC8 70H, 68H, 5FH, 44H, 72H, 69H, 76H, 65H
   \              0x5F 0x44    
   \              0x72 0x69    
   \              0x76 0x65    
   \   00000080   0x72 0x5C          DC8 72H, 5CH, 73H, 72H, 63H, 5CH, 73H, 74H
   \              0x73 0x72    
   \              0x63 0x5C    
   \              0x73 0x74    
   \   00000088   0x6D 0x33          DC8 6DH, 33H, 32H, 6CH, 31H, 78H, 78H, 5FH
   \              0x32 0x6C    
   \              0x31 0x78    
   \              0x78 0x5F    
   \   00000090   0x6C 0x63          DC8 6CH, 63H, 64H, 2EH, 63H, 0
   \              0x64 0x2E    
   \              0x63 0x00    
   \   00000096   0x00 0x00          DC8 0, 0
    620          
    621          /**
    622            * @}
    623            */
    624          
    625          /**
    626            * @}
    627            */
    628          
    629          /**
    630            * @}
    631            */
    632          
    633          /**
    634            * @}
    635            */
    636          
    637          /******************* (C) COPYRIGHT 2010 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   LCD_BlinkConfig
        16   -> assert_failed
       8   LCD_ClearFlag
         8   -> assert_failed
       8   LCD_ClearITPendingBit
         8   -> assert_failed
       8   LCD_Cmd
         8   -> assert_failed
       8   LCD_ContrastConfig
         8   -> assert_failed
       8   LCD_DeInit
         8   -> RCC_APB1PeriphResetCmd
       8   LCD_DeadTimeConfig
         8   -> assert_failed
      16   LCD_GetFlagStatus
        16   -> assert_failed
      16   LCD_GetITStatus
        16   -> assert_failed
       8   LCD_HighDriveCmd
         8   -> assert_failed
      16   LCD_ITConfig
        16   -> assert_failed
       8   LCD_Init
         8   -> LCD_WaitForSynchro
         8   -> assert_failed
       8   LCD_MuxSegmentCmd
         8   -> assert_failed
       8   LCD_PulseOnDurationConfig
         8   -> assert_failed
       0   LCD_StructInit
       0   LCD_UpdateDisplayRequest
       0   LCD_WaitForSynchro
      16   LCD_Write
        16   -> assert_failed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable15_8
       4  ??DataTable15_9
     152  ?_0
     122  LCD_BlinkConfig
      32  LCD_ClearFlag
      32  LCD_ClearITPendingBit
      58  LCD_Cmd
      84  LCD_ContrastConfig
      24  LCD_DeInit
      82  LCD_DeadTimeConfig
      64  LCD_GetFlagStatus
      72  LCD_GetITStatus
      38  LCD_HighDriveCmd
      80  LCD_ITConfig
     448  LCD_Init
      36  LCD_MuxSegmentCmd
      70  LCD_PulseOnDurationConfig
      22  LCD_StructInit
       8  LCD_UpdateDisplayRequest
      12  LCD_WaitForSynchro
      88  LCD_Write

 
   152 bytes in section .rodata
 1 412 bytes in section .text
 
 1 412 bytes of CODE  memory
   152 bytes of CONST memory

Errors: none
Warnings: none
