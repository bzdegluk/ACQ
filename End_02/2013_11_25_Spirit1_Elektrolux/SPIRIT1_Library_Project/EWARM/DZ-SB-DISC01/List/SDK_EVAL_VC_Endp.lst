###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.70.1.5641/W32 for ARM      22/Feb/2014  21:59:39 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\bzdegluk.PLY\Desktop\ACQ_SYS\Projekt_po_poprawi #
#                    e\2013_11_25_Spirit1_Elektrolux\STM32L\SDK_Virtual_Com\S #
#                    ource\src\SDK_EVAL_VC_Endp.c                             #
#    Command line =  C:\Users\bzdegluk.PLY\Desktop\ACQ_SYS\Projekt_po_poprawi #
#                    e\2013_11_25_Spirit1_Elektrolux\STM32L\SDK_Virtual_Com\S #
#                    ource\src\SDK_EVAL_VC_Endp.c -D USE_STDPERIPH_DRIVER -D  #
#                    VECT_TAB_FLASH -D STM32L1XX_MD -D IAR_ARM_CM3 -D         #
#                    USE_FULL_ASSERT -D SPIRIT_USE_FULL_ASSERT -D             #
#                    USE_SYSTICK_DELAY -D SDK -lC                             #
#                    C:\Users\bzdegluk.PLY\Desktop\ACQ_SYS\Projekt_po_poprawi #
#                    e\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\ #
#                    EWARM\DZ-SB-DISC01\List\ -o                              #
#                    C:\Users\bzdegluk.PLY\Desktop\ACQ_SYS\Projekt_po_poprawi #
#                    e\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\ #
#                    EWARM\DZ-SB-DISC01\Obj\ --no_cse --no_unroll             #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I C:\Users\bzdegluk.PLY\Desktop\ACQ_SYS\Projekt_ #
#                    po_poprawie\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Librar #
#                    y_Project\EWARM\.\ -I C:\Users\bzdegluk.PLY\Desktop\ACQ_ #
#                    SYS\Projekt_po_poprawie\2013_11_25_Spirit1_Elektrolux\SP #
#                    IRIT1_Library_Project\EWARM\..\Application\ -I           #
#                    C:\Users\bzdegluk.PLY\Desktop\ACQ_SYS\Projekt_po_poprawi #
#                    e\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\ #
#                    EWARM\..\Application\examples\ -I                        #
#                    C:\Users\bzdegluk.PLY\Desktop\ACQ_SYS\Projekt_po_poprawi #
#                    e\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\ #
#                    EWARM\..\Application\runtime\ -I                         #
#                    C:\Users\bzdegluk.PLY\Desktop\ACQ_SYS\Projekt_po_poprawi #
#                    e\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\ #
#                    EWARM\..\..\STM32L\SDK_Eval_STM32L\Source\inc\ -I        #
#                    C:\Users\bzdegluk.PLY\Desktop\ACQ_SYS\Projekt_po_poprawi #
#                    e\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\ #
#                    EWARM\..\SPIRIT1_Library\Source\inc\ -I                  #
#                    C:\Users\bzdegluk.PLY\Desktop\ACQ_SYS\Projekt_po_poprawi #
#                    e\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\ #
#                    EWARM\..\SDK_Eval_Util\Source\inc\ -I                    #
#                    C:\Users\bzdegluk.PLY\Desktop\ACQ_SYS\Projekt_po_poprawi #
#                    e\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\ #
#                    EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\CMSIS\ #
#                    CM3\DeviceSupport\ST\STM32L1xx\ -I                       #
#                    C:\Users\bzdegluk.PLY\Desktop\ACQ_SYS\Projekt_po_poprawi #
#                    e\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\ #
#                    EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L #
#                    1xx_StdPeriph_Driver\inc\ -I                             #
#                    C:\Users\bzdegluk.PLY\Desktop\ACQ_SYS\Projekt_po_poprawi #
#                    e\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\ #
#                    EWARM\..\..\STM32L\SDK_Virtual_Com\Source\inc\ -I        #
#                    C:\Users\bzdegluk.PLY\Desktop\ACQ_SYS\Projekt_po_poprawi #
#                    e\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\ #
#                    EWARM\..\..\STM32L\STM32_USB-FS-Device_Lib\Source\inc\   #
#                    -On --use_c++_inline -I "C:\Program Files (x86)\IAR      #
#                    Systems\Embedded Workbench 6.5\arm\CMSIS\Include\"       #
#    List file    =  C:\Users\bzdegluk.PLY\Desktop\ACQ_SYS\Projekt_po_poprawi #
#                    e\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\ #
#                    EWARM\DZ-SB-DISC01\List\SDK_EVAL_VC_Endp.lst             #
#    Object file  =  C:\Users\bzdegluk.PLY\Desktop\ACQ_SYS\Projekt_po_poprawi #
#                    e\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\ #
#                    EWARM\DZ-SB-DISC01\Obj\SDK_EVAL_VC_Endp.o                #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\bzdegluk.PLY\Desktop\ACQ_SYS\Projekt_po_poprawie\2013_11_25_Spirit1_Elektrolux\STM32L\SDK_Virtual_Com\Source\src\SDK_EVAL_VC_Endp.c
      1          /**
      2           * @file     SDK_EVAL_VC_Endp.c
      3           * @author   MSH RF/ART Team IMS-Systems Lab
      4           * @version  V1.0.0
      5           * @date     August 4, 2011
      6           * @brief    Endpoint routines.
      7           * @details
      8           *
      9           * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     10           * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     11           * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     12           * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     13           * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     14           * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     15           *
     16           * THIS SOURCE CODE IS PROTECTED BY A LICENSE.
     17           * FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED
     18           * IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
     19           *
     20           * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     21           *
     22           */
     23          
     24          /* Includes ------------------------------------------------------------------*/
     25          #include "usb_lib.h"
     26          #include "SDK_EVAL_VC_Desc.h"
     27          #include "usb_mem.h"
     28          #include "SDK_EVAL_VC_General.h"
     29          #include "SDK_EVAL_VC_Istr.h"
     30          #include "SDK_EVAL_VC_Pwr.h"
     31          
     32          
     33          
     34          /** @addtogroup SDK_EVAL_Virtual_Com
     35           * @{
     36           */
     37          
     38          
     39          /** @addtogroup SDK_EVAL_VC_Endpoint	SDK EVAL VC Endpoint
     40           * @brief Implementation of endpoint routines for Virtual COM Port Device.
     41           * @details See the file <i>@ref SDK_EVAL_VC_Endp.c</i> for more details.
     42           * @{
     43           */
     44          
     45          
     46          /** @defgroup SDK_EVAL_VC_Endpoint_Private_TypesDefinitions   SDK EVAL VC Endpoint Private TypesDefinitions
     47           * @{
     48           */
     49          
     50          /**
     51           * @}
     52           */
     53          
     54          
     55          /** @defgroup SDK_EVAL_VC_Endpoint_Private_Defines    SDK EVAL VC Endpoint Private Defines
     56           * @{
     57           */
     58          
     59          /**
     60           * @}
     61           */
     62          
     63          
     64          /** @defgroup SDK_EVAL_VC_Endpoint_Private_Macros   SDK EVAL VC Endpoint Private Macros
     65           * @{
     66           */
     67          
     68          /**
     69           * @}
     70           */
     71          
     72          
     73          /** @defgroup SDK_EVAL_VC_Endpoint_Private_Variables    SDK EVAL VC Endpoint Private Variables
     74           * @{
     75           */
     76          
     77          /* Interval between sending IN packets in frame number (1 frame = 1ms) */
     78          #define VCOMPORT_IN_FRAME_INTERVAL             5
     79          extern uint8_t  s_vectcVCTxBuffer [];
     80          
     81          
     82          extern uint32_t s_lVCTxDataLength;
     83          extern uint32_t s_lVCTxBufferOutIndex;
     84          
     85          extern uint8_t  USB_Tx_State;
     86          
     87          /**
     88           * @}
     89           */
     90          
     91          
     92          /** @defgroup SDK_EVAL_VC_Endpoint_Private_FunctionPrototypes   SDK EVAL VC Endpoint Private FunctionPrototypes
     93           * @{
     94           */
     95          
     96          /**
     97           * @}
     98           */
     99          
    100          
    101          /** @defgroup SDK_EVAL_VC_Endpoint_Private_Functions    SDK EVAL VC Endpoint Private Functions
    102           * @{
    103           */
    104          
    105          /**
    106           * @brief  Endpoint3_Output Callback.
    107           * @param  None
    108           * @retval None
    109           */
    110          
    111          /*******************************************************************************
    112          * Function Name  : EP1_IN_Callback
    113          * Description    :
    114          * Input          : None.
    115          * Output         : None.
    116          * Return         : None.
    117          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    118          void EP1_IN_Callback (void)
    119          {
   \                     EP1_IN_Callback: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    120            uint16_t USB_Tx_ptr;
    121            uint16_t USB_Tx_length;
    122            
    123            if (USB_Tx_State == 1)
   \   00000002   0x....             LDR.N    R0,??DataTable2
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD13D             BNE.N    ??EP1_IN_Callback_0
    124            {
    125              if (s_lVCTxDataLength == 0) 
   \   0000000A   0x....             LDR.N    R0,??DataTable2_1
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD105             BNE.N    ??EP1_IN_Callback_1
    126              {
    127                USB_Tx_State = 0;
   \   00000012   0x....             LDR.N    R0,??DataTable2
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x7001             STRB     R1,[R0, #+0]
    128                USB_Tx_length = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x0005             MOVS     R5,R0
   \   0000001C   0xE02B             B.N      ??EP1_IN_Callback_2
    129              }
    130              else 
    131              {
    132                if (s_lVCTxDataLength > VIRTUAL_COM_PORT_DATA_SIZE){
   \                     ??EP1_IN_Callback_1: (+1)
   \   0000001E   0x....             LDR.N    R0,??DataTable2_1
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x2841             CMP      R0,#+65
   \   00000024   0xD30F             BCC.N    ??EP1_IN_Callback_3
    133                  USB_Tx_ptr = s_lVCTxBufferOutIndex;
   \   00000026   0x....             LDR.N    R0,??DataTable2_2
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x0004             MOVS     R4,R0
    134                  USB_Tx_length = VIRTUAL_COM_PORT_DATA_SIZE;
   \   0000002C   0x2040             MOVS     R0,#+64
   \   0000002E   0x0005             MOVS     R5,R0
    135                  
    136                  s_lVCTxBufferOutIndex += VIRTUAL_COM_PORT_DATA_SIZE;
   \   00000030   0x....             LDR.N    R0,??DataTable2_2
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x3040             ADDS     R0,R0,#+64
   \   00000036   0x....             LDR.N    R1,??DataTable2_2
   \   00000038   0x6008             STR      R0,[R1, #+0]
    137                  s_lVCTxDataLength -= VIRTUAL_COM_PORT_DATA_SIZE;    
   \   0000003A   0x....             LDR.N    R0,??DataTable2_1
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x3840             SUBS     R0,R0,#+64
   \   00000040   0x....             LDR.N    R1,??DataTable2_1
   \   00000042   0x6008             STR      R0,[R1, #+0]
   \   00000044   0xE00F             B.N      ??EP1_IN_Callback_4
    138                }
    139                else 
    140                {
    141                  USB_Tx_ptr = s_lVCTxBufferOutIndex;
   \                     ??EP1_IN_Callback_3: (+1)
   \   00000046   0x....             LDR.N    R0,??DataTable2_2
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x0004             MOVS     R4,R0
    142                  USB_Tx_length = s_lVCTxDataLength;
   \   0000004C   0x....             LDR.N    R0,??DataTable2_1
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0x0005             MOVS     R5,R0
    143                  
    144                  s_lVCTxBufferOutIndex += s_lVCTxDataLength;
   \   00000052   0x....             LDR.N    R0,??DataTable2_2
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0x....             LDR.N    R1,??DataTable2_1
   \   00000058   0x6809             LDR      R1,[R1, #+0]
   \   0000005A   0x1808             ADDS     R0,R1,R0
   \   0000005C   0x....             LDR.N    R1,??DataTable2_2
   \   0000005E   0x6008             STR      R0,[R1, #+0]
    145                  s_lVCTxDataLength = 0;
   \   00000060   0x....             LDR.N    R0,??DataTable2_1
   \   00000062   0x2100             MOVS     R1,#+0
   \   00000064   0x6001             STR      R1,[R0, #+0]
    146                }
    147                
    148                UserToPMABufferCopy(&s_vectcVCTxBuffer[USB_Tx_ptr], ENDP1_TXADDR, USB_Tx_length);
   \                     ??EP1_IN_Callback_4: (+1)
   \   00000066   0x002A             MOVS     R2,R5
   \   00000068   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000006A   0x21C0             MOVS     R1,#+192
   \   0000006C   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000006E   0x....             LDR.N    R0,??DataTable2_3
   \   00000070   0x1820             ADDS     R0,R4,R0
   \   00000072   0x.... 0x....      BL       UserToPMABufferCopy
    149          //      SetEPTxCount(ENDP1, USB_Tx_length);
    150          //      SetEPTxValid(ENDP1); 
    151              }
    152              SetEPTxCount(ENDP1, USB_Tx_length);
   \                     ??EP1_IN_Callback_2: (+1)
   \   00000076   0x0029             MOVS     R1,R5
   \   00000078   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0x.... 0x....      BL       SetEPTxCount
    153              SetEPTxValid(ENDP1); 
   \   00000080   0x2001             MOVS     R0,#+1
   \   00000082   0x.... 0x....      BL       SetEPTxValid
    154            }
    155          }
   \                     ??EP1_IN_Callback_0: (+1)
   \   00000086   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    156          
    157          /*******************************************************************************
    158          * Function Name  : EP3_OUT_Callback
    159          * Description    :
    160          * Input          : None.
    161          * Output         : None.
    162          * Return         : None.
    163          *******************************************************************************/
    164          extern void enqueueRxChars(unsigned char * buffer, uint16_t size);

   \                                 In section .text, align 2, keep-with-next
    165          void EP3_OUT_Callback(void)
    166          {
   \                     EP3_OUT_Callback: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    167            static uint8_t cVCRxBuffer[VIRTUAL_COM_PORT_DATA_SIZE];
    168            uint16_t USB_Rx_Cnt;
    169            
    170            /* Get the received data buffer and update the counter */
    171            USB_Rx_Cnt = USB_SIL_Read(EP3_OUT, cVCRxBuffer);
   \   00000002   0x....             LDR.N    R1,??DataTable2_4
   \   00000004   0x2003             MOVS     R0,#+3
   \   00000006   0x.... 0x....      BL       USB_SIL_Read
   \   0000000A   0x0004             MOVS     R4,R0
    172            
    173            /* USB data will be immediately processed, this allow next USB traffic being 
    174            NAKed till the end of the USART Xfer */
    175            
    176            enqueueRxChars(cVCRxBuffer, USB_Rx_Cnt);
   \   0000000C   0x0021             MOVS     R1,R4
   \   0000000E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000010   0x....             LDR.N    R0,??DataTable2_4
   \   00000012   0x.... 0x....      BL       enqueueRxChars
    177            
    178            /* Enable the receive of data on EP3 */
    179            SetEPRxValid(ENDP3);
   \   00000016   0x2003             MOVS     R0,#+3
   \   00000018   0x.... 0x....      BL       SetEPRxValid
    180          }
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .bss, align 4
   \                     ??cVCRxBuffer:
   \   00000000                      DS8 64
    181          
    182          /*******************************************************************************
    183          * Function Name  : SOF_Callback 
    184          * Description    :
    185          * Input          : None.
    186          * Output         : None.
    187          * Return         : None.
    188          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    189          void SOF_Callback(void)
    190          {
   \                     SOF_Callback: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    191            static uint32_t FrameCount = 0;
    192            
    193            if(bDeviceState == CONFIGURED)
   \   00000002   0x....             LDR.N    R0,??DataTable2_5
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2805             CMP      R0,#+5
   \   00000008   0xD10B             BNE.N    ??SOF_Callback_0
    194            {
    195              if (FrameCount++ == VCOMPORT_IN_FRAME_INTERVAL)
   \   0000000A   0x....             LDR.N    R0,??DataTable2_6
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x1C41             ADDS     R1,R0,#+1
   \   00000010   0x....             LDR.N    R2,??DataTable2_6
   \   00000012   0x6011             STR      R1,[R2, #+0]
   \   00000014   0x2805             CMP      R0,#+5
   \   00000016   0xD104             BNE.N    ??SOF_Callback_0
    196              {
    197                /* Reset the frame counter */
    198                FrameCount = 0;
   \   00000018   0x....             LDR.N    R0,??DataTable2_6
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x6001             STR      R1,[R0, #+0]
    199                
    200                /* Check the data to be sent through IN pipe */
    201                SdkEvalVCSendData();
   \   0000001E   0x.... 0x....      BL       SdkEvalVCSendData
    202              }
    203            }  
    204          }
   \                     ??SOF_Callback_0: (+1)
   \   00000022   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .bss, align 4
   \                     ??FrameCount:
   \   00000000                      DS8 4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     USB_Tx_State

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x........         DC32     s_lVCTxDataLength

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x........         DC32     s_lVCTxBufferOutIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x........         DC32     s_vectcVCTxBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x........         DC32     ??cVCRxBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   0x........         DC32     bDeviceState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \   00000000   0x........         DC32     ??FrameCount
    205          
    206          /**
    207           * @}
    208           */
    209          
    210          
    211          /**
    212           * @}
    213           */
    214          
    215          
    216          /**
    217           * @}
    218           */
    219          
    220          
    221          
    222          
    223          
    224          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   EP1_IN_Callback
        16   -> SetEPTxCount
        16   -> SetEPTxValid
        16   -> UserToPMABufferCopy
       8   EP3_OUT_Callback
         8   -> SetEPRxValid
         8   -> USB_SIL_Read
         8   -> enqueueRxChars
       8   SOF_Callback
         8   -> SdkEvalVCSendData


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
     136  EP1_IN_Callback
      30  EP3_OUT_Callback
       4  FrameCount
      36  SOF_Callback
      64  cVCRxBuffer

 
  68 bytes in section .bss
 230 bytes in section .text
 
 230 bytes of CODE memory
  68 bytes of DATA memory

Errors: none
Warnings: none
