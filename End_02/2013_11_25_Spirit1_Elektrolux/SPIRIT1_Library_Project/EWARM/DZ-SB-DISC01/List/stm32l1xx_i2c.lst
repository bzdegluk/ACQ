###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        20/Nov/2015  05:04:54
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_i2c.c
#    Command line =  
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_i2c.c
#        -D USE_STDPERIPH_DRIVER -D VECT_TAB_FLASH -D STM32L1XX_MD -D
#        IAR_ARM_CM3 -D USE_FULL_ASSERT -D SPIRIT_USE_FULL_ASSERT -D
#        USE_SYSTICK_DELAY -D SDK -lC
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\List\
#        -o
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\.\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\examples\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\runtime\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\SDK_Eval_STM32L\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\SPIRIT1_Library\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\SDK_Eval_Util\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\SDK_Virtual_Com\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32_USB-FS-Device_Lib\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\ACQ\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\CMSIS\Include\"
#    List file    =  
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\List\stm32l1xx_i2c.lst
#    Object file  =  
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\Obj\stm32l1xx_i2c.o
#
###############################################################################

E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_i2c.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_i2c.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    31-December-2010
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Inter-integrated circuit (I2C)
      9            *           - Initialization and Configuration
     10            *           - Data transfers
     11            *           - PEC management
     12            *           - DMA transfers management
     13            *           - Interrupts, events and flags management 
     14            *           
     15            *  @verbatim
     16            *    
     17            *          ===================================================================
     18            *                                 How to use this driver
     19            *          ===================================================================
     20            *          1. Enable peripheral clock using RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2Cx, ENABLE)
     21            *             function for I2C1 or I2C2.
     22            *
     23            *          2. Enable SDA, SCL  and SMBA (when used) GPIO clocks using 
     24            *             RCC_AHBPeriphClockCmd() function. 
     25            *
     26            *          3. Peripherals alternate function: 
     27            *                 - Connect the pin to the desired peripherals' Alternate 
     28            *                   Function (AF) using GPIO_PinAFConfig() function
     29            *                 - Configure the desired pin in alternate function by:
     30            *                   GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
     31            *                 - Select the type, pull-up/pull-down and output speed via 
     32            *                   GPIO_PuPd, GPIO_OType and GPIO_Speed members
     33            *                 - Call GPIO_Init() function
     34            *        
     35            *          4. Program the Mode, duty cycle , Own address, Ack, Speed and Acknowledged
     36            *             Address using the I2C_Init() function.
     37            *
     38            *          5. Optionally you can enable/configure the following parameters without
     39            *             re-initialization (i.e there is no need to call again I2C_Init() function):
     40            *              - Enable the acknowledge feature using I2C_AcknowledgeConfig() function
     41            *              - Enable the dual addressing mode using I2C_DualAddressCmd() function
     42            *              - Enable the general call using the I2C_GeneralCallCmd() function
     43            *              - Enable the clock stretching using I2C_StretchClockCmd() function
     44            *              - Enable the fast mode duty cycle using the I2C_FastModeDutyCycleConfig()
     45            *                function
     46            *              - Enable the PEC Calculation using I2C_CalculatePEC() function
     47            *              - For SMBus Mode: 
     48            *                   - Enable the Address Resolution Protocol (ARP) using I2C_ARPCmd() function
     49            *                   - Configure the SMBusAlert pin using I2C_SMBusAlertConfig() function
     50            *
     51            *          6. Enable the NVIC and the corresponding interrupt using the function 
     52            *             I2C_ITConfig() if you need to use interrupt mode. 
     53            *
     54            *          7. When using the DMA mode 
     55            *                   - Configure the DMA using DMA_Init() function
     56            *                   - Active the needed channel Request using I2C_DMACmd() or
     57                        I2C_DMALastTransferCmd() function
     58            * 
     59            *          8. Enable the I2C using the I2C_Cmd() function.
     60            * 
     61            *          9. Enable the DMA using the DMA_Cmd() function when using DMA mode in the 
     62            *             transfers. 
     63            *
     64            *  @endverbatim
     65            *  
     66            ******************************************************************************
     67            * @attention
     68            *
     69            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     70            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     71            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     72            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     73            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     74            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     75            *
     76            * <h2><center>&copy; COPYRIGHT 2010 STMicroelectronics</center></h2>
     77            ******************************************************************************  
     78            */ 
     79          
     80          /* Includes ------------------------------------------------------------------*/
     81          #include "stm32l1xx_i2c.h"
     82          #include "stm32l1xx_rcc.h"
     83          
     84          
     85          /** @addtogroup STM32L1xx_StdPeriph_Driver
     86            * @{
     87            */
     88          
     89          /** @defgroup I2C 
     90            * @brief I2C driver modules
     91            * @{
     92            */ 
     93          
     94          /* Private typedef -----------------------------------------------------------*/
     95          /* Private define ------------------------------------------------------------*/
     96          
     97          #define CR1_CLEAR_MASK          ((uint16_t)0xFBF5)      /*<! I2C registers Masks */
     98          #define FLAG_MASK               ((uint32_t)0x00FFFFFF)  /*<! I2C FLAG mask */
     99          #define ITEN_MASK               ((uint32_t)0x07000000)  /*<! I2C Interrupt Enable mask */
    100          
    101          /* Private macro -------------------------------------------------------------*/
    102          /* Private variables ---------------------------------------------------------*/
    103          /* Private function prototypes -----------------------------------------------*/
    104          /* Private functions ---------------------------------------------------------*/
    105          
    106          /** @defgroup I2C_Private_Functions
    107            * @{
    108            */
    109          
    110          /** @defgroup I2C_Group1 Initialization and Configuration functions
    111           *  @brief   Initialization and Configuration functions 
    112           *
    113          @verbatim   
    114           ===============================================================================
    115                             Initialization and Configuration functions
    116           ===============================================================================  
    117          
    118          @endverbatim
    119            * @{
    120            */
    121          
    122          /**
    123            * @brief  Deinitializes the I2Cx peripheral registers to their default reset values.
    124            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    125            * @retval None
    126            */

   \                                 In section .text, align 2, keep-with-next
    127          void I2C_DeInit(I2C_TypeDef* I2Cx)
    128          {
   \                     I2C_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    129            /* Check the parameters */
    130            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x40005400
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD008             BEQ.N    ??I2C_DeInit_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable26_1  ;; 0x40005800
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD004             BEQ.N    ??I2C_DeInit_0
   \   00000014   0x2182             MOVS     R1,#+130
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   0000001A   0x.... 0x....      BL       assert_failed
    131          
    132            if (I2Cx == I2C1)
   \                     ??I2C_DeInit_0: (+1)
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x40005400
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD10A             BNE.N    ??I2C_DeInit_1
    133            {
    134              /* Enable I2C1 reset state */
    135              RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
   \   00000026   0x2101             MOVS     R1,#+1
   \   00000028   0xF45F 0x1000      MOVS     R0,#+2097152
   \   0000002C   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    136              /* Release I2C1 from reset state */
    137              RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0xF45F 0x1000      MOVS     R0,#+2097152
   \   00000036   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
   \   0000003A   0xE009             B.N      ??I2C_DeInit_2
    138            }
    139            else
    140            {
    141              /* Enable I2C2 reset state */
    142              RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
   \                     ??I2C_DeInit_1: (+1)
   \   0000003C   0x2101             MOVS     R1,#+1
   \   0000003E   0xF45F 0x0080      MOVS     R0,#+4194304
   \   00000042   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    143              /* Release I2C2 from reset state */
    144              RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0xF45F 0x0080      MOVS     R0,#+4194304
   \   0000004C   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    145            }
    146          }
   \                     ??I2C_DeInit_2: (+1)
   \   00000050   0xBD10             POP      {R4,PC}          ;; return
    147          
    148          /**
    149            * @brief  Initializes the I2Cx peripheral according to the specified 
    150            *         parameters in the I2C_InitStruct.
    151            * @note   To use the I2C at 400 KHz (in fast mode), the PCLK1 frequency 
    152            *         (I2C peripheral input clock) must be a multiple of 10 MHz.  
    153            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    154            * @param  I2C_InitStruct: pointer to a I2C_InitTypeDef structure that
    155            *   contains the configuration information for the specified I2C peripheral.
    156            * @retval None
    157            */

   \                                 In section .text, align 2, keep-with-next
    158          void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
    159          {
   \                     I2C_Init: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
    160            uint16_t tmpreg = 0, freqrange = 0;
   \   0000000A   0x2600             MOVS     R6,#+0
   \   0000000C   0x2700             MOVS     R7,#+0
    161            uint16_t result = 0x04;
   \   0000000E   0xF05F 0x0804      MOVS     R8,#+4
    162            uint32_t pclk1 = 8000000;
   \   00000012   0x.... 0x....      LDR.W    R9,??DataTable26_3  ;; 0x7a1200
    163            RCC_ClocksTypeDef  rcc_clocks;
    164            /* Check the parameters */
    165            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x40005400
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD008             BEQ.N    ??I2C_Init_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable26_1  ;; 0x40005800
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD004             BEQ.N    ??I2C_Init_0
   \   00000026   0x21A5             MOVS     R1,#+165
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   0000002C   0x.... 0x....      BL       assert_failed
    166            assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct->I2C_ClockSpeed));
   \                     ??I2C_Init_0: (+1)
   \   00000030   0x6828             LDR      R0,[R5, #+0]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD004             BEQ.N    ??I2C_Init_1
   \   00000036   0x6828             LDR      R0,[R5, #+0]
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable26_4  ;; 0x61a81
   \   0000003C   0x4288             CMP      R0,R1
   \   0000003E   0xD304             BCC.N    ??I2C_Init_2
   \                     ??I2C_Init_1: (+1)
   \   00000040   0x21A6             MOVS     R1,#+166
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   00000046   0x.... 0x....      BL       assert_failed
    167            assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
   \                     ??I2C_Init_2: (+1)
   \   0000004A   0x88A8             LDRH     R0,[R5, #+4]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD00A             BEQ.N    ??I2C_Init_3
   \   00000050   0x88A8             LDRH     R0,[R5, #+4]
   \   00000052   0x2802             CMP      R0,#+2
   \   00000054   0xD007             BEQ.N    ??I2C_Init_3
   \   00000056   0x88A8             LDRH     R0,[R5, #+4]
   \   00000058   0x280A             CMP      R0,#+10
   \   0000005A   0xD004             BEQ.N    ??I2C_Init_3
   \   0000005C   0x21A7             MOVS     R1,#+167
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   00000062   0x.... 0x....      BL       assert_failed
    168            assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct->I2C_DutyCycle));
   \                     ??I2C_Init_3: (+1)
   \   00000066   0x88E8             LDRH     R0,[R5, #+6]
   \   00000068   0xF5B0 0x4F80      CMP      R0,#+16384
   \   0000006C   0xD009             BEQ.N    ??I2C_Init_4
   \   0000006E   0x88E8             LDRH     R0,[R5, #+6]
   \   00000070   0xF64B 0x71FF      MOVW     R1,#+49151
   \   00000074   0x4288             CMP      R0,R1
   \   00000076   0xD004             BEQ.N    ??I2C_Init_4
   \   00000078   0x21A8             MOVS     R1,#+168
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   0000007E   0x.... 0x....      BL       assert_failed
    169            assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
   \                     ??I2C_Init_4: (+1)
   \   00000082   0x8928             LDRH     R0,[R5, #+8]
   \   00000084   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000088   0xDB04             BLT.N    ??I2C_Init_5
   \   0000008A   0x21A9             MOVS     R1,#+169
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   00000090   0x.... 0x....      BL       assert_failed
    170            assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
   \                     ??I2C_Init_5: (+1)
   \   00000094   0x8968             LDRH     R0,[R5, #+10]
   \   00000096   0xF5B0 0x6F80      CMP      R0,#+1024
   \   0000009A   0xD007             BEQ.N    ??I2C_Init_6
   \   0000009C   0x8968             LDRH     R0,[R5, #+10]
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD004             BEQ.N    ??I2C_Init_6
   \   000000A2   0x21AA             MOVS     R1,#+170
   \   000000A4   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   000000A8   0x.... 0x....      BL       assert_failed
    171            assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
   \                     ??I2C_Init_6: (+1)
   \   000000AC   0x89A8             LDRH     R0,[R5, #+12]
   \   000000AE   0xF5B0 0x4F80      CMP      R0,#+16384
   \   000000B2   0xD008             BEQ.N    ??I2C_Init_7
   \   000000B4   0x89A8             LDRH     R0,[R5, #+12]
   \   000000B6   0xF5B0 0x4F40      CMP      R0,#+49152
   \   000000BA   0xD004             BEQ.N    ??I2C_Init_7
   \   000000BC   0x21AB             MOVS     R1,#+171
   \   000000BE   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   000000C2   0x.... 0x....      BL       assert_failed
    172          
    173          /*---------------------------- I2Cx CR2 Configuration ------------------------*/
    174            /* Get the I2Cx CR2 value */
    175            tmpreg = I2Cx->CR2;
   \                     ??I2C_Init_7: (+1)
   \   000000C6   0x88A0             LDRH     R0,[R4, #+4]
   \   000000C8   0x0006             MOVS     R6,R0
    176            /* Clear frequency FREQ[5:0] bits */
    177            tmpreg &= (uint16_t)~((uint16_t)I2C_CR2_FREQ);
   \   000000CA   0xF64F 0x70C0      MOVW     R0,#+65472
   \   000000CE   0x4006             ANDS     R6,R0,R6
    178            /* Get pclk1 frequency value */
    179            RCC_GetClocksFreq(&rcc_clocks);
   \   000000D0   0xA800             ADD      R0,SP,#+0
   \   000000D2   0x.... 0x....      BL       RCC_GetClocksFreq
    180            pclk1 = rcc_clocks.PCLK1_Frequency;
   \   000000D6   0x9802             LDR      R0,[SP, #+8]
   \   000000D8   0x4681             MOV      R9,R0
    181            /* Set frequency bits depending on pclk1 value */
    182            freqrange = (uint16_t)(pclk1 / 1000000);
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable26_5  ;; 0xf4240
   \   000000DE   0xFBB9 0xF0F0      UDIV     R0,R9,R0
   \   000000E2   0x0007             MOVS     R7,R0
    183            tmpreg |= freqrange;
   \   000000E4   0x433E             ORRS     R6,R7,R6
    184            /* Write to I2Cx CR2 */
    185            I2Cx->CR2 = tmpreg;
   \   000000E6   0x80A6             STRH     R6,[R4, #+4]
    186          
    187          /*---------------------------- I2Cx CCR Configuration ------------------------*/
    188            /* Disable the selected I2C peripheral to configure TRISE */
    189            I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
   \   000000E8   0x8820             LDRH     R0,[R4, #+0]
   \   000000EA   0xF64F 0x71FE      MOVW     R1,#+65534
   \   000000EE   0x4008             ANDS     R0,R1,R0
   \   000000F0   0x8020             STRH     R0,[R4, #+0]
    190            /* Reset tmpreg value */
    191            /* Clear F/S, DUTY and CCR[11:0] bits */
    192            tmpreg = 0;
   \   000000F2   0x2000             MOVS     R0,#+0
   \   000000F4   0x0006             MOVS     R6,R0
    193          
    194            /* Configure speed in standard mode */
    195            if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
   \   000000F6   0x6828             LDR      R0,[R5, #+0]
   \   000000F8   0x.... 0x....      LDR.W    R1,??DataTable30  ;; 0x186a1
   \   000000FC   0x4288             CMP      R0,R1
   \   000000FE   0xD210             BCS.N    ??I2C_Init_8
    196            {
    197              /* Standard mode speed calculate */
    198              result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
   \   00000100   0x6828             LDR      R0,[R5, #+0]
   \   00000102   0x0040             LSLS     R0,R0,#+1
   \   00000104   0xFBB9 0xF0F0      UDIV     R0,R9,R0
   \   00000108   0x4680             MOV      R8,R0
    199              /* Test if CCR value is under 0x4*/
    200              if (result < 0x04)
   \   0000010A   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   0000010E   0xF1B8 0x0F04      CMP      R8,#+4
   \   00000112   0xDA01             BGE.N    ??I2C_Init_9
    201              {
    202                /* Set minimum allowed value */
    203                result = 0x04;  
   \   00000114   0x2004             MOVS     R0,#+4
   \   00000116   0x4680             MOV      R8,R0
    204              }
    205              /* Set speed value for standard mode */
    206              tmpreg |= result;	  
   \                     ??I2C_Init_9: (+1)
   \   00000118   0xEA58 0x0606      ORRS     R6,R8,R6
    207              /* Set Maximum Rise Time for standard mode */
    208              I2Cx->TRISE = freqrange + 1; 
   \   0000011C   0x1C78             ADDS     R0,R7,#+1
   \   0000011E   0x8420             STRH     R0,[R4, #+32]
   \   00000120   0xE026             B.N      ??I2C_Init_10
    209            }
    210            /* Configure speed in fast mode */
    211            /* To use the I2C at 400 KHz (in fast mode), the PCLK1 frequency (I2C peripheral
    212               input clock) must be a multiple of 10 MHz */
    213            else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
    214            {
    215              if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
   \                     ??I2C_Init_8: (+1)
   \   00000122   0x88E8             LDRH     R0,[R5, #+6]
   \   00000124   0xF64B 0x71FF      MOVW     R1,#+49151
   \   00000128   0x4288             CMP      R0,R1
   \   0000012A   0xD106             BNE.N    ??I2C_Init_11
    216              {
    217                /* Fast mode speed calculate: Tlow/Thigh = 2 */
    218                result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
   \   0000012C   0x6828             LDR      R0,[R5, #+0]
   \   0000012E   0x2103             MOVS     R1,#+3
   \   00000130   0x4348             MULS     R0,R1,R0
   \   00000132   0xFBB9 0xF0F0      UDIV     R0,R9,R0
   \   00000136   0x4680             MOV      R8,R0
   \   00000138   0xE007             B.N      ??I2C_Init_12
    219              }
    220              else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
    221              {
    222                /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
    223                result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
   \                     ??I2C_Init_11: (+1)
   \   0000013A   0x6828             LDR      R0,[R5, #+0]
   \   0000013C   0x2119             MOVS     R1,#+25
   \   0000013E   0x4348             MULS     R0,R1,R0
   \   00000140   0xFBB9 0xF0F0      UDIV     R0,R9,R0
   \   00000144   0x4680             MOV      R8,R0
    224                /* Set DUTY bit */
    225                result |= I2C_DutyCycle_16_9;
   \   00000146   0xF458 0x4880      ORRS     R8,R8,#0x4000
    226              }
    227          
    228              /* Test if CCR value is under 0x1*/
    229              if ((result & I2C_CCR_CCR) == 0)
   \                     ??I2C_Init_12: (+1)
   \   0000014A   0xEA5F 0x5008      LSLS     R0,R8,#+20
   \   0000014E   0xD101             BNE.N    ??I2C_Init_13
    230              {
    231                /* Set minimum allowed value */
    232                result |= (uint16_t)0x0001;  
   \   00000150   0xF058 0x0801      ORRS     R8,R8,#0x1
    233              }
    234              /* Set speed value and set F/S bit for fast mode */
    235              tmpreg |= (uint16_t)(result | I2C_CCR_FS);
   \                     ??I2C_Init_13: (+1)
   \   00000154   0xF458 0x4000      ORRS     R0,R8,#0x8000
   \   00000158   0x4306             ORRS     R6,R0,R6
    236              /* Set Maximum Rise Time for fast mode */
    237              I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
   \   0000015A   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000015C   0xF44F 0x7096      MOV      R0,#+300
   \   00000160   0xFB00 0xF007      MUL      R0,R0,R7
   \   00000164   0xF44F 0x717A      MOV      R1,#+1000
   \   00000168   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000016C   0x1C40             ADDS     R0,R0,#+1
   \   0000016E   0x8420             STRH     R0,[R4, #+32]
    238            }
    239          
    240            /* Write to I2Cx CCR */
    241            I2Cx->CCR = tmpreg;
   \                     ??I2C_Init_10: (+1)
   \   00000170   0x83A6             STRH     R6,[R4, #+28]
    242            /* Enable the selected I2C peripheral */
    243            I2Cx->CR1 |= I2C_CR1_PE;
   \   00000172   0x8820             LDRH     R0,[R4, #+0]
   \   00000174   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000178   0x8020             STRH     R0,[R4, #+0]
    244          
    245          /*---------------------------- I2Cx CR1 Configuration ------------------------*/
    246            /* Get the I2Cx CR1 value */
    247            tmpreg = I2Cx->CR1;
   \   0000017A   0x8820             LDRH     R0,[R4, #+0]
   \   0000017C   0x0006             MOVS     R6,R0
    248            /* Clear ACK, SMBTYPE and  SMBUS bits */
    249            tmpreg &= CR1_CLEAR_MASK;
   \   0000017E   0xF64F 0x30F5      MOVW     R0,#+64501
   \   00000182   0x4006             ANDS     R6,R0,R6
    250            /* Configure I2Cx: mode and acknowledgement */
    251            /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
    252            /* Set ACK bit according to I2C_Ack value */
    253            tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
   \   00000184   0x88A8             LDRH     R0,[R5, #+4]
   \   00000186   0x8969             LDRH     R1,[R5, #+10]
   \   00000188   0x4308             ORRS     R0,R1,R0
   \   0000018A   0x4306             ORRS     R6,R0,R6
    254            /* Write to I2Cx CR1 */
    255            I2Cx->CR1 = tmpreg;
   \   0000018C   0x8026             STRH     R6,[R4, #+0]
    256          
    257          /*---------------------------- I2Cx OAR1 Configuration -----------------------*/
    258            /* Set I2Cx Own Address1 and acknowledged address */
    259            I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
   \   0000018E   0x89A8             LDRH     R0,[R5, #+12]
   \   00000190   0x8929             LDRH     R1,[R5, #+8]
   \   00000192   0x4308             ORRS     R0,R1,R0
   \   00000194   0x8120             STRH     R0,[R4, #+8]
    260          }
   \   00000196   0xB005             ADD      SP,SP,#+20
   \   00000198   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    261          
    262          /**
    263            * @brief  Fills each I2C_InitStruct member with its default value.
    264            * @param  I2C_InitStruct: pointer to an I2C_InitTypeDef structure which will be initialized.
    265            * @retval None
    266            */

   \                                 In section .text, align 2, keep-with-next
    267          void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
    268          {
    269          /*---------------- Reset I2C init structure parameters values ----------------*/
    270            /* initialize the I2C_ClockSpeed member */
    271            I2C_InitStruct->I2C_ClockSpeed = 5000;
   \                     I2C_StructInit: (+1)
   \   00000000   0xF241 0x3188      MOVW     R1,#+5000
   \   00000004   0x6001             STR      R1,[R0, #+0]
    272            /* Initialize the I2C_Mode member */
    273            I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x8081             STRH     R1,[R0, #+4]
    274            /* Initialize the I2C_DutyCycle member */
    275            I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
   \   0000000A   0xF64B 0x71FF      MOVW     R1,#+49151
   \   0000000E   0x80C1             STRH     R1,[R0, #+6]
    276            /* Initialize the I2C_OwnAddress1 member */
    277            I2C_InitStruct->I2C_OwnAddress1 = 0;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x8101             STRH     R1,[R0, #+8]
    278            /* Initialize the I2C_Ack member */
    279            I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x8141             STRH     R1,[R0, #+10]
    280            /* Initialize the I2C_AcknowledgedAddress member */
    281            I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
   \   00000018   0xF44F 0x4180      MOV      R1,#+16384
   \   0000001C   0x8181             STRH     R1,[R0, #+12]
    282          }
   \   0000001E   0x4770             BX       LR               ;; return
    283          
    284          /**
    285            * @brief  Enables or disables the specified I2C peripheral.
    286            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    287            * @param  NewState: new state of the I2Cx peripheral. 
    288            *   This parameter can be: ENABLE or DISABLE.
    289            * @retval None
    290            */

   \                                 In section .text, align 2, keep-with-next
    291          void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    292          {
   \                     I2C_Cmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    293            /* Check the parameters */
    294            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x40005400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD009             BEQ.N    ??I2C_Cmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable26_1  ;; 0x40005800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD005             BEQ.N    ??I2C_Cmd_0
   \   00000016   0xF44F 0x7193      MOV      R1,#+294
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   0000001E   0x.... 0x....      BL       assert_failed
    295            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??I2C_Cmd_0: (+1)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD008             BEQ.N    ??I2C_Cmd_1
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD005             BEQ.N    ??I2C_Cmd_1
   \   0000002E   0xF240 0x1127      MOVW     R1,#+295
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   00000036   0x.... 0x....      BL       assert_failed
    296            if (NewState != DISABLE)
   \                     ??I2C_Cmd_1: (+1)
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x2D00             CMP      R5,#+0
   \   0000003E   0xD004             BEQ.N    ??I2C_Cmd_2
    297            {
    298              /* Enable the selected I2C peripheral */
    299              I2Cx->CR1 |= I2C_CR1_PE;
   \   00000040   0x8820             LDRH     R0,[R4, #+0]
   \   00000042   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000046   0x8020             STRH     R0,[R4, #+0]
   \   00000048   0xE004             B.N      ??I2C_Cmd_3
    300            }
    301            else
    302            {
    303              /* Disable the selected I2C peripheral */
    304              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
   \                     ??I2C_Cmd_2: (+1)
   \   0000004A   0x8820             LDRH     R0,[R4, #+0]
   \   0000004C   0xF64F 0x71FE      MOVW     R1,#+65534
   \   00000050   0x4008             ANDS     R0,R1,R0
   \   00000052   0x8020             STRH     R0,[R4, #+0]
    305            }
    306          }
   \                     ??I2C_Cmd_3: (+1)
   \   00000054   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    307          
    308          /**
    309            * @brief  Generates I2Cx communication START condition.
    310            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    311            * @param  NewState: new state of the I2C START condition generation.
    312            *   This parameter can be: ENABLE or DISABLE.
    313            * @retval None.
    314            */

   \                                 In section .text, align 2, keep-with-next
    315          void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
    316          {
   \                     I2C_GenerateSTART: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    317            /* Check the parameters */
    318            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x40005400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD009             BEQ.N    ??I2C_GenerateSTART_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable26_1  ;; 0x40005800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD005             BEQ.N    ??I2C_GenerateSTART_0
   \   00000016   0xF44F 0x719F      MOV      R1,#+318
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   0000001E   0x.... 0x....      BL       assert_failed
    319            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??I2C_GenerateSTART_0: (+1)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD008             BEQ.N    ??I2C_GenerateSTART_1
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD005             BEQ.N    ??I2C_GenerateSTART_1
   \   0000002E   0xF240 0x113F      MOVW     R1,#+319
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   00000036   0x.... 0x....      BL       assert_failed
    320            if (NewState != DISABLE)
   \                     ??I2C_GenerateSTART_1: (+1)
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x2D00             CMP      R5,#+0
   \   0000003E   0xD004             BEQ.N    ??I2C_GenerateSTART_2
    321            {
    322              /* Generate a START condition */
    323              I2Cx->CR1 |= I2C_CR1_START;
   \   00000040   0x8820             LDRH     R0,[R4, #+0]
   \   00000042   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000046   0x8020             STRH     R0,[R4, #+0]
   \   00000048   0xE004             B.N      ??I2C_GenerateSTART_3
    324            }
    325            else
    326            {
    327              /* Disable the START condition generation */
    328              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_START);
   \                     ??I2C_GenerateSTART_2: (+1)
   \   0000004A   0x8820             LDRH     R0,[R4, #+0]
   \   0000004C   0xF64F 0x61FF      MOVW     R1,#+65279
   \   00000050   0x4008             ANDS     R0,R1,R0
   \   00000052   0x8020             STRH     R0,[R4, #+0]
    329            }
    330          }
   \                     ??I2C_GenerateSTART_3: (+1)
   \   00000054   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    331          
    332          /**
    333            * @brief  Generates I2Cx communication STOP condition.
    334            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    335            * @param  NewState: new state of the I2C STOP condition generation.
    336            *   This parameter can be: ENABLE or DISABLE.
    337            * @retval None.
    338            */

   \                                 In section .text, align 2, keep-with-next
    339          void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
    340          {
   \                     I2C_GenerateSTOP: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    341            /* Check the parameters */
    342            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x40005400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD009             BEQ.N    ??I2C_GenerateSTOP_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable26_1  ;; 0x40005800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD005             BEQ.N    ??I2C_GenerateSTOP_0
   \   00000016   0xF44F 0x71AB      MOV      R1,#+342
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   0000001E   0x.... 0x....      BL       assert_failed
    343            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??I2C_GenerateSTOP_0: (+1)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD008             BEQ.N    ??I2C_GenerateSTOP_1
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD005             BEQ.N    ??I2C_GenerateSTOP_1
   \   0000002E   0xF240 0x1157      MOVW     R1,#+343
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   00000036   0x.... 0x....      BL       assert_failed
    344            if (NewState != DISABLE)
   \                     ??I2C_GenerateSTOP_1: (+1)
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x2D00             CMP      R5,#+0
   \   0000003E   0xD004             BEQ.N    ??I2C_GenerateSTOP_2
    345            {
    346              /* Generate a STOP condition */
    347              I2Cx->CR1 |= I2C_CR1_STOP;
   \   00000040   0x8820             LDRH     R0,[R4, #+0]
   \   00000042   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000046   0x8020             STRH     R0,[R4, #+0]
   \   00000048   0xE004             B.N      ??I2C_GenerateSTOP_3
    348            }
    349            else
    350            {
    351              /* Disable the STOP condition generation */
    352              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_STOP);
   \                     ??I2C_GenerateSTOP_2: (+1)
   \   0000004A   0x8820             LDRH     R0,[R4, #+0]
   \   0000004C   0xF64F 0x51FF      MOVW     R1,#+65023
   \   00000050   0x4008             ANDS     R0,R1,R0
   \   00000052   0x8020             STRH     R0,[R4, #+0]
    353            }
    354          }
   \                     ??I2C_GenerateSTOP_3: (+1)
   \   00000054   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    355          
    356          /**
    357            * @brief  Enables or disables the specified I2C acknowledge feature.
    358            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    359            * @param  NewState: new state of the I2C Acknowledgement.
    360            *   This parameter can be: ENABLE or DISABLE.
    361            * @retval None.
    362            */

   \                                 In section .text, align 2, keep-with-next
    363          void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
    364          {
   \                     I2C_AcknowledgeConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    365            /* Check the parameters */
    366            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x40005400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD009             BEQ.N    ??I2C_AcknowledgeConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable26_1  ;; 0x40005800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD005             BEQ.N    ??I2C_AcknowledgeConfig_0
   \   00000016   0xF44F 0x71B7      MOV      R1,#+366
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   0000001E   0x.... 0x....      BL       assert_failed
    367            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??I2C_AcknowledgeConfig_0: (+1)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD008             BEQ.N    ??I2C_AcknowledgeConfig_1
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD005             BEQ.N    ??I2C_AcknowledgeConfig_1
   \   0000002E   0xF240 0x116F      MOVW     R1,#+367
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   00000036   0x.... 0x....      BL       assert_failed
    368            if (NewState != DISABLE)
   \                     ??I2C_AcknowledgeConfig_1: (+1)
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x2D00             CMP      R5,#+0
   \   0000003E   0xD004             BEQ.N    ??I2C_AcknowledgeConfig_2
    369            {
    370              /* Enable the acknowledgement */
    371              I2Cx->CR1 |= I2C_CR1_ACK;
   \   00000040   0x8820             LDRH     R0,[R4, #+0]
   \   00000042   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000046   0x8020             STRH     R0,[R4, #+0]
   \   00000048   0xE004             B.N      ??I2C_AcknowledgeConfig_3
    372            }
    373            else
    374            {
    375              /* Disable the acknowledgement */
    376              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ACK);
   \                     ??I2C_AcknowledgeConfig_2: (+1)
   \   0000004A   0x8820             LDRH     R0,[R4, #+0]
   \   0000004C   0xF64F 0x31FF      MOVW     R1,#+64511
   \   00000050   0x4008             ANDS     R0,R1,R0
   \   00000052   0x8020             STRH     R0,[R4, #+0]
    377            }
    378          }
   \                     ??I2C_AcknowledgeConfig_3: (+1)
   \   00000054   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    379          
    380          /**
    381            * @brief  Configures the specified I2C own address2.
    382            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    383            * @param  Address: specifies the 7bit I2C own address2.
    384            * @retval None.
    385            */

   \                                 In section .text, align 2, keep-with-next
    386          void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address)
    387          {
   \                     I2C_OwnAddress2Config: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    388            uint16_t tmpreg = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    389          
    390            /* Check the parameters */
    391            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x40005400
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD009             BEQ.N    ??I2C_OwnAddress2Config_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable26_1  ;; 0x40005800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD005             BEQ.N    ??I2C_OwnAddress2Config_0
   \   00000018   0xF240 0x1187      MOVW     R1,#+391
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   00000020   0x.... 0x....      BL       assert_failed
    392          
    393            /* Get the old register value */
    394            tmpreg = I2Cx->OAR2;
   \                     ??I2C_OwnAddress2Config_0: (+1)
   \   00000024   0x89A0             LDRH     R0,[R4, #+12]
   \   00000026   0x0006             MOVS     R6,R0
    395          
    396            /* Reset I2Cx Own address2 bit [7:1] */
    397            tmpreg &= (uint16_t)~((uint16_t)I2C_OAR2_ADD2);
   \   00000028   0xF64F 0x7001      MOVW     R0,#+65281
   \   0000002C   0x4006             ANDS     R6,R0,R6
    398          
    399            /* Set I2Cx Own address2 */
    400            tmpreg |= (uint16_t)((uint16_t)Address & (uint16_t)0x00FE);
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0xF015 0x00FE      ANDS     R0,R5,#0xFE
   \   00000034   0x4306             ORRS     R6,R0,R6
    401          
    402            /* Store the new register value */
    403            I2Cx->OAR2 = tmpreg;
   \   00000036   0x81A6             STRH     R6,[R4, #+12]
    404          }
   \   00000038   0xBD70             POP      {R4-R6,PC}       ;; return
    405          
    406          /**
    407            * @brief  Enables or disables the specified I2C dual addressing mode.
    408            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    409            * @param  NewState: new state of the I2C dual addressing mode.
    410            *   This parameter can be: ENABLE or DISABLE.
    411            * @retval None
    412            */

   \                                 In section .text, align 2, keep-with-next
    413          void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    414          {
   \                     I2C_DualAddressCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    415            /* Check the parameters */
    416            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x40005400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD009             BEQ.N    ??I2C_DualAddressCmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable26_1  ;; 0x40005800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD005             BEQ.N    ??I2C_DualAddressCmd_0
   \   00000016   0xF44F 0x71D0      MOV      R1,#+416
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   0000001E   0x.... 0x....      BL       assert_failed
    417            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??I2C_DualAddressCmd_0: (+1)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD008             BEQ.N    ??I2C_DualAddressCmd_1
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD005             BEQ.N    ??I2C_DualAddressCmd_1
   \   0000002E   0xF240 0x11A1      MOVW     R1,#+417
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   00000036   0x.... 0x....      BL       assert_failed
    418            if (NewState != DISABLE)
   \                     ??I2C_DualAddressCmd_1: (+1)
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x2D00             CMP      R5,#+0
   \   0000003E   0xD004             BEQ.N    ??I2C_DualAddressCmd_2
    419            {
    420              /* Enable dual addressing mode */
    421              I2Cx->OAR2 |= I2C_OAR2_ENDUAL;
   \   00000040   0x89A0             LDRH     R0,[R4, #+12]
   \   00000042   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000046   0x81A0             STRH     R0,[R4, #+12]
   \   00000048   0xE004             B.N      ??I2C_DualAddressCmd_3
    422            }
    423            else
    424            {
    425              /* Disable dual addressing mode */
    426              I2Cx->OAR2 &= (uint16_t)~((uint16_t)I2C_OAR2_ENDUAL);
   \                     ??I2C_DualAddressCmd_2: (+1)
   \   0000004A   0x89A0             LDRH     R0,[R4, #+12]
   \   0000004C   0xF64F 0x71FE      MOVW     R1,#+65534
   \   00000050   0x4008             ANDS     R0,R1,R0
   \   00000052   0x81A0             STRH     R0,[R4, #+12]
    427            }
    428          }
   \                     ??I2C_DualAddressCmd_3: (+1)
   \   00000054   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    429          
    430          /**
    431            * @brief  Enables or disables the specified I2C general call feature.
    432            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    433            * @param  NewState: new state of the I2C General call.
    434            *   This parameter can be: ENABLE or DISABLE.
    435            * @retval None
    436            */

   \                                 In section .text, align 2, keep-with-next
    437          void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    438          {
   \                     I2C_GeneralCallCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    439            /* Check the parameters */
    440            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x40005400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD009             BEQ.N    ??I2C_GeneralCallCmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable26_1  ;; 0x40005800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD005             BEQ.N    ??I2C_GeneralCallCmd_0
   \   00000016   0xF44F 0x71DC      MOV      R1,#+440
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   0000001E   0x.... 0x....      BL       assert_failed
    441            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??I2C_GeneralCallCmd_0: (+1)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD008             BEQ.N    ??I2C_GeneralCallCmd_1
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD005             BEQ.N    ??I2C_GeneralCallCmd_1
   \   0000002E   0xF240 0x11B9      MOVW     R1,#+441
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   00000036   0x.... 0x....      BL       assert_failed
    442            if (NewState != DISABLE)
   \                     ??I2C_GeneralCallCmd_1: (+1)
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x2D00             CMP      R5,#+0
   \   0000003E   0xD004             BEQ.N    ??I2C_GeneralCallCmd_2
    443            {
    444              /* Enable generall call */
    445              I2Cx->CR1 |= I2C_CR1_ENGC;
   \   00000040   0x8820             LDRH     R0,[R4, #+0]
   \   00000042   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000046   0x8020             STRH     R0,[R4, #+0]
   \   00000048   0xE004             B.N      ??I2C_GeneralCallCmd_3
    446            }
    447            else
    448            {
    449              /* Disable generall call */
    450              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENGC);
   \                     ??I2C_GeneralCallCmd_2: (+1)
   \   0000004A   0x8820             LDRH     R0,[R4, #+0]
   \   0000004C   0xF64F 0x71BF      MOVW     R1,#+65471
   \   00000050   0x4008             ANDS     R0,R1,R0
   \   00000052   0x8020             STRH     R0,[R4, #+0]
    451            }
    452          }
   \                     ??I2C_GeneralCallCmd_3: (+1)
   \   00000054   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    453          
    454          /**
    455            * @brief  Enables or disables the specified I2C software reset.
    456            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    457            * @param  NewState: new state of the I2C software reset.
    458            *   This parameter can be: ENABLE or DISABLE.
    459            * @retval None
    460            */

   \                                 In section .text, align 2, keep-with-next
    461          void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    462          {
   \                     I2C_SoftwareResetCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    463            /* Check the parameters */
    464            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x40005400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD009             BEQ.N    ??I2C_SoftwareResetCmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable26_1  ;; 0x40005800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD005             BEQ.N    ??I2C_SoftwareResetCmd_0
   \   00000016   0xF44F 0x71E8      MOV      R1,#+464
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   0000001E   0x.... 0x....      BL       assert_failed
    465            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??I2C_SoftwareResetCmd_0: (+1)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD008             BEQ.N    ??I2C_SoftwareResetCmd_1
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD005             BEQ.N    ??I2C_SoftwareResetCmd_1
   \   0000002E   0xF240 0x11D1      MOVW     R1,#+465
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   00000036   0x.... 0x....      BL       assert_failed
    466            if (NewState != DISABLE)
   \                     ??I2C_SoftwareResetCmd_1: (+1)
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x2D00             CMP      R5,#+0
   \   0000003E   0xD004             BEQ.N    ??I2C_SoftwareResetCmd_2
    467            {
    468              /* Peripheral under reset */
    469              I2Cx->CR1 |= I2C_CR1_SWRST;
   \   00000040   0x8820             LDRH     R0,[R4, #+0]
   \   00000042   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   00000046   0x8020             STRH     R0,[R4, #+0]
   \   00000048   0xE003             B.N      ??I2C_SoftwareResetCmd_3
    470            }
    471            else
    472            {
    473              /* Peripheral not under reset */
    474              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_SWRST);
   \                     ??I2C_SoftwareResetCmd_2: (+1)
   \   0000004A   0x8820             LDRH     R0,[R4, #+0]
   \   0000004C   0x0440             LSLS     R0,R0,#+17       ;; ZeroExtS R0,R0,#+17,#+17
   \   0000004E   0x0C40             LSRS     R0,R0,#+17
   \   00000050   0x8020             STRH     R0,[R4, #+0]
    475            }
    476          }
   \                     ??I2C_SoftwareResetCmd_3: (+1)
   \   00000052   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    477          
    478          /**
    479            * @brief  Drives the SMBusAlert pin high or low for the specified I2C.
    480            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    481            * @param  I2C_SMBusAlert: specifies SMBAlert pin level. 
    482            *   This parameter can be one of the following values:
    483            *     @arg I2C_SMBusAlert_Low: SMBAlert pin driven low
    484            *     @arg I2C_SMBusAlert_High: SMBAlert pin driven high
    485            * @retval None
    486            */

   \                                 In section .text, align 2, keep-with-next
    487          void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)
    488          {
   \                     I2C_SMBusAlertConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    489            /* Check the parameters */
    490            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x40005400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD009             BEQ.N    ??I2C_SMBusAlertConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable26_1  ;; 0x40005800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD005             BEQ.N    ??I2C_SMBusAlertConfig_0
   \   00000016   0xF44F 0x71F5      MOV      R1,#+490
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   0000001E   0x.... 0x....      BL       assert_failed
    491            assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
   \                     ??I2C_SMBusAlertConfig_0: (+1)
   \   00000022   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000024   0xF5B5 0x5F00      CMP      R5,#+8192
   \   00000028   0xD00A             BEQ.N    ??I2C_SMBusAlertConfig_1
   \   0000002A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002C   0xF64D 0x70FF      MOVW     R0,#+57343
   \   00000030   0x4285             CMP      R5,R0
   \   00000032   0xD005             BEQ.N    ??I2C_SMBusAlertConfig_1
   \   00000034   0xF240 0x11EB      MOVW     R1,#+491
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   0000003C   0x.... 0x....      BL       assert_failed
    492            if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
   \                     ??I2C_SMBusAlertConfig_1: (+1)
   \   00000040   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000042   0xF5B5 0x5F00      CMP      R5,#+8192
   \   00000046   0xD104             BNE.N    ??I2C_SMBusAlertConfig_2
    493            {
    494              /* Drive the SMBusAlert pin Low */
    495              I2Cx->CR1 |= I2C_SMBusAlert_Low;
   \   00000048   0x8820             LDRH     R0,[R4, #+0]
   \   0000004A   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   0000004E   0x8020             STRH     R0,[R4, #+0]
   \   00000050   0xE004             B.N      ??I2C_SMBusAlertConfig_3
    496            }
    497            else
    498            {
    499              /* Drive the SMBusAlert pin High  */
    500              I2Cx->CR1 &= I2C_SMBusAlert_High;
   \                     ??I2C_SMBusAlertConfig_2: (+1)
   \   00000052   0x8820             LDRH     R0,[R4, #+0]
   \   00000054   0xF64D 0x71FF      MOVW     R1,#+57343
   \   00000058   0x4008             ANDS     R0,R1,R0
   \   0000005A   0x8020             STRH     R0,[R4, #+0]
    501            }
    502          }
   \                     ??I2C_SMBusAlertConfig_3: (+1)
   \   0000005C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    503          
    504          /**
    505            * @brief  Enables or disables the specified I2C ARP.
    506            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    507            * @param  NewState: new state of the I2Cx ARP. 
    508            *   This parameter can be: ENABLE or DISABLE.
    509            * @retval None
    510            */

   \                                 In section .text, align 2, keep-with-next
    511          void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    512          {
   \                     I2C_ARPCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    513            /* Check the parameters */
    514            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x40005400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD009             BEQ.N    ??I2C_ARPCmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable26_1  ;; 0x40005800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD005             BEQ.N    ??I2C_ARPCmd_0
   \   00000016   0xF240 0x2102      MOVW     R1,#+514
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   0000001E   0x.... 0x....      BL       assert_failed
    515            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??I2C_ARPCmd_0: (+1)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD008             BEQ.N    ??I2C_ARPCmd_1
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD005             BEQ.N    ??I2C_ARPCmd_1
   \   0000002E   0xF240 0x2103      MOVW     R1,#+515
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   00000036   0x.... 0x....      BL       assert_failed
    516            if (NewState != DISABLE)
   \                     ??I2C_ARPCmd_1: (+1)
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x2D00             CMP      R5,#+0
   \   0000003E   0xD004             BEQ.N    ??I2C_ARPCmd_2
    517            {
    518              /* Enable the selected I2C ARP */
    519              I2Cx->CR1 |= I2C_CR1_ENARP;
   \   00000040   0x8820             LDRH     R0,[R4, #+0]
   \   00000042   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000046   0x8020             STRH     R0,[R4, #+0]
   \   00000048   0xE004             B.N      ??I2C_ARPCmd_3
    520            }
    521            else
    522            {
    523              /* Disable the selected I2C ARP */
    524              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENARP);
   \                     ??I2C_ARPCmd_2: (+1)
   \   0000004A   0x8820             LDRH     R0,[R4, #+0]
   \   0000004C   0xF64F 0x71EF      MOVW     R1,#+65519
   \   00000050   0x4008             ANDS     R0,R1,R0
   \   00000052   0x8020             STRH     R0,[R4, #+0]
    525            }
    526          }
   \                     ??I2C_ARPCmd_3: (+1)
   \   00000054   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    527          
    528          /**
    529            * @brief  Enables or disables the specified I2C Clock stretching.
    530            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    531            * @param  NewState: new state of the I2Cx Clock stretching.
    532            *   This parameter can be: ENABLE or DISABLE.
    533            * @retval None
    534            */

   \                                 In section .text, align 2, keep-with-next
    535          void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    536          {
   \                     I2C_StretchClockCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    537            /* Check the parameters */
    538            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x40005400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD009             BEQ.N    ??I2C_StretchClockCmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable26_1  ;; 0x40005800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD005             BEQ.N    ??I2C_StretchClockCmd_0
   \   00000016   0xF240 0x211A      MOVW     R1,#+538
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   0000001E   0x.... 0x....      BL       assert_failed
    539            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??I2C_StretchClockCmd_0: (+1)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD008             BEQ.N    ??I2C_StretchClockCmd_1
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD005             BEQ.N    ??I2C_StretchClockCmd_1
   \   0000002E   0xF240 0x211B      MOVW     R1,#+539
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   00000036   0x.... 0x....      BL       assert_failed
    540            if (NewState == DISABLE)
   \                     ??I2C_StretchClockCmd_1: (+1)
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x2D00             CMP      R5,#+0
   \   0000003E   0xD104             BNE.N    ??I2C_StretchClockCmd_2
    541            {
    542              /* Enable the selected I2C Clock stretching */
    543              I2Cx->CR1 |= I2C_CR1_NOSTRETCH;
   \   00000040   0x8820             LDRH     R0,[R4, #+0]
   \   00000042   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000046   0x8020             STRH     R0,[R4, #+0]
   \   00000048   0xE004             B.N      ??I2C_StretchClockCmd_3
    544            }
    545            else
    546            {
    547              /* Disable the selected I2C Clock stretching */
    548              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_NOSTRETCH);
   \                     ??I2C_StretchClockCmd_2: (+1)
   \   0000004A   0x8820             LDRH     R0,[R4, #+0]
   \   0000004C   0xF64F 0x717F      MOVW     R1,#+65407
   \   00000050   0x4008             ANDS     R0,R1,R0
   \   00000052   0x8020             STRH     R0,[R4, #+0]
    549            }
    550          }
   \                     ??I2C_StretchClockCmd_3: (+1)
   \   00000054   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    551          
    552          /**
    553            * @brief  Selects the specified I2C fast mode duty cycle.
    554            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    555            * @param  I2C_DutyCycle: specifies the fast mode duty cycle.
    556            *   This parameter can be one of the following values:
    557            *     @arg I2C_DutyCycle_2: I2C fast mode Tlow/Thigh = 2
    558            *     @arg I2C_DutyCycle_16_9: I2C fast mode Tlow/Thigh = 16/9
    559            * @retval None
    560            */

   \                                 In section .text, align 2, keep-with-next
    561          void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle)
    562          {
   \                     I2C_FastModeDutyCycleConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    563            /* Check the parameters */
    564            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x40005400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD009             BEQ.N    ??I2C_FastModeDutyCycleConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable26_1  ;; 0x40005800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD005             BEQ.N    ??I2C_FastModeDutyCycleConfig_0
   \   00000016   0xF44F 0x710D      MOV      R1,#+564
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   0000001E   0x.... 0x....      BL       assert_failed
    565            assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
   \                     ??I2C_FastModeDutyCycleConfig_0: (+1)
   \   00000022   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000024   0xF5B5 0x4F80      CMP      R5,#+16384
   \   00000028   0xD00A             BEQ.N    ??I2C_FastModeDutyCycleConfig_1
   \   0000002A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002C   0xF64B 0x70FF      MOVW     R0,#+49151
   \   00000030   0x4285             CMP      R5,R0
   \   00000032   0xD005             BEQ.N    ??I2C_FastModeDutyCycleConfig_1
   \   00000034   0xF240 0x2135      MOVW     R1,#+565
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   0000003C   0x.... 0x....      BL       assert_failed
    566            if (I2C_DutyCycle != I2C_DutyCycle_16_9)
   \                     ??I2C_FastModeDutyCycleConfig_1: (+1)
   \   00000040   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000042   0xF5B5 0x4F80      CMP      R5,#+16384
   \   00000046   0xD005             BEQ.N    ??I2C_FastModeDutyCycleConfig_2
    567            {
    568              /* I2C fast mode Tlow/Thigh=2 */
    569              I2Cx->CCR &= I2C_DutyCycle_2;
   \   00000048   0x8BA0             LDRH     R0,[R4, #+28]
   \   0000004A   0xF64B 0x71FF      MOVW     R1,#+49151
   \   0000004E   0x4008             ANDS     R0,R1,R0
   \   00000050   0x83A0             STRH     R0,[R4, #+28]
   \   00000052   0xE003             B.N      ??I2C_FastModeDutyCycleConfig_3
    570            }
    571            else
    572            {
    573              /* I2C fast mode Tlow/Thigh=16/9 */
    574              I2Cx->CCR |= I2C_DutyCycle_16_9;
   \                     ??I2C_FastModeDutyCycleConfig_2: (+1)
   \   00000054   0x8BA0             LDRH     R0,[R4, #+28]
   \   00000056   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \   0000005A   0x83A0             STRH     R0,[R4, #+28]
    575            }
    576          }
   \                     ??I2C_FastModeDutyCycleConfig_3: (+1)
   \   0000005C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    577          
    578          /**
    579            * @brief  Transmits the address byte to select the slave device.
    580            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    581            * @param  Address: specifies the slave address which will be transmitted
    582            * @param  I2C_Direction: specifies whether the I2C device will be a
    583            *   Transmitter or a Receiver. This parameter can be one of the following values
    584            *     @arg I2C_Direction_Transmitter: Transmitter mode
    585            *     @arg I2C_Direction_Receiver: Receiver mode
    586            * @retval None.
    587            */

   \                                 In section .text, align 2, keep-with-next
    588          void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction)
    589          {
   \                     I2C_Send7bitAddress: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    590            /* Check the parameters */
    591            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x40005400
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD009             BEQ.N    ??I2C_Send7bitAddress_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable26_1  ;; 0x40005800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD005             BEQ.N    ??I2C_Send7bitAddress_0
   \   00000018   0xF240 0x214F      MOVW     R1,#+591
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   00000020   0x.... 0x....      BL       assert_failed
    592            assert_param(IS_I2C_DIRECTION(I2C_Direction));
   \                     ??I2C_Send7bitAddress_0: (+1)
   \   00000024   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000026   0x2E00             CMP      R6,#+0
   \   00000028   0xD008             BEQ.N    ??I2C_Send7bitAddress_1
   \   0000002A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002C   0x2E01             CMP      R6,#+1
   \   0000002E   0xD005             BEQ.N    ??I2C_Send7bitAddress_1
   \   00000030   0xF44F 0x7114      MOV      R1,#+592
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   00000038   0x.... 0x....      BL       assert_failed
    593            /* Test on the direction to set/reset the read/write bit */
    594            if (I2C_Direction != I2C_Direction_Transmitter)
   \                     ??I2C_Send7bitAddress_1: (+1)
   \   0000003C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003E   0x2E00             CMP      R6,#+0
   \   00000040   0xD002             BEQ.N    ??I2C_Send7bitAddress_2
    595            {
    596              /* Set the address bit0 for read */
    597              Address |= I2C_OAR1_ADD0;
   \   00000042   0xF055 0x0501      ORRS     R5,R5,#0x1
   \   00000046   0xE001             B.N      ??I2C_Send7bitAddress_3
    598            }
    599            else
    600            {
    601              /* Reset the address bit0 for write */
    602              Address &= (uint8_t)~((uint8_t)I2C_OAR1_ADD0);
   \                     ??I2C_Send7bitAddress_2: (+1)
   \   00000048   0xF015 0x05FE      ANDS     R5,R5,#0xFE
    603            }
    604            /* Send the address */
    605            I2Cx->DR = Address;
   \                     ??I2C_Send7bitAddress_3: (+1)
   \   0000004C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004E   0x8225             STRH     R5,[R4, #+16]
    606          }
   \   00000050   0xBD70             POP      {R4-R6,PC}       ;; return
    607          
    608          /**
    609            * @}
    610            */
    611          
    612          /** @defgroup I2C_Group2 Data transfers functions
    613           *  @brief   Data transfers functions 
    614           *
    615          @verbatim   
    616           ===============================================================================
    617                                  Data transfers functions
    618           ===============================================================================  
    619          
    620          @endverbatim
    621            * @{
    622            */
    623          
    624          /**
    625            * @brief  Sends a data byte through the I2Cx peripheral.
    626            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    627            * @param  Data: Byte to be transmitted..
    628            * @retval None
    629            */

   \                                 In section .text, align 2, keep-with-next
    630          void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
    631          {
   \                     I2C_SendData: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    632            /* Check the parameters */
    633            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x40005400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD009             BEQ.N    ??I2C_SendData_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable26_1  ;; 0x40005800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD005             BEQ.N    ??I2C_SendData_0
   \   00000016   0xF240 0x2179      MOVW     R1,#+633
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   0000001E   0x.... 0x....      BL       assert_failed
    634            /* Write in the DR register the data to be sent */
    635            I2Cx->DR = Data;
   \                     ??I2C_SendData_0: (+1)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x8225             STRH     R5,[R4, #+16]
    636          }
   \   00000026   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    637          
    638          /**
    639            * @brief  Returns the most recent received data by the I2Cx peripheral.
    640            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    641            * @retval The value of the received data.
    642            */

   \                                 In section .text, align 2, keep-with-next
    643          uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
    644          {
   \                     I2C_ReceiveData: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    645            /* Check the parameters */
    646            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x40005400
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD009             BEQ.N    ??I2C_ReceiveData_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable26_1  ;; 0x40005800
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD005             BEQ.N    ??I2C_ReceiveData_0
   \   00000014   0xF240 0x2186      MOVW     R1,#+646
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   0000001C   0x.... 0x....      BL       assert_failed
    647            /* Return the data in the DR register */
    648            return (uint8_t)I2Cx->DR;
   \                     ??I2C_ReceiveData_0: (+1)
   \   00000020   0x8A20             LDRH     R0,[R4, #+16]
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    649          }
    650          
    651          /**
    652            * @}
    653            */
    654          
    655          /** @defgroup I2C_Group3 PEC management functions
    656           *  @brief   PEC management functions 
    657           *
    658          @verbatim   
    659           ===============================================================================
    660                                   PEC management functions
    661           ===============================================================================  
    662          
    663          @endverbatim
    664            * @{
    665            */
    666          
    667          /**
    668            * @brief  Enables or disables the specified I2C PEC transfer.
    669            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    670            * @param  NewState: new state of the I2C PEC transmission.
    671            *   This parameter can be: ENABLE or DISABLE.
    672            * @retval None
    673            */

   \                                 In section .text, align 2, keep-with-next
    674          void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
    675          {
   \                     I2C_TransmitPEC: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    676            /* Check the parameters */
    677            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x40005400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD009             BEQ.N    ??I2C_TransmitPEC_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable26_1  ;; 0x40005800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD005             BEQ.N    ??I2C_TransmitPEC_0
   \   00000016   0xF240 0x21A5      MOVW     R1,#+677
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   0000001E   0x.... 0x....      BL       assert_failed
    678            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??I2C_TransmitPEC_0: (+1)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD008             BEQ.N    ??I2C_TransmitPEC_1
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD005             BEQ.N    ??I2C_TransmitPEC_1
   \   0000002E   0xF240 0x21A6      MOVW     R1,#+678
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   00000036   0x.... 0x....      BL       assert_failed
    679            if (NewState != DISABLE)
   \                     ??I2C_TransmitPEC_1: (+1)
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x2D00             CMP      R5,#+0
   \   0000003E   0xD004             BEQ.N    ??I2C_TransmitPEC_2
    680            {
    681              /* Enable the selected I2C PEC transmission */
    682              I2Cx->CR1 |= I2C_CR1_PEC;
   \   00000040   0x8820             LDRH     R0,[R4, #+0]
   \   00000042   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   00000046   0x8020             STRH     R0,[R4, #+0]
   \   00000048   0xE004             B.N      ??I2C_TransmitPEC_3
    683            }
    684            else
    685            {
    686              /* Disable the selected I2C PEC transmission */
    687              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PEC);
   \                     ??I2C_TransmitPEC_2: (+1)
   \   0000004A   0x8820             LDRH     R0,[R4, #+0]
   \   0000004C   0xF64E 0x71FF      MOVW     R1,#+61439
   \   00000050   0x4008             ANDS     R0,R1,R0
   \   00000052   0x8020             STRH     R0,[R4, #+0]
    688            }
    689          }
   \                     ??I2C_TransmitPEC_3: (+1)
   \   00000054   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    690          
    691          /**
    692            * @brief  Selects the specified I2C PEC position.
    693            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    694            * @param  I2C_PECPosition: specifies the PEC position. 
    695            *   This parameter can be one of the following values:
    696            *     @arg I2C_PECPosition_Next: indicates that the next byte is PEC
    697            *     @arg I2C_PECPosition_Current: indicates that current byte is PEC
    698            * @retval None
    699            */

   \                                 In section .text, align 2, keep-with-next
    700          void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition)
    701          {
   \                     I2C_PECPositionConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    702            /* Check the parameters */
    703            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x40005400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD009             BEQ.N    ??I2C_PECPositionConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable26_1  ;; 0x40005800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD005             BEQ.N    ??I2C_PECPositionConfig_0
   \   00000016   0xF240 0x21BF      MOVW     R1,#+703
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   0000001E   0x.... 0x....      BL       assert_failed
    704            assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
   \                     ??I2C_PECPositionConfig_0: (+1)
   \   00000022   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000024   0xF5B5 0x6F00      CMP      R5,#+2048
   \   00000028   0xD00A             BEQ.N    ??I2C_PECPositionConfig_1
   \   0000002A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002C   0xF24F 0x70FF      MOVW     R0,#+63487
   \   00000030   0x4285             CMP      R5,R0
   \   00000032   0xD005             BEQ.N    ??I2C_PECPositionConfig_1
   \   00000034   0xF44F 0x7130      MOV      R1,#+704
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   0000003C   0x.... 0x....      BL       assert_failed
    705            if (I2C_PECPosition == I2C_PECPosition_Next)
   \                     ??I2C_PECPositionConfig_1: (+1)
   \   00000040   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000042   0xF5B5 0x6F00      CMP      R5,#+2048
   \   00000046   0xD104             BNE.N    ??I2C_PECPositionConfig_2
    706            {
    707              /* Next byte in shift register is PEC */
    708              I2Cx->CR1 |= I2C_PECPosition_Next;
   \   00000048   0x8820             LDRH     R0,[R4, #+0]
   \   0000004A   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   0000004E   0x8020             STRH     R0,[R4, #+0]
   \   00000050   0xE004             B.N      ??I2C_PECPositionConfig_3
    709            }
    710            else
    711            {
    712              /* Current byte in shift register is PEC */
    713              I2Cx->CR1 &= I2C_PECPosition_Current;
   \                     ??I2C_PECPositionConfig_2: (+1)
   \   00000052   0x8820             LDRH     R0,[R4, #+0]
   \   00000054   0xF24F 0x71FF      MOVW     R1,#+63487
   \   00000058   0x4008             ANDS     R0,R1,R0
   \   0000005A   0x8020             STRH     R0,[R4, #+0]
    714            }
    715          }
   \                     ??I2C_PECPositionConfig_3: (+1)
   \   0000005C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    716          
    717          /**
    718            * @brief  Enables or disables the PEC value calculation of the transferred bytes.
    719            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    720            * @param  NewState: new state of the I2Cx PEC value calculation.
    721            *   This parameter can be: ENABLE or DISABLE.
    722            * @retval None
    723            */

   \                                 In section .text, align 2, keep-with-next
    724          void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
    725          {
   \                     I2C_CalculatePEC: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    726            /* Check the parameters */
    727            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x....             LDR.N    R0,??DataTable26  ;; 0x40005400
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD007             BEQ.N    ??I2C_CalculatePEC_0
   \   0000000C   0x....             LDR.N    R0,??DataTable26_1  ;; 0x40005800
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD004             BEQ.N    ??I2C_CalculatePEC_0
   \   00000012   0xF240 0x21D7      MOVW     R1,#+727
   \   00000016   0x....             LDR.N    R0,??DataTable26_2
   \   00000018   0x.... 0x....      BL       assert_failed
    728            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??I2C_CalculatePEC_0: (+1)
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD007             BEQ.N    ??I2C_CalculatePEC_1
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D01             CMP      R5,#+1
   \   00000026   0xD004             BEQ.N    ??I2C_CalculatePEC_1
   \   00000028   0xF44F 0x7136      MOV      R1,#+728
   \   0000002C   0x....             LDR.N    R0,??DataTable26_2
   \   0000002E   0x.... 0x....      BL       assert_failed
    729            if (NewState != DISABLE)
   \                     ??I2C_CalculatePEC_1: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD004             BEQ.N    ??I2C_CalculatePEC_2
    730            {
    731              /* Enable the selected I2C PEC calculation */
    732              I2Cx->CR1 |= I2C_CR1_ENPEC;
   \   00000038   0x8820             LDRH     R0,[R4, #+0]
   \   0000003A   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000003E   0x8020             STRH     R0,[R4, #+0]
   \   00000040   0xE004             B.N      ??I2C_CalculatePEC_3
    733            }
    734            else
    735            {
    736              /* Disable the selected I2C PEC calculation */
    737              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENPEC);
   \                     ??I2C_CalculatePEC_2: (+1)
   \   00000042   0x8820             LDRH     R0,[R4, #+0]
   \   00000044   0xF64F 0x71DF      MOVW     R1,#+65503
   \   00000048   0x4008             ANDS     R0,R1,R0
   \   0000004A   0x8020             STRH     R0,[R4, #+0]
    738            }
    739          }
   \                     ??I2C_CalculatePEC_3: (+1)
   \   0000004C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    740          
    741          /**
    742            * @brief  Returns the PEC value for the specified I2C.
    743            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    744            * @retval The PEC value.
    745            */

   \                                 In section .text, align 2, keep-with-next
    746          uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
    747          {
   \                     I2C_GetPEC: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    748            /* Check the parameters */
    749            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000004   0x....             LDR.N    R0,??DataTable26  ;; 0x40005400
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD007             BEQ.N    ??I2C_GetPEC_0
   \   0000000A   0x....             LDR.N    R0,??DataTable26_1  ;; 0x40005800
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD004             BEQ.N    ??I2C_GetPEC_0
   \   00000010   0xF240 0x21ED      MOVW     R1,#+749
   \   00000014   0x....             LDR.N    R0,??DataTable26_2
   \   00000016   0x.... 0x....      BL       assert_failed
    750            /* Return the selected I2C PEC value */
    751            return ((I2Cx->SR2) >> 8);
   \                     ??I2C_GetPEC_0: (+1)
   \   0000001A   0x8B20             LDRH     R0,[R4, #+24]
   \   0000001C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000001E   0x0A00             LSRS     R0,R0,#+8
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    752          }
    753          
    754          /**
    755            * @}
    756            */
    757          
    758          /** @defgroup I2C_Group4 DMA transfers management functions
    759           *  @brief   DMA transfers management functions 
    760           *
    761          @verbatim   
    762           ===============================================================================
    763                                   DMA transfers management functions
    764           ===============================================================================  
    765            This section provides functions allowing to configure the I2C DMA channels 
    766            requests.
    767            
    768          @endverbatim
    769            * @{
    770            */
    771          
    772          /**
    773            * @brief  Enables or disables the specified I2C DMA requests.
    774            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    775            * @param  NewState: new state of the I2C DMA transfer.
    776            *   This parameter can be: ENABLE or DISABLE.
    777            * @retval None
    778            */

   \                                 In section .text, align 2, keep-with-next
    779          void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    780          {
   \                     I2C_DMACmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    781            /* Check the parameters */
    782            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x....             LDR.N    R0,??DataTable26  ;; 0x40005400
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD007             BEQ.N    ??I2C_DMACmd_0
   \   0000000C   0x....             LDR.N    R0,??DataTable26_1  ;; 0x40005800
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD004             BEQ.N    ??I2C_DMACmd_0
   \   00000012   0xF240 0x310E      MOVW     R1,#+782
   \   00000016   0x....             LDR.N    R0,??DataTable26_2
   \   00000018   0x.... 0x....      BL       assert_failed
    783            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??I2C_DMACmd_0: (+1)
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD007             BEQ.N    ??I2C_DMACmd_1
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D01             CMP      R5,#+1
   \   00000026   0xD004             BEQ.N    ??I2C_DMACmd_1
   \   00000028   0xF240 0x310F      MOVW     R1,#+783
   \   0000002C   0x....             LDR.N    R0,??DataTable26_2
   \   0000002E   0x.... 0x....      BL       assert_failed
    784            if (NewState != DISABLE)
   \                     ??I2C_DMACmd_1: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD004             BEQ.N    ??I2C_DMACmd_2
    785            {
    786              /* Enable the selected I2C DMA requests */
    787              I2Cx->CR2 |= I2C_CR2_DMAEN;
   \   00000038   0x88A0             LDRH     R0,[R4, #+4]
   \   0000003A   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   0000003E   0x80A0             STRH     R0,[R4, #+4]
   \   00000040   0xE004             B.N      ??I2C_DMACmd_3
    788            }
    789            else
    790            {
    791              /* Disable the selected I2C DMA requests */
    792              I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_DMAEN);
   \                     ??I2C_DMACmd_2: (+1)
   \   00000042   0x88A0             LDRH     R0,[R4, #+4]
   \   00000044   0xF24F 0x71FF      MOVW     R1,#+63487
   \   00000048   0x4008             ANDS     R0,R1,R0
   \   0000004A   0x80A0             STRH     R0,[R4, #+4]
    793            }
    794          }
   \                     ??I2C_DMACmd_3: (+1)
   \   0000004C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    795          
    796          /**
    797            * @brief  Specifies that the next DMA transfer is the last one.
    798            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    799            * @param  NewState: new state of the I2C DMA last transfer.
    800            *   This parameter can be: ENABLE or DISABLE.
    801            * @retval None
    802            */

   \                                 In section .text, align 2, keep-with-next
    803          void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    804          {
   \                     I2C_DMALastTransferCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    805            /* Check the parameters */
    806            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x....             LDR.N    R0,??DataTable26  ;; 0x40005400
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD007             BEQ.N    ??I2C_DMALastTransferCmd_0
   \   0000000C   0x....             LDR.N    R0,??DataTable26_1  ;; 0x40005800
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD004             BEQ.N    ??I2C_DMALastTransferCmd_0
   \   00000012   0xF240 0x3126      MOVW     R1,#+806
   \   00000016   0x....             LDR.N    R0,??DataTable26_2
   \   00000018   0x.... 0x....      BL       assert_failed
    807            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??I2C_DMALastTransferCmd_0: (+1)
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD007             BEQ.N    ??I2C_DMALastTransferCmd_1
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D01             CMP      R5,#+1
   \   00000026   0xD004             BEQ.N    ??I2C_DMALastTransferCmd_1
   \   00000028   0xF240 0x3127      MOVW     R1,#+807
   \   0000002C   0x....             LDR.N    R0,??DataTable26_2
   \   0000002E   0x.... 0x....      BL       assert_failed
    808            if (NewState != DISABLE)
   \                     ??I2C_DMALastTransferCmd_1: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD004             BEQ.N    ??I2C_DMALastTransferCmd_2
    809            {
    810              /* Next DMA transfer is the last transfer */
    811              I2Cx->CR2 |= I2C_CR2_LAST;
   \   00000038   0x88A0             LDRH     R0,[R4, #+4]
   \   0000003A   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   0000003E   0x80A0             STRH     R0,[R4, #+4]
   \   00000040   0xE004             B.N      ??I2C_DMALastTransferCmd_3
    812            }
    813            else
    814            {
    815              /* Next DMA transfer is not the last transfer */
    816              I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_LAST);
   \                     ??I2C_DMALastTransferCmd_2: (+1)
   \   00000042   0x88A0             LDRH     R0,[R4, #+4]
   \   00000044   0xF64E 0x71FF      MOVW     R1,#+61439
   \   00000048   0x4008             ANDS     R0,R1,R0
   \   0000004A   0x80A0             STRH     R0,[R4, #+4]
    817            }
    818          }
   \                     ??I2C_DMALastTransferCmd_3: (+1)
   \   0000004C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    819          
    820          /**
    821            * @}
    822            */
    823          
    824          /** @defgroup I2C_Group5 Interrupts events and flags management functions
    825           *  @brief   Interrupts, events and flags management functions
    826           *
    827          @verbatim   
    828           ===============================================================================
    829                          Interrupts, events and flags management functions
    830           ===============================================================================  
    831            This section provides functions allowing to configure the I2C Interrupts 
    832            sources and check or clear the flags or pending bits status.
    833            The user should identify which mode will be used in his application to manage 
    834            the communication: Polling mode, Interrupt mode or DMA mode. 
    835          
    836           ===============================================================================
    837                                    I2C State Monitoring Functions                    
    838           ===============================================================================   
    839            This I2C driver provides three different ways for I2C state monitoring
    840            depending on the application requirements and constraints:
    841                   
    842             
    843               1. Basic state monitoring (Using I2C_CheckEvent() function)
    844               -----------------------------------------------------------
    845                  It compares the status registers (SR1 and SR2) content to a given event
    846                  (can be the combination of one or more flags).
    847                  It returns SUCCESS if the current status includes the given flags 
    848                  and returns ERROR if one or more flags are missing in the current status.
    849          
    850                    - When to use
    851                       - This function is suitable for most applications as well as for startup 
    852                         activity since the events are fully described in the product reference 
    853                         manual (RM0038).
    854                       - It is also suitable for users who need to define their own events.
    855          
    856                    - Limitations
    857                       - If an error occurs (ie. error flags are set besides to the monitored 
    858                         flags), the I2C_CheckEvent() function may return SUCCESS despite 
    859                         the communication hold or corrupted real state. 
    860                         In this case, it is advised to use error interrupts to monitor 
    861                         the error events and handle them in the interrupt IRQ handler.
    862                   
    863               @note 
    864                   For error management, it is advised to use the following functions:
    865                     - I2C_ITConfig() to configure and enable the error interrupts (I2C_IT_ERR).
    866                     - I2Cx_ER_IRQHandler() which is called when the error interrupt occurs.
    867                       Where x is the peripheral instance (I2C1, I2C2 ...)
    868                     - I2C_GetFlagStatus() or I2C_GetITStatus()  to be called into the 
    869                       I2Cx_ER_IRQHandler() function in order to determine which error occurred.
    870                     - I2C_ClearFlag() or I2C_ClearITPendingBit() and/or I2C_SoftwareResetCmd() 
    871                       and/or I2C_GenerateStop() in order to clear the error flag and source 
    872                       and return to correct  communication status.
    873                       
    874           
    875               2. Advanced state monitoring (Using the function I2C_GetLastEvent())
    876               -------------------------------------------------------------------- 
    877                  Using the function I2C_GetLastEvent() which returns the image of both status 
    878                  registers in a single word (uint32_t) (Status Register 2 value is shifted left 
    879                  by 16 bits and concatenated to Status Register 1).
    880          
    881                    - When to use
    882                       - This function is suitable for the same applications above but it 
    883                         allows to overcome the mentioned limitation of I2C_GetFlagStatus() 
    884                         function.
    885                       - The returned value could be compared to events already defined in 
    886                         the library (stm32l1xx_i2c.h) or to custom values defined by user.
    887                         This function is suitable when multiple flags are monitored at the 
    888                         same time.
    889                       - At the opposite of I2C_CheckEvent() function, this function allows 
    890                         user to choose when an event is accepted (when all events flags are 
    891                         set and no other flags are set or just when the needed flags are set 
    892                         like I2C_CheckEvent() function.
    893          
    894                    - Limitations
    895                       - User may need to define his own events.
    896                       - Same remark concerning the error management is applicable for this 
    897                         function if user decides to check only regular communication flags 
    898                         (and ignores error flags).
    899                
    900           
    901               3. Flag-based state monitoring (Using the function I2C_GetFlagStatus())
    902               -----------------------------------------------------------------------
    903               
    904                Using the function I2C_GetFlagStatus() which simply returns the status of 
    905                one single flag (ie. I2C_FLAG_RXNE ...). 
    906          
    907                    - When to use
    908                       - This function could be used for specific applications or in debug 
    909                         phase.
    910                       - It is suitable when only one flag checking is needed (most I2C 
    911                         events are monitored through multiple flags).
    912                    - Limitations: 
    913                       - When calling this function, the Status register is accessed. 
    914                         Some flags are cleared when the status register is accessed. 
    915                         So checking the status of one Flag, may clear other ones.
    916                       - Function may need to be called twice or more in order to monitor 
    917                         one single event.
    918           
    919             For detailed description of Events, please refer to section I2C_Events in 
    920             stm32l1xx_i2c.h file.
    921                 
    922          @endverbatim
    923            * @{
    924            */
    925             
    926          /**
    927            * @brief  Reads the specified I2C register and returns its value.
    928            * @param  I2C_Register: specifies the register to read.
    929            *   This parameter can be one of the following values:
    930            *     @arg I2C_Register_CR1:  CR1 register.
    931            *     @arg I2C_Register_CR2:   CR2 register.
    932            *     @arg I2C_Register_OAR1:  OAR1 register.
    933            *     @arg I2C_Register_OAR2:  OAR2 register.
    934            *     @arg I2C_Register_DR:    DR register.
    935            *     @arg I2C_Register_SR1:   SR1 register.
    936            *     @arg I2C_Register_SR2:   SR2 register.
    937            *     @arg I2C_Register_CCR:   CCR register.
    938            *     @arg I2C_Register_TRISE: TRISE register.
    939            * @retval The value of the read register.
    940            */

   \                                 In section .text, align 2, keep-with-next
    941          uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
    942          {
   \                     I2C_ReadRegister: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    943            __IO uint32_t tmp = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
    944          
    945            /* Check the parameters */
    946            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   0000000A   0x....             LDR.N    R0,??DataTable26  ;; 0x40005400
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD007             BEQ.N    ??I2C_ReadRegister_0
   \   00000010   0x....             LDR.N    R0,??DataTable26_1  ;; 0x40005800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD004             BEQ.N    ??I2C_ReadRegister_0
   \   00000016   0xF240 0x31B2      MOVW     R1,#+946
   \   0000001A   0x....             LDR.N    R0,??DataTable26_2
   \   0000001C   0x.... 0x....      BL       assert_failed
    947            assert_param(IS_I2C_REGISTER(I2C_Register));
   \                     ??I2C_ReadRegister_0: (+1)
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD01C             BEQ.N    ??I2C_ReadRegister_1
   \   00000026   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000028   0x2D04             CMP      R5,#+4
   \   0000002A   0xD019             BEQ.N    ??I2C_ReadRegister_1
   \   0000002C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002E   0x2D08             CMP      R5,#+8
   \   00000030   0xD016             BEQ.N    ??I2C_ReadRegister_1
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D0C             CMP      R5,#+12
   \   00000036   0xD013             BEQ.N    ??I2C_ReadRegister_1
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0x2D10             CMP      R5,#+16
   \   0000003C   0xD010             BEQ.N    ??I2C_ReadRegister_1
   \   0000003E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000040   0x2D14             CMP      R5,#+20
   \   00000042   0xD00D             BEQ.N    ??I2C_ReadRegister_1
   \   00000044   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000046   0x2D18             CMP      R5,#+24
   \   00000048   0xD00A             BEQ.N    ??I2C_ReadRegister_1
   \   0000004A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004C   0x2D1C             CMP      R5,#+28
   \   0000004E   0xD007             BEQ.N    ??I2C_ReadRegister_1
   \   00000050   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000052   0x2D20             CMP      R5,#+32
   \   00000054   0xD004             BEQ.N    ??I2C_ReadRegister_1
   \   00000056   0xF240 0x31B3      MOVW     R1,#+947
   \   0000005A   0x....             LDR.N    R0,??DataTable26_2
   \   0000005C   0x.... 0x....      BL       assert_failed
    948          
    949            tmp = (uint32_t) I2Cx;
   \                     ??I2C_ReadRegister_1: (+1)
   \   00000060   0x9400             STR      R4,[SP, #+0]
    950            tmp += I2C_Register;
   \   00000062   0x9800             LDR      R0,[SP, #+0]
   \   00000064   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000066   0x1828             ADDS     R0,R5,R0
   \   00000068   0x9000             STR      R0,[SP, #+0]
    951          
    952            /* Return the selected register value */
    953            return (*(__IO uint16_t *) tmp);
   \   0000006A   0x9800             LDR      R0,[SP, #+0]
   \   0000006C   0x8800             LDRH     R0,[R0, #+0]
   \   0000006E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    954          }
    955          
    956          /**
    957            * @brief  Enables or disables the specified I2C interrupts.
    958            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    959            * @param  I2C_IT: specifies the I2C interrupts sources to be enabled or disabled. 
    960            *   This parameter can be any combination of the following values:
    961            *     @arg I2C_IT_BUF: Buffer interrupt mask
    962            *     @arg I2C_IT_EVT: Event interrupt mask
    963            *     @arg I2C_IT_ERR: Error interrupt mask
    964            * @param  NewState: new state of the specified I2C interrupts.
    965            *   This parameter can be: ENABLE or DISABLE.
    966            * @retval None
    967            */

   \                                 In section .text, align 2, keep-with-next
    968          void I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState)
    969          {
   \                     I2C_ITConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    970            /* Check the parameters */
    971            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000008   0x....             LDR.N    R0,??DataTable26  ;; 0x40005400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD007             BEQ.N    ??I2C_ITConfig_0
   \   0000000E   0x....             LDR.N    R0,??DataTable26_1  ;; 0x40005800
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD004             BEQ.N    ??I2C_ITConfig_0
   \   00000014   0xF240 0x31CB      MOVW     R1,#+971
   \   00000018   0x....             LDR.N    R0,??DataTable26_2
   \   0000001A   0x.... 0x....      BL       assert_failed
    972            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??I2C_ITConfig_0: (+1)
   \   0000001E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000020   0x2E00             CMP      R6,#+0
   \   00000022   0xD007             BEQ.N    ??I2C_ITConfig_1
   \   00000024   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000026   0x2E01             CMP      R6,#+1
   \   00000028   0xD004             BEQ.N    ??I2C_ITConfig_1
   \   0000002A   0xF44F 0x7173      MOV      R1,#+972
   \   0000002E   0x....             LDR.N    R0,??DataTable26_2
   \   00000030   0x.... 0x....      BL       assert_failed
    973            assert_param(IS_I2C_CONFIG_IT(I2C_IT));
   \                     ??I2C_ITConfig_1: (+1)
   \   00000034   0xF64F 0x00FF      MOVW     R0,#+63743
   \   00000038   0x4205             TST      R5,R0
   \   0000003A   0xD102             BNE.N    ??I2C_ITConfig_2
   \   0000003C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000003E   0x2D00             CMP      R5,#+0
   \   00000040   0xD104             BNE.N    ??I2C_ITConfig_3
   \                     ??I2C_ITConfig_2: (+1)
   \   00000042   0xF240 0x31CD      MOVW     R1,#+973
   \   00000046   0x....             LDR.N    R0,??DataTable26_2
   \   00000048   0x.... 0x....      BL       assert_failed
    974            
    975            if (NewState != DISABLE)
   \                     ??I2C_ITConfig_3: (+1)
   \   0000004C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004E   0x2E00             CMP      R6,#+0
   \   00000050   0xD003             BEQ.N    ??I2C_ITConfig_4
    976            {
    977              /* Enable the selected I2C interrupts */
    978              I2Cx->CR2 |= I2C_IT;
   \   00000052   0x88A0             LDRH     R0,[R4, #+4]
   \   00000054   0x4328             ORRS     R0,R5,R0
   \   00000056   0x80A0             STRH     R0,[R4, #+4]
   \   00000058   0xE002             B.N      ??I2C_ITConfig_5
    979            }
    980            else
    981            {
    982              /* Disable the selected I2C interrupts */
    983              I2Cx->CR2 &= (uint16_t)~I2C_IT;
   \                     ??I2C_ITConfig_4: (+1)
   \   0000005A   0x88A0             LDRH     R0,[R4, #+4]
   \   0000005C   0x43A8             BICS     R0,R0,R5
   \   0000005E   0x80A0             STRH     R0,[R4, #+4]
    984            }
    985          }
   \                     ??I2C_ITConfig_5: (+1)
   \   00000060   0xBD70             POP      {R4-R6,PC}       ;; return
    986          
    987          /**
    988           ===============================================================================
    989                                    1. Basic state monitoring                    
    990           ===============================================================================  
    991           */
    992          
    993          /**
    994            * @brief  Checks whether the last I2Cx Event is equal to the one passed
    995            *   as parameter.
    996            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    997            * @param  I2C_EVENT: specifies the event to be checked. 
    998            *   This parameter can be one of the following values:
    999            *     @arg I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED           : EV1
   1000            *     @arg I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED              : EV1
   1001            *     @arg I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED     : EV1
   1002            *     @arg I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED        : EV1
   1003            *     @arg I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED            : EV1
   1004            *     @arg I2C_EVENT_SLAVE_BYTE_RECEIVED                         : EV2
   1005            *     @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_DUALF)      : EV2
   1006            *     @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL)    : EV2
   1007            *     @arg I2C_EVENT_SLAVE_BYTE_TRANSMITTED                      : EV3
   1008            *     @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_DUALF)   : EV3
   1009            *     @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL) : EV3
   1010            *     @arg I2C_EVENT_SLAVE_ACK_FAILURE                           : EV3_2
   1011            *     @arg I2C_EVENT_SLAVE_STOP_DETECTED                         : EV4
   1012            *     @arg I2C_EVENT_MASTER_MODE_SELECT                          : EV5
   1013            *     @arg I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED            : EV6     
   1014            *     @arg I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED               : EV6
   1015            *     @arg I2C_EVENT_MASTER_BYTE_RECEIVED                        : EV7
   1016            *     @arg I2C_EVENT_MASTER_BYTE_TRANSMITTING                    : EV8
   1017            *     @arg I2C_EVENT_MASTER_BYTE_TRANSMITTED                     : EV8_2
   1018            *     @arg I2C_EVENT_MASTER_MODE_ADDRESS10                       : EV9
   1019            *     
   1020            * @note: For detailed description of Events, please refer to section 
   1021            *    I2C_Events in stm32l1xx_i2c.h file.
   1022            *    
   1023            * @retval An ErrorStatus enumeration value:
   1024            * - SUCCESS: Last event is equal to the I2C_EVENT
   1025            * - ERROR: Last event is different from the I2C_EVENT
   1026            */

   \                                 In section .text, align 2, keep-with-next
   1027          ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT)
   1028          {
   \                     I2C_CheckEvent: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1029            uint32_t lastevent = 0;
   \   00000008   0x2600             MOVS     R6,#+0
   1030            uint32_t flag1 = 0, flag2 = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   1031            ErrorStatus status = ERROR;
   \   00000010   0xF05F 0x0900      MOVS     R9,#+0
   1032          
   1033            /* Check the parameters */
   1034            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000014   0x....             LDR.N    R0,??DataTable26  ;; 0x40005400
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD007             BEQ.N    ??I2C_CheckEvent_0
   \   0000001A   0x....             LDR.N    R0,??DataTable26_1  ;; 0x40005800
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD004             BEQ.N    ??I2C_CheckEvent_0
   \   00000020   0xF240 0x410A      MOVW     R1,#+1034
   \   00000024   0x....             LDR.N    R0,??DataTable26_2
   \   00000026   0x.... 0x....      BL       assert_failed
   1035            assert_param(IS_I2C_EVENT(I2C_EVENT));
   \                     ??I2C_CheckEvent_0: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable30_1  ;; 0x60082
   \   0000002E   0x4285             CMP      R5,R0
   \   00000030   0xD042             BEQ.N    ??I2C_CheckEvent_1
   \   00000032   0xF1B5 0x1F02      CMP      R5,#+131074
   \   00000036   0xD03F             BEQ.N    ??I2C_CheckEvent_1
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable30_2  ;; 0x860080
   \   0000003C   0x4285             CMP      R5,R0
   \   0000003E   0xD03B             BEQ.N    ??I2C_CheckEvent_1
   \   00000040   0xF5B5 0x0F02      CMP      R5,#+8519680
   \   00000044   0xD038             BEQ.N    ??I2C_CheckEvent_1
   \   00000046   0xF5B5 0x1F90      CMP      R5,#+1179648
   \   0000004A   0xD035             BEQ.N    ??I2C_CheckEvent_1
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable30_3  ;; 0x20040
   \   00000050   0x4285             CMP      R5,R0
   \   00000052   0xD031             BEQ.N    ??I2C_CheckEvent_1
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable30_4  ;; 0x820040
   \   00000058   0x4285             CMP      R5,R0
   \   0000005A   0xD02D             BEQ.N    ??I2C_CheckEvent_1
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable30_5  ;; 0x120040
   \   00000060   0x4285             CMP      R5,R0
   \   00000062   0xD029             BEQ.N    ??I2C_CheckEvent_1
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable30_6  ;; 0x60084
   \   00000068   0x4285             CMP      R5,R0
   \   0000006A   0xD025             BEQ.N    ??I2C_CheckEvent_1
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable30_7  ;; 0x860084
   \   00000070   0x4285             CMP      R5,R0
   \   00000072   0xD021             BEQ.N    ??I2C_CheckEvent_1
   \   00000074   0x....             LDR.N    R0,??DataTable30_8  ;; 0x160084
   \   00000076   0x4285             CMP      R5,R0
   \   00000078   0xD01E             BEQ.N    ??I2C_CheckEvent_1
   \   0000007A   0x2D10             CMP      R5,#+16
   \   0000007C   0xD01C             BEQ.N    ??I2C_CheckEvent_1
   \   0000007E   0x....             LDR.N    R0,??DataTable30_9  ;; 0x30001
   \   00000080   0x4285             CMP      R5,R0
   \   00000082   0xD019             BEQ.N    ??I2C_CheckEvent_1
   \   00000084   0x....             LDR.N    R0,??DataTable30_10  ;; 0x70082
   \   00000086   0x4285             CMP      R5,R0
   \   00000088   0xD016             BEQ.N    ??I2C_CheckEvent_1
   \   0000008A   0x....             LDR.N    R0,??DataTable30_11  ;; 0x30002
   \   0000008C   0x4285             CMP      R5,R0
   \   0000008E   0xD013             BEQ.N    ??I2C_CheckEvent_1
   \   00000090   0x....             LDR.N    R0,??DataTable30_12  ;; 0x30040
   \   00000092   0x4285             CMP      R5,R0
   \   00000094   0xD010             BEQ.N    ??I2C_CheckEvent_1
   \   00000096   0x....             LDR.N    R0,??DataTable30_13  ;; 0x70084
   \   00000098   0x4285             CMP      R5,R0
   \   0000009A   0xD00D             BEQ.N    ??I2C_CheckEvent_1
   \   0000009C   0x....             LDR.N    R0,??DataTable30_14  ;; 0x70080
   \   0000009E   0x4285             CMP      R5,R0
   \   000000A0   0xD00A             BEQ.N    ??I2C_CheckEvent_1
   \   000000A2   0x....             LDR.N    R0,??DataTable30_15  ;; 0x30008
   \   000000A4   0x4285             CMP      R5,R0
   \   000000A6   0xD007             BEQ.N    ??I2C_CheckEvent_1
   \   000000A8   0xF5B5 0x6F80      CMP      R5,#+1024
   \   000000AC   0xD004             BEQ.N    ??I2C_CheckEvent_1
   \   000000AE   0xF240 0x410B      MOVW     R1,#+1035
   \   000000B2   0x....             LDR.N    R0,??DataTable26_2
   \   000000B4   0x.... 0x....      BL       assert_failed
   1036          
   1037            /* Read the I2Cx status register */
   1038            flag1 = I2Cx->SR1;
   \                     ??I2C_CheckEvent_1: (+1)
   \   000000B8   0x8AA0             LDRH     R0,[R4, #+20]
   \   000000BA   0x0007             MOVS     R7,R0
   1039            flag2 = I2Cx->SR2;
   \   000000BC   0x8B20             LDRH     R0,[R4, #+24]
   \   000000BE   0x4680             MOV      R8,R0
   1040            flag2 = flag2 << 16;
   \   000000C0   0xEA5F 0x4808      LSLS     R8,R8,#+16
   1041          
   1042            /* Get the last event value from I2C status register */
   1043            lastevent = (flag1 | flag2) & FLAG_MASK;
   \   000000C4   0xEA58 0x0007      ORRS     R0,R8,R7
   \   000000C8   0x0200             LSLS     R0,R0,#+8        ;; ZeroExtS R0,R0,#+8,#+8
   \   000000CA   0x0A00             LSRS     R0,R0,#+8
   \   000000CC   0x0006             MOVS     R6,R0
   1044          
   1045            /* Check whether the last event contains the I2C_EVENT */
   1046            if ((lastevent & I2C_EVENT) == I2C_EVENT)
   \   000000CE   0xEA15 0x0006      ANDS     R0,R5,R6
   \   000000D2   0x42A8             CMP      R0,R5
   \   000000D4   0xD102             BNE.N    ??I2C_CheckEvent_2
   1047            {
   1048              /* SUCCESS: last event is equal to I2C_EVENT */
   1049              status = SUCCESS;
   \   000000D6   0x2001             MOVS     R0,#+1
   \   000000D8   0x4681             MOV      R9,R0
   \   000000DA   0xE001             B.N      ??I2C_CheckEvent_3
   1050            }
   1051            else
   1052            {
   1053              /* ERROR: last event is different from I2C_EVENT */
   1054              status = ERROR;
   \                     ??I2C_CheckEvent_2: (+1)
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0x4681             MOV      R9,R0
   1055            }
   1056            /* Return status */
   1057            return status;
   \                     ??I2C_CheckEvent_3: (+1)
   \   000000E0   0x4648             MOV      R0,R9
   \   000000E2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E4   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1058          }
   1059          
   1060          /**
   1061           ===============================================================================
   1062                                    2. Advanced state monitoring                   
   1063           ===============================================================================  
   1064           */
   1065          
   1066          /**
   1067            * @brief  Returns the last I2Cx Event.
   1068            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
   1069            *     
   1070            * @note: For detailed description of Events, please refer to section 
   1071            *    I2C_Events in stm32l1xx_i2c.h file.
   1072            *    
   1073            * @retval The last event
   1074            */

   \                                 In section .text, align 2, keep-with-next
   1075          uint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx)
   1076          {
   \                     I2C_GetLastEvent: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1077            uint32_t lastevent = 0;
   \   00000004   0x2500             MOVS     R5,#+0
   1078            uint32_t flag1 = 0, flag2 = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0x2700             MOVS     R7,#+0
   1079          
   1080            /* Check the parameters */
   1081            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   0000000A   0x....             LDR.N    R0,??DataTable26  ;; 0x40005400
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD007             BEQ.N    ??I2C_GetLastEvent_0
   \   00000010   0x....             LDR.N    R0,??DataTable26_1  ;; 0x40005800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD004             BEQ.N    ??I2C_GetLastEvent_0
   \   00000016   0xF240 0x4139      MOVW     R1,#+1081
   \   0000001A   0x....             LDR.N    R0,??DataTable26_2
   \   0000001C   0x.... 0x....      BL       assert_failed
   1082          
   1083            /* Read the I2Cx status register */
   1084            flag1 = I2Cx->SR1;
   \                     ??I2C_GetLastEvent_0: (+1)
   \   00000020   0x8AA0             LDRH     R0,[R4, #+20]
   \   00000022   0x0006             MOVS     R6,R0
   1085            flag2 = I2Cx->SR2;
   \   00000024   0x8B20             LDRH     R0,[R4, #+24]
   \   00000026   0x0007             MOVS     R7,R0
   1086            flag2 = flag2 << 16;
   \   00000028   0x043F             LSLS     R7,R7,#+16
   1087          
   1088            /* Get the last event value from I2C status register */
   1089            lastevent = (flag1 | flag2) & FLAG_MASK;
   \   0000002A   0xEA57 0x0006      ORRS     R0,R7,R6
   \   0000002E   0x0200             LSLS     R0,R0,#+8        ;; ZeroExtS R0,R0,#+8,#+8
   \   00000030   0x0A00             LSRS     R0,R0,#+8
   \   00000032   0x0005             MOVS     R5,R0
   1090          
   1091            /* Return status */
   1092            return lastevent;
   \   00000034   0x0028             MOVS     R0,R5
   \   00000036   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1093          }
   1094          
   1095          /**
   1096           ===============================================================================
   1097                                    3. Flag-based state monitoring                   
   1098           ===============================================================================  
   1099           */
   1100          
   1101          /**
   1102            * @brief  Checks whether the specified I2C flag is set or not.
   1103            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
   1104            * @param  I2C_FLAG: specifies the flag to check. 
   1105            *   This parameter can be one of the following values:
   1106            *     @arg I2C_FLAG_DUALF: Dual flag (Slave mode)
   1107            *     @arg I2C_FLAG_SMBHOST: SMBus host header (Slave mode)
   1108            *     @arg I2C_FLAG_SMBDEFAULT: SMBus default header (Slave mode)
   1109            *     @arg I2C_FLAG_GENCALL: General call header flag (Slave mode)
   1110            *     @arg I2C_FLAG_TRA: Transmitter/Receiver flag
   1111            *     @arg I2C_FLAG_BUSY: Bus busy flag
   1112            *     @arg I2C_FLAG_MSL: Master/Slave flag
   1113            *     @arg I2C_FLAG_SMBALERT: SMBus Alert flag
   1114            *     @arg I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
   1115            *     @arg I2C_FLAG_PECERR: PEC error in reception flag
   1116            *     @arg I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
   1117            *     @arg I2C_FLAG_AF: Acknowledge failure flag
   1118            *     @arg I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
   1119            *     @arg I2C_FLAG_BERR: Bus error flag
   1120            *     @arg I2C_FLAG_TXE: Data register empty flag (Transmitter)
   1121            *     @arg I2C_FLAG_RXNE: Data register not empty (Receiver) flag
   1122            *     @arg I2C_FLAG_STOPF: Stop detection flag (Slave mode)
   1123            *     @arg I2C_FLAG_ADD10: 10-bit header sent flag (Master mode)
   1124            *     @arg I2C_FLAG_BTF: Byte transfer finished flag
   1125            *     @arg I2C_FLAG_ADDR: Address sent flag (Master mode) ADSL
   1126            *   Address matched flag (Slave mode)ENDAD
   1127            *     @arg I2C_FLAG_SB: Start bit flag (Master mode)
   1128            * @retval The new state of I2C_FLAG (SET or RESET).
   1129            */

   \                                 In section .text, align 2, keep-with-next
   1130          FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
   1131          {
   \                     I2C_GetFlagStatus: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1132            FlagStatus bitstatus = RESET;
   \   00000006   0x2600             MOVS     R6,#+0
   1133            __IO uint32_t i2creg = 0, i2cxbase = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x9001             STR      R0,[SP, #+4]
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x9000             STR      R0,[SP, #+0]
   1134          
   1135            /* Check the parameters */
   1136            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000010   0x....             LDR.N    R0,??DataTable30_16  ;; 0x40005400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD007             BEQ.N    ??I2C_GetFlagStatus_0
   \   00000016   0x....             LDR.N    R0,??DataTable30_17  ;; 0x40005800
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD004             BEQ.N    ??I2C_GetFlagStatus_0
   \   0000001C   0xF44F 0x618E      MOV      R1,#+1136
   \   00000020   0x....             LDR.N    R0,??DataTable30_18
   \   00000022   0x.... 0x....      BL       assert_failed
   1137            assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
   \                     ??I2C_GetFlagStatus_0: (+1)
   \   00000026   0xF5B5 0x0F00      CMP      R5,#+8388608
   \   0000002A   0xD040             BEQ.N    ??I2C_GetFlagStatus_1
   \   0000002C   0xF5B5 0x0F80      CMP      R5,#+4194304
   \   00000030   0xD03D             BEQ.N    ??I2C_GetFlagStatus_1
   \   00000032   0xF5B5 0x1F00      CMP      R5,#+2097152
   \   00000036   0xD03A             BEQ.N    ??I2C_GetFlagStatus_1
   \   00000038   0xF5B5 0x1F80      CMP      R5,#+1048576
   \   0000003C   0xD037             BEQ.N    ??I2C_GetFlagStatus_1
   \   0000003E   0xF5B5 0x2F80      CMP      R5,#+262144
   \   00000042   0xD034             BEQ.N    ??I2C_GetFlagStatus_1
   \   00000044   0xF5B5 0x3F00      CMP      R5,#+131072
   \   00000048   0xD031             BEQ.N    ??I2C_GetFlagStatus_1
   \   0000004A   0xF5B5 0x3F80      CMP      R5,#+65536
   \   0000004E   0xD02E             BEQ.N    ??I2C_GetFlagStatus_1
   \   00000050   0x....             LDR.N    R0,??DataTable30_19  ;; 0x10008000
   \   00000052   0x4285             CMP      R5,R0
   \   00000054   0xD02B             BEQ.N    ??I2C_GetFlagStatus_1
   \   00000056   0x....             LDR.N    R0,??DataTable30_20  ;; 0x10004000
   \   00000058   0x4285             CMP      R5,R0
   \   0000005A   0xD028             BEQ.N    ??I2C_GetFlagStatus_1
   \   0000005C   0xF1B5 0x2F10      CMP      R5,#+268439552
   \   00000060   0xD025             BEQ.N    ??I2C_GetFlagStatus_1
   \   00000062   0x....             LDR.N    R0,??DataTable30_21  ;; 0x10000800
   \   00000064   0x4285             CMP      R5,R0
   \   00000066   0xD022             BEQ.N    ??I2C_GetFlagStatus_1
   \   00000068   0x....             LDR.N    R0,??DataTable30_22  ;; 0x10000400
   \   0000006A   0x4285             CMP      R5,R0
   \   0000006C   0xD01F             BEQ.N    ??I2C_GetFlagStatus_1
   \   0000006E   0x....             LDR.N    R0,??DataTable30_23  ;; 0x10000200
   \   00000070   0x4285             CMP      R5,R0
   \   00000072   0xD01C             BEQ.N    ??I2C_GetFlagStatus_1
   \   00000074   0x....             LDR.N    R0,??DataTable30_24  ;; 0x10000100
   \   00000076   0x4285             CMP      R5,R0
   \   00000078   0xD019             BEQ.N    ??I2C_GetFlagStatus_1
   \   0000007A   0x....             LDR.N    R0,??DataTable30_25  ;; 0x10000080
   \   0000007C   0x4285             CMP      R5,R0
   \   0000007E   0xD016             BEQ.N    ??I2C_GetFlagStatus_1
   \   00000080   0x....             LDR.N    R0,??DataTable30_26  ;; 0x10000040
   \   00000082   0x4285             CMP      R5,R0
   \   00000084   0xD013             BEQ.N    ??I2C_GetFlagStatus_1
   \   00000086   0x....             LDR.N    R0,??DataTable30_27  ;; 0x10000010
   \   00000088   0x4285             CMP      R5,R0
   \   0000008A   0xD010             BEQ.N    ??I2C_GetFlagStatus_1
   \   0000008C   0x....             LDR.N    R0,??DataTable30_28  ;; 0x10000008
   \   0000008E   0x4285             CMP      R5,R0
   \   00000090   0xD00D             BEQ.N    ??I2C_GetFlagStatus_1
   \   00000092   0x....             LDR.N    R0,??DataTable30_29  ;; 0x10000004
   \   00000094   0x4285             CMP      R5,R0
   \   00000096   0xD00A             BEQ.N    ??I2C_GetFlagStatus_1
   \   00000098   0x....             LDR.N    R0,??DataTable30_30  ;; 0x10000002
   \   0000009A   0x4285             CMP      R5,R0
   \   0000009C   0xD007             BEQ.N    ??I2C_GetFlagStatus_1
   \   0000009E   0x....             LDR.N    R0,??DataTable30_31  ;; 0x10000001
   \   000000A0   0x4285             CMP      R5,R0
   \   000000A2   0xD004             BEQ.N    ??I2C_GetFlagStatus_1
   \   000000A4   0xF240 0x4171      MOVW     R1,#+1137
   \   000000A8   0x....             LDR.N    R0,??DataTable30_18
   \   000000AA   0x.... 0x....      BL       assert_failed
   1138          
   1139            /* Get the I2Cx peripheral base address */
   1140            i2cxbase = (uint32_t)I2Cx;
   \                     ??I2C_GetFlagStatus_1: (+1)
   \   000000AE   0x9400             STR      R4,[SP, #+0]
   1141            
   1142            /* Read flag register index */
   1143            i2creg = I2C_FLAG >> 28;
   \   000000B0   0x0F28             LSRS     R0,R5,#+28
   \   000000B2   0x9001             STR      R0,[SP, #+4]
   1144            
   1145            /* Get bit[23:0] of the flag */
   1146            I2C_FLAG &= FLAG_MASK;
   \   000000B4   0x022D             LSLS     R5,R5,#+8        ;; ZeroExtS R5,R5,#+8,#+8
   \   000000B6   0x0A2D             LSRS     R5,R5,#+8
   1147            
   1148            if(i2creg != 0)
   \   000000B8   0x9801             LDR      R0,[SP, #+4]
   \   000000BA   0x2800             CMP      R0,#+0
   \   000000BC   0xD003             BEQ.N    ??I2C_GetFlagStatus_2
   1149            {
   1150              /* Get the I2Cx SR1 register address */
   1151              i2cxbase += 0x14;
   \   000000BE   0x9800             LDR      R0,[SP, #+0]
   \   000000C0   0x3014             ADDS     R0,R0,#+20
   \   000000C2   0x9000             STR      R0,[SP, #+0]
   \   000000C4   0xE003             B.N      ??I2C_GetFlagStatus_3
   1152            }
   1153            else
   1154            {
   1155              /* Flag in I2Cx SR2 Register */
   1156              I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
   \                     ??I2C_GetFlagStatus_2: (+1)
   \   000000C6   0x0C2D             LSRS     R5,R5,#+16
   1157              /* Get the I2Cx SR2 register address */
   1158              i2cxbase += 0x18;
   \   000000C8   0x9800             LDR      R0,[SP, #+0]
   \   000000CA   0x3018             ADDS     R0,R0,#+24
   \   000000CC   0x9000             STR      R0,[SP, #+0]
   1159            }
   1160            
   1161            if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
   \                     ??I2C_GetFlagStatus_3: (+1)
   \   000000CE   0x9800             LDR      R0,[SP, #+0]
   \   000000D0   0x6800             LDR      R0,[R0, #+0]
   \   000000D2   0x4228             TST      R0,R5
   \   000000D4   0xD002             BEQ.N    ??I2C_GetFlagStatus_4
   1162            {
   1163              /* I2C_FLAG is set */
   1164              bitstatus = SET;
   \   000000D6   0x2001             MOVS     R0,#+1
   \   000000D8   0x0006             MOVS     R6,R0
   \   000000DA   0xE001             B.N      ??I2C_GetFlagStatus_5
   1165            }
   1166            else
   1167            {
   1168              /* I2C_FLAG is reset */
   1169              bitstatus = RESET;
   \                     ??I2C_GetFlagStatus_4: (+1)
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0x0006             MOVS     R6,R0
   1170            }
   1171            
   1172            /* Return the I2C_FLAG status */
   1173            return  bitstatus;
   \                     ??I2C_GetFlagStatus_5: (+1)
   \   000000E0   0x0030             MOVS     R0,R6
   \   000000E2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E4   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   1174          }
   1175          
   1176          /**
   1177            * @brief  Clears the I2Cx's pending flags.
   1178            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
   1179            * @param  I2C_FLAG: specifies the flag to clear. 
   1180            *   This parameter can be any combination of the following values:
   1181            *     @arg I2C_FLAG_SMBALERT: SMBus Alert flag
   1182            *     @arg I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
   1183            *     @arg I2C_FLAG_PECERR: PEC error in reception flag
   1184            *     @arg I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
   1185            *     @arg I2C_FLAG_AF: Acknowledge failure flag
   1186            *     @arg I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
   1187            *     @arg I2C_FLAG_BERR: Bus error flag
   1188            *   
   1189            * @note
   1190            *   - STOPF (STOP detection) is cleared by software sequence: a read operation 
   1191            *     to I2C_SR1 register (I2C_GetFlagStatus()) followed by a write operation 
   1192            *     to I2C_CR1 register (I2C_Cmd() to re-enable the I2C peripheral).
   1193            *   - ADD10 (10-bit header sent) is cleared by software sequence: a read 
   1194            *     operation to I2C_SR1 (I2C_GetFlagStatus()) followed by writing the 
   1195            *     second byte of the address in DR register.
   1196            *   - BTF (Byte Transfer Finished) is cleared by software sequence: a read 
   1197            *     operation to I2C_SR1 register (I2C_GetFlagStatus()) followed by a 
   1198            *     read/write to I2C_DR register (I2C_SendData()).
   1199            *   - ADDR (Address sent) is cleared by software sequence: a read operation to 
   1200            *     I2C_SR1 register (I2C_GetFlagStatus()) followed by a read operation to 
   1201            *     I2C_SR2 register ((void)(I2Cx->SR2)).
   1202            *   - SB (Start Bit) is cleared software sequence: a read operation to I2C_SR1
   1203            *     register (I2C_GetFlagStatus()) followed by a write operation to I2C_DR
   1204            *     register  (I2C_SendData()).
   1205            * @retval None
   1206            */

   \                                 In section .text, align 2, keep-with-next
   1207          void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
   1208          {
   \                     I2C_ClearFlag: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1209            uint32_t flagpos = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1210            /* Check the parameters */
   1211            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000008   0x....             LDR.N    R0,??DataTable30_16  ;; 0x40005400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD007             BEQ.N    ??I2C_ClearFlag_0
   \   0000000E   0x....             LDR.N    R0,??DataTable30_17  ;; 0x40005800
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD004             BEQ.N    ??I2C_ClearFlag_0
   \   00000014   0xF240 0x41BB      MOVW     R1,#+1211
   \   00000018   0x....             LDR.N    R0,??DataTable30_18
   \   0000001A   0x.... 0x....      BL       assert_failed
   1212            assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
   \                     ??I2C_ClearFlag_0: (+1)
   \   0000001E   0xF242 0x00FF      MOVW     R0,#+8447
   \   00000022   0x4205             TST      R5,R0
   \   00000024   0xD101             BNE.N    ??I2C_ClearFlag_1
   \   00000026   0x2D00             CMP      R5,#+0
   \   00000028   0xD104             BNE.N    ??I2C_ClearFlag_2
   \                     ??I2C_ClearFlag_1: (+1)
   \   0000002A   0xF240 0x41BC      MOVW     R1,#+1212
   \   0000002E   0x....             LDR.N    R0,??DataTable30_18
   \   00000030   0x.... 0x....      BL       assert_failed
   1213            /* Get the I2C flag position */
   1214            flagpos = I2C_FLAG & FLAG_MASK;
   \                     ??I2C_ClearFlag_2: (+1)
   \   00000034   0x0228             LSLS     R0,R5,#+8        ;; ZeroExtS R0,R5,#+8,#+8
   \   00000036   0x0A00             LSRS     R0,R0,#+8
   \   00000038   0x0006             MOVS     R6,R0
   1215            /* Clear the selected I2C flag */
   1216            I2Cx->SR1 = (uint16_t)~flagpos;
   \   0000003A   0x43F0             MVNS     R0,R6
   \   0000003C   0x82A0             STRH     R0,[R4, #+20]
   1217          }
   \   0000003E   0xBD70             POP      {R4-R6,PC}       ;; return
   1218          
   1219          /**
   1220            * @brief  Checks whether the specified I2C interrupt has occurred or not.
   1221            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
   1222            * @param  I2C_IT: specifies the interrupt source to check. 
   1223            *   This parameter can be one of the following values:
   1224            *     @arg I2C_IT_SMBALERT: SMBus Alert flag
   1225            *     @arg I2C_IT_TIMEOUT: Timeout or Tlow error flag
   1226            *     @arg I2C_IT_PECERR: PEC error in reception flag
   1227            *     @arg I2C_IT_OVR: Overrun/Underrun flag (Slave mode)
   1228            *     @arg I2C_IT_AF: Acknowledge failure flag
   1229            *     @arg I2C_IT_ARLO: Arbitration lost flag (Master mode)
   1230            *     @arg I2C_IT_BERR: Bus error flag
   1231            *     @arg I2C_IT_TXE: Data register empty flag (Transmitter)
   1232            *     @arg I2C_IT_RXNE: Data register not empty (Receiver) flag
   1233            *     @arg I2C_IT_STOPF: Stop detection flag (Slave mode)
   1234            *     @arg I2C_IT_ADD10: 10-bit header sent flag (Master mode)
   1235            *     @arg I2C_IT_BTF: Byte transfer finished flag
   1236            *     @arg I2C_IT_ADDR: Address sent flag (Master mode) ADSL
   1237            *                       Address matched flag (Slave mode)ENDAD
   1238            *     @arg I2C_IT_SB: Start bit flag (Master mode)
   1239            * @retval The new state of I2C_IT (SET or RESET).
   1240            */

   \                                 In section .text, align 2, keep-with-next
   1241          ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
   1242          {
   \                     I2C_GetITStatus: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1243            ITStatus bitstatus = RESET;
   \   00000006   0x2600             MOVS     R6,#+0
   1244            uint32_t enablestatus = 0;
   \   00000008   0x2700             MOVS     R7,#+0
   1245          
   1246            /* Check the parameters */
   1247            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   0000000A   0x....             LDR.N    R0,??DataTable30_16  ;; 0x40005400
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD007             BEQ.N    ??I2C_GetITStatus_0
   \   00000010   0x....             LDR.N    R0,??DataTable30_17  ;; 0x40005800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD004             BEQ.N    ??I2C_GetITStatus_0
   \   00000016   0xF240 0x41DF      MOVW     R1,#+1247
   \   0000001A   0x....             LDR.N    R0,??DataTable30_18
   \   0000001C   0x.... 0x....      BL       assert_failed
   1248            assert_param(IS_I2C_GET_IT(I2C_IT));
   \                     ??I2C_GetITStatus_0: (+1)
   \   00000020   0x....             LDR.N    R0,??DataTable30_32  ;; 0x1008000
   \   00000022   0x4285             CMP      R5,R0
   \   00000024   0xD02B             BEQ.N    ??I2C_GetITStatus_1
   \   00000026   0x....             LDR.N    R0,??DataTable30_33  ;; 0x1004000
   \   00000028   0x4285             CMP      R5,R0
   \   0000002A   0xD028             BEQ.N    ??I2C_GetITStatus_1
   \   0000002C   0x....             LDR.N    R0,??DataTable30_34  ;; 0x1001000
   \   0000002E   0x4285             CMP      R5,R0
   \   00000030   0xD025             BEQ.N    ??I2C_GetITStatus_1
   \   00000032   0x....             LDR.N    R0,??DataTable30_35  ;; 0x1000800
   \   00000034   0x4285             CMP      R5,R0
   \   00000036   0xD022             BEQ.N    ??I2C_GetITStatus_1
   \   00000038   0x....             LDR.N    R0,??DataTable30_36  ;; 0x1000400
   \   0000003A   0x4285             CMP      R5,R0
   \   0000003C   0xD01F             BEQ.N    ??I2C_GetITStatus_1
   \   0000003E   0x....             LDR.N    R0,??DataTable30_37  ;; 0x1000200
   \   00000040   0x4285             CMP      R5,R0
   \   00000042   0xD01C             BEQ.N    ??I2C_GetITStatus_1
   \   00000044   0xF1B5 0x2F01      CMP      R5,#+16777472
   \   00000048   0xD019             BEQ.N    ??I2C_GetITStatus_1
   \   0000004A   0x....             LDR.N    R0,??DataTable30_38  ;; 0x6000080
   \   0000004C   0x4285             CMP      R5,R0
   \   0000004E   0xD016             BEQ.N    ??I2C_GetITStatus_1
   \   00000050   0x....             LDR.N    R0,??DataTable30_39  ;; 0x6000040
   \   00000052   0x4285             CMP      R5,R0
   \   00000054   0xD013             BEQ.N    ??I2C_GetITStatus_1
   \   00000056   0x....             LDR.N    R0,??DataTable30_40  ;; 0x2000010
   \   00000058   0x4285             CMP      R5,R0
   \   0000005A   0xD010             BEQ.N    ??I2C_GetITStatus_1
   \   0000005C   0x....             LDR.N    R0,??DataTable30_41  ;; 0x2000008
   \   0000005E   0x4285             CMP      R5,R0
   \   00000060   0xD00D             BEQ.N    ??I2C_GetITStatus_1
   \   00000062   0x....             LDR.N    R0,??DataTable30_42  ;; 0x2000004
   \   00000064   0x4285             CMP      R5,R0
   \   00000066   0xD00A             BEQ.N    ??I2C_GetITStatus_1
   \   00000068   0x....             LDR.N    R0,??DataTable30_43  ;; 0x2000002
   \   0000006A   0x4285             CMP      R5,R0
   \   0000006C   0xD007             BEQ.N    ??I2C_GetITStatus_1
   \   0000006E   0x....             LDR.N    R0,??DataTable30_44  ;; 0x2000001
   \   00000070   0x4285             CMP      R5,R0
   \   00000072   0xD004             BEQ.N    ??I2C_GetITStatus_1
   \   00000074   0xF44F 0x619C      MOV      R1,#+1248
   \   00000078   0x....             LDR.N    R0,??DataTable30_18
   \   0000007A   0x.... 0x....      BL       assert_failed
   1249          
   1250            /* Check if the interrupt source is enabled or not */
   1251            enablestatus = (uint32_t)(((I2C_IT & ITEN_MASK) >> 16) & (I2Cx->CR2)) ;
   \                     ??I2C_GetITStatus_1: (+1)
   \   0000007E   0x88A0             LDRH     R0,[R4, #+4]
   \   00000080   0xEA10 0x4015      ANDS     R0,R0,R5, LSR #+16
   \   00000084   0xF410 0x60E0      ANDS     R0,R0,#0x700
   \   00000088   0x0007             MOVS     R7,R0
   1252            
   1253            /* Get bit[23:0] of the flag */
   1254            I2C_IT &= FLAG_MASK;
   \   0000008A   0x022D             LSLS     R5,R5,#+8        ;; ZeroExtS R5,R5,#+8,#+8
   \   0000008C   0x0A2D             LSRS     R5,R5,#+8
   1255          
   1256            /* Check the status of the specified I2C flag */
   1257            if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
   \   0000008E   0x8AA0             LDRH     R0,[R4, #+20]
   \   00000090   0x4228             TST      R0,R5
   \   00000092   0xD004             BEQ.N    ??I2C_GetITStatus_2
   \   00000094   0x2F00             CMP      R7,#+0
   \   00000096   0xD002             BEQ.N    ??I2C_GetITStatus_2
   1258            {
   1259              /* I2C_IT is set */
   1260              bitstatus = SET;
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0x0006             MOVS     R6,R0
   \   0000009C   0xE001             B.N      ??I2C_GetITStatus_3
   1261            }
   1262            else
   1263            {
   1264              /* I2C_IT is reset */
   1265              bitstatus = RESET;
   \                     ??I2C_GetITStatus_2: (+1)
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x0006             MOVS     R6,R0
   1266            }
   1267            /* Return the I2C_IT status */
   1268            return  bitstatus;
   \                     ??I2C_GetITStatus_3: (+1)
   \   000000A2   0x0030             MOVS     R0,R6
   \   000000A4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A6   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1269          }
   1270          
   1271          /**
   1272            * @brief  Clears the I2Cxs interrupt pending bits.
   1273            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
   1274            * @param  I2C_IT: specifies the interrupt pending bit to clear. 
   1275            *   This parameter can be any combination of the following values:
   1276            *     @arg I2C_IT_SMBALERT: SMBus Alert interrupt
   1277            *     @arg I2C_IT_TIMEOUT: Timeout or Tlow error interrupt
   1278            *     @arg I2C_IT_PECERR: PEC error in reception  interrupt
   1279            *     @arg I2C_IT_OVR: Overrun/Underrun interrupt (Slave mode)
   1280            *     @arg I2C_IT_AF: Acknowledge failure interrupt
   1281            *     @arg I2C_IT_ARLO: Arbitration lost interrupt (Master mode)
   1282            *     @arg I2C_IT_BERR: Bus error interrupt
   1283            *   
   1284            * @note
   1285            *   - STOPF (STOP detection) is cleared by software sequence: a read operation 
   1286            *     to I2C_SR1 register (I2C_GetITStatus()) followed by a write operation to 
   1287            *     I2C_CR1 register (I2C_Cmd() to re-enable the I2C peripheral).
   1288            *   - ADD10 (10-bit header sent) is cleared by software sequence: a read 
   1289            *     operation to I2C_SR1 (I2C_GetITStatus()) followed by writing the second 
   1290            *     byte of the address in I2C_DR register.
   1291            *   - BTF (Byte Transfer Finished) is cleared by software sequence: a read 
   1292            *     operation to I2C_SR1 register (I2C_GetITStatus()) followed by a 
   1293            *     read/write to I2C_DR register (I2C_SendData()).
   1294            *   - ADDR (Address sent) is cleared by software sequence: a read operation to 
   1295            *     I2C_SR1 register (I2C_GetITStatus()) followed by a read operation to 
   1296            *     I2C_SR2 register ((void)(I2Cx->SR2)).
   1297            *   - SB (Start Bit) is cleared by software sequence: a read operation to 
   1298            *     I2C_SR1 register (I2C_GetITStatus()) followed by a write operation to 
   1299            *     I2C_DR register (I2C_SendData()).
   1300            * @retval None
   1301            */

   \                                 In section .text, align 2, keep-with-next
   1302          void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
   1303          {
   \                     I2C_ClearITPendingBit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1304            uint32_t flagpos = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1305            /* Check the parameters */
   1306            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000008   0x....             LDR.N    R0,??DataTable30_16  ;; 0x40005400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD007             BEQ.N    ??I2C_ClearITPendingBit_0
   \   0000000E   0x....             LDR.N    R0,??DataTable30_17  ;; 0x40005800
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD004             BEQ.N    ??I2C_ClearITPendingBit_0
   \   00000014   0xF240 0x511A      MOVW     R1,#+1306
   \   00000018   0x....             LDR.N    R0,??DataTable30_18
   \   0000001A   0x.... 0x....      BL       assert_failed
   1307            assert_param(IS_I2C_CLEAR_IT(I2C_IT));
   \                     ??I2C_ClearITPendingBit_0: (+1)
   \   0000001E   0xF242 0x00FF      MOVW     R0,#+8447
   \   00000022   0x4205             TST      R5,R0
   \   00000024   0xD101             BNE.N    ??I2C_ClearITPendingBit_1
   \   00000026   0x2D00             CMP      R5,#+0
   \   00000028   0xD104             BNE.N    ??I2C_ClearITPendingBit_2
   \                     ??I2C_ClearITPendingBit_1: (+1)
   \   0000002A   0xF240 0x511B      MOVW     R1,#+1307
   \   0000002E   0x....             LDR.N    R0,??DataTable30_18
   \   00000030   0x.... 0x....      BL       assert_failed
   1308            /* Get the I2C flag position */
   1309            flagpos = I2C_IT & FLAG_MASK;
   \                     ??I2C_ClearITPendingBit_2: (+1)
   \   00000034   0x0228             LSLS     R0,R5,#+8        ;; ZeroExtS R0,R5,#+8,#+8
   \   00000036   0x0A00             LSRS     R0,R0,#+8
   \   00000038   0x0006             MOVS     R6,R0
   1310            /* Clear the selected I2C flag */
   1311            I2Cx->SR1 = (uint16_t)~flagpos;
   \   0000003A   0x43F0             MVNS     R0,R6
   \   0000003C   0x82A0             STRH     R0,[R4, #+20]
   1312          }
   \   0000003E   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \   00000000   0x40005400         DC32     0x40005400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_1:
   \   00000000   0x40005800         DC32     0x40005800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_2:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_3:
   \   00000000   0x007A1200         DC32     0x7a1200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_4:
   \   00000000   0x00061A81         DC32     0x61a81

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_5:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30:
   \   00000000   0x000186A1         DC32     0x186a1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_1:
   \   00000000   0x00060082         DC32     0x60082

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_2:
   \   00000000   0x00860080         DC32     0x860080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_3:
   \   00000000   0x00020040         DC32     0x20040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_4:
   \   00000000   0x00820040         DC32     0x820040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_5:
   \   00000000   0x00120040         DC32     0x120040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_6:
   \   00000000   0x00060084         DC32     0x60084

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_7:
   \   00000000   0x00860084         DC32     0x860084

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_8:
   \   00000000   0x00160084         DC32     0x160084

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_9:
   \   00000000   0x00030001         DC32     0x30001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_10:
   \   00000000   0x00070082         DC32     0x70082

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_11:
   \   00000000   0x00030002         DC32     0x30002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_12:
   \   00000000   0x00030040         DC32     0x30040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_13:
   \   00000000   0x00070084         DC32     0x70084

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_14:
   \   00000000   0x00070080         DC32     0x70080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_15:
   \   00000000   0x00030008         DC32     0x30008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_16:
   \   00000000   0x40005400         DC32     0x40005400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_17:
   \   00000000   0x40005800         DC32     0x40005800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_18:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_19:
   \   00000000   0x10008000         DC32     0x10008000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_20:
   \   00000000   0x10004000         DC32     0x10004000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_21:
   \   00000000   0x10000800         DC32     0x10000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_22:
   \   00000000   0x10000400         DC32     0x10000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_23:
   \   00000000   0x10000200         DC32     0x10000200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_24:
   \   00000000   0x10000100         DC32     0x10000100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_25:
   \   00000000   0x10000080         DC32     0x10000080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_26:
   \   00000000   0x10000040         DC32     0x10000040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_27:
   \   00000000   0x10000010         DC32     0x10000010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_28:
   \   00000000   0x10000008         DC32     0x10000008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_29:
   \   00000000   0x10000004         DC32     0x10000004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_30:
   \   00000000   0x10000002         DC32     0x10000002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_31:
   \   00000000   0x10000001         DC32     0x10000001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_32:
   \   00000000   0x01008000         DC32     0x1008000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_33:
   \   00000000   0x01004000         DC32     0x1004000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_34:
   \   00000000   0x01001000         DC32     0x1001000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_35:
   \   00000000   0x01000800         DC32     0x1000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_36:
   \   00000000   0x01000400         DC32     0x1000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_37:
   \   00000000   0x01000200         DC32     0x1000200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_38:
   \   00000000   0x06000080         DC32     0x6000080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_39:
   \   00000000   0x06000040         DC32     0x6000040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_40:
   \   00000000   0x02000010         DC32     0x2000010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_41:
   \   00000000   0x02000008         DC32     0x2000008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_42:
   \   00000000   0x02000004         DC32     0x2000004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_43:
   \   00000000   0x02000002         DC32     0x2000002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_44:
   \   00000000   0x02000001         DC32     0x2000001

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x45 0x3A          DC8 45H, 3AH, 5CH, 41H, 43H, 51H, 5CH, 50H
   \              0x5C 0x41    
   \              0x43 0x51    
   \              0x5C 0x50    
   \   00000008   0x72 0x6F          DC8 72H, 6FH, 6AH, 5FH, 76H, 65H, 72H, 30H
   \              0x6A 0x5F    
   \              0x76 0x65    
   \              0x72 0x30    
   \   00000010   0x39 0x61          DC8 39H, 61H, 5FH, 31H, 35H, 31H, 30H, 32H
   \              0x5F 0x31    
   \              0x35 0x31    
   \              0x30 0x32    
   \   00000018   0x30 0x31          DC8 30H, 31H, 35H, 5CH, 45H, 6EH, 64H, 5FH
   \              0x35 0x5C    
   \              0x45 0x6E    
   \              0x64 0x5F    
   \   00000020   0x30 0x32          DC8 30H, 32H, 5CH, 32H, 30H, 31H, 33H, 5FH
   \              0x5C 0x32    
   \              0x30 0x31    
   \              0x33 0x5F    
   \   00000028   0x31 0x31          DC8 31H, 31H, 5FH, 32H, 35H, 5FH, 53H, 70H
   \              0x5F 0x32    
   \              0x35 0x5F    
   \              0x53 0x70    
   \   00000030   0x69 0x72          DC8 69H, 72H, 69H, 74H, 31H, 5FH, 45H, 6CH
   \              0x69 0x74    
   \              0x31 0x5F    
   \              0x45 0x6C    
   \   00000038   0x65 0x6B          DC8 65H, 6BH, 74H, 72H, 6FH, 6CH, 75H, 78H
   \              0x74 0x72    
   \              0x6F 0x6C    
   \              0x75 0x78    
   \   00000040   0x5C 0x53          DC8 5CH, 53H, 54H, 4DH, 33H, 32H, 4CH, 5CH
   \              0x54 0x4D    
   \              0x33 0x32    
   \              0x4C 0x5C    
   \   00000048   0x53 0x54          DC8 53H, 54H, 4DH, 33H, 32H, 4CH, 31H, 78H
   \              0x4D 0x33    
   \              0x32 0x4C    
   \              0x31 0x78    
   \   00000050   0x78 0x5F          DC8 78H, 5FH, 53H, 74H, 64H, 50H, 65H, 72H
   \              0x53 0x74    
   \              0x64 0x50    
   \              0x65 0x72    
   \   00000058   0x69 0x70          DC8 69H, 70H, 68H, 5FH, 4CH, 69H, 62H, 5CH
   \              0x68 0x5F    
   \              0x4C 0x69    
   \              0x62 0x5C    
   \   00000060   0x53 0x6F          DC8 53H, 6FH, 75H, 72H, 63H, 65H, 5CH, 53H
   \              0x75 0x72    
   \              0x63 0x65    
   \              0x5C 0x53    
   \   00000068   0x54 0x4D          DC8 54H, 4DH, 33H, 32H, 4CH, 31H, 78H, 78H
   \              0x33 0x32    
   \              0x4C 0x31    
   \              0x78 0x78    
   \   00000070   0x5F 0x53          DC8 5FH, 53H, 74H, 64H, 50H, 65H, 72H, 69H
   \              0x74 0x64    
   \              0x50 0x65    
   \              0x72 0x69    
   \   00000078   0x70 0x68          DC8 70H, 68H, 5FH, 44H, 72H, 69H, 76H, 65H
   \              0x5F 0x44    
   \              0x72 0x69    
   \              0x76 0x65    
   \   00000080   0x72 0x5C          DC8 72H, 5CH, 73H, 72H, 63H, 5CH, 73H, 74H
   \              0x73 0x72    
   \              0x63 0x5C    
   \              0x73 0x74    
   \   00000088   0x6D 0x33          DC8 6DH, 33H, 32H, 6CH, 31H, 78H, 78H, 5FH
   \              0x32 0x6C    
   \              0x31 0x78    
   \              0x78 0x5F    
   \   00000090   0x69 0x32          DC8 69H, 32H, 63H, 2EH, 63H, 0
   \              0x63 0x2E    
   \              0x63 0x00    
   \   00000096   0x00 0x00          DC8 0, 0
   1313          
   1314          /**
   1315            * @}
   1316            */
   1317          
   1318          /**
   1319            * @}
   1320            */ 
   1321          
   1322          /**
   1323            * @}
   1324            */ 
   1325          
   1326          /**
   1327            * @}
   1328            */ 
   1329          
   1330          /******************* (C) COPYRIGHT 2010 STMicroelectronics *****END OF FILE****/
   1331          
   1332          
   1333          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   I2C_ARPCmd
        16   -> assert_failed
      16   I2C_AcknowledgeConfig
        16   -> assert_failed
      16   I2C_CalculatePEC
        16   -> assert_failed
      32   I2C_CheckEvent
        32   -> assert_failed
      16   I2C_ClearFlag
        16   -> assert_failed
      16   I2C_ClearITPendingBit
        16   -> assert_failed
      16   I2C_Cmd
        16   -> assert_failed
      16   I2C_DMACmd
        16   -> assert_failed
      16   I2C_DMALastTransferCmd
        16   -> assert_failed
       8   I2C_DeInit
         8   -> RCC_APB1PeriphResetCmd
         8   -> assert_failed
      16   I2C_DualAddressCmd
        16   -> assert_failed
      16   I2C_FastModeDutyCycleConfig
        16   -> assert_failed
      16   I2C_GeneralCallCmd
        16   -> assert_failed
      16   I2C_GenerateSTART
        16   -> assert_failed
      16   I2C_GenerateSTOP
        16   -> assert_failed
      24   I2C_GetFlagStatus
        24   -> assert_failed
      24   I2C_GetITStatus
        24   -> assert_failed
      24   I2C_GetLastEvent
        24   -> assert_failed
       8   I2C_GetPEC
         8   -> assert_failed
      16   I2C_ITConfig
        16   -> assert_failed
      48   I2C_Init
        48   -> RCC_GetClocksFreq
        48   -> assert_failed
      16   I2C_OwnAddress2Config
        16   -> assert_failed
      16   I2C_PECPositionConfig
        16   -> assert_failed
      16   I2C_ReadRegister
        16   -> assert_failed
       8   I2C_ReceiveData
         8   -> assert_failed
      16   I2C_SMBusAlertConfig
        16   -> assert_failed
      16   I2C_Send7bitAddress
        16   -> assert_failed
      16   I2C_SendData
        16   -> assert_failed
      16   I2C_SoftwareResetCmd
        16   -> assert_failed
      16   I2C_StretchClockCmd
        16   -> assert_failed
       0   I2C_StructInit
      16   I2C_TransmitPEC
        16   -> assert_failed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable26
       4  ??DataTable26_1
       4  ??DataTable26_2
       4  ??DataTable26_3
       4  ??DataTable26_4
       4  ??DataTable26_5
       4  ??DataTable30
       4  ??DataTable30_1
       4  ??DataTable30_10
       4  ??DataTable30_11
       4  ??DataTable30_12
       4  ??DataTable30_13
       4  ??DataTable30_14
       4  ??DataTable30_15
       4  ??DataTable30_16
       4  ??DataTable30_17
       4  ??DataTable30_18
       4  ??DataTable30_19
       4  ??DataTable30_2
       4  ??DataTable30_20
       4  ??DataTable30_21
       4  ??DataTable30_22
       4  ??DataTable30_23
       4  ??DataTable30_24
       4  ??DataTable30_25
       4  ??DataTable30_26
       4  ??DataTable30_27
       4  ??DataTable30_28
       4  ??DataTable30_29
       4  ??DataTable30_3
       4  ??DataTable30_30
       4  ??DataTable30_31
       4  ??DataTable30_32
       4  ??DataTable30_33
       4  ??DataTable30_34
       4  ??DataTable30_35
       4  ??DataTable30_36
       4  ??DataTable30_37
       4  ??DataTable30_38
       4  ??DataTable30_39
       4  ??DataTable30_4
       4  ??DataTable30_40
       4  ??DataTable30_41
       4  ??DataTable30_42
       4  ??DataTable30_43
       4  ??DataTable30_44
       4  ??DataTable30_5
       4  ??DataTable30_6
       4  ??DataTable30_7
       4  ??DataTable30_8
       4  ??DataTable30_9
     152  ?_0
      86  I2C_ARPCmd
      86  I2C_AcknowledgeConfig
      78  I2C_CalculatePEC
     232  I2C_CheckEvent
      64  I2C_ClearFlag
      64  I2C_ClearITPendingBit
      86  I2C_Cmd
      78  I2C_DMACmd
      78  I2C_DMALastTransferCmd
      82  I2C_DeInit
      86  I2C_DualAddressCmd
      94  I2C_FastModeDutyCycleConfig
      86  I2C_GeneralCallCmd
      86  I2C_GenerateSTART
      86  I2C_GenerateSTOP
     230  I2C_GetFlagStatus
     168  I2C_GetITStatus
      56  I2C_GetLastEvent
      36  I2C_GetPEC
      98  I2C_ITConfig
     412  I2C_Init
      58  I2C_OwnAddress2Config
      94  I2C_PECPositionConfig
     112  I2C_ReadRegister
      38  I2C_ReceiveData
      94  I2C_SMBusAlertConfig
      82  I2C_Send7bitAddress
      40  I2C_SendData
      84  I2C_SoftwareResetCmd
      86  I2C_StretchClockCmd
      32  I2C_StructInit
      86  I2C_TransmitPEC

 
   152 bytes in section .rodata
 3 382 bytes in section .text
 
 3 382 bytes of CODE  memory
   152 bytes of CONST memory

Errors: none
Warnings: none
