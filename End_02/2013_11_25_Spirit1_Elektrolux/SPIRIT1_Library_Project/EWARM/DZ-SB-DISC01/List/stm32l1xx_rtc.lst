###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        20/Nov/2015  05:04:59
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_rtc.c
#    Command line =  
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_rtc.c
#        -D USE_STDPERIPH_DRIVER -D VECT_TAB_FLASH -D STM32L1XX_MD -D
#        IAR_ARM_CM3 -D USE_FULL_ASSERT -D SPIRIT_USE_FULL_ASSERT -D
#        USE_SYSTICK_DELAY -D SDK -lC
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\List\
#        -o
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\.\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\examples\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\runtime\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\SDK_Eval_STM32L\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\SPIRIT1_Library\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\SDK_Eval_Util\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\SDK_Virtual_Com\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32_USB-FS-Device_Lib\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\ACQ\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\CMSIS\Include\"
#    List file    =  
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\List\stm32l1xx_rtc.lst
#    Object file  =  
#        E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\Obj\stm32l1xx_rtc.o
#
###############################################################################

E:\ACQ\Proj_ver09a_15102015\End_02\2013_11_25_Spirit1_Elektrolux\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_rtc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_rtc.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    31-December-2010
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Real-Time Clock (RTC) peripheral:           
      9            *           - Initialization
     10            *           - Calendar (Time and Date) configuration
     11            *           - Alarms (Alarm A and Alarm B) configuration
     12            *           - WakeUp Timer configuration
     13            *           - Daylight Saving configuration
     14            *           - Output pin Configuration
     15            *           - Digital Calibration configuration
     16            *           - TimeStamp configuration
     17            *           - Tampers configuration
     18            *           - Backup Data Registers configuration
     19            *           - Output Type Config configuration
     20            *           - Interrupts and flags management       
     21            *                     
     22            *  @verbatim
     23            *       
     24            *          ===================================================================      
     25            *                                    RTC Domain Reset
     26            *          ===================================================================          
     27            *          After power-on reset, the RTC domain (RTC clock source configuration,
     28            *          RTC registers and RTC Backup data registers) is reset. You can also
     29            *          reset this domain by software using the RCC_RTCResetCmd() function.        
     30            *         
     31            *          ===================================================================      
     32            *                                  RTC Operating Condition
     33            *          ===================================================================            
     34            *          As long as the supply voltage remains in the operating range, 
     35            *          the RTC never stops, regardless of the device status (Run mode, 
     36            *          low power modes or under reset).
     37            *              
     38            *          ===================================================================      
     39            *                                   RTC Domain Access
     40            *          ===================================================================          
     41            *          After reset, the RTC domain (RTC clock source configuration,
     42            *          RTC registers and RTC Backup data registers) are protected against 
     43            *          possible stray write accesses. 
     44            *          To enable access to the RTC Domain and RTC registers, proceed as follows:
     45            *            - Enable the Power Controller (PWR) APB1 interface clock using the
     46            *              RCC_APB1PeriphClockCmd() function.
     47            *            - Enable access to RTC domain using the PWR_RTCAccessCmd() function.
     48            *            - Select the RTC clock source using the RCC_RTCCLKConfig() function.
     49            *            - Enable RTC Clock using the RCC_RTCCLKCmd() function.
     50            *              
     51            *          ===================================================================      
     52            *                                   RTC Driver: how to use it
     53            *          ===================================================================          
     54            *            - Enable the RTC domain access (see description in the section above)
     55            *            - Configure the RTC Prescaler (Asynchronous and Synchronous) and
     56            *              RTC hour format using the RTC_Init() function.
     57            *                
     58            *          Time and Date configuration
     59            *          ===========================    
     60            *            - To configure the RTC Calendar (Time and Date) use the RTC_SetTime()
     61            *              and RTC_SetDate() functions.
     62            *            - To read the RTC Calendar, use the RTC_GetTime() and RTC_GetDate()
     63            *              functions.
     64            *            - Use the RTC_DayLightSavingConfig() function to add or sub one
     65            *              hour to the RTC Calendar.    
     66            *                
     67            *          Alarm configuration
     68            *          ===================    
     69            *            - To configure the RTC Alarm use the RTC_SetAlarm() function.
     70            *            - Enable the selected RTC Alarm using the RTC_AlarmCmd() function  
     71            *            - To read the RTC Alarm, use the RTC_GetAlarm() function.
     72            *              
     73            *          RTC Wakeup configuration
     74            *          ========================    
     75            *            - Configure the RTC Wakeup Clock source use the RTC_WakeUpClockConfig()
     76            *              function.
     77            *            - Configure the RTC WakeUp Counter using the RTC_SetWakeUpCounter() 
     78            *              function  
     79            *            - Enable the RTC WakeUp using the RTC_WakeUpCmd() function  
     80            *            - To read the RTC WakeUp Counter register, use the RTC_GetWakeUpCounter() 
     81            *              function.
     82            *                
     83            *          Outputs configuration
     84            *          =====================  
     85            *          The RTC has 2 different outputs:
     86            *            - AFO_ALARM: this output is used to manage the RTC Alarm A, Alarm B
     87            *              and WaKeUp signals.          
     88            *              To output the selected RTC signal on RTC_AF1 pin, use the 
     89            *              RTC_OutputConfig() function.                
     90            *            - AFO_CALIB: this output is used to manage the RTC Clock divided 
     91            *              by 64 (512Hz) signal.
     92            *              To output the RTC Clock on RTC_AF1 pin, use the RTC_CalibOutputCmd()
     93            *              function.                
     94            *                                                           
     95            *          Digital Calibration configuration
     96            *          =================================    
     97            *            - Configure the RTC Digital Calibration Value and the corresponding
     98            *              sign using the RTC_DigitalCalibConfig() function.
     99            *            - Enable the RTC Digital Calibration using the RTC_DigitalCalibCmd() 
    100            *              function  
    101            *                
    102            *          TimeStamp configuration
    103            *          =======================    
    104            *            - Configure the RTC_AF1 trigger and enables the RTC TimeStamp 
    105            *              using the RTC_TimeStampCmd() function.
    106            *            - To read the RTC TimeStamp Time and Date register, use the 
    107            *              RTC_GetTimeStamp() function.  
    108            *
    109            *          Tamper configuration
    110            *          ====================    
    111            *            - Configure the RTC Tamper trigger using the RTC_TamperConfig() 
    112            *              function.
    113            *            - Enable the RTC Tamper using the RTC_TamperCmd() function.
    114            *
    115            *          Backup Data Registers configuration
    116            *          ===================================    
    117            *            - To write to the RTC Backup Data registers, use the RTC_WriteBackupRegister()
    118            *              function.  
    119            *            - To read the RTC Backup Data registers, use the RTC_ReadBackupRegister()
    120            *              function.  
    121            *                                  
    122            *          ===================================================================      
    123            *                                  RTC and low power modes
    124            *          =================================================================== 
    125            *           The MCU can be woken up from a low power mode by an RTC alternate 
    126            *           function.
    127            *           The RTC alternate functions are the RTC alarms (Alarm A and Alarm B), 
    128            *           RTC wakeup, RTC tamper event detection and RTC time stamp event detection.
    129            *           These RTC alternate functions can wake up the system from the Stop 
    130            *           and Standby lowpower modes.
    131            *           The system can also wake up from low power modes without depending 
    132            *           on an external interrupt (Auto-wakeup mode), by using the RTC alarm 
    133            *           or the RTC wakeup events.
    134            *           The RTC provides a programmable time base for waking up from the 
    135            *           Stop or Standby mode at regular intervals.
    136            *           Wakeup from STOP and Standby modes is possible only when the RTC 
    137            *           clock source is LSE or LSI.
    138            *           
    139            *          ===================================================================      
    140            *                            Selection of RTC_AF1 alternate functions
    141            *          ===================================================================     
    142            *          The RTC_AF1 pin (PC13) can be used for the following purposes:
    143            *            - Wakeup pin 2 (WKUP2) using the PWR_WakeUpPinCmd() function.
    144            *            - AFO_ALARM output       
    145            *            - AFO_CALIB output
    146            *            - AFI_TAMPER
    147            *            - AFI_TIMESTAMP
    148            *                         
    149            * +------------------------------------------------------------------------------------------+     
    150            * |     Pin         |AFO_ALARM |AFO_CALIB |AFI_TAMPER |AFI_TIMESTAMP | WKUP2  |ALARMOUTTYPE  |
    151            * |  configuration  | ENABLED  | ENABLED  |  ENABLED  |   ENABLED    |ENABLED |  AFO_ALARM   |
    152            * |  and function   |          |          |           |              |        |Configuration |
    153            * |-----------------|----------|----------|-----------|--------------|--------|--------------|             
    154            * |   Alarm out     |          |          |           |              | Don't  |              |
    155            * |   output OD     |     1    |    0     |Don't care | Don't care   | care   |      0       |
    156            * |-----------------|----------|----------|-----------|--------------|--------|--------------|  
    157            * |   Alarm out     |          |          |           |              | Don't  |              |
    158            * |   output PP     |     1    |    0     |Don't care | Don't care   | care   |      1       |
    159            * |-----------------|----------|----------|-----------|--------------|--------|--------------|  
    160            * | Calibration out |          |          |           |              | Don't  |              |
    161            * |   output PP     |     0    |    1     |Don't care | Don't care   | care   |  Don't care  |
    162            * |-----------------|----------|----------|-----------|--------------|--------|--------------|  
    163            * |  TAMPER input   |          |          |           |              | Don't  |              | 
    164            * |   floating      |     0    |    0     |     1     |      0       | care   |  Don't care  |
    165            * |-----------------|----------|----------|-----------|--------------|--------|--------------|  
    166            * |  TIMESTAMP and  |          |          |           |              | Don't  |              |
    167            * |  TAMPER input   |     0    |    0     |     1     |      1       | care   |  Don't care  |
    168            * |   floating      |          |          |           |              |        |              |                 
    169            * |-----------------|----------|----------|-----------|--------------|--------|--------------|  
    170            * | TIMESTAMP input |          |          |           |              | Don't  |              | 
    171            * |    floating     |     0    |    0     |     0     |      1       | care   |  Don't care  |                 
    172            * |-----------------|----------|----------|-----------|--------------|--------|--------------|  
    173            * |  Wakeup Pin 2   |     0    |    0     |     0     |      0       |   1    |  Don't care  |                 
    174            * |-----------------|----------|----------|-----------|--------------|--------|--------------|  
    175            * |  Standard GPIO  |     0    |    0     |     0     |      0       |   0    |  Don't care  |             
    176            * +------------------------------------------------------------------------------------------+  
    177            *
    178            *  @endverbatim
    179            *                      
    180            ******************************************************************************
    181            * @attention
    182            *
    183            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
    184            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
    185            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
    186            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
    187            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
    188            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
    189            *
    190            * <h2><center>&copy; COPYRIGHT 2010 STMicroelectronics</center></h2>
    191            ******************************************************************************  
    192            */ 
    193          
    194          /* Includes ------------------------------------------------------------------*/
    195          #include "stm32l1xx_rtc.h"
    196          #include "stm32l1xx_rcc.h"
    197          
    198          /** @addtogroup STM32L1xx_StdPeriph_Driver
    199            * @{
    200            */
    201          
    202          /** @defgroup RTC 
    203            * @brief RTC driver modules
    204            * @{
    205            */
    206          
    207          /* Private typedef -----------------------------------------------------------*/
    208          /* Private define ------------------------------------------------------------*/
    209          
    210          /* Masks Definition */
    211          #define RTC_TR_RESERVED_MASK    ((uint32_t)0x007F7F7F)
    212          #define RTC_DR_RESERVED_MASK    ((uint32_t)0x00FFFF3F) 
    213          #define RTC_INIT_MASK           ((uint32_t)0xFFFFFFFF)  
    214          #define RTC_RSF_MASK            ((uint32_t)0xFFFFFF5F)
    215          #define RTC_FLAGS_MASK          ((uint32_t)(RTC_FLAG_TSOVF | RTC_FLAG_TSF | RTC_FLAG_WUTF | \
    216                                                      RTC_FLAG_ALRBF | RTC_FLAG_ALRAF | RTC_FLAG_INITF | \
    217                                                      RTC_FLAG_RSF | RTC_FLAG_INITS | RTC_FLAG_WUTWF | \
    218                                                      RTC_FLAG_ALRBWF | RTC_FLAG_ALRAWF | RTC_FLAG_TAMP1F ))
    219          
    220          #define INITMODE_TIMEOUT         ((uint32_t) 0x00002000)
    221          #define SYNCHRO_TIMEOUT          ((uint32_t) 0x00001000)
    222          
    223          /* Private macro -------------------------------------------------------------*/
    224          /* Private variables ---------------------------------------------------------*/
    225          /* Private function prototypes -----------------------------------------------*/
    226          static uint8_t RTC_ByteToBcd2(uint8_t Value);
    227          static uint8_t RTC_Bcd2ToByte(uint8_t Value);
    228          
    229          /* Private functions ---------------------------------------------------------*/
    230          
    231          /** @defgroup RTC_Private_Functions
    232            * @{
    233            */ 
    234          
    235          /** @defgroup RTC_Group1 Initialization and Configuration functions
    236           *  @brief   Initialization and Configuration functions 
    237           *
    238          @verbatim   
    239           ===============================================================================
    240                           Initialization and Configuration functions
    241           ===============================================================================  
    242          
    243            This section provide functions allowing to initialize and configure the RTC
    244            Prescaler (Synchronous and Asynchronous), RTC Hour format, disable RTC registers
    245            Write protection, enter and exit the RTC initialization mode, RTC registers
    246            synchronization check and reference clock detection enable.
    247            
    248            1. The RTC Prescaler is programmed to generate the RTC 1Hz time base. It is
    249               split into 2 programmable prescalers to minimize power consumption.
    250               - A 7-bit asynchronous prescaler and A 13-bit synchronous prescaler.
    251               - When both prescalers are used, it is recommended to configure the asynchronous
    252                 prescaler to a high value to minimize consumption.
    253          
    254            2. All RTC registers are Write protected. Writing to the RTC registers
    255               is enabled by writing a key into the Write Protection register, RTC_WPR.
    256          
    257            3. To Configure the RTC Calendar, user application should enter initialization
    258               mode. In this mode, the calendar counter is stopped and its value can be 
    259               updated. When the initialization sequence is complete, the calendar restarts 
    260               counting after 4 RTCCLK cycles.
    261          
    262            4. To read the calendar through the shadow registers after Calendar initialization,
    263               calendar update or after wakeup from low power modes the software must first 
    264               clear the RSF flag. The software must then wait until it is set again before 
    265               reading the calendar, which means that the calendar registers have been 
    266               correctly copied into the RTC_TR and RTC_DR shadow registers.
    267               The RTC_WaitForSynchro() function implements the above software sequence 
    268               (RSF clear and RSF check).
    269          
    270          @endverbatim
    271            * @{
    272            */
    273          
    274          /**
    275            * @brief  Deinitializes the RTC registers to their default reset values.
    276            * @note   This function doesn't reset the RTC Clock source and RTC Backup Data
    277            *         registers.       
    278            * @param  None
    279            * @retval An ErrorStatus enumeration value:
    280            *          - SUCCESS: RTC registers are deinitialized
    281            *          - ERROR: RTC registers are not deinitialized
    282            */

   \                                 In section .text, align 2, keep-with-next
    283          ErrorStatus RTC_DeInit(void)
    284          {
   \                     RTC_DeInit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    285            __IO uint32_t wutcounter = 0x00;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x9000             STR      R0,[SP, #+0]
    286            uint32_t wutwfstatus = 0x00;
   \   00000006   0x2400             MOVS     R4,#+0
    287            ErrorStatus status = ERROR;
   \   00000008   0x2500             MOVS     R5,#+0
    288            
    289            /* Disable the write protection for RTC registers */
    290            RTC->WPR = 0xCA;
   \   0000000A   0x20CA             MOVS     R0,#+202
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable18  ;; 0x40002824
   \   00000010   0x6008             STR      R0,[R1, #+0]
    291            RTC->WPR = 0x53;
   \   00000012   0x2053             MOVS     R0,#+83
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable18  ;; 0x40002824
   \   00000018   0x6008             STR      R0,[R1, #+0]
    292          
    293            /* Set Initialization mode */
    294            if (RTC_EnterInitMode() == ERROR)
   \   0000001A   0x.... 0x....      BL       RTC_EnterInitMode
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD102             BNE.N    ??RTC_DeInit_0
    295            {
    296              status = ERROR;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x0005             MOVS     R5,R0
   \   00000026   0xE055             B.N      ??RTC_DeInit_1
    297            }  
    298            else
    299            {
    300              /* Reset TR, DR and CR registers */
    301              RTC->TR = (uint32_t)0x00000000;
   \                     ??RTC_DeInit_0: (+1)
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable16  ;; 0x40002800
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    302              RTC->DR = (uint32_t)0x00002101;
   \   00000030   0xF242 0x1001      MOVW     R0,#+8449
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable16_1  ;; 0x40002804
   \   00000038   0x6008             STR      R0,[R1, #+0]
    303              /* Reset All CR bits except CR[2:0] */
    304              RTC->CR &= (uint32_t)0x00000007;
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable16_2  ;; 0x40002808
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable16_2  ;; 0x40002808
   \   00000048   0x6008             STR      R0,[R1, #+0]
    305            
    306              /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
    307              do
    308              {
    309                wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
   \                     ??RTC_DeInit_2: (+1)
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x4000280c
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0xF010 0x0004      ANDS     R0,R0,#0x4
   \   00000054   0x0004             MOVS     R4,R0
    310                wutcounter++;  
   \   00000056   0x9800             LDR      R0,[SP, #+0]
   \   00000058   0x1C40             ADDS     R0,R0,#+1
   \   0000005A   0x9000             STR      R0,[SP, #+0]
    311              } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
   \   0000005C   0x9800             LDR      R0,[SP, #+0]
   \   0000005E   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000062   0xD001             BEQ.N    ??RTC_DeInit_3
   \   00000064   0x2C00             CMP      R4,#+0
   \   00000066   0xD0F0             BEQ.N    ??RTC_DeInit_2
    312              
    313              if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
   \                     ??RTC_DeInit_3: (+1)
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x4000280c
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0x0740             LSLS     R0,R0,#+29
   \   00000070   0xD402             BMI.N    ??RTC_DeInit_4
    314              {
    315                status = ERROR;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x0005             MOVS     R5,R0
   \   00000076   0xE02D             B.N      ??RTC_DeInit_1
    316              }
    317              else
    318              {
    319                /* Reset all RTC CR register bits */
    320                RTC->CR &= (uint32_t)0x00000000;
   \                     ??RTC_DeInit_4: (+1)
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable16_2  ;; 0x40002808
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable16_2  ;; 0x40002808
   \   00000084   0x6008             STR      R0,[R1, #+0]
    321                RTC->WUTR = (uint32_t)0x0000FFFF;
   \   00000086   0xF64F 0x70FF      MOVW     R0,#+65535
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable16_3  ;; 0x40002814
   \   0000008E   0x6008             STR      R0,[R1, #+0]
    322                RTC->PRER = (uint32_t)0x007F00FF;
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable16_4  ;; 0x7f00ff
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable16_5  ;; 0x40002810
   \   00000098   0x6008             STR      R0,[R1, #+0]
    323                RTC->CALIBR = (uint32_t)0x00000000;
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x.... 0x....      LDR.W    R1,??DataTable16_6  ;; 0x40002818
   \   000000A0   0x6008             STR      R0,[R1, #+0]
    324                RTC->ALRMAR = (uint32_t)0x00000000;        
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0x.... 0x....      LDR.W    R1,??DataTable16_7  ;; 0x4000281c
   \   000000A8   0x6008             STR      R0,[R1, #+0]
    325                RTC->ALRMBR = (uint32_t)0x00000000;
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x.... 0x....      LDR.W    R1,??DataTable16_8  ;; 0x40002820
   \   000000B0   0x6008             STR      R0,[R1, #+0]
    326                
    327                /* Reset ISR register and exit initialization mode */
    328                RTC->ISR = (uint32_t)0x00000000;
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0x.... 0x....      LDR.W    R1,??DataTable19  ;; 0x4000280c
   \   000000B8   0x6008             STR      R0,[R1, #+0]
    329                
    330                /* Reset Tamper and alternate functions configuration register */
    331                RTC->TAFCR = 0x00000000;
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x40002840
   \   000000C0   0x6008             STR      R0,[R1, #+0]
    332            
    333                if(RTC_WaitForSynchro() == ERROR)
   \   000000C2   0x.... 0x....      BL       RTC_WaitForSynchro
   \   000000C6   0x2800             CMP      R0,#+0
   \   000000C8   0xD102             BNE.N    ??RTC_DeInit_5
    334                {
    335                  status = ERROR;
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0x0005             MOVS     R5,R0
   \   000000CE   0xE001             B.N      ??RTC_DeInit_1
    336                }
    337                else
    338                {
    339                  status = SUCCESS;      
   \                     ??RTC_DeInit_5: (+1)
   \   000000D0   0x2001             MOVS     R0,#+1
   \   000000D2   0x0005             MOVS     R5,R0
    340                }
    341              }
    342            }
    343            
    344            /* Enable the write protection for RTC registers */
    345            RTC->WPR = 0xFF;  
   \                     ??RTC_DeInit_1: (+1)
   \   000000D4   0x20FF             MOVS     R0,#+255
   \   000000D6   0x.... 0x....      LDR.W    R1,??DataTable18  ;; 0x40002824
   \   000000DA   0x6008             STR      R0,[R1, #+0]
    346            
    347            return status;
   \   000000DC   0x0028             MOVS     R0,R5
   \   000000DE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E0   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    348          }
    349          
    350          /**
    351            * @brief  Initializes the RTC registers according to the specified parameters 
    352            *         in RTC_InitStruct.
    353            * @param  RTC_InitStruct: pointer to a RTC_InitTypeDef structure that contains 
    354            *         the configuration information for the RTC peripheral.
    355            * @note   The RTC Prescaler register is write protected and can be written in 
    356            *         initialization mode only.  
    357            * @retval An ErrorStatus enumeration value:
    358            *          - SUCCESS: RTC registers are initialized
    359            *          - ERROR: RTC registers are not initialized  
    360            */

   \                                 In section .text, align 2, keep-with-next
    361          ErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct)
    362          {
   \                     RTC_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    363            ErrorStatus status = ERROR;
   \   00000004   0x2500             MOVS     R5,#+0
    364            
    365            /* Check the parameters */
    366            assert_param(IS_RTC_HOUR_FORMAT(RTC_InitStruct->RTC_HourFormat));
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x2840             CMP      R0,#+64
   \   0000000A   0xD008             BEQ.N    ??RTC_Init_0
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD005             BEQ.N    ??RTC_Init_0
   \   00000012   0xF44F 0x71B7      MOV      R1,#+366
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   0000001A   0x.... 0x....      BL       assert_failed
    367            assert_param(IS_RTC_ASYNCH_PREDIV(RTC_InitStruct->RTC_AsynchPrediv));
   \                     ??RTC_Init_0: (+1)
   \   0000001E   0x6860             LDR      R0,[R4, #+4]
   \   00000020   0x2880             CMP      R0,#+128
   \   00000022   0xD305             BCC.N    ??RTC_Init_1
   \   00000024   0xF240 0x116F      MOVW     R1,#+367
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   0000002C   0x.... 0x....      BL       assert_failed
    368            assert_param(IS_RTC_SYNCH_PREDIV(RTC_InitStruct->RTC_SynchPrediv));
   \                     ??RTC_Init_1: (+1)
   \   00000030   0x68A0             LDR      R0,[R4, #+8]
   \   00000032   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000036   0xD305             BCC.N    ??RTC_Init_2
   \   00000038   0xF44F 0x71B8      MOV      R1,#+368
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000040   0x.... 0x....      BL       assert_failed
    369          
    370            /* Disable the write protection for RTC registers */
    371            RTC->WPR = 0xCA;
   \                     ??RTC_Init_2: (+1)
   \   00000044   0x20CA             MOVS     R0,#+202
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable18  ;; 0x40002824
   \   0000004A   0x6008             STR      R0,[R1, #+0]
    372            RTC->WPR = 0x53;
   \   0000004C   0x2053             MOVS     R0,#+83
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable18  ;; 0x40002824
   \   00000052   0x6008             STR      R0,[R1, #+0]
    373          
    374            /* Set Initialization mode */
    375            if (RTC_EnterInitMode() == ERROR)
   \   00000054   0x.... 0x....      BL       RTC_EnterInitMode
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD102             BNE.N    ??RTC_Init_3
    376            {
    377              status = ERROR;
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x0005             MOVS     R5,R0
   \   00000060   0xE020             B.N      ??RTC_Init_4
    378            } 
    379            else
    380            {
    381              /* Clear RTC CR FMT Bit */
    382              RTC->CR &= ((uint32_t)~(RTC_CR_FMT));
   \                     ??RTC_Init_3: (+1)
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable16_2  ;; 0x40002808
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0xF030 0x0040      BICS     R0,R0,#0x40
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable16_2  ;; 0x40002808
   \   00000070   0x6008             STR      R0,[R1, #+0]
    383              /* Set RTC_CR register */
    384              RTC->CR |=  ((uint32_t)(RTC_InitStruct->RTC_HourFormat));
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable16_2  ;; 0x40002808
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0x6821             LDR      R1,[R4, #+0]
   \   0000007A   0x4308             ORRS     R0,R1,R0
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable16_2  ;; 0x40002808
   \   00000080   0x6008             STR      R0,[R1, #+0]
    385            
    386              /* Configure the RTC PRER */
    387              RTC->PRER = (uint32_t)(RTC_InitStruct->RTC_SynchPrediv);
   \   00000082   0x68A0             LDR      R0,[R4, #+8]
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable16_5  ;; 0x40002810
   \   00000088   0x6008             STR      R0,[R1, #+0]
    388              RTC->PRER |= (uint32_t)(RTC_InitStruct->RTC_AsynchPrediv << 16);
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable16_5  ;; 0x40002810
   \   0000008E   0x6800             LDR      R0,[R0, #+0]
   \   00000090   0x6861             LDR      R1,[R4, #+4]
   \   00000092   0xEA50 0x4001      ORRS     R0,R0,R1, LSL #+16
   \   00000096   0x.... 0x....      LDR.W    R1,??DataTable16_5  ;; 0x40002810
   \   0000009A   0x6008             STR      R0,[R1, #+0]
    389          
    390              /* Exit Initialization mode */
    391              RTC_ExitInitMode();
   \   0000009C   0x.... 0x....      BL       RTC_ExitInitMode
    392          
    393              status = SUCCESS;    
   \   000000A0   0x2001             MOVS     R0,#+1
   \   000000A2   0x0005             MOVS     R5,R0
    394            }
    395            /* Enable the write protection for RTC registers */
    396            RTC->WPR = 0xFF; 
   \                     ??RTC_Init_4: (+1)
   \   000000A4   0x20FF             MOVS     R0,#+255
   \   000000A6   0x.... 0x....      LDR.W    R1,??DataTable18  ;; 0x40002824
   \   000000AA   0x6008             STR      R0,[R1, #+0]
    397            
    398            return status;
   \   000000AC   0x0028             MOVS     R0,R5
   \   000000AE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B0   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    399          }
    400          
    401          /**
    402            * @brief  Fills each RTC_InitStruct member with its default value.
    403            * @param  RTC_InitStruct: pointer to a RTC_InitTypeDef structure which will be 
    404            *         initialized.
    405            * @retval None
    406            */

   \                                 In section .text, align 2, keep-with-next
    407          void RTC_StructInit(RTC_InitTypeDef* RTC_InitStruct)
    408          {
    409            /* Initialize the RTC_HourFormat member */
    410            RTC_InitStruct->RTC_HourFormat = RTC_HourFormat_24;
   \                     RTC_StructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    411              
    412            /* Initialize the RTC_AsynchPrediv member */
    413            RTC_InitStruct->RTC_AsynchPrediv = (uint32_t)0x7F;
   \   00000004   0x217F             MOVS     R1,#+127
   \   00000006   0x6041             STR      R1,[R0, #+4]
    414          
    415            /* Initialize the RTC_SynchPrediv member */
    416            RTC_InitStruct->RTC_SynchPrediv = (uint32_t)0xFF; 
   \   00000008   0x21FF             MOVS     R1,#+255
   \   0000000A   0x6081             STR      R1,[R0, #+8]
    417          }
   \   0000000C   0x4770             BX       LR               ;; return
    418          
    419          /**
    420            * @brief  Enables or disables the RTC registers write protection.
    421            * @note   All the RTC registers are write protected except for RTC_ISR[13:8], 
    422            *         RTC_TAFCR and RTC_BKPxR.
    423            * @note   Writing a wrong key reactivates the write protection.
    424            * @note   The protection mechanism is not affected by system reset.  
    425            * @param  NewState: new state of the write protection.
    426            *   This parameter can be: ENABLE or DISABLE.
    427            * @retval None
    428            */

   \                                 In section .text, align 2, keep-with-next
    429          void RTC_WriteProtectionCmd(FunctionalState NewState)
    430          {
   \                     RTC_WriteProtectionCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    431            /* Check the parameters */
    432            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD008             BEQ.N    ??RTC_WriteProtectionCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD005             BEQ.N    ??RTC_WriteProtectionCmd_0
   \   00000010   0xF44F 0x71D8      MOV      R1,#+432
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000018   0x.... 0x....      BL       assert_failed
    433              
    434            if (NewState != DISABLE)
   \                     ??RTC_WriteProtectionCmd_0: (+1)
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD004             BEQ.N    ??RTC_WriteProtectionCmd_1
    435            {
    436              /* Enable the write protection for RTC registers */
    437              RTC->WPR = 0xFF;   
   \   00000022   0x20FF             MOVS     R0,#+255
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable18  ;; 0x40002824
   \   00000028   0x6008             STR      R0,[R1, #+0]
   \   0000002A   0xE007             B.N      ??RTC_WriteProtectionCmd_2
    438            }
    439            else
    440            {
    441              /* Disable the write protection for RTC registers */
    442              RTC->WPR = 0xCA;
   \                     ??RTC_WriteProtectionCmd_1: (+1)
   \   0000002C   0x20CA             MOVS     R0,#+202
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable18  ;; 0x40002824
   \   00000032   0x6008             STR      R0,[R1, #+0]
    443              RTC->WPR = 0x53;    
   \   00000034   0x2053             MOVS     R0,#+83
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable18  ;; 0x40002824
   \   0000003A   0x6008             STR      R0,[R1, #+0]
    444            }
    445          }
   \                     ??RTC_WriteProtectionCmd_2: (+1)
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
    446          
    447          /**
    448            * @brief  Enters the RTC Initialization mode.
    449            * @note   The RTC Initialization mode is write protected, use the 
    450            *         RTC_WriteProtectionCmd(DISABLE) before calling this function.    
    451            * @param  None
    452            * @retval An ErrorStatus enumeration value:
    453            *          - SUCCESS: RTC is in Init mode
    454            *          - ERROR: RTC is not in Init mode  
    455            */

   \                                 In section .text, align 2, keep-with-next
    456          ErrorStatus RTC_EnterInitMode(void)
    457          {
   \                     RTC_EnterInitMode: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
    458            __IO uint32_t initcounter = 0x00;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x9000             STR      R0,[SP, #+0]
    459            ErrorStatus status = ERROR;
   \   00000006   0x2000             MOVS     R0,#+0
    460            uint32_t initstatus = 0x00;
   \   00000008   0x2100             MOVS     R1,#+0
    461               
    462            /* Check if the Initialization mode is set */
    463            if ((RTC->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
   \   0000000A   0x.... 0x....      LDR.W    R2,??DataTable19  ;; 0x4000280c
   \   0000000E   0x6812             LDR      R2,[R2, #+0]
   \   00000010   0x0652             LSLS     R2,R2,#+25
   \   00000012   0xD41E             BMI.N    ??RTC_EnterInitMode_0
    464            {
    465              /* Set the Initialization mode */
    466              RTC->ISR = (uint32_t)RTC_INIT_MASK;
   \   00000014   0xF05F 0x32FF      MOVS     R2,#-1
   \   00000018   0x.... 0x....      LDR.W    R3,??DataTable19  ;; 0x4000280c
   \   0000001C   0x601A             STR      R2,[R3, #+0]
    467              
    468              /* Wait till RTC is in INIT state and if Time out is reached exit */
    469              do
    470              {
    471                initstatus = RTC->ISR & RTC_ISR_INITF;
   \                     ??RTC_EnterInitMode_1: (+1)
   \   0000001E   0x.... 0x....      LDR.W    R2,??DataTable19  ;; 0x4000280c
   \   00000022   0x6812             LDR      R2,[R2, #+0]
   \   00000024   0xF012 0x0240      ANDS     R2,R2,#0x40
   \   00000028   0x0011             MOVS     R1,R2
    472                initcounter++;  
   \   0000002A   0x9A00             LDR      R2,[SP, #+0]
   \   0000002C   0x1C52             ADDS     R2,R2,#+1
   \   0000002E   0x9200             STR      R2,[SP, #+0]
    473              } while((initcounter != INITMODE_TIMEOUT) && (initstatus == 0x00));
   \   00000030   0x9A00             LDR      R2,[SP, #+0]
   \   00000032   0xF5B2 0x5F00      CMP      R2,#+8192
   \   00000036   0xD001             BEQ.N    ??RTC_EnterInitMode_2
   \   00000038   0x2900             CMP      R1,#+0
   \   0000003A   0xD0F0             BEQ.N    ??RTC_EnterInitMode_1
    474              
    475              if ((RTC->ISR & RTC_ISR_INITF) != RESET)
   \                     ??RTC_EnterInitMode_2: (+1)
   \   0000003C   0x.... 0x....      LDR.W    R2,??DataTable19  ;; 0x4000280c
   \   00000040   0x6812             LDR      R2,[R2, #+0]
   \   00000042   0x0652             LSLS     R2,R2,#+25
   \   00000044   0xD502             BPL.N    ??RTC_EnterInitMode_3
    476              {
    477                status = SUCCESS;
   \   00000046   0x2201             MOVS     R2,#+1
   \   00000048   0x0010             MOVS     R0,R2
   \   0000004A   0xE004             B.N      ??RTC_EnterInitMode_4
    478              }
    479              else
    480              {
    481                status = ERROR;
   \                     ??RTC_EnterInitMode_3: (+1)
   \   0000004C   0x2200             MOVS     R2,#+0
   \   0000004E   0x0010             MOVS     R0,R2
   \   00000050   0xE001             B.N      ??RTC_EnterInitMode_4
    482              }        
    483            }
    484            else
    485            {
    486              status = SUCCESS;  
   \                     ??RTC_EnterInitMode_0: (+1)
   \   00000052   0x2201             MOVS     R2,#+1
   \   00000054   0x0010             MOVS     R0,R2
    487            } 
    488              
    489            return (status);  
   \                     ??RTC_EnterInitMode_4: (+1)
   \   00000056   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000058   0xB001             ADD      SP,SP,#+4
   \   0000005A   0x4770             BX       LR               ;; return
    490          }
    491          
    492          /**
    493            * @brief  Exits the RTC Initialization mode.
    494            * @note   When the initialization sequence is complete, the calendar restarts 
    495            *         counting after 4 RTCCLK cycles.  
    496            * @note   The RTC Initialization mode is write protected, use the 
    497            *         RTC_WriteProtectionCmd(DISABLE) before calling this function.      
    498            * @param  None
    499            * @retval None
    500            */

   \                                 In section .text, align 2, keep-with-next
    501          void RTC_ExitInitMode(void)
    502          { 
    503            /* Exit Initialization mode */
    504            RTC->ISR &= (uint32_t)~RTC_ISR_INIT;  
   \                     RTC_ExitInitMode: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable21  ;; 0x4000280c
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF030 0x0080      BICS     R0,R0,#0x80
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable21  ;; 0x4000280c
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    505          }
   \   00000010   0x4770             BX       LR               ;; return
    506          
    507          /**
    508            * @brief  Waits until the RTC Time and Date registers (RTC_TR and RTC_DR) are 
    509            *         synchronized with RTC APB clock.
    510            * @note   The RTC Resynchronization mode is write protected, use the 
    511            *         RTC_WriteProtectionCmd(DISABLE) before calling this function. 
    512            * @note   To read the calendar through the shadow registers after Calendar 
    513            *         initialization, calendar update or after wakeup from low power modes 
    514            *         the software must first clear the RSF flag. 
    515            *         The software must then wait until it is set again before reading 
    516            *         the calendar, which means that the calendar registers have been 
    517            *         correctly copied into the RTC_TR and RTC_DR shadow registers.   
    518            * @param  None
    519            * @retval An ErrorStatus enumeration value:
    520            *          - SUCCESS: RTC registers are synchronised
    521            *          - ERROR: RTC registers are not synchronised
    522            */

   \                                 In section .text, align 2, keep-with-next
    523          ErrorStatus RTC_WaitForSynchro(void)
    524          {
   \                     RTC_WaitForSynchro: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
    525            __IO uint32_t synchrocounter = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x9000             STR      R0,[SP, #+0]
    526            ErrorStatus status = ERROR;
   \   00000006   0x2000             MOVS     R0,#+0
    527            uint32_t synchrostatus = 0x00;
   \   00000008   0x2100             MOVS     R1,#+0
    528          
    529            /* Disable the write protection for RTC registers */
    530            RTC->WPR = 0xCA;
   \   0000000A   0x22CA             MOVS     R2,#+202
   \   0000000C   0x.... 0x....      LDR.W    R3,??DataTable18  ;; 0x40002824
   \   00000010   0x601A             STR      R2,[R3, #+0]
    531            RTC->WPR = 0x53;
   \   00000012   0x2253             MOVS     R2,#+83
   \   00000014   0x.... 0x....      LDR.W    R3,??DataTable18  ;; 0x40002824
   \   00000018   0x601A             STR      R2,[R3, #+0]
    532              
    533            /* Clear RSF flag */
    534            RTC->ISR &= (uint32_t)RTC_RSF_MASK;
   \   0000001A   0x.... 0x....      LDR.W    R2,??DataTable19  ;; 0x4000280c
   \   0000001E   0x6812             LDR      R2,[R2, #+0]
   \   00000020   0xF032 0x02A0      BICS     R2,R2,#0xA0
   \   00000024   0x.... 0x....      LDR.W    R3,??DataTable19  ;; 0x4000280c
   \   00000028   0x601A             STR      R2,[R3, #+0]
    535              
    536            /* Wait the registers to be synchronised */
    537            do
    538            {
    539              synchrostatus = RTC->ISR & RTC_ISR_RSF;
   \                     ??RTC_WaitForSynchro_0: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R2,??DataTable19  ;; 0x4000280c
   \   0000002E   0x6812             LDR      R2,[R2, #+0]
   \   00000030   0xF012 0x0220      ANDS     R2,R2,#0x20
   \   00000034   0x0011             MOVS     R1,R2
    540              synchrocounter++;  
   \   00000036   0x9A00             LDR      R2,[SP, #+0]
   \   00000038   0x1C52             ADDS     R2,R2,#+1
   \   0000003A   0x9200             STR      R2,[SP, #+0]
    541            } while((synchrocounter != SYNCHRO_TIMEOUT) && (synchrostatus == 0x00));
   \   0000003C   0x9A00             LDR      R2,[SP, #+0]
   \   0000003E   0xF5B2 0x5F80      CMP      R2,#+4096
   \   00000042   0xD001             BEQ.N    ??RTC_WaitForSynchro_1
   \   00000044   0x2900             CMP      R1,#+0
   \   00000046   0xD0F0             BEQ.N    ??RTC_WaitForSynchro_0
    542              
    543            if ((RTC->ISR & RTC_ISR_RSF) != RESET)
   \                     ??RTC_WaitForSynchro_1: (+1)
   \   00000048   0x.... 0x....      LDR.W    R2,??DataTable19  ;; 0x4000280c
   \   0000004C   0x6812             LDR      R2,[R2, #+0]
   \   0000004E   0x0692             LSLS     R2,R2,#+26
   \   00000050   0xD502             BPL.N    ??RTC_WaitForSynchro_2
    544            {
    545              status = SUCCESS;
   \   00000052   0x2201             MOVS     R2,#+1
   \   00000054   0x0010             MOVS     R0,R2
   \   00000056   0xE001             B.N      ??RTC_WaitForSynchro_3
    546            }
    547            else
    548            {
    549              status = ERROR;
   \                     ??RTC_WaitForSynchro_2: (+1)
   \   00000058   0x2200             MOVS     R2,#+0
   \   0000005A   0x0010             MOVS     R0,R2
    550            }        
    551          
    552            /* Enable the write protection for RTC registers */
    553            RTC->WPR = 0xFF; 
   \                     ??RTC_WaitForSynchro_3: (+1)
   \   0000005C   0x22FF             MOVS     R2,#+255
   \   0000005E   0x.... 0x....      LDR.W    R3,??DataTable18  ;; 0x40002824
   \   00000062   0x601A             STR      R2,[R3, #+0]
    554              
    555            return (status); 
   \   00000064   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000066   0xB001             ADD      SP,SP,#+4
   \   00000068   0x4770             BX       LR               ;; return
    556          }
    557          
    558          /**
    559            * @brief  Enables or disables the RTC reference clock detection.
    560            * @param  NewState: new state of the RTC reference clock.
    561            *   This parameter can be: ENABLE or DISABLE.
    562            * @retval An ErrorStatus enumeration value:
    563            *          - SUCCESS: RTC reference clock detection is enabled
    564            *          - ERROR: RTC reference clock detection is disabled  
    565            */

   \                                 In section .text, align 2, keep-with-next
    566          ErrorStatus RTC_RefClockCmd(FunctionalState NewState)
    567          { 
   \                     RTC_RefClockCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    568            ErrorStatus status = ERROR;
   \   00000004   0x2500             MOVS     R5,#+0
    569            
    570            /* Check the parameters */
    571            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD008             BEQ.N    ??RTC_RefClockCmd_0
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x2C01             CMP      R4,#+1
   \   00000010   0xD005             BEQ.N    ??RTC_RefClockCmd_0
   \   00000012   0xF240 0x213B      MOVW     R1,#+571
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   0000001A   0x.... 0x....      BL       assert_failed
    572            
    573            /* Disable the write protection for RTC registers */
    574            RTC->WPR = 0xCA;
   \                     ??RTC_RefClockCmd_0: (+1)
   \   0000001E   0x20CA             MOVS     R0,#+202
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable21_1  ;; 0x40002824
   \   00000024   0x6008             STR      R0,[R1, #+0]
    575            RTC->WPR = 0x53;
   \   00000026   0x2053             MOVS     R0,#+83
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable21_1  ;; 0x40002824
   \   0000002C   0x6008             STR      R0,[R1, #+0]
    576              
    577            /* Set Initialization mode */
    578            if (RTC_EnterInitMode() == ERROR)
   \   0000002E   0x.... 0x....      BL       RTC_EnterInitMode
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD102             BNE.N    ??RTC_RefClockCmd_1
    579            {
    580              status = ERROR;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x0005             MOVS     R5,R0
   \   0000003A   0xE017             B.N      ??RTC_RefClockCmd_2
    581            } 
    582            else
    583            {  
    584              if (NewState != DISABLE)
   \                     ??RTC_RefClockCmd_1: (+1)
   \   0000003C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003E   0x2C00             CMP      R4,#+0
   \   00000040   0xD008             BEQ.N    ??RTC_RefClockCmd_3
    585              {
    586                /* Enable the RTC reference clock detection */
    587                RTC->CR |= RTC_CR_REFCKON;   
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable16_2  ;; 0x40002808
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable16_2  ;; 0x40002808
   \   00000050   0x6008             STR      R0,[R1, #+0]
   \   00000052   0xE007             B.N      ??RTC_RefClockCmd_4
    588              }
    589              else
    590              {
    591                /* Disable the RTC reference clock detection */
    592                RTC->CR &= ~RTC_CR_REFCKON;    
   \                     ??RTC_RefClockCmd_3: (+1)
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable16_2  ;; 0x40002808
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0xF030 0x0010      BICS     R0,R0,#0x10
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable16_2  ;; 0x40002808
   \   00000062   0x6008             STR      R0,[R1, #+0]
    593              }
    594              /* Exit Initialization mode */
    595              RTC_ExitInitMode();
   \                     ??RTC_RefClockCmd_4: (+1)
   \   00000064   0x.... 0x....      BL       RTC_ExitInitMode
    596              
    597              status = SUCCESS;
   \   00000068   0x2001             MOVS     R0,#+1
   \   0000006A   0x0005             MOVS     R5,R0
    598            }
    599            
    600            /* Enable the write protection for RTC registers */
    601            RTC->WPR = 0xFF;  
   \                     ??RTC_RefClockCmd_2: (+1)
   \   0000006C   0x20FF             MOVS     R0,#+255
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable21_1  ;; 0x40002824
   \   00000072   0x6008             STR      R0,[R1, #+0]
    602            
    603            return status; 
   \   00000074   0x0028             MOVS     R0,R5
   \   00000076   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000078   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    604          }
    605          
    606          /**
    607            * @}
    608            */
    609          
    610          /** @defgroup RTC_Group2 Time and Date configuration functions
    611           *  @brief   Time and Date configuration functions 
    612           *
    613          @verbatim   
    614           ===============================================================================
    615                             Time and Date configuration functions
    616           ===============================================================================  
    617          
    618            This section provide functions allowing to program and read the RTC Calendar
    619            (Time and Date).
    620          
    621          @endverbatim
    622            * @{
    623            */
    624          
    625          /**
    626            * @brief  Set the RTC current time.
    627            * @param  RTC_Format: specifies the format of the entered parameters.
    628            *   This parameter can be  one of the following values:
    629            *     @arg RTC_Format_BIN:  Binary data format 
    630            *     @arg RTC_Format_BCD:  BCD data format
    631            * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure that contains 
    632            *                        the time configuration information for the RTC.     
    633            * @retval An ErrorStatus enumeration value:
    634            *          - SUCCESS: RTC Time register is configured
    635            *          - ERROR: RTC Time register is not configured
    636            */

   \                                 In section .text, align 2, keep-with-next
    637          ErrorStatus RTC_SetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
    638          {
   \                     RTC_SetTime: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    639            uint32_t tmpreg = 0;
   \   00000008   0x2600             MOVS     R6,#+0
    640            ErrorStatus status = ERROR;
   \   0000000A   0x2700             MOVS     R7,#+0
    641              
    642            /* Check the parameters */
    643            assert_param(IS_RTC_FORMAT(RTC_Format));
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD007             BEQ.N    ??RTC_SetTime_0
   \   00000010   0x2C01             CMP      R4,#+1
   \   00000012   0xD005             BEQ.N    ??RTC_SetTime_0
   \   00000014   0xF240 0x2183      MOVW     R1,#+643
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   0000001C   0x.... 0x....      BL       assert_failed
    644            
    645            if (RTC_Format == RTC_Format_BIN)
   \                     ??RTC_SetTime_0: (+1)
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD13B             BNE.N    ??RTC_SetTime_1
    646            {
    647              if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable16_2  ;; 0x40002808
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x0640             LSLS     R0,R0,#+25
   \   0000002C   0xD518             BPL.N    ??RTC_SetTime_2
    648              {
    649                assert_param(IS_RTC_HOUR12(RTC_TimeStruct->RTC_Hours));
   \   0000002E   0x7828             LDRB     R0,[R5, #+0]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD002             BEQ.N    ??RTC_SetTime_3
   \   00000034   0x7828             LDRB     R0,[R5, #+0]
   \   00000036   0x280D             CMP      R0,#+13
   \   00000038   0xDB05             BLT.N    ??RTC_SetTime_4
   \                     ??RTC_SetTime_3: (+1)
   \   0000003A   0xF240 0x2189      MOVW     R1,#+649
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000042   0x.... 0x....      BL       assert_failed
    650                assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12));
   \                     ??RTC_SetTime_4: (+1)
   \   00000046   0x78E8             LDRB     R0,[R5, #+3]
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD014             BEQ.N    ??RTC_SetTime_5
   \   0000004C   0x78E8             LDRB     R0,[R5, #+3]
   \   0000004E   0x2840             CMP      R0,#+64
   \   00000050   0xD011             BEQ.N    ??RTC_SetTime_5
   \   00000052   0xF240 0x218A      MOVW     R1,#+650
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   0000005A   0x.... 0x....      BL       assert_failed
   \   0000005E   0xE00A             B.N      ??RTC_SetTime_5
    651              } 
    652              else
    653              {
    654                RTC_TimeStruct->RTC_H12 = 0x00;
   \                     ??RTC_SetTime_2: (+1)
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x70E8             STRB     R0,[R5, #+3]
    655                assert_param(IS_RTC_HOUR24(RTC_TimeStruct->RTC_Hours));
   \   00000064   0x7828             LDRB     R0,[R5, #+0]
   \   00000066   0x2818             CMP      R0,#+24
   \   00000068   0xDB05             BLT.N    ??RTC_SetTime_5
   \   0000006A   0xF240 0x218F      MOVW     R1,#+655
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000072   0x.... 0x....      BL       assert_failed
    656              }
    657              assert_param(IS_RTC_MINUTES(RTC_TimeStruct->RTC_Minutes));
   \                     ??RTC_SetTime_5: (+1)
   \   00000076   0x7868             LDRB     R0,[R5, #+1]
   \   00000078   0x283C             CMP      R0,#+60
   \   0000007A   0xDB05             BLT.N    ??RTC_SetTime_6
   \   0000007C   0xF240 0x2191      MOVW     R1,#+657
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000084   0x.... 0x....      BL       assert_failed
    658              assert_param(IS_RTC_SECONDS(RTC_TimeStruct->RTC_Seconds));
   \                     ??RTC_SetTime_6: (+1)
   \   00000088   0x78A8             LDRB     R0,[R5, #+2]
   \   0000008A   0x283C             CMP      R0,#+60
   \   0000008C   0xDB49             BLT.N    ??RTC_SetTime_7
   \   0000008E   0xF240 0x2192      MOVW     R1,#+658
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000096   0x.... 0x....      BL       assert_failed
   \   0000009A   0xE042             B.N      ??RTC_SetTime_7
    659            }
    660            else
    661            {
    662              if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
   \                     ??RTC_SetTime_1: (+1)
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable16_2  ;; 0x40002808
   \   000000A0   0x6800             LDR      R0,[R0, #+0]
   \   000000A2   0x0640             LSLS     R0,R0,#+25
   \   000000A4   0xD51A             BPL.N    ??RTC_SetTime_8
    663              {
    664                tmpreg = RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
   \   000000A6   0x7828             LDRB     R0,[R5, #+0]
   \   000000A8   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   000000AC   0x0006             MOVS     R6,R0
    665                assert_param(IS_RTC_HOUR12(tmpreg));
   \   000000AE   0x2E00             CMP      R6,#+0
   \   000000B0   0xD001             BEQ.N    ??RTC_SetTime_9
   \   000000B2   0x2E0D             CMP      R6,#+13
   \   000000B4   0xD305             BCC.N    ??RTC_SetTime_10
   \                     ??RTC_SetTime_9: (+1)
   \   000000B6   0xF240 0x2199      MOVW     R1,#+665
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   000000BE   0x.... 0x....      BL       assert_failed
    666                assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12)); 
   \                     ??RTC_SetTime_10: (+1)
   \   000000C2   0x78E8             LDRB     R0,[R5, #+3]
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD016             BEQ.N    ??RTC_SetTime_11
   \   000000C8   0x78E8             LDRB     R0,[R5, #+3]
   \   000000CA   0x2840             CMP      R0,#+64
   \   000000CC   0xD013             BEQ.N    ??RTC_SetTime_11
   \   000000CE   0xF240 0x219A      MOVW     R1,#+666
   \   000000D2   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   000000D6   0x.... 0x....      BL       assert_failed
   \   000000DA   0xE00C             B.N      ??RTC_SetTime_11
    667              } 
    668              else
    669              {
    670                RTC_TimeStruct->RTC_H12 = 0x00;
   \                     ??RTC_SetTime_8: (+1)
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0x70E8             STRB     R0,[R5, #+3]
    671                assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours)));
   \   000000E0   0x7828             LDRB     R0,[R5, #+0]
   \   000000E2   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   000000E6   0x2818             CMP      R0,#+24
   \   000000E8   0xDB05             BLT.N    ??RTC_SetTime_11
   \   000000EA   0xF240 0x219F      MOVW     R1,#+671
   \   000000EE   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   000000F2   0x.... 0x....      BL       assert_failed
    672              }
    673              assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes)));
   \                     ??RTC_SetTime_11: (+1)
   \   000000F6   0x7868             LDRB     R0,[R5, #+1]
   \   000000F8   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   000000FC   0x283C             CMP      R0,#+60
   \   000000FE   0xDB05             BLT.N    ??RTC_SetTime_12
   \   00000100   0xF240 0x21A1      MOVW     R1,#+673
   \   00000104   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000108   0x.... 0x....      BL       assert_failed
    674              assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds)));
   \                     ??RTC_SetTime_12: (+1)
   \   0000010C   0x78A8             LDRB     R0,[R5, #+2]
   \   0000010E   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   00000112   0x283C             CMP      R0,#+60
   \   00000114   0xDB05             BLT.N    ??RTC_SetTime_7
   \   00000116   0xF240 0x21A2      MOVW     R1,#+674
   \   0000011A   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   0000011E   0x.... 0x....      BL       assert_failed
    675            }
    676            
    677            /* Check the input parameters format */
    678            if (RTC_Format != RTC_Format_BIN)
   \                     ??RTC_SetTime_7: (+1)
   \   00000122   0x2C00             CMP      R4,#+0
   \   00000124   0xD00B             BEQ.N    ??RTC_SetTime_13
    679            {
    680              tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
    681                       ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
    682                       ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
    683                       ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
   \   00000126   0x7828             LDRB     R0,[R5, #+0]
   \   00000128   0x7869             LDRB     R1,[R5, #+1]
   \   0000012A   0x0209             LSLS     R1,R1,#+8
   \   0000012C   0xEA51 0x4000      ORRS     R0,R1,R0, LSL #+16
   \   00000130   0x78A9             LDRB     R1,[R5, #+2]
   \   00000132   0x4308             ORRS     R0,R1,R0
   \   00000134   0x78E9             LDRB     R1,[R5, #+3]
   \   00000136   0xEA50 0x4001      ORRS     R0,R0,R1, LSL #+16
   \   0000013A   0x0006             MOVS     R6,R0
   \   0000013C   0xE018             B.N      ??RTC_SetTime_14
    684            }  
    685            else
    686            {
    687              tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
    688                             ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
    689                             ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
    690                             (((uint32_t)RTC_TimeStruct->RTC_H12) << 16));
   \                     ??RTC_SetTime_13: (+1)
   \   0000013E   0x7828             LDRB     R0,[R5, #+0]
   \   00000140   0x.... 0x....      BL       RTC_ByteToBcd2
   \   00000144   0x4680             MOV      R8,R0
   \   00000146   0x7868             LDRB     R0,[R5, #+1]
   \   00000148   0x.... 0x....      BL       RTC_ByteToBcd2
   \   0000014C   0x4681             MOV      R9,R0
   \   0000014E   0x78A8             LDRB     R0,[R5, #+2]
   \   00000150   0x.... 0x....      BL       RTC_ByteToBcd2
   \   00000154   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000158   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000015C   0xEA5F 0x2109      LSLS     R1,R9,#+8
   \   00000160   0xEA51 0x4108      ORRS     R1,R1,R8, LSL #+16
   \   00000164   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000166   0x4308             ORRS     R0,R0,R1
   \   00000168   0x78E9             LDRB     R1,[R5, #+3]
   \   0000016A   0xEA50 0x4001      ORRS     R0,R0,R1, LSL #+16
   \   0000016E   0x0006             MOVS     R6,R0
    691            }  
    692          
    693            /* Disable the write protection for RTC registers */
    694            RTC->WPR = 0xCA;
   \                     ??RTC_SetTime_14: (+1)
   \   00000170   0x20CA             MOVS     R0,#+202
   \   00000172   0x.... 0x....      LDR.W    R1,??DataTable21_1  ;; 0x40002824
   \   00000176   0x6008             STR      R0,[R1, #+0]
    695            RTC->WPR = 0x53;
   \   00000178   0x2053             MOVS     R0,#+83
   \   0000017A   0x.... 0x....      LDR.W    R1,??DataTable21_1  ;; 0x40002824
   \   0000017E   0x6008             STR      R0,[R1, #+0]
    696          
    697            /* Set Initialization mode */
    698            if (RTC_EnterInitMode() == ERROR)
   \   00000180   0x.... 0x....      BL       RTC_EnterInitMode
   \   00000184   0x2800             CMP      R0,#+0
   \   00000186   0xD102             BNE.N    ??RTC_SetTime_15
    699            {
    700              status = ERROR;
   \   00000188   0x2000             MOVS     R0,#+0
   \   0000018A   0x0007             MOVS     R7,R0
   \   0000018C   0xE010             B.N      ??RTC_SetTime_16
    701            } 
    702            else
    703            {
    704              /* Set the RTC_TR register */
    705              RTC->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
   \                     ??RTC_SetTime_15: (+1)
   \   0000018E   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x7f7f7f
   \   00000192   0x4030             ANDS     R0,R0,R6
   \   00000194   0x.... 0x....      LDR.W    R1,??DataTable16  ;; 0x40002800
   \   00000198   0x6008             STR      R0,[R1, #+0]
    706          
    707              /* Exit Initialization mode */
    708              RTC_ExitInitMode(); 
   \   0000019A   0x.... 0x....      BL       RTC_ExitInitMode
    709          
    710              if(RTC_WaitForSynchro() == ERROR)
   \   0000019E   0x.... 0x....      BL       RTC_WaitForSynchro
   \   000001A2   0x2800             CMP      R0,#+0
   \   000001A4   0xD102             BNE.N    ??RTC_SetTime_17
    711              {
    712                status = ERROR;
   \   000001A6   0x2000             MOVS     R0,#+0
   \   000001A8   0x0007             MOVS     R7,R0
   \   000001AA   0xE001             B.N      ??RTC_SetTime_16
    713              }
    714              else
    715              {
    716                status = SUCCESS;
   \                     ??RTC_SetTime_17: (+1)
   \   000001AC   0x2001             MOVS     R0,#+1
   \   000001AE   0x0007             MOVS     R7,R0
    717              }
    718            
    719            }
    720            /* Enable the write protection for RTC registers */
    721            RTC->WPR = 0xFF; 
   \                     ??RTC_SetTime_16: (+1)
   \   000001B0   0x20FF             MOVS     R0,#+255
   \   000001B2   0x.... 0x....      LDR.W    R1,??DataTable21_1  ;; 0x40002824
   \   000001B6   0x6008             STR      R0,[R1, #+0]
    722              
    723            return status;
   \   000001B8   0x0038             MOVS     R0,R7
   \   000001BA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001BC   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    724          }
    725          
    726          /**
    727            * @brief  Fills each RTC_TimeStruct member with its default value
    728            *         (Time = 00h:00min:00sec).
    729            * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure which will be 
    730            *         initialized.
    731            * @retval None
    732            */

   \                                 In section .text, align 2, keep-with-next
    733          void RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct)
    734          {
    735            /* Time = 00h:00min:00sec */
    736            RTC_TimeStruct->RTC_H12 = RTC_H12_AM;
   \                     RTC_TimeStructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x70C1             STRB     R1,[R0, #+3]
    737            RTC_TimeStruct->RTC_Hours = 0;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x7001             STRB     R1,[R0, #+0]
    738            RTC_TimeStruct->RTC_Minutes = 0;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x7041             STRB     R1,[R0, #+1]
    739            RTC_TimeStruct->RTC_Seconds = 0; 
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x7081             STRB     R1,[R0, #+2]
    740          }
   \   00000010   0x4770             BX       LR               ;; return
    741          
    742          /**
    743            * @brief  Get the RTC current Time.
    744            * @param  RTC_Format: specifies the format of the returned parameters.
    745            *   This parameter can be  one of the following values:
    746            *     @arg RTC_Format_BIN:  Binary data format 
    747            *     @arg RTC_Format_BCD:  BCD data format
    748            * @param RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure that will 
    749            *                        contain the returned current time configuration.     
    750            * @retval None
    751            */

   \                                 In section .text, align 2, keep-with-next
    752          void RTC_GetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
    753          {
   \                     RTC_GetTime: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    754            uint32_t tmpreg = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    755          
    756            /* Check the parameters */
    757            assert_param(IS_RTC_FORMAT(RTC_Format));
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD007             BEQ.N    ??RTC_GetTime_0
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD005             BEQ.N    ??RTC_GetTime_0
   \   00000010   0xF240 0x21F5      MOVW     R1,#+757
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000018   0x.... 0x....      BL       assert_failed
    758          
    759            /* Get the RTC_TR register */
    760            tmpreg = (uint32_t)(RTC->TR & RTC_TR_RESERVED_MASK); 
   \                     ??RTC_GetTime_0: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40002800
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable26  ;; 0x7f7f7f
   \   00000026   0x4008             ANDS     R0,R1,R0
   \   00000028   0x0006             MOVS     R6,R0
    761            
    762            /* Fill the structure fields with the read parameters */
    763            RTC_TimeStruct->RTC_Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
   \   0000002A   0x0C30             LSRS     R0,R6,#+16
   \   0000002C   0xF010 0x003F      ANDS     R0,R0,#0x3F
   \   00000030   0x7028             STRB     R0,[R5, #+0]
    764            RTC_TimeStruct->RTC_Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
   \   00000032   0x0A30             LSRS     R0,R6,#+8
   \   00000034   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   00000038   0x7068             STRB     R0,[R5, #+1]
    765            RTC_TimeStruct->RTC_Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
   \   0000003A   0xF016 0x007F      ANDS     R0,R6,#0x7F
   \   0000003E   0x70A8             STRB     R0,[R5, #+2]
    766            RTC_TimeStruct->RTC_H12 = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);  
   \   00000040   0x0C30             LSRS     R0,R6,#+16
   \   00000042   0xF010 0x0040      ANDS     R0,R0,#0x40
   \   00000046   0x70E8             STRB     R0,[R5, #+3]
    767          
    768            /* Check the input parameters format */
    769            if (RTC_Format == RTC_Format_BIN)
   \   00000048   0x2C00             CMP      R4,#+0
   \   0000004A   0xD10B             BNE.N    ??RTC_GetTime_1
    770            {
    771              /* Convert the structure parameters to Binary format */
    772              RTC_TimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
   \   0000004C   0x7828             LDRB     R0,[R5, #+0]
   \   0000004E   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   00000052   0x7028             STRB     R0,[R5, #+0]
    773              RTC_TimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes);
   \   00000054   0x7868             LDRB     R0,[R5, #+1]
   \   00000056   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   0000005A   0x7068             STRB     R0,[R5, #+1]
    774              RTC_TimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds);   
   \   0000005C   0x78A8             LDRB     R0,[R5, #+2]
   \   0000005E   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   00000062   0x70A8             STRB     R0,[R5, #+2]
    775            }
    776          }
   \                     ??RTC_GetTime_1: (+1)
   \   00000064   0xBD70             POP      {R4-R6,PC}       ;; return
    777          
    778          /**
    779            * @brief  Set the RTC current date.
    780            * @param  RTC_Format: specifies the format of the entered parameters.
    781            *   This parameter can be  one of the following values:
    782            *     @arg RTC_Format_BIN:  Binary data format 
    783            *     @arg RTC_Format_BCD:  BCD data format
    784            * @param  RTC_DateStruct: pointer to a RTC_DateTypeDef structure that contains 
    785            *                         the date configuration information for the RTC.
    786            * @retval An ErrorStatus enumeration value:
    787            *          - SUCCESS: RTC Date register is configured
    788            *          - ERROR: RTC Date register is not configured
    789            */

   \                                 In section .text, align 2, keep-with-next
    790          ErrorStatus RTC_SetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
    791          {
   \                     RTC_SetDate: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    792            uint32_t tmpreg = 0;
   \   00000008   0x2600             MOVS     R6,#+0
    793            ErrorStatus status = ERROR;
   \   0000000A   0x2700             MOVS     R7,#+0
    794            
    795            /* Check the parameters */
    796            assert_param(IS_RTC_FORMAT(RTC_Format));
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD007             BEQ.N    ??RTC_SetDate_0
   \   00000010   0x2C01             CMP      R4,#+1
   \   00000012   0xD005             BEQ.N    ??RTC_SetDate_0
   \   00000014   0xF44F 0x7147      MOV      R1,#+796
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   0000001C   0x.... 0x....      BL       assert_failed
    797          
    798            if ((RTC_Format == RTC_Format_BIN) && ((RTC_DateStruct->RTC_Month & 0x10) == 0x10))
   \                     ??RTC_SetDate_0: (+1)
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD107             BNE.N    ??RTC_SetDate_1
   \   00000024   0x7928             LDRB     R0,[R5, #+4]
   \   00000026   0x06C0             LSLS     R0,R0,#+27
   \   00000028   0xD504             BPL.N    ??RTC_SetDate_1
    799            {
    800              RTC_DateStruct->RTC_Month = (RTC_DateStruct->RTC_Month & (uint32_t)~(0x10)) + 0x0A;
   \   0000002A   0x6868             LDR      R0,[R5, #+4]
   \   0000002C   0xF030 0x0010      BICS     R0,R0,#0x10
   \   00000030   0x300A             ADDS     R0,R0,#+10
   \   00000032   0x6068             STR      R0,[R5, #+4]
    801            }  
    802            if (RTC_Format == RTC_Format_BIN)
   \                     ??RTC_SetDate_1: (+1)
   \   00000034   0x2C00             CMP      R4,#+0
   \   00000036   0xD121             BNE.N    ??RTC_SetDate_2
    803            {
    804              assert_param(IS_RTC_YEAR(RTC_DateStruct->RTC_Year));
   \   00000038   0x7A68             LDRB     R0,[R5, #+9]
   \   0000003A   0x2864             CMP      R0,#+100
   \   0000003C   0xDB05             BLT.N    ??RTC_SetDate_3
   \   0000003E   0xF44F 0x7149      MOV      R1,#+804
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000046   0x.... 0x....      BL       assert_failed
    805              assert_param(IS_RTC_MONTH(RTC_DateStruct->RTC_Month));
   \                     ??RTC_SetDate_3: (+1)
   \   0000004A   0x6868             LDR      R0,[R5, #+4]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD002             BEQ.N    ??RTC_SetDate_4
   \   00000050   0x6868             LDR      R0,[R5, #+4]
   \   00000052   0x280D             CMP      R0,#+13
   \   00000054   0xD305             BCC.N    ??RTC_SetDate_5
   \                     ??RTC_SetDate_4: (+1)
   \   00000056   0xF240 0x3125      MOVW     R1,#+805
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   0000005E   0x.... 0x....      BL       assert_failed
    806              assert_param(IS_RTC_DATE(RTC_DateStruct->RTC_Date));
   \                     ??RTC_SetDate_5: (+1)
   \   00000062   0x7A28             LDRB     R0,[R5, #+8]
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD002             BEQ.N    ??RTC_SetDate_6
   \   00000068   0x7A28             LDRB     R0,[R5, #+8]
   \   0000006A   0x2820             CMP      R0,#+32
   \   0000006C   0xDB2E             BLT.N    ??RTC_SetDate_7
   \                     ??RTC_SetDate_6: (+1)
   \   0000006E   0xF240 0x3126      MOVW     R1,#+806
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000076   0x.... 0x....      BL       assert_failed
   \   0000007A   0xE027             B.N      ??RTC_SetDate_7
    807            }
    808            else
    809            {
    810              assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year)));
   \                     ??RTC_SetDate_2: (+1)
   \   0000007C   0x7A68             LDRB     R0,[R5, #+9]
   \   0000007E   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   00000082   0x2864             CMP      R0,#+100
   \   00000084   0xDB05             BLT.N    ??RTC_SetDate_8
   \   00000086   0xF240 0x312A      MOVW     R1,#+810
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   0000008E   0x.... 0x....      BL       assert_failed
    811              tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
   \                     ??RTC_SetDate_8: (+1)
   \   00000092   0x6868             LDR      R0,[R5, #+4]
   \   00000094   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000096   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   0000009A   0x0006             MOVS     R6,R0
    812              assert_param(IS_RTC_MONTH(tmpreg));
   \   0000009C   0x2E00             CMP      R6,#+0
   \   0000009E   0xD001             BEQ.N    ??RTC_SetDate_9
   \   000000A0   0x2E0D             CMP      R6,#+13
   \   000000A2   0xD305             BCC.N    ??RTC_SetDate_10
   \                     ??RTC_SetDate_9: (+1)
   \   000000A4   0xF44F 0x714B      MOV      R1,#+812
   \   000000A8   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   000000AC   0x.... 0x....      BL       assert_failed
    813              tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
   \                     ??RTC_SetDate_10: (+1)
   \   000000B0   0x7A28             LDRB     R0,[R5, #+8]
   \   000000B2   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   000000B6   0x0006             MOVS     R6,R0
    814              assert_param(IS_RTC_DATE(tmpreg));
   \   000000B8   0x2E00             CMP      R6,#+0
   \   000000BA   0xD001             BEQ.N    ??RTC_SetDate_11
   \   000000BC   0x2E20             CMP      R6,#+32
   \   000000BE   0xD305             BCC.N    ??RTC_SetDate_7
   \                     ??RTC_SetDate_11: (+1)
   \   000000C0   0xF240 0x312E      MOVW     R1,#+814
   \   000000C4   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   000000C8   0x.... 0x....      BL       assert_failed
    815            }
    816            assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));
   \                     ??RTC_SetDate_7: (+1)
   \   000000CC   0x6828             LDR      R0,[R5, #+0]
   \   000000CE   0x2801             CMP      R0,#+1
   \   000000D0   0xD017             BEQ.N    ??RTC_SetDate_12
   \   000000D2   0x6828             LDR      R0,[R5, #+0]
   \   000000D4   0x2802             CMP      R0,#+2
   \   000000D6   0xD014             BEQ.N    ??RTC_SetDate_12
   \   000000D8   0x6828             LDR      R0,[R5, #+0]
   \   000000DA   0x2803             CMP      R0,#+3
   \   000000DC   0xD011             BEQ.N    ??RTC_SetDate_12
   \   000000DE   0x6828             LDR      R0,[R5, #+0]
   \   000000E0   0x2804             CMP      R0,#+4
   \   000000E2   0xD00E             BEQ.N    ??RTC_SetDate_12
   \   000000E4   0x6828             LDR      R0,[R5, #+0]
   \   000000E6   0x2805             CMP      R0,#+5
   \   000000E8   0xD00B             BEQ.N    ??RTC_SetDate_12
   \   000000EA   0x6828             LDR      R0,[R5, #+0]
   \   000000EC   0x2806             CMP      R0,#+6
   \   000000EE   0xD008             BEQ.N    ??RTC_SetDate_12
   \   000000F0   0x6828             LDR      R0,[R5, #+0]
   \   000000F2   0x2807             CMP      R0,#+7
   \   000000F4   0xD005             BEQ.N    ??RTC_SetDate_12
   \   000000F6   0xF44F 0x714C      MOV      R1,#+816
   \   000000FA   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   000000FE   0x.... 0x....      BL       assert_failed
    817          
    818            /* Check the input parameters format */
    819            if (RTC_Format != RTC_Format_BIN)
   \                     ??RTC_SetDate_12: (+1)
   \   00000102   0x2C00             CMP      R4,#+0
   \   00000104   0xD00B             BEQ.N    ??RTC_SetDate_13
    820            {
    821              tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
    822                        (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
    823                        ((uint32_t)RTC_DateStruct->RTC_Date) | \
    824                        (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
   \   00000106   0x7A68             LDRB     R0,[R5, #+9]
   \   00000108   0x6869             LDR      R1,[R5, #+4]
   \   0000010A   0x0209             LSLS     R1,R1,#+8
   \   0000010C   0xEA51 0x4000      ORRS     R0,R1,R0, LSL #+16
   \   00000110   0x7A29             LDRB     R1,[R5, #+8]
   \   00000112   0x4308             ORRS     R0,R1,R0
   \   00000114   0x6829             LDR      R1,[R5, #+0]
   \   00000116   0xEA50 0x3041      ORRS     R0,R0,R1, LSL #+13
   \   0000011A   0x0006             MOVS     R6,R0
   \   0000011C   0xE019             B.N      ??RTC_SetDate_14
    825            }  
    826            else
    827            {
    828              tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
    829                        ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
    830                        ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
    831                        ((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
   \                     ??RTC_SetDate_13: (+1)
   \   0000011E   0x7A68             LDRB     R0,[R5, #+9]
   \   00000120   0x.... 0x....      BL       RTC_ByteToBcd2
   \   00000124   0x4680             MOV      R8,R0
   \   00000126   0x6868             LDR      R0,[R5, #+4]
   \   00000128   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000012A   0x.... 0x....      BL       RTC_ByteToBcd2
   \   0000012E   0x4681             MOV      R9,R0
   \   00000130   0x7A28             LDRB     R0,[R5, #+8]
   \   00000132   0x.... 0x....      BL       RTC_ByteToBcd2
   \   00000136   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000013A   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000013E   0xEA5F 0x2109      LSLS     R1,R9,#+8
   \   00000142   0xEA51 0x4108      ORRS     R1,R1,R8, LSL #+16
   \   00000146   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000148   0x4308             ORRS     R0,R0,R1
   \   0000014A   0x6829             LDR      R1,[R5, #+0]
   \   0000014C   0xEA50 0x3041      ORRS     R0,R0,R1, LSL #+13
   \   00000150   0x0006             MOVS     R6,R0
    832            }
    833          
    834            /* Disable the write protection for RTC registers */
    835            RTC->WPR = 0xCA;
   \                     ??RTC_SetDate_14: (+1)
   \   00000152   0x20CA             MOVS     R0,#+202
   \   00000154   0x.... 0x....      LDR.W    R1,??DataTable21_1  ;; 0x40002824
   \   00000158   0x6008             STR      R0,[R1, #+0]
    836            RTC->WPR = 0x53;
   \   0000015A   0x2053             MOVS     R0,#+83
   \   0000015C   0x.... 0x....      LDR.W    R1,??DataTable21_1  ;; 0x40002824
   \   00000160   0x6008             STR      R0,[R1, #+0]
    837          
    838            /* Set Initialization mode */
    839            if (RTC_EnterInitMode() == ERROR)
   \   00000162   0x.... 0x....      BL       RTC_EnterInitMode
   \   00000166   0x2800             CMP      R0,#+0
   \   00000168   0xD102             BNE.N    ??RTC_SetDate_15
    840            {
    841              status = ERROR;
   \   0000016A   0x2000             MOVS     R0,#+0
   \   0000016C   0x0007             MOVS     R7,R0
   \   0000016E   0xE010             B.N      ??RTC_SetDate_16
    842            } 
    843            else
    844            {
    845              /* Set the RTC_DR register */
    846              RTC->DR = (uint32_t)(tmpreg & RTC_DR_RESERVED_MASK);
   \                     ??RTC_SetDate_15: (+1)
   \   00000170   0x.... 0x....      LDR.W    R0,??DataTable30  ;; 0xffff3f
   \   00000174   0x4030             ANDS     R0,R0,R6
   \   00000176   0x.... 0x....      LDR.W    R1,??DataTable16_1  ;; 0x40002804
   \   0000017A   0x6008             STR      R0,[R1, #+0]
    847          
    848              /* Exit Initialization mode */
    849              RTC_ExitInitMode(); 
   \   0000017C   0x.... 0x....      BL       RTC_ExitInitMode
    850          
    851              if(RTC_WaitForSynchro() == ERROR)
   \   00000180   0x.... 0x....      BL       RTC_WaitForSynchro
   \   00000184   0x2800             CMP      R0,#+0
   \   00000186   0xD102             BNE.N    ??RTC_SetDate_17
    852              {
    853                status = ERROR;
   \   00000188   0x2000             MOVS     R0,#+0
   \   0000018A   0x0007             MOVS     R7,R0
   \   0000018C   0xE001             B.N      ??RTC_SetDate_16
    854              }
    855              else
    856              {
    857                status = SUCCESS;
   \                     ??RTC_SetDate_17: (+1)
   \   0000018E   0x2001             MOVS     R0,#+1
   \   00000190   0x0007             MOVS     R7,R0
    858              }
    859            }
    860            /* Enable the write protection for RTC registers */
    861            RTC->WPR = 0xFF;   
   \                     ??RTC_SetDate_16: (+1)
   \   00000192   0x20FF             MOVS     R0,#+255
   \   00000194   0x.... 0x....      LDR.W    R1,??DataTable21_1  ;; 0x40002824
   \   00000198   0x6008             STR      R0,[R1, #+0]
    862            
    863            return status;
   \   0000019A   0x0038             MOVS     R0,R7
   \   0000019C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000019E   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    864          }
    865          
    866          /**
    867            * @brief  Fills each RTC_DateStruct member with its default value
    868            *         (Monday, January 01 xx00).
    869            * @param  RTC_DateStruct: pointer to a RTC_DateTypeDef structure which will be 
    870            *         initialized.
    871            * @retval None
    872            */

   \                                 In section .text, align 2, keep-with-next
    873          void RTC_DateStructInit(RTC_DateTypeDef* RTC_DateStruct)
    874          {
    875            /* Monday, January 01 xx00 */
    876            RTC_DateStruct->RTC_WeekDay = RTC_Weekday_Monday;
   \                     RTC_DateStructInit: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x6001             STR      R1,[R0, #+0]
    877            RTC_DateStruct->RTC_Date = 1;
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x7201             STRB     R1,[R0, #+8]
    878            RTC_DateStruct->RTC_Month = RTC_Month_January;
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0x6041             STR      R1,[R0, #+4]
    879            RTC_DateStruct->RTC_Year = 0;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x7241             STRB     R1,[R0, #+9]
    880          }
   \   00000010   0x4770             BX       LR               ;; return
    881          
    882          /**
    883            * @brief  Get the RTC current date. 
    884            * @param  RTC_Format: specifies the format of the returned parameters.
    885            *   This parameter can be one of the following values:
    886            *     @arg RTC_Format_BIN: Binary data format 
    887            *     @arg RTC_Format_BCD: BCD data format
    888            * @param RTC_DateStruct: pointer to a RTC_DateTypeDef structure that will 
    889            *                        contain the returned current date configuration.     
    890            * @retval None
    891            */

   \                                 In section .text, align 2, keep-with-next
    892          void RTC_GetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
    893          {
   \                     RTC_GetDate: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    894            uint32_t tmpreg = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    895          
    896            /* Check the parameters */
    897            assert_param(IS_RTC_FORMAT(RTC_Format));
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD007             BEQ.N    ??RTC_GetDate_0
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD005             BEQ.N    ??RTC_GetDate_0
   \   00000010   0xF240 0x3181      MOVW     R1,#+897
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000018   0x.... 0x....      BL       assert_failed
    898            
    899            /* Get the RTC_TR register */
    900            tmpreg = (uint32_t)(RTC->DR & RTC_DR_RESERVED_MASK); 
   \                     ??RTC_GetDate_0: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x40002804
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable30  ;; 0xffff3f
   \   00000026   0x4008             ANDS     R0,R1,R0
   \   00000028   0x0006             MOVS     R6,R0
    901          
    902            /* Fill the structure fields with the read parameters */
    903            RTC_DateStruct->RTC_Year = (uint8_t)((tmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
   \   0000002A   0x0C30             LSRS     R0,R6,#+16
   \   0000002C   0x7268             STRB     R0,[R5, #+9]
    904            RTC_DateStruct->RTC_Month = (uint8_t)((tmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
   \   0000002E   0x0A30             LSRS     R0,R6,#+8
   \   00000030   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   00000034   0x6068             STR      R0,[R5, #+4]
    905            RTC_DateStruct->RTC_Date = (uint8_t)(tmpreg & (RTC_DR_DT | RTC_DR_DU));
   \   00000036   0xF016 0x003F      ANDS     R0,R6,#0x3F
   \   0000003A   0x7228             STRB     R0,[R5, #+8]
    906            RTC_DateStruct->RTC_WeekDay = (uint8_t)((tmpreg & (RTC_DR_WDU)) >> 13);  
   \   0000003C   0x0B70             LSRS     R0,R6,#+13
   \   0000003E   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000042   0x6028             STR      R0,[R5, #+0]
    907          
    908            /* Check the input parameters format */
    909            if (RTC_Format == RTC_Format_BIN)
   \   00000044   0x2C00             CMP      R4,#+0
   \   00000046   0xD10E             BNE.N    ??RTC_GetDate_1
    910            {
    911              /* Convert the structure parameters to Binary format */
    912              RTC_DateStruct->RTC_Year = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year);
   \   00000048   0x7A68             LDRB     R0,[R5, #+9]
   \   0000004A   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   0000004E   0x7268             STRB     R0,[R5, #+9]
    913              RTC_DateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
   \   00000050   0x6868             LDR      R0,[R5, #+4]
   \   00000052   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000054   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   00000058   0x6068             STR      R0,[R5, #+4]
    914              RTC_DateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
   \   0000005A   0x7A28             LDRB     R0,[R5, #+8]
   \   0000005C   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   00000060   0x7228             STRB     R0,[R5, #+8]
    915              RTC_DateStruct->RTC_WeekDay = (uint8_t)(RTC_DateStruct->RTC_WeekDay);   
   \   00000062   0x7828             LDRB     R0,[R5, #+0]
   \   00000064   0x6028             STR      R0,[R5, #+0]
    916            }
    917          }
   \                     ??RTC_GetDate_1: (+1)
   \   00000066   0xBD70             POP      {R4-R6,PC}       ;; return
    918          
    919          /**
    920            * @}
    921            */
    922          
    923          /** @defgroup RTC_Group3 Alarms configuration functions
    924           *  @brief   Alarms (Alarm A and Alarm B) configuration functions 
    925           *
    926          @verbatim   
    927           ===============================================================================
    928                        Alarms (Alarm A and Alarm B) configuration functions
    929           ===============================================================================  
    930          
    931            This section provide functions allowing to program and read the RTC Alarms.
    932          
    933          @endverbatim
    934            * @{
    935            */
    936          
    937          /**
    938            * @brief  Set the specified RTC Alarm.
    939            * @note   The Alarm register can only be written when the corresponding Alarm
    940            *         is disabled (Use the RTC_AlarmCmd(DISABLE)).    
    941            * @param  RTC_Format: specifies the format of the returned parameters.
    942            *   This parameter can be one of the following values:
    943            *     @arg RTC_Format_BIN: Binary data format 
    944            *     @arg RTC_Format_BCD: BCD data format
    945            * @param  RTC_Alarm: specifies the alarm to be configured.
    946            *   This parameter can be one of the following values:
    947            *     @arg RTC_Alarm_A: to select Alarm A
    948            *     @arg RTC_Alarm_B: to select Alarm B  
    949            * @param  RTC_AlarmStruct: pointer to a RTC_AlarmTypeDef structure that 
    950            *                          contains the alarm configuration parameters.     
    951            * @retval None
    952            */

   \                                 In section .text, align 2, keep-with-next
    953          void RTC_SetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
    954          {
   \                     RTC_SetAlarm: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    955            uint32_t tmpreg = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
    956            
    957            /* Check the parameters */
    958            assert_param(IS_RTC_FORMAT(RTC_Format));
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD007             BEQ.N    ??RTC_SetAlarm_0
   \   00000010   0x2C01             CMP      R4,#+1
   \   00000012   0xD005             BEQ.N    ??RTC_SetAlarm_0
   \   00000014   0xF240 0x31BE      MOVW     R1,#+958
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   0000001C   0x.... 0x....      BL       assert_failed
    959            assert_param(IS_RTC_ALARM(RTC_Alarm));
   \                     ??RTC_SetAlarm_0: (+1)
   \   00000020   0xF5B5 0x7F80      CMP      R5,#+256
   \   00000024   0xD008             BEQ.N    ??RTC_SetAlarm_1
   \   00000026   0xF5B5 0x7F00      CMP      R5,#+512
   \   0000002A   0xD005             BEQ.N    ??RTC_SetAlarm_1
   \   0000002C   0xF240 0x31BF      MOVW     R1,#+959
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000034   0x.... 0x....      BL       assert_failed
    960            assert_param(IS_ALARM_MASK(RTC_AlarmStruct->RTC_AlarmMask));
   \                     ??RTC_SetAlarm_1: (+1)
   \   00000038   0x6870             LDR      R0,[R6, #+4]
   \   0000003A   0xF010 0x3F7F      TST      R0,#0x7F7F7F7F
   \   0000003E   0xD005             BEQ.N    ??RTC_SetAlarm_2
   \   00000040   0xF44F 0x7170      MOV      R1,#+960
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000048   0x.... 0x....      BL       assert_failed
    961            assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel));
   \                     ??RTC_SetAlarm_2: (+1)
   \   0000004C   0x68B0             LDR      R0,[R6, #+8]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD009             BEQ.N    ??RTC_SetAlarm_3
   \   00000052   0x68B0             LDR      R0,[R6, #+8]
   \   00000054   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \   00000058   0xD005             BEQ.N    ??RTC_SetAlarm_3
   \   0000005A   0xF240 0x31C1      MOVW     R1,#+961
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000062   0x.... 0x....      BL       assert_failed
    962          
    963            if (RTC_Format == RTC_Format_BIN)
   \                     ??RTC_SetAlarm_3: (+1)
   \   00000066   0x2C00             CMP      R4,#+0
   \   00000068   0xD16A             BNE.N    ??RTC_SetAlarm_4
    964            {
    965              if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable16_2  ;; 0x40002808
   \   0000006E   0x6800             LDR      R0,[R0, #+0]
   \   00000070   0x0640             LSLS     R0,R0,#+25
   \   00000072   0xD518             BPL.N    ??RTC_SetAlarm_5
    966              {
    967                assert_param(IS_RTC_HOUR12(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
   \   00000074   0x7830             LDRB     R0,[R6, #+0]
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD002             BEQ.N    ??RTC_SetAlarm_6
   \   0000007A   0x7830             LDRB     R0,[R6, #+0]
   \   0000007C   0x280D             CMP      R0,#+13
   \   0000007E   0xDB05             BLT.N    ??RTC_SetAlarm_7
   \                     ??RTC_SetAlarm_6: (+1)
   \   00000080   0xF240 0x31C7      MOVW     R1,#+967
   \   00000084   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000088   0x.... 0x....      BL       assert_failed
    968                assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
   \                     ??RTC_SetAlarm_7: (+1)
   \   0000008C   0x78F0             LDRB     R0,[R6, #+3]
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD014             BEQ.N    ??RTC_SetAlarm_8
   \   00000092   0x78F0             LDRB     R0,[R6, #+3]
   \   00000094   0x2840             CMP      R0,#+64
   \   00000096   0xD011             BEQ.N    ??RTC_SetAlarm_8
   \   00000098   0xF44F 0x7172      MOV      R1,#+968
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   000000A0   0x.... 0x....      BL       assert_failed
   \   000000A4   0xE00A             B.N      ??RTC_SetAlarm_8
    969              } 
    970              else
    971              {
    972                RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
   \                     ??RTC_SetAlarm_5: (+1)
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0x70F0             STRB     R0,[R6, #+3]
    973                assert_param(IS_RTC_HOUR24(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
   \   000000AA   0x7830             LDRB     R0,[R6, #+0]
   \   000000AC   0x2818             CMP      R0,#+24
   \   000000AE   0xDB05             BLT.N    ??RTC_SetAlarm_8
   \   000000B0   0xF240 0x31CD      MOVW     R1,#+973
   \   000000B4   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   000000B8   0x.... 0x....      BL       assert_failed
    974              }
    975              assert_param(IS_RTC_MINUTES(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes));
   \                     ??RTC_SetAlarm_8: (+1)
   \   000000BC   0x7870             LDRB     R0,[R6, #+1]
   \   000000BE   0x283C             CMP      R0,#+60
   \   000000C0   0xDB05             BLT.N    ??RTC_SetAlarm_9
   \   000000C2   0xF240 0x31CF      MOVW     R1,#+975
   \   000000C6   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   000000CA   0x.... 0x....      BL       assert_failed
    976              assert_param(IS_RTC_SECONDS(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds));
   \                     ??RTC_SetAlarm_9: (+1)
   \   000000CE   0x78B0             LDRB     R0,[R6, #+2]
   \   000000D0   0x283C             CMP      R0,#+60
   \   000000D2   0xDB05             BLT.N    ??RTC_SetAlarm_10
   \   000000D4   0xF44F 0x7174      MOV      R1,#+976
   \   000000D8   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   000000DC   0x.... 0x....      BL       assert_failed
    977              
    978              if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
   \                     ??RTC_SetAlarm_10: (+1)
   \   000000E0   0x68B0             LDR      R0,[R6, #+8]
   \   000000E2   0x2800             CMP      R0,#+0
   \   000000E4   0xD10D             BNE.N    ??RTC_SetAlarm_11
    979              {
    980                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
   \   000000E6   0x7B30             LDRB     R0,[R6, #+12]
   \   000000E8   0x2800             CMP      R0,#+0
   \   000000EA   0xD003             BEQ.N    ??RTC_SetAlarm_12
   \   000000EC   0x7B30             LDRB     R0,[R6, #+12]
   \   000000EE   0x2820             CMP      R0,#+32
   \   000000F0   0xF2C0 0x8092      BLT.W    ??RTC_SetAlarm_13
   \                     ??RTC_SetAlarm_12: (+1)
   \   000000F4   0xF44F 0x7175      MOV      R1,#+980
   \   000000F8   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   000000FC   0x.... 0x....      BL       assert_failed
   \   00000100   0xE08A             B.N      ??RTC_SetAlarm_13
    981              }
    982              else
    983              {
    984                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
   \                     ??RTC_SetAlarm_11: (+1)
   \   00000102   0x7B30             LDRB     R0,[R6, #+12]
   \   00000104   0x2801             CMP      R0,#+1
   \   00000106   0xF000 0x8087      BEQ.W    ??RTC_SetAlarm_13
   \   0000010A   0x7B30             LDRB     R0,[R6, #+12]
   \   0000010C   0x2802             CMP      R0,#+2
   \   0000010E   0xF000 0x8083      BEQ.W    ??RTC_SetAlarm_13
   \   00000112   0x7B30             LDRB     R0,[R6, #+12]
   \   00000114   0x2803             CMP      R0,#+3
   \   00000116   0xF000 0x807F      BEQ.W    ??RTC_SetAlarm_13
   \   0000011A   0x7B30             LDRB     R0,[R6, #+12]
   \   0000011C   0x2804             CMP      R0,#+4
   \   0000011E   0xD07B             BEQ.N    ??RTC_SetAlarm_13
   \   00000120   0x7B30             LDRB     R0,[R6, #+12]
   \   00000122   0x2805             CMP      R0,#+5
   \   00000124   0xD078             BEQ.N    ??RTC_SetAlarm_13
   \   00000126   0x7B30             LDRB     R0,[R6, #+12]
   \   00000128   0x2806             CMP      R0,#+6
   \   0000012A   0xD075             BEQ.N    ??RTC_SetAlarm_13
   \   0000012C   0x7B30             LDRB     R0,[R6, #+12]
   \   0000012E   0x2807             CMP      R0,#+7
   \   00000130   0xD072             BEQ.N    ??RTC_SetAlarm_13
   \   00000132   0xF44F 0x7176      MOV      R1,#+984
   \   00000136   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   0000013A   0x.... 0x....      BL       assert_failed
   \   0000013E   0xE06B             B.N      ??RTC_SetAlarm_13
    985              }
    986            }
    987            else
    988            {
    989              if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
   \                     ??RTC_SetAlarm_4: (+1)
   \   00000140   0x.... 0x....      LDR.W    R0,??DataTable16_2  ;; 0x40002808
   \   00000144   0x6800             LDR      R0,[R0, #+0]
   \   00000146   0x0640             LSLS     R0,R0,#+25
   \   00000148   0xD51A             BPL.N    ??RTC_SetAlarm_14
    990              {
    991                tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours);
   \   0000014A   0x7830             LDRB     R0,[R6, #+0]
   \   0000014C   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   00000150   0x0007             MOVS     R7,R0
    992                assert_param(IS_RTC_HOUR12(tmpreg));
   \   00000152   0x2F00             CMP      R7,#+0
   \   00000154   0xD001             BEQ.N    ??RTC_SetAlarm_15
   \   00000156   0x2F0D             CMP      R7,#+13
   \   00000158   0xD305             BCC.N    ??RTC_SetAlarm_16
   \                     ??RTC_SetAlarm_15: (+1)
   \   0000015A   0xF44F 0x7178      MOV      R1,#+992
   \   0000015E   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000162   0x.... 0x....      BL       assert_failed
    993                assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
   \                     ??RTC_SetAlarm_16: (+1)
   \   00000166   0x78F0             LDRB     R0,[R6, #+3]
   \   00000168   0x2800             CMP      R0,#+0
   \   0000016A   0xD016             BEQ.N    ??RTC_SetAlarm_17
   \   0000016C   0x78F0             LDRB     R0,[R6, #+3]
   \   0000016E   0x2840             CMP      R0,#+64
   \   00000170   0xD013             BEQ.N    ??RTC_SetAlarm_17
   \   00000172   0xF240 0x31E1      MOVW     R1,#+993
   \   00000176   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   0000017A   0x.... 0x....      BL       assert_failed
   \   0000017E   0xE00C             B.N      ??RTC_SetAlarm_17
    994              } 
    995              else
    996              {
    997                RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
   \                     ??RTC_SetAlarm_14: (+1)
   \   00000180   0x2000             MOVS     R0,#+0
   \   00000182   0x70F0             STRB     R0,[R6, #+3]
    998                assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours)));
   \   00000184   0x7830             LDRB     R0,[R6, #+0]
   \   00000186   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   0000018A   0x2818             CMP      R0,#+24
   \   0000018C   0xDB05             BLT.N    ??RTC_SetAlarm_17
   \   0000018E   0xF240 0x31E6      MOVW     R1,#+998
   \   00000192   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000196   0x.... 0x....      BL       assert_failed
    999              }
   1000              
   1001              assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes)));
   \                     ??RTC_SetAlarm_17: (+1)
   \   0000019A   0x7870             LDRB     R0,[R6, #+1]
   \   0000019C   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   000001A0   0x283C             CMP      R0,#+60
   \   000001A2   0xDB05             BLT.N    ??RTC_SetAlarm_18
   \   000001A4   0xF240 0x31E9      MOVW     R1,#+1001
   \   000001A8   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   000001AC   0x.... 0x....      BL       assert_failed
   1002              assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)));
   \                     ??RTC_SetAlarm_18: (+1)
   \   000001B0   0x78B0             LDRB     R0,[R6, #+2]
   \   000001B2   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   000001B6   0x283C             CMP      R0,#+60
   \   000001B8   0xDB05             BLT.N    ??RTC_SetAlarm_19
   \   000001BA   0xF240 0x31EA      MOVW     R1,#+1002
   \   000001BE   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   000001C2   0x.... 0x....      BL       assert_failed
   1003              
   1004              if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
   \                     ??RTC_SetAlarm_19: (+1)
   \   000001C6   0x68B0             LDR      R0,[R6, #+8]
   \   000001C8   0x2800             CMP      R0,#+0
   \   000001CA   0xD10E             BNE.N    ??RTC_SetAlarm_20
   1005              {
   1006                tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
   \   000001CC   0x7B30             LDRB     R0,[R6, #+12]
   \   000001CE   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   000001D2   0x0007             MOVS     R7,R0
   1007                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(tmpreg));    
   \   000001D4   0x2F00             CMP      R7,#+0
   \   000001D6   0xD001             BEQ.N    ??RTC_SetAlarm_21
   \   000001D8   0x2F20             CMP      R7,#+32
   \   000001DA   0xD31D             BCC.N    ??RTC_SetAlarm_13
   \                     ??RTC_SetAlarm_21: (+1)
   \   000001DC   0xF240 0x31EF      MOVW     R1,#+1007
   \   000001E0   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   000001E4   0x.... 0x....      BL       assert_failed
   \   000001E8   0xE016             B.N      ??RTC_SetAlarm_13
   1008              }
   1009              else
   1010              {
   1011                tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
   \                     ??RTC_SetAlarm_20: (+1)
   \   000001EA   0x7B30             LDRB     R0,[R6, #+12]
   \   000001EC   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   000001F0   0x0007             MOVS     R7,R0
   1012                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(tmpreg));      
   \   000001F2   0x2F01             CMP      R7,#+1
   \   000001F4   0xD010             BEQ.N    ??RTC_SetAlarm_13
   \   000001F6   0x2F02             CMP      R7,#+2
   \   000001F8   0xD00E             BEQ.N    ??RTC_SetAlarm_13
   \   000001FA   0x2F03             CMP      R7,#+3
   \   000001FC   0xD00C             BEQ.N    ??RTC_SetAlarm_13
   \   000001FE   0x2F04             CMP      R7,#+4
   \   00000200   0xD00A             BEQ.N    ??RTC_SetAlarm_13
   \   00000202   0x2F05             CMP      R7,#+5
   \   00000204   0xD008             BEQ.N    ??RTC_SetAlarm_13
   \   00000206   0x2F06             CMP      R7,#+6
   \   00000208   0xD006             BEQ.N    ??RTC_SetAlarm_13
   \   0000020A   0x2F07             CMP      R7,#+7
   \   0000020C   0xD004             BEQ.N    ??RTC_SetAlarm_13
   \   0000020E   0xF44F 0x717D      MOV      R1,#+1012
   \   00000212   0x....             LDR.N    R0,??DataTable17_1
   \   00000214   0x.... 0x....      BL       assert_failed
   1013              }    
   1014            }
   1015          
   1016            /* Check the input parameters format */
   1017            if (RTC_Format != RTC_Format_BIN)
   \                     ??RTC_SetAlarm_13: (+1)
   \   00000218   0x2C00             CMP      R4,#+0
   \   0000021A   0xD012             BEQ.N    ??RTC_SetAlarm_22
   1018            {
   1019              tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
   1020                        ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
   1021                        ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
   1022                        ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
   1023                        ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
   1024                        ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
   1025                        ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
   \   0000021C   0x7830             LDRB     R0,[R6, #+0]
   \   0000021E   0x7871             LDRB     R1,[R6, #+1]
   \   00000220   0x0209             LSLS     R1,R1,#+8
   \   00000222   0xEA51 0x4000      ORRS     R0,R1,R0, LSL #+16
   \   00000226   0x78B1             LDRB     R1,[R6, #+2]
   \   00000228   0x4308             ORRS     R0,R1,R0
   \   0000022A   0x78F1             LDRB     R1,[R6, #+3]
   \   0000022C   0xEA50 0x4001      ORRS     R0,R0,R1, LSL #+16
   \   00000230   0x7B31             LDRB     R1,[R6, #+12]
   \   00000232   0xEA50 0x6001      ORRS     R0,R0,R1, LSL #+24
   \   00000236   0x68B1             LDR      R1,[R6, #+8]
   \   00000238   0x4308             ORRS     R0,R1,R0
   \   0000023A   0x6871             LDR      R1,[R6, #+4]
   \   0000023C   0x4308             ORRS     R0,R1,R0
   \   0000023E   0x0007             MOVS     R7,R0
   \   00000240   0xE025             B.N      ??RTC_SetAlarm_23
   1026            }  
   1027            else
   1028            {
   1029              tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
   1030                        ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
   1031                        ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
   1032                        ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
   1033                        ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
   1034                        ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
   1035                        ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
   \                     ??RTC_SetAlarm_22: (+1)
   \   00000242   0x7830             LDRB     R0,[R6, #+0]
   \   00000244   0x.... 0x....      BL       RTC_ByteToBcd2
   \   00000248   0x4681             MOV      R9,R0
   \   0000024A   0x7870             LDRB     R0,[R6, #+1]
   \   0000024C   0x.... 0x....      BL       RTC_ByteToBcd2
   \   00000250   0x4682             MOV      R10,R0
   \   00000252   0x78B0             LDRB     R0,[R6, #+2]
   \   00000254   0x.... 0x....      BL       RTC_ByteToBcd2
   \   00000258   0x4680             MOV      R8,R0
   \   0000025A   0x7B30             LDRB     R0,[R6, #+12]
   \   0000025C   0x.... 0x....      BL       RTC_ByteToBcd2
   \   00000260   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000264   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000268   0xEA5F 0x210A      LSLS     R1,R10,#+8
   \   0000026C   0xEA51 0x4109      ORRS     R1,R1,R9, LSL #+16
   \   00000270   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000274   0xEA58 0x0101      ORRS     R1,R8,R1
   \   00000278   0x78F2             LDRB     R2,[R6, #+3]
   \   0000027A   0xEA51 0x4102      ORRS     R1,R1,R2, LSL #+16
   \   0000027E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000280   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   00000284   0x68B1             LDR      R1,[R6, #+8]
   \   00000286   0x4308             ORRS     R0,R1,R0
   \   00000288   0x6871             LDR      R1,[R6, #+4]
   \   0000028A   0x4308             ORRS     R0,R1,R0
   \   0000028C   0x0007             MOVS     R7,R0
   1036            } 
   1037          
   1038            /* Disable the write protection for RTC registers */
   1039            RTC->WPR = 0xCA;
   \                     ??RTC_SetAlarm_23: (+1)
   \   0000028E   0x20CA             MOVS     R0,#+202
   \   00000290   0x.... 0x....      LDR.W    R1,??DataTable21_1  ;; 0x40002824
   \   00000294   0x6008             STR      R0,[R1, #+0]
   1040            RTC->WPR = 0x53;
   \   00000296   0x2053             MOVS     R0,#+83
   \   00000298   0x.... 0x....      LDR.W    R1,??DataTable21_1  ;; 0x40002824
   \   0000029C   0x6008             STR      R0,[R1, #+0]
   1041          
   1042            /* Configure the Alarm register */
   1043            if (RTC_Alarm == RTC_Alarm_A)
   \   0000029E   0xF5B5 0x7F80      CMP      R5,#+256
   \   000002A2   0xD102             BNE.N    ??RTC_SetAlarm_24
   1044            {
   1045              RTC->ALRMAR = (uint32_t)tmpreg;
   \   000002A4   0x....             LDR.N    R0,??DataTable16_7  ;; 0x4000281c
   \   000002A6   0x6007             STR      R7,[R0, #+0]
   \   000002A8   0xE001             B.N      ??RTC_SetAlarm_25
   1046            }
   1047            else
   1048            {
   1049              RTC->ALRMBR = (uint32_t)tmpreg;
   \                     ??RTC_SetAlarm_24: (+1)
   \   000002AA   0x....             LDR.N    R0,??DataTable16_8  ;; 0x40002820
   \   000002AC   0x6007             STR      R7,[R0, #+0]
   1050            }
   1051          
   1052            /* Enable the write protection for RTC registers */
   1053            RTC->WPR = 0xFF;   
   \                     ??RTC_SetAlarm_25: (+1)
   \   000002AE   0x20FF             MOVS     R0,#+255
   \   000002B0   0x.... 0x....      LDR.W    R1,??DataTable21_1  ;; 0x40002824
   \   000002B4   0x6008             STR      R0,[R1, #+0]
   1054          }
   \   000002B6   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   1055          
   1056          /**
   1057            * @brief  Fills each RTC_AlarmStruct member with its default value
   1058            *         (Time = 00h:00mn:00sec / Date = 1st day of the month/Mask =
   1059            *         all fields are masked).
   1060            * @param  RTC_AlarmStruct: pointer to a @ref RTC_AlarmTypeDef structure which
   1061            *         will be initialized.
   1062            * @retval None
   1063            */

   \                                 In section .text, align 2, keep-with-next
   1064          void RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct)
   1065          {
   1066            /* Alarm Time Settings : Time = 00h:00mn:00sec */
   1067            RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = RTC_H12_AM;
   \                     RTC_AlarmStructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x70C1             STRB     R1,[R0, #+3]
   1068            RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = 0;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x7001             STRB     R1,[R0, #+0]
   1069            RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = 0;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x7041             STRB     R1,[R0, #+1]
   1070            RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = 0;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x7081             STRB     R1,[R0, #+2]
   1071          
   1072            /* Alarm Date Settings : Date = 1st day of the month */
   1073            RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6081             STR      R1,[R0, #+8]
   1074            RTC_AlarmStruct->RTC_AlarmDateWeekDay = 1;
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x7301             STRB     R1,[R0, #+12]
   1075          
   1076            /* Alarm Masks Settings : Mask =  all fields are not masked */
   1077            RTC_AlarmStruct->RTC_AlarmMask = RTC_AlarmMask_None;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x6041             STR      R1,[R0, #+4]
   1078          }
   \   0000001C   0x4770             BX       LR               ;; return
   1079          
   1080          /**
   1081            * @brief  Get the RTC Alarm value and masks.
   1082            * @param  RTC_Format: specifies the format of the output parameters.
   1083            *   This parameter can be one of the following values:
   1084            *     @arg RTC_Format_BIN: Binary data format 
   1085            *     @arg RTC_Format_BCD: BCD data format
   1086            * @param  RTC_Alarm: specifies the alarm to be read.
   1087            *   This parameter can be one of the following values:
   1088            *     @arg RTC_Alarm_A: to select Alarm A
   1089            *     @arg RTC_Alarm_B: to select Alarm B  
   1090            * @param  RTC_AlarmStruct: pointer to a RTC_AlarmTypeDef structure that will 
   1091            *                          contains the output alarm configuration values.     
   1092            * @retval None
   1093            */

   \                                 In section .text, align 2, keep-with-next
   1094          void RTC_GetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
   1095          {
   \                     RTC_GetAlarm: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1096            uint32_t tmpreg = 0;
   \   00000008   0x2700             MOVS     R7,#+0
   1097          
   1098            /* Check the parameters */
   1099            assert_param(IS_RTC_FORMAT(RTC_Format));
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD006             BEQ.N    ??RTC_GetAlarm_0
   \   0000000E   0x2C01             CMP      R4,#+1
   \   00000010   0xD004             BEQ.N    ??RTC_GetAlarm_0
   \   00000012   0xF240 0x414B      MOVW     R1,#+1099
   \   00000016   0x....             LDR.N    R0,??DataTable17_1
   \   00000018   0x.... 0x....      BL       assert_failed
   1100            assert_param(IS_RTC_ALARM(RTC_Alarm)); 
   \                     ??RTC_GetAlarm_0: (+1)
   \   0000001C   0xF5B5 0x7F80      CMP      R5,#+256
   \   00000020   0xD007             BEQ.N    ??RTC_GetAlarm_1
   \   00000022   0xF5B5 0x7F00      CMP      R5,#+512
   \   00000026   0xD004             BEQ.N    ??RTC_GetAlarm_1
   \   00000028   0xF240 0x414C      MOVW     R1,#+1100
   \   0000002C   0x....             LDR.N    R0,??DataTable17_1
   \   0000002E   0x.... 0x....      BL       assert_failed
   1101          
   1102            /* Get the RTC_ALRMxR register */
   1103            if (RTC_Alarm == RTC_Alarm_A)
   \                     ??RTC_GetAlarm_1: (+1)
   \   00000032   0xF5B5 0x7F80      CMP      R5,#+256
   \   00000036   0xD103             BNE.N    ??RTC_GetAlarm_2
   1104            {
   1105              tmpreg = (uint32_t)(RTC->ALRMAR);
   \   00000038   0x....             LDR.N    R0,??DataTable16_7  ;; 0x4000281c
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x0007             MOVS     R7,R0
   \   0000003E   0xE002             B.N      ??RTC_GetAlarm_3
   1106            }
   1107            else
   1108            {
   1109              tmpreg = (uint32_t)(RTC->ALRMBR);
   \                     ??RTC_GetAlarm_2: (+1)
   \   00000040   0x....             LDR.N    R0,??DataTable16_8  ;; 0x40002820
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x0007             MOVS     R7,R0
   1110            }
   1111          
   1112            /* Fill the structure with the read parameters */
   1113            RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | \
   1114                                                               RTC_ALRMAR_HU)) >> 16);
   \                     ??RTC_GetAlarm_3: (+1)
   \   00000046   0x0C38             LSRS     R0,R7,#+16
   \   00000048   0xF010 0x003F      ANDS     R0,R0,#0x3F
   \   0000004C   0x7030             STRB     R0,[R6, #+0]
   1115            RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
   1116                                                               RTC_ALRMAR_MNU)) >> 8);
   \   0000004E   0x0A38             LSRS     R0,R7,#+8
   \   00000050   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   00000054   0x7070             STRB     R0,[R6, #+1]
   1117            RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
   1118                                                               RTC_ALRMAR_SU));
   \   00000056   0xF017 0x007F      ANDS     R0,R7,#0x7F
   \   0000005A   0x70B0             STRB     R0,[R6, #+2]
   1119            RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
   \   0000005C   0x0C38             LSRS     R0,R7,#+16
   \   0000005E   0xF010 0x0040      ANDS     R0,R0,#0x40
   \   00000062   0x70F0             STRB     R0,[R6, #+3]
   1120            RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24);
   \   00000064   0x0E38             LSRS     R0,R7,#+24
   \   00000066   0xF010 0x003F      ANDS     R0,R0,#0x3F
   \   0000006A   0x7330             STRB     R0,[R6, #+12]
   1121            RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
   \   0000006C   0xF017 0x4080      ANDS     R0,R7,#0x40000000
   \   00000070   0x60B0             STR      R0,[R6, #+8]
   1122            RTC_AlarmStruct->RTC_AlarmMask = (uint32_t)(tmpreg & RTC_AlarmMask_All);
   \   00000072   0xF037 0x307F      BICS     R0,R7,#0x7F7F7F7F
   \   00000076   0x6070             STR      R0,[R6, #+4]
   1123          
   1124            if (RTC_Format == RTC_Format_BIN)
   \   00000078   0x2C00             CMP      R4,#+0
   \   0000007A   0xD10F             BNE.N    ??RTC_GetAlarm_4
   1125            {
   1126              RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
   1127                                                                  RTC_AlarmTime.RTC_Hours);
   \   0000007C   0x7830             LDRB     R0,[R6, #+0]
   \   0000007E   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   00000082   0x7030             STRB     R0,[R6, #+0]
   1128              RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
   1129                                                                  RTC_AlarmTime.RTC_Minutes);
   \   00000084   0x7870             LDRB     R0,[R6, #+1]
   \   00000086   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   0000008A   0x7070             STRB     R0,[R6, #+1]
   1130              RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
   1131                                                                  RTC_AlarmTime.RTC_Seconds);
   \   0000008C   0x78B0             LDRB     R0,[R6, #+2]
   \   0000008E   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   00000092   0x70B0             STRB     R0,[R6, #+2]
   1132              RTC_AlarmStruct->RTC_AlarmDateWeekDay = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
   \   00000094   0x7B30             LDRB     R0,[R6, #+12]
   \   00000096   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   0000009A   0x7330             STRB     R0,[R6, #+12]
   1133            }  
   1134          }
   \                     ??RTC_GetAlarm_4: (+1)
   \   0000009C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1135          
   1136          /**
   1137            * @brief  Enables or disables the specified RTC Alarm.
   1138            * @param  RTC_Alarm: specifies the alarm to be configured.
   1139            *   This parameter can be any combination of the following values:
   1140            *     @arg RTC_Alarm_A: to select Alarm A
   1141            *     @arg RTC_Alarm_B: to select Alarm B  
   1142            * @param  NewState: new state of the specified alarm.
   1143            *   This parameter can be: ENABLE or DISABLE.
   1144            * @retval An ErrorStatus enumeration value:
   1145            *          - SUCCESS: RTC Alarm is enabled/disabled
   1146            *          - ERROR: RTC Alarm is not enabled/disabled  
   1147            */

   \                                 In section .text, align 2, keep-with-next
   1148          ErrorStatus RTC_AlarmCmd(uint32_t RTC_Alarm, FunctionalState NewState)
   1149          {
   \                     RTC_AlarmCmd: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1150            __IO uint32_t alarmcounter = 0x00;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
   1151            uint32_t alarmstatus = 0x00;
   \   0000000A   0x2600             MOVS     R6,#+0
   1152            ErrorStatus status = ERROR;
   \   0000000C   0x2700             MOVS     R7,#+0
   1153              
   1154            /* Check the parameters */
   1155            assert_param(IS_RTC_CMD_ALARM(RTC_Alarm));
   \   0000000E   0xF414 0x7F40      TST      R4,#0x300
   \   00000012   0xD104             BNE.N    ??RTC_AlarmCmd_0
   \   00000014   0xF240 0x4183      MOVW     R1,#+1155
   \   00000018   0x....             LDR.N    R0,??DataTable17_1
   \   0000001A   0x.... 0x....      BL       assert_failed
   1156            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RTC_AlarmCmd_0: (+1)
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD007             BEQ.N    ??RTC_AlarmCmd_1
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0x2D01             CMP      R5,#+1
   \   00000028   0xD004             BEQ.N    ??RTC_AlarmCmd_1
   \   0000002A   0xF240 0x4184      MOVW     R1,#+1156
   \   0000002E   0x....             LDR.N    R0,??DataTable17_1
   \   00000030   0x.... 0x....      BL       assert_failed
   1157          
   1158            /* Disable the write protection for RTC registers */
   1159            RTC->WPR = 0xCA;
   \                     ??RTC_AlarmCmd_1: (+1)
   \   00000034   0x20CA             MOVS     R0,#+202
   \   00000036   0x....             LDR.N    R1,??DataTable21_1  ;; 0x40002824
   \   00000038   0x6008             STR      R0,[R1, #+0]
   1160            RTC->WPR = 0x53;
   \   0000003A   0x2053             MOVS     R0,#+83
   \   0000003C   0x....             LDR.N    R1,??DataTable21_1  ;; 0x40002824
   \   0000003E   0x6008             STR      R0,[R1, #+0]
   1161          
   1162            /* Configure the Alarm state */
   1163            if (NewState != DISABLE)
   \   00000040   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000042   0x2D00             CMP      R5,#+0
   \   00000044   0xD007             BEQ.N    ??RTC_AlarmCmd_2
   1164            {
   1165              RTC->CR |= (uint32_t)RTC_Alarm;
   \   00000046   0x....             LDR.N    R0,??DataTable16_2  ;; 0x40002808
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x4320             ORRS     R0,R4,R0
   \   0000004C   0x....             LDR.N    R1,??DataTable16_2  ;; 0x40002808
   \   0000004E   0x6008             STR      R0,[R1, #+0]
   1166          
   1167              status = SUCCESS;    
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0x0007             MOVS     R7,R0
   \   00000054   0xE01C             B.N      ??RTC_AlarmCmd_3
   1168            }
   1169            else
   1170            { 
   1171              /* Disable the Alarm in RTC_CR register */
   1172              RTC->CR &= (uint32_t)~RTC_Alarm;
   \                     ??RTC_AlarmCmd_2: (+1)
   \   00000056   0x....             LDR.N    R0,??DataTable16_2  ;; 0x40002808
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0x43A0             BICS     R0,R0,R4
   \   0000005C   0x....             LDR.N    R1,??DataTable16_2  ;; 0x40002808
   \   0000005E   0x6008             STR      R0,[R1, #+0]
   1173             
   1174              /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
   1175              do
   1176              {
   1177                alarmstatus = RTC->ISR & (RTC_Alarm >> 8);
   \                     ??RTC_AlarmCmd_4: (+1)
   \   00000060   0x....             LDR.N    R0,??DataTable19  ;; 0x4000280c
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0xEA10 0x2014      ANDS     R0,R0,R4, LSR #+8
   \   00000068   0x0006             MOVS     R6,R0
   1178                alarmcounter++;  
   \   0000006A   0x9800             LDR      R0,[SP, #+0]
   \   0000006C   0x1C40             ADDS     R0,R0,#+1
   \   0000006E   0x9000             STR      R0,[SP, #+0]
   1179              } while((alarmcounter != INITMODE_TIMEOUT) && (alarmstatus == 0x00));
   \   00000070   0x9800             LDR      R0,[SP, #+0]
   \   00000072   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000076   0xD001             BEQ.N    ??RTC_AlarmCmd_5
   \   00000078   0x2E00             CMP      R6,#+0
   \   0000007A   0xD0F1             BEQ.N    ??RTC_AlarmCmd_4
   1180              
   1181              if ((RTC->ISR & (RTC_Alarm >> 8)) == RESET)
   \                     ??RTC_AlarmCmd_5: (+1)
   \   0000007C   0x....             LDR.N    R0,??DataTable19  ;; 0x4000280c
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0xEA10 0x2F14      TST      R0,R4, LSR #+8
   \   00000084   0xD102             BNE.N    ??RTC_AlarmCmd_6
   1182              {
   1183                status = ERROR;
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x0007             MOVS     R7,R0
   \   0000008A   0xE001             B.N      ??RTC_AlarmCmd_3
   1184              } 
   1185              else
   1186              {
   1187                status = SUCCESS;
   \                     ??RTC_AlarmCmd_6: (+1)
   \   0000008C   0x2001             MOVS     R0,#+1
   \   0000008E   0x0007             MOVS     R7,R0
   1188              }        
   1189            } 
   1190          
   1191            /* Enable the write protection for RTC registers */
   1192            RTC->WPR = 0xFF; 
   \                     ??RTC_AlarmCmd_3: (+1)
   \   00000090   0x20FF             MOVS     R0,#+255
   \   00000092   0x....             LDR.N    R1,??DataTable21_1  ;; 0x40002824
   \   00000094   0x6008             STR      R0,[R1, #+0]
   1193            
   1194            return status;
   \   00000096   0x0038             MOVS     R0,R7
   \   00000098   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1195          }
   1196          
   1197          /**
   1198            * @}
   1199            */
   1200          
   1201          /** @defgroup RTC_Group4 WakeUp Timer configuration functions
   1202           *  @brief   WakeUp Timer configuration functions 
   1203           *
   1204          @verbatim   
   1205           ===============================================================================
   1206                               WakeUp Timer configuration functions
   1207           ===============================================================================  
   1208          
   1209            This section provide functions allowing to program and read the RTC WakeUp.
   1210          
   1211          @endverbatim
   1212            * @{
   1213            */
   1214          
   1215          /**
   1216            * @brief  Configures the RTC Wakeup clock source.
   1217            * @note   The WakeUp Clock source can only be changed when the RTC WakeUp
   1218            *         is disabled (Use the RTC_WakeUpCmd(DISABLE)).      
   1219            * @param  RTC_WakeUpClock: Wakeup Clock source.
   1220            *   This parameter can be one of the following values:
   1221            *     @arg RTC_WakeUpClock_RTCCLK_Div16
   1222            *     @arg RTC_WakeUpClock_RTCCLK_Div8
   1223            *     @arg RTC_WakeUpClock_RTCCLK_Div4
   1224            *     @arg RTC_WakeUpClock_RTCCLK_Div2
   1225            *     @arg RTC_WakeUpClock_CK_SPRE_16bits
   1226            *     @arg RTC_WakeUpClock_CK_SPRE_17bits
   1227            * @retval None
   1228            */

   \                                 In section .text, align 2, keep-with-next
   1229          void RTC_WakeUpClockConfig(uint32_t RTC_WakeUpClock)
   1230          {
   \                     RTC_WakeUpClockConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1231            /* Check the parameters */
   1232            assert_param(IS_RTC_WAKEUP_CLOCK(RTC_WakeUpClock));
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD00E             BEQ.N    ??RTC_WakeUpClockConfig_0
   \   00000008   0x2C01             CMP      R4,#+1
   \   0000000A   0xD00C             BEQ.N    ??RTC_WakeUpClockConfig_0
   \   0000000C   0x2C02             CMP      R4,#+2
   \   0000000E   0xD00A             BEQ.N    ??RTC_WakeUpClockConfig_0
   \   00000010   0x2C03             CMP      R4,#+3
   \   00000012   0xD008             BEQ.N    ??RTC_WakeUpClockConfig_0
   \   00000014   0x2C04             CMP      R4,#+4
   \   00000016   0xD006             BEQ.N    ??RTC_WakeUpClockConfig_0
   \   00000018   0x2C06             CMP      R4,#+6
   \   0000001A   0xD004             BEQ.N    ??RTC_WakeUpClockConfig_0
   \   0000001C   0xF44F 0x619A      MOV      R1,#+1232
   \   00000020   0x....             LDR.N    R0,??DataTable17_1
   \   00000022   0x.... 0x....      BL       assert_failed
   1233          
   1234            /* Disable the write protection for RTC registers */
   1235            RTC->WPR = 0xCA;
   \                     ??RTC_WakeUpClockConfig_0: (+1)
   \   00000026   0x20CA             MOVS     R0,#+202
   \   00000028   0x....             LDR.N    R1,??DataTable21_1  ;; 0x40002824
   \   0000002A   0x6008             STR      R0,[R1, #+0]
   1236            RTC->WPR = 0x53;
   \   0000002C   0x2053             MOVS     R0,#+83
   \   0000002E   0x....             LDR.N    R1,??DataTable21_1  ;; 0x40002824
   \   00000030   0x6008             STR      R0,[R1, #+0]
   1237          
   1238            /* Clear the Wakeup Timer clock source bits in CR register */
   1239            RTC->CR &= (uint32_t)~RTC_CR_WUCKSEL;
   \   00000032   0x....             LDR.N    R0,??DataTable16_2  ;; 0x40002808
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x08C0             LSRS     R0,R0,#+3
   \   00000038   0x00C0             LSLS     R0,R0,#+3
   \   0000003A   0x....             LDR.N    R1,??DataTable16_2  ;; 0x40002808
   \   0000003C   0x6008             STR      R0,[R1, #+0]
   1240          
   1241            /* Configure the clock source */
   1242            RTC->CR |= (uint32_t)RTC_WakeUpClock;
   \   0000003E   0x....             LDR.N    R0,??DataTable16_2  ;; 0x40002808
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x4320             ORRS     R0,R4,R0
   \   00000044   0x....             LDR.N    R1,??DataTable16_2  ;; 0x40002808
   \   00000046   0x6008             STR      R0,[R1, #+0]
   1243            
   1244            /* Enable the write protection for RTC registers */
   1245            RTC->WPR = 0xFF; 
   \   00000048   0x20FF             MOVS     R0,#+255
   \   0000004A   0x....             LDR.N    R1,??DataTable21_1  ;; 0x40002824
   \   0000004C   0x6008             STR      R0,[R1, #+0]
   1246          }
   \   0000004E   0xBD10             POP      {R4,PC}          ;; return
   1247          
   1248          /**
   1249            * @brief  Configures the RTC Wakeup counter.
   1250            * @note   The RTC WakeUp counter can only be written when the RTC WakeUp
   1251            *         is disabled (Use the RTC_WakeUpCmd(DISABLE)).        
   1252            * @param  RTC_WakeUpCounter: specifies the WakeUp counter.
   1253            *   This parameter can be a value from 0x0000 to 0xFFFF. 
   1254            * @retval None
   1255            */

   \                                 In section .text, align 2, keep-with-next
   1256          void RTC_SetWakeUpCounter(uint32_t RTC_WakeUpCounter)
   1257          {
   \                     RTC_SetWakeUpCounter: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1258            /* Check the parameters */
   1259            assert_param(IS_RTC_WAKEUP_COUNTER(RTC_WakeUpCounter));
   \   00000004   0xF5B4 0x3F80      CMP      R4,#+65536
   \   00000008   0xD304             BCC.N    ??RTC_SetWakeUpCounter_0
   \   0000000A   0xF240 0x41EB      MOVW     R1,#+1259
   \   0000000E   0x....             LDR.N    R0,??DataTable17_1
   \   00000010   0x.... 0x....      BL       assert_failed
   1260            
   1261            /* Disable the write protection for RTC registers */
   1262            RTC->WPR = 0xCA;
   \                     ??RTC_SetWakeUpCounter_0: (+1)
   \   00000014   0x20CA             MOVS     R0,#+202
   \   00000016   0x....             LDR.N    R1,??DataTable21_1  ;; 0x40002824
   \   00000018   0x6008             STR      R0,[R1, #+0]
   1263            RTC->WPR = 0x53;
   \   0000001A   0x2053             MOVS     R0,#+83
   \   0000001C   0x....             LDR.N    R1,??DataTable21_1  ;; 0x40002824
   \   0000001E   0x6008             STR      R0,[R1, #+0]
   1264            
   1265            /* Configure the Wakeup Timer counter */
   1266            RTC->WUTR = (uint32_t)RTC_WakeUpCounter;
   \   00000020   0x....             LDR.N    R0,??DataTable16_3  ;; 0x40002814
   \   00000022   0x6004             STR      R4,[R0, #+0]
   1267            
   1268            /* Enable the write protection for RTC registers */
   1269            RTC->WPR = 0xFF; 
   \   00000024   0x20FF             MOVS     R0,#+255
   \   00000026   0x....             LDR.N    R1,??DataTable21_1  ;; 0x40002824
   \   00000028   0x6008             STR      R0,[R1, #+0]
   1270          }
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
   1271          
   1272          /**
   1273            * @brief  Returns the RTC WakeUp timer counter value.
   1274            * @param  None
   1275            * @retval The RTC WakeUp Counter value.
   1276            */

   \                                 In section .text, align 2, keep-with-next
   1277          uint32_t RTC_GetWakeUpCounter(void)
   1278          {
   1279            /* Get the counter value */
   1280            return ((uint32_t)(RTC->WUTR & RTC_WUTR_WUT));
   \                     RTC_GetWakeUpCounter: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable16_3  ;; 0x40002814
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000006   0x4770             BX       LR               ;; return
   1281          }
   1282          
   1283          /**
   1284            * @brief  Enables or Disables the RTC WakeUp timer.
   1285            * @param  NewState: new state of the WakeUp timer.
   1286            *   This parameter can be: ENABLE or DISABLE.
   1287            * @retval None
   1288            */

   \                                 In section .text, align 2, keep-with-next
   1289          ErrorStatus RTC_WakeUpCmd(FunctionalState NewState)
   1290          {
   \                     RTC_WakeUpCmd: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   1291            __IO uint32_t wutcounter = 0x00;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
   1292            uint32_t wutwfstatus = 0x00;
   \   0000000A   0x2500             MOVS     R5,#+0
   1293            ErrorStatus status = ERROR;
   \   0000000C   0x2600             MOVS     R6,#+0
   1294            
   1295            /* Check the parameters */
   1296            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   0000000E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD007             BEQ.N    ??RTC_WakeUpCmd_0
   \   00000014   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000016   0x2C01             CMP      R4,#+1
   \   00000018   0xD004             BEQ.N    ??RTC_WakeUpCmd_0
   \   0000001A   0xF44F 0x61A2      MOV      R1,#+1296
   \   0000001E   0x....             LDR.N    R0,??DataTable17_1
   \   00000020   0x.... 0x....      BL       assert_failed
   1297          
   1298            /* Disable the write protection for RTC registers */
   1299            RTC->WPR = 0xCA;
   \                     ??RTC_WakeUpCmd_0: (+1)
   \   00000024   0x20CA             MOVS     R0,#+202
   \   00000026   0x....             LDR.N    R1,??DataTable21_1  ;; 0x40002824
   \   00000028   0x6008             STR      R0,[R1, #+0]
   1300            RTC->WPR = 0x53;
   \   0000002A   0x2053             MOVS     R0,#+83
   \   0000002C   0x....             LDR.N    R1,??DataTable21_1  ;; 0x40002824
   \   0000002E   0x6008             STR      R0,[R1, #+0]
   1301          
   1302            if (NewState != DISABLE)
   \   00000030   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000032   0x2C00             CMP      R4,#+0
   \   00000034   0xD00A             BEQ.N    ??RTC_WakeUpCmd_1
   1303            {
   1304              /* Enable the Wakeup Timer */
   1305              RTC->CR |= (uint32_t)RTC_CR_WUTE;
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable35  ;; 0x40002808
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable35  ;; 0x40002808
   \   00000044   0x6008             STR      R0,[R1, #+0]
   1306              status = SUCCESS;    
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0x0006             MOVS     R6,R0
   \   0000004A   0xE01E             B.N      ??RTC_WakeUpCmd_2
   1307            }
   1308            else
   1309            {
   1310              /* Disable the Wakeup Timer */
   1311              RTC->CR &= (uint32_t)~RTC_CR_WUTE;
   \                     ??RTC_WakeUpCmd_1: (+1)
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable35  ;; 0x40002808
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0xF430 0x6080      BICS     R0,R0,#0x400
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable35  ;; 0x40002808
   \   0000005A   0x6008             STR      R0,[R1, #+0]
   1312              /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
   1313              do
   1314              {
   1315                wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
   \                     ??RTC_WakeUpCmd_3: (+1)
   \   0000005C   0x....             LDR.N    R0,??DataTable19  ;; 0x4000280c
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0xF010 0x0004      ANDS     R0,R0,#0x4
   \   00000064   0x0005             MOVS     R5,R0
   1316                wutcounter++;  
   \   00000066   0x9800             LDR      R0,[SP, #+0]
   \   00000068   0x1C40             ADDS     R0,R0,#+1
   \   0000006A   0x9000             STR      R0,[SP, #+0]
   1317              } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
   \   0000006C   0x9800             LDR      R0,[SP, #+0]
   \   0000006E   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000072   0xD001             BEQ.N    ??RTC_WakeUpCmd_4
   \   00000074   0x2D00             CMP      R5,#+0
   \   00000076   0xD0F1             BEQ.N    ??RTC_WakeUpCmd_3
   1318              
   1319              if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
   \                     ??RTC_WakeUpCmd_4: (+1)
   \   00000078   0x....             LDR.N    R0,??DataTable19  ;; 0x4000280c
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0x0740             LSLS     R0,R0,#+29
   \   0000007E   0xD402             BMI.N    ??RTC_WakeUpCmd_5
   1320              {
   1321                status = ERROR;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x0006             MOVS     R6,R0
   \   00000084   0xE001             B.N      ??RTC_WakeUpCmd_2
   1322              }
   1323              else
   1324              {
   1325                status = SUCCESS;
   \                     ??RTC_WakeUpCmd_5: (+1)
   \   00000086   0x2001             MOVS     R0,#+1
   \   00000088   0x0006             MOVS     R6,R0
   1326              }    
   1327            }
   1328          
   1329            /* Enable the write protection for RTC registers */
   1330            RTC->WPR = 0xFF; 
   \                     ??RTC_WakeUpCmd_2: (+1)
   \   0000008A   0x20FF             MOVS     R0,#+255
   \   0000008C   0x....             LDR.N    R1,??DataTable21_1  ;; 0x40002824
   \   0000008E   0x6008             STR      R0,[R1, #+0]
   1331            
   1332            return status;
   \   00000090   0x0030             MOVS     R0,R6
   \   00000092   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000094   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   1333          }
   1334          
   1335          /**
   1336            * @}
   1337            */
   1338          
   1339          /** @defgroup RTC_Group5 Daylight Saving configuration functions
   1340           *  @brief   Daylight Saving configuration functions 
   1341           *
   1342          @verbatim   
   1343           ===============================================================================
   1344                              Daylight Saving configuration functions
   1345           ===============================================================================  
   1346          
   1347            This section provide functions allowing to configure the RTC DayLight Saving.
   1348          
   1349          @endverbatim
   1350            * @{
   1351            */
   1352          
   1353          /**
   1354            * @brief  Adds or substract one hour from the current time.
   1355            * @param  RTC_DayLightSaveOperation: the value of hour adjustment. 
   1356            *   This parameter can be one of the following values:
   1357            *     @arg RTC_DayLightSaving_SUB1H: Substract one hour (winter time)
   1358            *     @arg RTC_DayLightSaving_ADD1H: Add one hour (summer time)
   1359            * @param  RTC_StoreOperation: Specifies the value to be written in the BCK bit 
   1360            *                            in CR register to store the operation.
   1361            *   This parameter can be one of the following values:
   1362            *     @arg RTC_StoreOperation_Reset
   1363            *     @arg RTC_StoreOperation_Set
   1364            * @retval None
   1365            */

   \                                 In section .text, align 2, keep-with-next
   1366          void RTC_DayLightSavingConfig(uint32_t RTC_DayLightSaving, uint32_t RTC_StoreOperation)
   1367          {
   \                     RTC_DayLightSavingConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1368            /* Check the parameters */
   1369            assert_param(IS_RTC_DAYLIGHT_SAVING(RTC_DayLightSaving));
   \   00000006   0xF5B4 0x3F00      CMP      R4,#+131072
   \   0000000A   0xD008             BEQ.N    ??RTC_DayLightSavingConfig_0
   \   0000000C   0xF5B4 0x3F80      CMP      R4,#+65536
   \   00000010   0xD005             BEQ.N    ??RTC_DayLightSavingConfig_0
   \   00000012   0xF240 0x5159      MOVW     R1,#+1369
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   0000001A   0x.... 0x....      BL       assert_failed
   1370            assert_param(IS_RTC_STORE_OPERATION(RTC_StoreOperation));
   \                     ??RTC_DayLightSavingConfig_0: (+1)
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD008             BEQ.N    ??RTC_DayLightSavingConfig_1
   \   00000022   0xF5B5 0x2F80      CMP      R5,#+262144
   \   00000026   0xD005             BEQ.N    ??RTC_DayLightSavingConfig_1
   \   00000028   0xF240 0x515A      MOVW     R1,#+1370
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   00000030   0x.... 0x....      BL       assert_failed
   1371          
   1372            /* Disable the write protection for RTC registers */
   1373            RTC->WPR = 0xCA;
   \                     ??RTC_DayLightSavingConfig_1: (+1)
   \   00000034   0x20CA             MOVS     R0,#+202
   \   00000036   0x....             LDR.N    R1,??DataTable21_1  ;; 0x40002824
   \   00000038   0x6008             STR      R0,[R1, #+0]
   1374            RTC->WPR = 0x53;
   \   0000003A   0x2053             MOVS     R0,#+83
   \   0000003C   0x....             LDR.N    R1,??DataTable21_1  ;; 0x40002824
   \   0000003E   0x6008             STR      R0,[R1, #+0]
   1375          
   1376            /* Clear the bits to be configured */
   1377            RTC->CR &= (uint32_t)~(RTC_CR_BCK);
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable35  ;; 0x40002808
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0xF430 0x2080      BICS     R0,R0,#0x40000
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable35  ;; 0x40002808
   \   0000004E   0x6008             STR      R0,[R1, #+0]
   1378          
   1379            /* Configure the RTC_CR register */
   1380            RTC->CR |= (uint32_t)(RTC_DayLightSaving | RTC_StoreOperation);
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable35  ;; 0x40002808
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0xEA55 0x0104      ORRS     R1,R5,R4
   \   0000005A   0x4308             ORRS     R0,R1,R0
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable35  ;; 0x40002808
   \   00000060   0x6008             STR      R0,[R1, #+0]
   1381          
   1382            /* Enable the write protection for RTC registers */
   1383            RTC->WPR = 0xFF; 
   \   00000062   0x20FF             MOVS     R0,#+255
   \   00000064   0x....             LDR.N    R1,??DataTable21_1  ;; 0x40002824
   \   00000066   0x6008             STR      R0,[R1, #+0]
   1384          }
   \   00000068   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1385          
   1386          /**
   1387            * @brief  Returns the RTC Day Light Saving stored operation.
   1388            * @param  None
   1389            * @retval RTC Day Light Saving stored operation.
   1390            *          - RTC_StoreOperation_Reset
   1391            *          - RTC_StoreOperation_Set       
   1392            */

   \                                 In section .text, align 2, keep-with-next
   1393          uint32_t RTC_GetStoreOperation(void)
   1394          {
   1395            return (RTC->CR & RTC_CR_BCK);
   \                     RTC_GetStoreOperation: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable35  ;; 0x40002808
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF410 0x2080      ANDS     R0,R0,#0x40000
   \   0000000A   0x4770             BX       LR               ;; return
   1396          }
   1397          
   1398          /**
   1399            * @}
   1400            */
   1401          
   1402          /** @defgroup RTC_Group6 Output pin Configuration function
   1403           *  @brief   Output pin Configuration function 
   1404           *
   1405          @verbatim   
   1406           ===============================================================================
   1407                                   Output pin Configuration function
   1408           ===============================================================================  
   1409          
   1410            This section provide functions allowing to configure the RTC Output source.
   1411          
   1412          @endverbatim
   1413            * @{
   1414            */
   1415          
   1416          /**
   1417            * @brief  Configures the RTC output source (AFO_ALARM).
   1418            * @param  RTC_Output: Specifies which signal will be routed to the RTC output. 
   1419            *   This parameter can be one of the following values:
   1420            *     @arg RTC_Output_Disable: No output selected
   1421            *     @arg RTC_Output_AlarmA: signal of AlarmA mapped to output
   1422            *     @arg RTC_Output_AlarmB: signal of AlarmB mapped to output
   1423            *     @arg RTC_Output_WakeUp: signal of WakeUp mapped to output
   1424            * @param  RTC_OutputPolarity: Specifies the polarity of the output signal. 
   1425            *   This parameter can be one of the following:
   1426            *     @arg RTC_OutputPolarity_High: The output pin is high when the 
   1427            *                                 ALRAF/ALRBF/WUTF is high (depending on OSEL)
   1428            *     @arg RTC_OutputPolarity_Low: The output pin is low when the 
   1429            *                                 ALRAF/ALRBF/WUTF is high (depending on OSEL)
   1430            * @retval None
   1431            */

   \                                 In section .text, align 2, keep-with-next
   1432          void RTC_OutputConfig(uint32_t RTC_Output, uint32_t RTC_OutputPolarity)
   1433          {
   \                     RTC_OutputConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1434            /* Check the parameters */
   1435            assert_param(IS_RTC_OUTPUT(RTC_Output));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD00E             BEQ.N    ??RTC_OutputConfig_0
   \   0000000A   0xF5B4 0x1F00      CMP      R4,#+2097152
   \   0000000E   0xD00B             BEQ.N    ??RTC_OutputConfig_0
   \   00000010   0xF5B4 0x0F80      CMP      R4,#+4194304
   \   00000014   0xD008             BEQ.N    ??RTC_OutputConfig_0
   \   00000016   0xF5B4 0x0FC0      CMP      R4,#+6291456
   \   0000001A   0xD005             BEQ.N    ??RTC_OutputConfig_0
   \   0000001C   0xF240 0x519B      MOVW     R1,#+1435
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   00000024   0x.... 0x....      BL       assert_failed
   1436            assert_param(IS_RTC_OUTPUT_POL(RTC_OutputPolarity));
   \                     ??RTC_OutputConfig_0: (+1)
   \   00000028   0x2D00             CMP      R5,#+0
   \   0000002A   0xD008             BEQ.N    ??RTC_OutputConfig_1
   \   0000002C   0xF5B5 0x1F80      CMP      R5,#+1048576
   \   00000030   0xD005             BEQ.N    ??RTC_OutputConfig_1
   \   00000032   0xF240 0x519C      MOVW     R1,#+1436
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   0000003A   0x.... 0x....      BL       assert_failed
   1437          
   1438            /* Disable the write protection for RTC registers */
   1439            RTC->WPR = 0xCA;
   \                     ??RTC_OutputConfig_1: (+1)
   \   0000003E   0x20CA             MOVS     R0,#+202
   \   00000040   0x....             LDR.N    R1,??DataTable21_1  ;; 0x40002824
   \   00000042   0x6008             STR      R0,[R1, #+0]
   1440            RTC->WPR = 0x53;
   \   00000044   0x2053             MOVS     R0,#+83
   \   00000046   0x....             LDR.N    R1,??DataTable21_1  ;; 0x40002824
   \   00000048   0x6008             STR      R0,[R1, #+0]
   1441          
   1442            /* Clear the bits to be configured */
   1443            RTC->CR &= (uint32_t)~(RTC_CR_OSEL | RTC_CR_POL);
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable35  ;; 0x40002808
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0xF430 0x00E0      BICS     R0,R0,#0x700000
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable35  ;; 0x40002808
   \   00000058   0x6008             STR      R0,[R1, #+0]
   1444          
   1445            /* Configure the output selection and polarity */
   1446            RTC->CR |= (uint32_t)(RTC_Output | RTC_OutputPolarity);
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable35  ;; 0x40002808
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0xEA55 0x0104      ORRS     R1,R5,R4
   \   00000064   0x4308             ORRS     R0,R1,R0
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable35  ;; 0x40002808
   \   0000006A   0x6008             STR      R0,[R1, #+0]
   1447          
   1448            /* Enable the write protection for RTC registers */
   1449            RTC->WPR = 0xFF; 
   \   0000006C   0x20FF             MOVS     R0,#+255
   \   0000006E   0x....             LDR.N    R1,??DataTable21_1  ;; 0x40002824
   \   00000070   0x6008             STR      R0,[R1, #+0]
   1450          }
   \   00000072   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1451          
   1452          /**
   1453            * @}
   1454            */
   1455          
   1456          /** @defgroup RTC_Group7 Digital Calibration configuration functions
   1457           *  @brief   Digital Calibration configuration functions 
   1458           *
   1459          @verbatim   
   1460           ===============================================================================
   1461                            Digital Calibration configuration functions
   1462           ===============================================================================  
   1463          
   1464          @endverbatim
   1465            * @{
   1466            */
   1467          
   1468          /**
   1469            * @brief  Configures the digital calibration parameters.
   1470            * @param  RTC_CalibSign: specifies the sign of the calibration value.
   1471            *   This parameter can be  one of the following values:
   1472            *     @arg RTC_CalibSign_Positive: The value sign is positive 
   1473            *     @arg RTC_CalibSign_Negative: The value sign is negative
   1474            * @param  Value: value of calibration expressed in ppm (coded on 5 bits) 
   1475            *             - This value should be between 0 and 63 when using negative sign
   1476            *               with a 2-ppm step.
   1477            *             - This value should be between 0 and 126 when using positive sign
   1478            *               with a 4-ppm step.
   1479            * @retval An ErrorStatus enumeration value:
   1480            *          - SUCCESS: RTC digital calibration are initialized
   1481            *          - ERROR: RTC digital calibration are not initialized     
   1482            */

   \                                 In section .text, align 2, keep-with-next
   1483          ErrorStatus RTC_DigitalCalibConfig(uint32_t RTC_CalibSign, uint32_t Value)
   1484          {
   \                     RTC_DigitalCalibConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1485            ErrorStatus status = ERROR;
   \   00000006   0x2600             MOVS     R6,#+0
   1486             
   1487            /* Check the parameters */
   1488            assert_param(IS_RTC_CALIB_SIGN(RTC_CalibSign));
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD007             BEQ.N    ??RTC_DigitalCalibConfig_0
   \   0000000C   0x2C80             CMP      R4,#+128
   \   0000000E   0xD005             BEQ.N    ??RTC_DigitalCalibConfig_0
   \   00000010   0xF44F 0x61BA      MOV      R1,#+1488
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   00000018   0x.... 0x....      BL       assert_failed
   1489            assert_param(IS_RTC_CALIB_VALUE(Value)); 
   \                     ??RTC_DigitalCalibConfig_0: (+1)
   \   0000001C   0x2D20             CMP      R5,#+32
   \   0000001E   0xD305             BCC.N    ??RTC_DigitalCalibConfig_1
   \   00000020   0xF240 0x51D1      MOVW     R1,#+1489
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   00000028   0x.... 0x....      BL       assert_failed
   1490          
   1491            /* Disable the write protection for RTC registers */
   1492            RTC->WPR = 0xCA;
   \                     ??RTC_DigitalCalibConfig_1: (+1)
   \   0000002C   0x20CA             MOVS     R0,#+202
   \   0000002E   0x....             LDR.N    R1,??DataTable21_1  ;; 0x40002824
   \   00000030   0x6008             STR      R0,[R1, #+0]
   1493            RTC->WPR = 0x53;
   \   00000032   0x2053             MOVS     R0,#+83
   \   00000034   0x....             LDR.N    R1,??DataTable21_1  ;; 0x40002824
   \   00000036   0x6008             STR      R0,[R1, #+0]
   1494          
   1495            /* Set Initialization mode */
   1496            if (RTC_EnterInitMode() == ERROR)
   \   00000038   0x.... 0x....      BL       RTC_EnterInitMode
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD102             BNE.N    ??RTC_DigitalCalibConfig_2
   1497            {
   1498              status = ERROR;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x0006             MOVS     R6,R0
   \   00000044   0xE008             B.N      ??RTC_DigitalCalibConfig_3
   1499            } 
   1500            else
   1501            {
   1502              /* Set the calibration value */
   1503              RTC->CALIBR = (uint32_t)(RTC_CalibSign | Value);
   \                     ??RTC_DigitalCalibConfig_2: (+1)
   \   00000046   0xEA55 0x0004      ORRS     R0,R5,R4
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable35_2  ;; 0x40002818
   \   0000004E   0x6008             STR      R0,[R1, #+0]
   1504              /* Exit Initialization mode */
   1505              RTC_ExitInitMode();
   \   00000050   0x.... 0x....      BL       RTC_ExitInitMode
   1506              
   1507              status = SUCCESS;
   \   00000054   0x2001             MOVS     R0,#+1
   \   00000056   0x0006             MOVS     R6,R0
   1508            } 
   1509          
   1510            /* Enable the write protection for RTC registers */
   1511            RTC->WPR = 0xFF; 
   \                     ??RTC_DigitalCalibConfig_3: (+1)
   \   00000058   0x20FF             MOVS     R0,#+255
   \   0000005A   0x....             LDR.N    R1,??DataTable21_1  ;; 0x40002824
   \   0000005C   0x6008             STR      R0,[R1, #+0]
   1512            
   1513            return status;
   \   0000005E   0x0030             MOVS     R0,R6
   \   00000060   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000062   0xBD70             POP      {R4-R6,PC}       ;; return
   1514          }
   1515          
   1516          /**
   1517            * @brief  Enables or disables the digital calibration process.
   1518            * @param  NewState: new state of the digital calibration.
   1519            *   This parameter can be: ENABLE or DISABLE.
   1520            * @retval An ErrorStatus enumeration value:
   1521            *          - SUCCESS: RTC digital calibration are enabled/disabled
   1522            *          - ERROR: RTC digital calibration are not enabled/disabled    
   1523            */

   \                                 In section .text, align 2, keep-with-next
   1524          ErrorStatus RTC_DigitalCalibCmd(FunctionalState NewState)
   1525          {
   \                     RTC_DigitalCalibCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1526            ErrorStatus status = ERROR;
   \   00000004   0x2500             MOVS     R5,#+0
   1527            
   1528            /* Check the parameters */
   1529            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD008             BEQ.N    ??RTC_DigitalCalibCmd_0
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x2C01             CMP      R4,#+1
   \   00000010   0xD005             BEQ.N    ??RTC_DigitalCalibCmd_0
   \   00000012   0xF240 0x51F9      MOVW     R1,#+1529
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   0000001A   0x.... 0x....      BL       assert_failed
   1530          
   1531            /* Disable the write protection for RTC registers */
   1532            RTC->WPR = 0xCA;
   \                     ??RTC_DigitalCalibCmd_0: (+1)
   \   0000001E   0x20CA             MOVS     R0,#+202
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable35_3  ;; 0x40002824
   \   00000024   0x6008             STR      R0,[R1, #+0]
   1533            RTC->WPR = 0x53;
   \   00000026   0x2053             MOVS     R0,#+83
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable35_3  ;; 0x40002824
   \   0000002C   0x6008             STR      R0,[R1, #+0]
   1534            
   1535            /* Set Initialization mode */
   1536            if (RTC_EnterInitMode() == ERROR)
   \   0000002E   0x.... 0x....      BL       RTC_EnterInitMode
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD102             BNE.N    ??RTC_DigitalCalibCmd_1
   1537            {
   1538              status =  ERROR;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x0005             MOVS     R5,R0
   \   0000003A   0xE017             B.N      ??RTC_DigitalCalibCmd_2
   1539            }
   1540            else
   1541            {
   1542              if (NewState != DISABLE)
   \                     ??RTC_DigitalCalibCmd_1: (+1)
   \   0000003C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003E   0x2C00             CMP      R4,#+0
   \   00000040   0xD008             BEQ.N    ??RTC_DigitalCalibCmd_3
   1543              {
   1544                /* Enable the Digital Calibration */
   1545                RTC->CR |= (uint32_t)RTC_CR_DCE;
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable35  ;; 0x40002808
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable35  ;; 0x40002808
   \   00000050   0x6008             STR      R0,[R1, #+0]
   \   00000052   0xE007             B.N      ??RTC_DigitalCalibCmd_4
   1546              }
   1547              else
   1548              { 
   1549                /* Disable the Digital Calibration */
   1550                RTC->CR &= (uint32_t)~RTC_CR_DCE;
   \                     ??RTC_DigitalCalibCmd_3: (+1)
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable35  ;; 0x40002808
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0xF030 0x0080      BICS     R0,R0,#0x80
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable35  ;; 0x40002808
   \   00000062   0x6008             STR      R0,[R1, #+0]
   1551              }
   1552              /* Exit Initialization mode */
   1553              RTC_ExitInitMode();
   \                     ??RTC_DigitalCalibCmd_4: (+1)
   \   00000064   0x.... 0x....      BL       RTC_ExitInitMode
   1554              
   1555              status = SUCCESS;
   \   00000068   0x2001             MOVS     R0,#+1
   \   0000006A   0x0005             MOVS     R5,R0
   1556            } 
   1557            
   1558            /* Enable the write protection for RTC registers */
   1559            RTC->WPR = 0xFF; 
   \                     ??RTC_DigitalCalibCmd_2: (+1)
   \   0000006C   0x20FF             MOVS     R0,#+255
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable35_3  ;; 0x40002824
   \   00000072   0x6008             STR      R0,[R1, #+0]
   1560            
   1561            return status;
   \   00000074   0x0028             MOVS     R0,R5
   \   00000076   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000078   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1562          }
   1563          
   1564          /**
   1565            * @brief  Enables or disables the RTC clock to be output through the relative 
   1566            *         pin.
   1567            * @param  NewState: new state of the digital calibration Output.
   1568            *   This parameter can be: ENABLE or DISABLE.
   1569            * @retval None
   1570            */

   \                                 In section .text, align 2, keep-with-next
   1571          void RTC_CalibOutputCmd(FunctionalState NewState)
   1572          {
   \                     RTC_CalibOutputCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1573            /* Check the parameters */
   1574            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD008             BEQ.N    ??RTC_CalibOutputCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD005             BEQ.N    ??RTC_CalibOutputCmd_0
   \   00000010   0xF240 0x6126      MOVW     R1,#+1574
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   00000018   0x.... 0x....      BL       assert_failed
   1575            
   1576            /* Disable the write protection for RTC registers */
   1577            RTC->WPR = 0xCA;
   \                     ??RTC_CalibOutputCmd_0: (+1)
   \   0000001C   0x20CA             MOVS     R0,#+202
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable35_3  ;; 0x40002824
   \   00000022   0x6008             STR      R0,[R1, #+0]
   1578            RTC->WPR = 0x53;
   \   00000024   0x2053             MOVS     R0,#+83
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable35_3  ;; 0x40002824
   \   0000002A   0x6008             STR      R0,[R1, #+0]
   1579            
   1580            if (NewState != DISABLE)
   \   0000002C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002E   0x2C00             CMP      R4,#+0
   \   00000030   0xD008             BEQ.N    ??RTC_CalibOutputCmd_1
   1581            {
   1582              /* Enable the RTC clock output */
   1583              RTC->CR |= (uint32_t)RTC_CR_COE;
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable35  ;; 0x40002808
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF450 0x0000      ORRS     R0,R0,#0x800000
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable35  ;; 0x40002808
   \   00000040   0x6008             STR      R0,[R1, #+0]
   \   00000042   0xE007             B.N      ??RTC_CalibOutputCmd_2
   1584            }
   1585            else
   1586            { 
   1587              /* Disable the RTC clock output */
   1588              RTC->CR &= (uint32_t)~RTC_CR_COE;
   \                     ??RTC_CalibOutputCmd_1: (+1)
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable35  ;; 0x40002808
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0xF430 0x0000      BICS     R0,R0,#0x800000
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable35  ;; 0x40002808
   \   00000052   0x6008             STR      R0,[R1, #+0]
   1589            }
   1590            
   1591            /* Enable the write protection for RTC registers */
   1592            RTC->WPR = 0xFF; 
   \                     ??RTC_CalibOutputCmd_2: (+1)
   \   00000054   0x20FF             MOVS     R0,#+255
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable35_3  ;; 0x40002824
   \   0000005A   0x6008             STR      R0,[R1, #+0]
   1593          }
   \   0000005C   0xBD10             POP      {R4,PC}          ;; return
   1594          
   1595          /**
   1596            * @}
   1597            */
   1598          
   1599          
   1600          /** @defgroup RTC_Group8 TimeStamp configuration functions
   1601           *  @brief   TimeStamp configuration functions 
   1602           *
   1603          @verbatim   
   1604           ===============================================================================
   1605                                 TimeStamp configuration functions
   1606           ===============================================================================  
   1607          
   1608          @endverbatim
   1609            * @{
   1610            */
   1611          
   1612          /**
   1613            * @brief  Enables or Disables the RTC TimeStamp functionality with the 
   1614            *         specified time stamp pin stimulating edge.
   1615            * @param  RTC_TimeStampEdge: Specifies the pin edge on which the TimeStamp is 
   1616            *         activated.
   1617            *   This parameter can be one of the following:
   1618            *     @arg RTC_TimeStampEdge_Rising: the Time stamp event occurs on the rising 
   1619            *                                    edge of the related pin.
   1620            *     @arg RTC_TimeStampEdge_Falling: the Time stamp event occurs on the 
   1621            *                                     falling edge of the related pin.
   1622            * @param  NewState: new state of the TimeStamp.
   1623            *   This parameter can be: ENABLE or DISABLE.
   1624            * @retval None
   1625            */

   \                                 In section .text, align 2, keep-with-next
   1626          void RTC_TimeStampCmd(uint32_t RTC_TimeStampEdge, FunctionalState NewState)
   1627          {
   \                     RTC_TimeStampCmd: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1628            uint32_t tmpreg = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1629          
   1630            /* Check the parameters */
   1631            assert_param(IS_RTC_TIMESTAMP_EDGE(RTC_TimeStampEdge));
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD007             BEQ.N    ??RTC_TimeStampCmd_0
   \   0000000C   0x2C08             CMP      R4,#+8
   \   0000000E   0xD005             BEQ.N    ??RTC_TimeStampCmd_0
   \   00000010   0xF240 0x615F      MOVW     R1,#+1631
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   00000018   0x.... 0x....      BL       assert_failed
   1632            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RTC_TimeStampCmd_0: (+1)
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD008             BEQ.N    ??RTC_TimeStampCmd_1
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D01             CMP      R5,#+1
   \   00000026   0xD005             BEQ.N    ??RTC_TimeStampCmd_1
   \   00000028   0xF44F 0x61CC      MOV      R1,#+1632
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   00000030   0x.... 0x....      BL       assert_failed
   1633          
   1634            /* Get the RTC_CR register and clear the bits to be configured */
   1635            tmpreg = (uint32_t)(RTC->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
   \                     ??RTC_TimeStampCmd_1: (+1)
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable35  ;; 0x40002808
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable35_4  ;; 0xfffff7f7
   \   0000003E   0x4008             ANDS     R0,R1,R0
   \   00000040   0x0006             MOVS     R6,R0
   1636          
   1637            /* Get the new configuration */
   1638            if (NewState != DISABLE)
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0x2D00             CMP      R5,#+0
   \   00000046   0xD003             BEQ.N    ??RTC_TimeStampCmd_2
   1639            {
   1640              tmpreg |= (uint32_t)(RTC_TimeStampEdge | RTC_CR_TSE);
   \   00000048   0xF454 0x6000      ORRS     R0,R4,#0x800
   \   0000004C   0x4306             ORRS     R6,R0,R6
   \   0000004E   0xE000             B.N      ??RTC_TimeStampCmd_3
   1641            }
   1642            else
   1643            {
   1644              tmpreg |= (uint32_t)(RTC_TimeStampEdge);
   \                     ??RTC_TimeStampCmd_2: (+1)
   \   00000050   0x4326             ORRS     R6,R4,R6
   1645            }
   1646          
   1647            /* Disable the write protection for RTC registers */
   1648            RTC->WPR = 0xCA;
   \                     ??RTC_TimeStampCmd_3: (+1)
   \   00000052   0x20CA             MOVS     R0,#+202
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable35_3  ;; 0x40002824
   \   00000058   0x6008             STR      R0,[R1, #+0]
   1649            RTC->WPR = 0x53;
   \   0000005A   0x2053             MOVS     R0,#+83
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable35_3  ;; 0x40002824
   \   00000060   0x6008             STR      R0,[R1, #+0]
   1650          
   1651            /* Configure the Time Stamp TSEDGE and Enable bits */
   1652            RTC->CR = (uint32_t)tmpreg;
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable35  ;; 0x40002808
   \   00000066   0x6006             STR      R6,[R0, #+0]
   1653          
   1654            /* Enable the write protection for RTC registers */
   1655            RTC->WPR = 0xFF; 
   \   00000068   0x20FF             MOVS     R0,#+255
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable35_3  ;; 0x40002824
   \   0000006E   0x6008             STR      R0,[R1, #+0]
   1656          }
   \   00000070   0xBD70             POP      {R4-R6,PC}       ;; return
   1657          
   1658          /**
   1659            * @brief  Get the RTC TimeStamp value and masks.
   1660            * @param  RTC_Format: specifies the format of the output parameters.
   1661            *   This parameter can be one of the following values:
   1662            *     @arg RTC_Format_BIN: Binary data format 
   1663            *     @arg RTC_Format_BCD: BCD data format
   1664            * @param RTC_StampTimeStruct: pointer to a RTC_TimeTypeDef structure that will 
   1665            *                             contains the TimeStamp time values. 
   1666            * @param RTC_StampDateStruct: pointer to a RTC_DateTypeDef structure that will 
   1667            *                             contains the TimeStamp date values.     
   1668            * @retval None
   1669            */

   \                                 In section .text, align 2, keep-with-next
   1670          void RTC_GetTimeStamp(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_StampTimeStruct, 
   1671                                                RTC_DateTypeDef* RTC_StampDateStruct)
   1672          {
   \                     RTC_GetTimeStamp: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1673            uint32_t tmptime = 0, tmpdate = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   1674          
   1675            /* Check the parameters */
   1676            assert_param(IS_RTC_FORMAT(RTC_Format));
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD007             BEQ.N    ??RTC_GetTimeStamp_0
   \   00000014   0x2C01             CMP      R4,#+1
   \   00000016   0xD005             BEQ.N    ??RTC_GetTimeStamp_0
   \   00000018   0xF240 0x618C      MOVW     R1,#+1676
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   00000020   0x.... 0x....      BL       assert_failed
   1677          
   1678            /* Get the TimeStamp time and date registers values */
   1679            tmptime = (uint32_t)(RTC->TSTR & RTC_TR_RESERVED_MASK);
   \                     ??RTC_GetTimeStamp_0: (+1)
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable35_5  ;; 0x40002830
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x....             LDR.N    R1,??DataTable26  ;; 0x7f7f7f
   \   0000002C   0x4008             ANDS     R0,R1,R0
   \   0000002E   0x0007             MOVS     R7,R0
   1680            tmpdate = (uint32_t)(RTC->TSDR & RTC_DR_RESERVED_MASK);
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable35_6  ;; 0x40002834
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x....             LDR.N    R1,??DataTable30  ;; 0xffff3f
   \   00000038   0x4008             ANDS     R0,R1,R0
   \   0000003A   0x4680             MOV      R8,R0
   1681          
   1682            /* Fill the Time structure fields with the read parameters */
   1683            RTC_StampTimeStruct->RTC_Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16);
   \   0000003C   0x0C38             LSRS     R0,R7,#+16
   \   0000003E   0xF010 0x003F      ANDS     R0,R0,#0x3F
   \   00000042   0x7028             STRB     R0,[R5, #+0]
   1684            RTC_StampTimeStruct->RTC_Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
   \   00000044   0x0A38             LSRS     R0,R7,#+8
   \   00000046   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   0000004A   0x7068             STRB     R0,[R5, #+1]
   1685            RTC_StampTimeStruct->RTC_Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
   \   0000004C   0xF017 0x007F      ANDS     R0,R7,#0x7F
   \   00000050   0x70A8             STRB     R0,[R5, #+2]
   1686            RTC_StampTimeStruct->RTC_H12 = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);  
   \   00000052   0x0C38             LSRS     R0,R7,#+16
   \   00000054   0xF010 0x0040      ANDS     R0,R0,#0x40
   \   00000058   0x70E8             STRB     R0,[R5, #+3]
   1687          
   1688            /* Fill the Date structure fields with the read parameters */
   1689            RTC_StampDateStruct->RTC_Year = 0;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x7270             STRB     R0,[R6, #+9]
   1690            RTC_StampDateStruct->RTC_Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8);
   \   0000005E   0xEA5F 0x2018      LSRS     R0,R8,#+8
   \   00000062   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   00000066   0x6070             STR      R0,[R6, #+4]
   1691            RTC_StampDateStruct->RTC_Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
   \   00000068   0xF018 0x003F      ANDS     R0,R8,#0x3F
   \   0000006C   0x7230             STRB     R0,[R6, #+8]
   1692            RTC_StampDateStruct->RTC_WeekDay = (uint8_t)((tmpdate & (RTC_DR_WDU)) >> 13);
   \   0000006E   0xEA5F 0x3058      LSRS     R0,R8,#+13
   \   00000072   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000076   0x6030             STR      R0,[R6, #+0]
   1693          
   1694            /* Check the input parameters format */
   1695            if (RTC_Format == RTC_Format_BIN)
   \   00000078   0x2C00             CMP      R4,#+0
   \   0000007A   0xD119             BNE.N    ??RTC_GetTimeStamp_1
   1696            {
   1697              /* Convert the Time structure parameters to Binary format */
   1698              RTC_StampTimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Hours);
   \   0000007C   0x7828             LDRB     R0,[R5, #+0]
   \   0000007E   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   00000082   0x7028             STRB     R0,[R5, #+0]
   1699              RTC_StampTimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Minutes);
   \   00000084   0x7868             LDRB     R0,[R5, #+1]
   \   00000086   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   0000008A   0x7068             STRB     R0,[R5, #+1]
   1700              RTC_StampTimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Seconds);
   \   0000008C   0x78A8             LDRB     R0,[R5, #+2]
   \   0000008E   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   00000092   0x70A8             STRB     R0,[R5, #+2]
   1701          
   1702              /* Convert the Date structure parameters to Binary format */
   1703              RTC_StampDateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Month);
   \   00000094   0x6870             LDR      R0,[R6, #+4]
   \   00000096   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000098   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   0000009C   0x6070             STR      R0,[R6, #+4]
   1704              RTC_StampDateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Date);
   \   0000009E   0x7A30             LDRB     R0,[R6, #+8]
   \   000000A0   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   000000A4   0x7230             STRB     R0,[R6, #+8]
   1705              RTC_StampDateStruct->RTC_WeekDay = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_WeekDay);
   \   000000A6   0x6830             LDR      R0,[R6, #+0]
   \   000000A8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AA   0x.... 0x....      BL       RTC_Bcd2ToByte
   \   000000AE   0x6030             STR      R0,[R6, #+0]
   1706            }
   1707          }
   \                     ??RTC_GetTimeStamp_1: (+1)
   \   000000B0   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1708          
   1709          /**
   1710            * @}
   1711            */
   1712          
   1713          /** @defgroup RTC_Group9 Tampers configuration functions
   1714           *  @brief   Tampers configuration functions 
   1715           *
   1716          @verbatim   
   1717           ===============================================================================
   1718                                 Tampers configuration functions
   1719           ===============================================================================  
   1720          
   1721          @endverbatim
   1722            * @{
   1723            */
   1724          
   1725          /**
   1726            * @brief  Configures the select Tamper pin edge.
   1727            * @param  RTC_Tamper: Selected tamper pin.
   1728            *   This parameter can be RTC_Tamper_1.
   1729            * @param  RTC_TamperTrigger: Specifies the trigger on the tamper pin that 
   1730            *         stimulates tamper event. 
   1731            *   This parameter can be one of the following values:
   1732            *     @arg RTC_TamperTrigger_RisingEdge: Rising Edge of the tamper pin causes tamper event.
   1733            *     @arg RTC_TamperTrigger_FallingEdge: Falling Edge of the tamper pin causes tamper event.                         
   1734            * @retval None
   1735            */

   \                                 In section .text, align 2, keep-with-next
   1736          void RTC_TamperTriggerConfig(uint32_t RTC_Tamper, uint32_t RTC_TamperTrigger)
   1737          {
   \                     RTC_TamperTriggerConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1738            /* Check the parameters */
   1739            assert_param(IS_RTC_TAMPER(RTC_Tamper)); 
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD005             BEQ.N    ??RTC_TamperTriggerConfig_0
   \   0000000A   0xF240 0x61CB      MOVW     R1,#+1739
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   00000012   0x.... 0x....      BL       assert_failed
   1740            assert_param(IS_RTC_TAMPER_TRIGGER(RTC_TamperTrigger));
   \                     ??RTC_TamperTriggerConfig_0: (+1)
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD007             BEQ.N    ??RTC_TamperTriggerConfig_1
   \   0000001A   0x2D01             CMP      R5,#+1
   \   0000001C   0xD005             BEQ.N    ??RTC_TamperTriggerConfig_1
   \   0000001E   0xF240 0x61CC      MOVW     R1,#+1740
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   00000026   0x.... 0x....      BL       assert_failed
   1741           
   1742            if (RTC_TamperTrigger == RTC_TamperTrigger_RisingEdge)
   \                     ??RTC_TamperTriggerConfig_1: (+1)
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD108             BNE.N    ??RTC_TamperTriggerConfig_2
   1743            {  
   1744              /* Configure the RTC_TAFCR register */
   1745              RTC->TAFCR &= (uint32_t)((uint32_t)~(RTC_Tamper << 1));	
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable35_7  ;; 0x40002840
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0xEA30 0x0044      BICS     R0,R0,R4, LSL #+1
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable35_7  ;; 0x40002840
   \   0000003C   0x6008             STR      R0,[R1, #+0]
   \   0000003E   0xE007             B.N      ??RTC_TamperTriggerConfig_3
   1746            }
   1747            else
   1748            { 
   1749              /* Configure the RTC_TAFCR register */
   1750              RTC->TAFCR |= (uint32_t)(RTC_Tamper << 1);  
   \                     ??RTC_TamperTriggerConfig_2: (+1)
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable35_7  ;; 0x40002840
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0xEA50 0x0044      ORRS     R0,R0,R4, LSL #+1
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable35_7  ;; 0x40002840
   \   0000004E   0x6008             STR      R0,[R1, #+0]
   1751            }  
   1752          }
   \                     ??RTC_TamperTriggerConfig_3: (+1)
   \   00000050   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1753          
   1754          /**
   1755            * @brief  Enables or Disables the Tamper detection.
   1756            * @param  RTC_Tamper: Selected tamper pin.
   1757            *   This parameter can be RTC_Tamper_1.
   1758            * @param  NewState: new state of the tamper pin.
   1759            *   This parameter can be: ENABLE or DISABLE.                   
   1760            * @retval None
   1761            */

   \                                 In section .text, align 2, keep-with-next
   1762          void RTC_TamperCmd(uint32_t RTC_Tamper, FunctionalState NewState)
   1763          {
   \                     RTC_TamperCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1764            /* Check the parameters */
   1765            assert_param(IS_RTC_TAMPER(RTC_Tamper));  
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD005             BEQ.N    ??RTC_TamperCmd_0
   \   0000000A   0xF240 0x61E5      MOVW     R1,#+1765
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   00000012   0x.... 0x....      BL       assert_failed
   1766            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RTC_TamperCmd_0: (+1)
   \   00000016   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD008             BEQ.N    ??RTC_TamperCmd_1
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D01             CMP      R5,#+1
   \   00000020   0xD005             BEQ.N    ??RTC_TamperCmd_1
   \   00000022   0xF240 0x61E6      MOVW     R1,#+1766
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   0000002A   0x.... 0x....      BL       assert_failed
   1767            
   1768            if (NewState != DISABLE)
   \                     ??RTC_TamperCmd_1: (+1)
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0x2D00             CMP      R5,#+0
   \   00000032   0xD007             BEQ.N    ??RTC_TamperCmd_2
   1769            {
   1770              /* Enable the selected Tamper pin */
   1771              RTC->TAFCR |= (uint32_t)RTC_Tamper;
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable35_7  ;; 0x40002840
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x4320             ORRS     R0,R4,R0
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable35_7  ;; 0x40002840
   \   00000040   0x6008             STR      R0,[R1, #+0]
   \   00000042   0xE005             B.N      ??RTC_TamperCmd_3
   1772            }
   1773            else
   1774            {
   1775              /* Disable the selected Tamper pin */
   1776              RTC->TAFCR &= (uint32_t)~RTC_Tamper;    
   \                     ??RTC_TamperCmd_2: (+1)
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable35_7  ;; 0x40002840
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x43A0             BICS     R0,R0,R4
   \   0000004C   0x....             LDR.N    R1,??DataTable35_7  ;; 0x40002840
   \   0000004E   0x6008             STR      R0,[R1, #+0]
   1777            }  
   1778          }
   \                     ??RTC_TamperCmd_3: (+1)
   \   00000050   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1779          
   1780          /**
   1781            * @}
   1782            */
   1783          
   1784          /** @defgroup RTC_Group10 Backup Data Registers configuration functions
   1785           *  @brief   Backup Data Registers configuration functions  
   1786           *
   1787          @verbatim   
   1788           ===============================================================================
   1789                                 Backup Data Registers configuration functions 
   1790           ===============================================================================  
   1791          
   1792          @endverbatim
   1793            * @{
   1794            */
   1795          
   1796          /**
   1797            * @brief  Writes a data in a specified RTC Backup data register.
   1798            * @param  RTC_BKP_DR: RTC Backup data Register number.
   1799            *   This parameter can be: RTC_BKP_DRx where x can be from 0 to 19 to 
   1800            *                          specify the register.
   1801            * @param  Data: Data to be written in the specified RTC Backup data register.                     
   1802            * @retval None
   1803            */

   \                                 In section .text, align 2, keep-with-next
   1804          void RTC_WriteBackupRegister(uint32_t RTC_BKP_DR, uint32_t Data)
   1805          {
   \                     RTC_WriteBackupRegister: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1806            __IO uint32_t tmp = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
   1807            
   1808            /* Check the parameters */
   1809            assert_param(IS_RTC_BKP(RTC_BKP_DR));
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD02A             BEQ.N    ??RTC_WriteBackupRegister_0
   \   0000000E   0x2C01             CMP      R4,#+1
   \   00000010   0xD028             BEQ.N    ??RTC_WriteBackupRegister_0
   \   00000012   0x2C02             CMP      R4,#+2
   \   00000014   0xD026             BEQ.N    ??RTC_WriteBackupRegister_0
   \   00000016   0x2C03             CMP      R4,#+3
   \   00000018   0xD024             BEQ.N    ??RTC_WriteBackupRegister_0
   \   0000001A   0x2C04             CMP      R4,#+4
   \   0000001C   0xD022             BEQ.N    ??RTC_WriteBackupRegister_0
   \   0000001E   0x2C05             CMP      R4,#+5
   \   00000020   0xD020             BEQ.N    ??RTC_WriteBackupRegister_0
   \   00000022   0x2C06             CMP      R4,#+6
   \   00000024   0xD01E             BEQ.N    ??RTC_WriteBackupRegister_0
   \   00000026   0x2C07             CMP      R4,#+7
   \   00000028   0xD01C             BEQ.N    ??RTC_WriteBackupRegister_0
   \   0000002A   0x2C08             CMP      R4,#+8
   \   0000002C   0xD01A             BEQ.N    ??RTC_WriteBackupRegister_0
   \   0000002E   0x2C09             CMP      R4,#+9
   \   00000030   0xD018             BEQ.N    ??RTC_WriteBackupRegister_0
   \   00000032   0x2C0A             CMP      R4,#+10
   \   00000034   0xD016             BEQ.N    ??RTC_WriteBackupRegister_0
   \   00000036   0x2C0B             CMP      R4,#+11
   \   00000038   0xD014             BEQ.N    ??RTC_WriteBackupRegister_0
   \   0000003A   0x2C0C             CMP      R4,#+12
   \   0000003C   0xD012             BEQ.N    ??RTC_WriteBackupRegister_0
   \   0000003E   0x2C0D             CMP      R4,#+13
   \   00000040   0xD010             BEQ.N    ??RTC_WriteBackupRegister_0
   \   00000042   0x2C0E             CMP      R4,#+14
   \   00000044   0xD00E             BEQ.N    ??RTC_WriteBackupRegister_0
   \   00000046   0x2C0F             CMP      R4,#+15
   \   00000048   0xD00C             BEQ.N    ??RTC_WriteBackupRegister_0
   \   0000004A   0x2C10             CMP      R4,#+16
   \   0000004C   0xD00A             BEQ.N    ??RTC_WriteBackupRegister_0
   \   0000004E   0x2C11             CMP      R4,#+17
   \   00000050   0xD008             BEQ.N    ??RTC_WriteBackupRegister_0
   \   00000052   0x2C12             CMP      R4,#+18
   \   00000054   0xD006             BEQ.N    ??RTC_WriteBackupRegister_0
   \   00000056   0x2C13             CMP      R4,#+19
   \   00000058   0xD004             BEQ.N    ??RTC_WriteBackupRegister_0
   \   0000005A   0xF240 0x7111      MOVW     R1,#+1809
   \   0000005E   0x....             LDR.N    R0,??DataTable35_1
   \   00000060   0x.... 0x....      BL       assert_failed
   1810          
   1811            tmp = RTC_BASE + 0x50;
   \                     ??RTC_WriteBackupRegister_0: (+1)
   \   00000064   0x....             LDR.N    R0,??DataTable35_8  ;; 0x40002850
   \   00000066   0x9000             STR      R0,[SP, #+0]
   1812            tmp += (RTC_BKP_DR * 4);
   \   00000068   0x9800             LDR      R0,[SP, #+0]
   \   0000006A   0xEB10 0x0084      ADDS     R0,R0,R4, LSL #+2
   \   0000006E   0x9000             STR      R0,[SP, #+0]
   1813          
   1814            /* Write the specified register */
   1815            *(__IO uint32_t *)tmp = (uint32_t)Data;
   \   00000070   0x9800             LDR      R0,[SP, #+0]
   \   00000072   0x6005             STR      R5,[R0, #+0]
   1816          }
   \   00000074   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1817          
   1818          /**
   1819            * @brief  Reads data from the specified RTC Backup data Register.
   1820            * @param  RTC_BKP_DR: RTC Backup data Register number.
   1821            *   This parameter can be: RTC_BKP_DRx where x can be from 0 to 19 to 
   1822            *                          specify the register.                   
   1823            * @retval None
   1824            */

   \                                 In section .text, align 2, keep-with-next
   1825          uint32_t RTC_ReadBackupRegister(uint32_t RTC_BKP_DR)
   1826          {
   \                     RTC_ReadBackupRegister: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   1827            __IO uint32_t tmp = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
   1828            
   1829            /* Check the parameters */
   1830            assert_param(IS_RTC_BKP(RTC_BKP_DR));
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD02A             BEQ.N    ??RTC_ReadBackupRegister_0
   \   0000000E   0x2C01             CMP      R4,#+1
   \   00000010   0xD028             BEQ.N    ??RTC_ReadBackupRegister_0
   \   00000012   0x2C02             CMP      R4,#+2
   \   00000014   0xD026             BEQ.N    ??RTC_ReadBackupRegister_0
   \   00000016   0x2C03             CMP      R4,#+3
   \   00000018   0xD024             BEQ.N    ??RTC_ReadBackupRegister_0
   \   0000001A   0x2C04             CMP      R4,#+4
   \   0000001C   0xD022             BEQ.N    ??RTC_ReadBackupRegister_0
   \   0000001E   0x2C05             CMP      R4,#+5
   \   00000020   0xD020             BEQ.N    ??RTC_ReadBackupRegister_0
   \   00000022   0x2C06             CMP      R4,#+6
   \   00000024   0xD01E             BEQ.N    ??RTC_ReadBackupRegister_0
   \   00000026   0x2C07             CMP      R4,#+7
   \   00000028   0xD01C             BEQ.N    ??RTC_ReadBackupRegister_0
   \   0000002A   0x2C08             CMP      R4,#+8
   \   0000002C   0xD01A             BEQ.N    ??RTC_ReadBackupRegister_0
   \   0000002E   0x2C09             CMP      R4,#+9
   \   00000030   0xD018             BEQ.N    ??RTC_ReadBackupRegister_0
   \   00000032   0x2C0A             CMP      R4,#+10
   \   00000034   0xD016             BEQ.N    ??RTC_ReadBackupRegister_0
   \   00000036   0x2C0B             CMP      R4,#+11
   \   00000038   0xD014             BEQ.N    ??RTC_ReadBackupRegister_0
   \   0000003A   0x2C0C             CMP      R4,#+12
   \   0000003C   0xD012             BEQ.N    ??RTC_ReadBackupRegister_0
   \   0000003E   0x2C0D             CMP      R4,#+13
   \   00000040   0xD010             BEQ.N    ??RTC_ReadBackupRegister_0
   \   00000042   0x2C0E             CMP      R4,#+14
   \   00000044   0xD00E             BEQ.N    ??RTC_ReadBackupRegister_0
   \   00000046   0x2C0F             CMP      R4,#+15
   \   00000048   0xD00C             BEQ.N    ??RTC_ReadBackupRegister_0
   \   0000004A   0x2C10             CMP      R4,#+16
   \   0000004C   0xD00A             BEQ.N    ??RTC_ReadBackupRegister_0
   \   0000004E   0x2C11             CMP      R4,#+17
   \   00000050   0xD008             BEQ.N    ??RTC_ReadBackupRegister_0
   \   00000052   0x2C12             CMP      R4,#+18
   \   00000054   0xD006             BEQ.N    ??RTC_ReadBackupRegister_0
   \   00000056   0x2C13             CMP      R4,#+19
   \   00000058   0xD004             BEQ.N    ??RTC_ReadBackupRegister_0
   \   0000005A   0xF240 0x7126      MOVW     R1,#+1830
   \   0000005E   0x....             LDR.N    R0,??DataTable35_1
   \   00000060   0x.... 0x....      BL       assert_failed
   1831          
   1832            tmp = RTC_BASE + 0x50;
   \                     ??RTC_ReadBackupRegister_0: (+1)
   \   00000064   0x....             LDR.N    R0,??DataTable35_8  ;; 0x40002850
   \   00000066   0x9000             STR      R0,[SP, #+0]
   1833            tmp += (RTC_BKP_DR * 4);
   \   00000068   0x9800             LDR      R0,[SP, #+0]
   \   0000006A   0xEB10 0x0084      ADDS     R0,R0,R4, LSL #+2
   \   0000006E   0x9000             STR      R0,[SP, #+0]
   1834            
   1835            /* Read the specified register */
   1836            return (*(__IO uint32_t *)tmp);
   \   00000070   0x9800             LDR      R0,[SP, #+0]
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   1837          }
   1838          
   1839          /**
   1840            * @}
   1841            */
   1842          
   1843          /** @defgroup RTC_Group11 Output Type Config configuration functions
   1844           *  @brief   Output Type Config configuration functions  
   1845           *
   1846          @verbatim   
   1847           ===============================================================================
   1848                                 Output Type Config configuration functions 
   1849           ===============================================================================  
   1850          
   1851          @endverbatim
   1852            * @{
   1853            */
   1854          
   1855          /**
   1856            * @brief  Configures the RTC Output Pin mode. 
   1857            * @param  RTC_OutputType: specifies the RTC Output (PC13) pin mode.
   1858            *   This parameter can be one of the following values:
   1859            *     @arg RTC_OutputType_OpenDrain: RTC Output (PC13) is configured in 
   1860            *                                    Open Drain mode.
   1861            *     @arg RTC_OutputType_PushPull:  RTC Output (PC13) is configured in 
   1862            *                                    Push Pull mode.    
   1863            * @retval None
   1864            */

   \                                 In section .text, align 2, keep-with-next
   1865          void RTC_OutputTypeConfig(uint32_t RTC_OutputType)
   1866          {
   \                     RTC_OutputTypeConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1867            /* Check the parameters */
   1868            assert_param(IS_RTC_OUTPUT_TYPE(RTC_OutputType));
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD007             BEQ.N    ??RTC_OutputTypeConfig_0
   \   00000008   0xF5B4 0x2F80      CMP      R4,#+262144
   \   0000000C   0xD004             BEQ.N    ??RTC_OutputTypeConfig_0
   \   0000000E   0xF240 0x714C      MOVW     R1,#+1868
   \   00000012   0x....             LDR.N    R0,??DataTable35_1
   \   00000014   0x.... 0x....      BL       assert_failed
   1869            
   1870            RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_ALARMOUTTYPE);
   \                     ??RTC_OutputTypeConfig_0: (+1)
   \   00000018   0x....             LDR.N    R0,??DataTable35_7  ;; 0x40002840
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF430 0x2080      BICS     R0,R0,#0x40000
   \   00000020   0x....             LDR.N    R1,??DataTable35_7  ;; 0x40002840
   \   00000022   0x6008             STR      R0,[R1, #+0]
   1871            RTC->TAFCR |= (uint32_t)(RTC_OutputType);  
   \   00000024   0x....             LDR.N    R0,??DataTable35_7  ;; 0x40002840
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x4320             ORRS     R0,R4,R0
   \   0000002A   0x....             LDR.N    R1,??DataTable35_7  ;; 0x40002840
   \   0000002C   0x6008             STR      R0,[R1, #+0]
   1872          }
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
   1873          
   1874          /**
   1875            * @}
   1876            */
   1877          
   1878          /** @defgroup RTC_Group12 Interrupts and flags management functions
   1879           *  @brief   Interrupts and flags management functions  
   1880           *
   1881          @verbatim   
   1882           ===============================================================================
   1883                                 Interrupts and flags management functions
   1884           ===============================================================================  
   1885           All RTC interrupts are connected to the EXTI controller.
   1886           
   1887           - To enable the RTC Alarm interrupt, the following sequence is required:
   1888             - Configure and enable the EXTI Line 17 in interrupt mode and select the rising 
   1889               edge sensitivity using the EXTI_Init() function.
   1890             - Configure and enable the RTC_Alarm IRQ channel in the NVIC using the NVIC_Init()
   1891               function.
   1892             - Configure the RTC to generate RTC alarms (Alarm A and/or Alarm B) using
   1893               the RTC_SetAlarm() and RTC_AlarmCmd() functions.
   1894          
   1895           - To enable the RTC Wakeup interrupt, the following sequence is required:
   1896             - Configure and enable the EXTI Line 20 in interrupt mode and select the rising 
   1897               edge sensitivity using the EXTI_Init() function.
   1898             - Configure and enable the RTC_WKUP IRQ channel in the NVIC using the NVIC_Init()
   1899               function.
   1900             - Configure the RTC to generate the RTC wakeup timer event using the 
   1901               RTC_WakeUpClockConfig(), RTC_SetWakeUpCounter() and RTC_WakeUpCmd() functions.
   1902          
   1903           - To enable the RTC Tamper interrupt, the following sequence is required:
   1904             - Configure and enable the EXTI Line 19 in interrupt mode and select the rising 
   1905               edge sensitivity using the EXTI_Init() function.
   1906             - Configure and enable the TAMP_STAMP IRQ channel in the NVIC using the NVIC_Init()
   1907               function.
   1908             - Configure the RTC to detect the RTC tamper event using the 
   1909               RTC_TamperTriggerConfig() and RTC_TamperCmd() functions.
   1910          
   1911           - To enable the RTC TimeStamp interrupt, the following sequence is required:
   1912             - Configure and enable the EXTI Line 19 in interrupt mode and select the rising 
   1913               edge sensitivity using the EXTI_Init() function.
   1914             - Configure and enable the TAMP_STAMP IRQ channel in the NVIC using the NVIC_Init()
   1915               function.
   1916             - Configure the RTC to detect the RTC time-stamp event using the 
   1917               RTC_TimeStampCmd() functions.
   1918          
   1919          @endverbatim
   1920            * @{
   1921            */
   1922          
   1923          /**
   1924            * @brief  Enables or disables the specified RTC interrupts.
   1925            * @param  RTC_IT: specifies the RTC interrupt sources to be enabled or disabled. 
   1926            *   This parameter can be any combination of the following values:
   1927            *     @arg RTC_IT_TS:  Time Stamp interrupt mask
   1928            *     @arg RTC_IT_WUT:  WakeUp Timer interrupt mask
   1929            *     @arg RTC_IT_ALRB:  Alarm B interrupt mask
   1930            *     @arg RTC_IT_ALRA:  Alarm A interrupt mask
   1931            *     @arg RTC_IT_TAMP: Tamper event interrupt mask
   1932            * @param  NewState: new state of the specified RTC interrupts.
   1933            *   This parameter can be: ENABLE or DISABLE.
   1934            * @retval None
   1935            */

   \                                 In section .text, align 2, keep-with-next
   1936          void RTC_ITConfig(uint32_t RTC_IT, FunctionalState NewState)
   1937          {
   \                     RTC_ITConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1938            /* Check the parameters */
   1939            assert_param(IS_RTC_CONFIG_IT(RTC_IT));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD002             BEQ.N    ??RTC_ITConfig_0
   \   0000000A   0x....             LDR.N    R0,??DataTable35_9  ;; 0xffff0ffb
   \   0000000C   0x4204             TST      R4,R0
   \   0000000E   0xD004             BEQ.N    ??RTC_ITConfig_1
   \                     ??RTC_ITConfig_0: (+1)
   \   00000010   0xF240 0x7193      MOVW     R1,#+1939
   \   00000014   0x....             LDR.N    R0,??DataTable35_1
   \   00000016   0x.... 0x....      BL       assert_failed
   1940            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RTC_ITConfig_1: (+1)
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD007             BEQ.N    ??RTC_ITConfig_2
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D01             CMP      R5,#+1
   \   00000024   0xD004             BEQ.N    ??RTC_ITConfig_2
   \   00000026   0xF240 0x7194      MOVW     R1,#+1940
   \   0000002A   0x....             LDR.N    R0,??DataTable35_1
   \   0000002C   0x.... 0x....      BL       assert_failed
   1941          
   1942            /* Disable the write protection for RTC registers */
   1943            RTC->WPR = 0xCA;
   \                     ??RTC_ITConfig_2: (+1)
   \   00000030   0x20CA             MOVS     R0,#+202
   \   00000032   0x....             LDR.N    R1,??DataTable35_3  ;; 0x40002824
   \   00000034   0x6008             STR      R0,[R1, #+0]
   1944            RTC->WPR = 0x53;
   \   00000036   0x2053             MOVS     R0,#+83
   \   00000038   0x....             LDR.N    R1,??DataTable35_3  ;; 0x40002824
   \   0000003A   0x6008             STR      R0,[R1, #+0]
   1945          
   1946            if (NewState != DISABLE)
   \   0000003C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003E   0x2D00             CMP      R5,#+0
   \   00000040   0xD00E             BEQ.N    ??RTC_ITConfig_3
   1947            {
   1948              /* Configure the Interrupts in the RTC_CR register */
   1949              RTC->CR |= (uint32_t)(RTC_IT & ~RTC_TAFCR_TAMPIE);
   \   00000042   0x....             LDR.N    R0,??DataTable35  ;; 0x40002808
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0xF034 0x0104      BICS     R1,R4,#0x4
   \   0000004A   0x4308             ORRS     R0,R1,R0
   \   0000004C   0x....             LDR.N    R1,??DataTable35  ;; 0x40002808
   \   0000004E   0x6008             STR      R0,[R1, #+0]
   1950              /* Configure the Tamper Interrupt in the RTC_TAFCR */
   1951              RTC->TAFCR |= (uint32_t)(RTC_IT & RTC_TAFCR_TAMPIE);
   \   00000050   0x....             LDR.N    R0,??DataTable35_7  ;; 0x40002840
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0xF014 0x0104      ANDS     R1,R4,#0x4
   \   00000058   0x4308             ORRS     R0,R1,R0
   \   0000005A   0x....             LDR.N    R1,??DataTable35_7  ;; 0x40002840
   \   0000005C   0x6008             STR      R0,[R1, #+0]
   \   0000005E   0xE00D             B.N      ??RTC_ITConfig_4
   1952            }
   1953            else
   1954            {
   1955              /* Configure the Interrupts in the RTC_CR register */
   1956              RTC->CR &= (uint32_t)~(RTC_IT & (uint32_t)~RTC_TAFCR_TAMPIE);
   \                     ??RTC_ITConfig_3: (+1)
   \   00000060   0x....             LDR.N    R0,??DataTable35  ;; 0x40002808
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0xF034 0x0104      BICS     R1,R4,#0x4
   \   00000068   0x4388             BICS     R0,R0,R1
   \   0000006A   0x....             LDR.N    R1,??DataTable35  ;; 0x40002808
   \   0000006C   0x6008             STR      R0,[R1, #+0]
   1957              /* Configure the Tamper Interrupt in the RTC_TAFCR */
   1958              RTC->TAFCR &= (uint32_t)~(RTC_IT & RTC_TAFCR_TAMPIE);
   \   0000006E   0x....             LDR.N    R0,??DataTable35_7  ;; 0x40002840
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0xF014 0x0104      ANDS     R1,R4,#0x4
   \   00000076   0x4388             BICS     R0,R0,R1
   \   00000078   0x....             LDR.N    R1,??DataTable35_7  ;; 0x40002840
   \   0000007A   0x6008             STR      R0,[R1, #+0]
   1959            }
   1960            /* Enable the write protection for RTC registers */
   1961            RTC->WPR = 0xFF; 
   \                     ??RTC_ITConfig_4: (+1)
   \   0000007C   0x20FF             MOVS     R0,#+255
   \   0000007E   0x....             LDR.N    R1,??DataTable35_3  ;; 0x40002824
   \   00000080   0x6008             STR      R0,[R1, #+0]
   1962          }
   \   00000082   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1963          
   1964          /**
   1965            * @brief  Checks whether the specified RTC flag is set or not.
   1966            * @param  RTC_FLAG: specifies the flag to check.
   1967            *   This parameter can be one of the following values:
   1968            *     @arg RTC_FLAG_TAMP1F: Tamper 1 event flag
   1969            *     @arg RTC_FLAG_TSOVF: Time Stamp OverFlow flag
   1970            *     @arg RTC_FLAG_TSF: Time Stamp event flag
   1971            *     @arg RTC_FLAG_WUTF: WakeUp Timer flag
   1972            *     @arg RTC_FLAG_ALRBF: Alarm B flag
   1973            *     @arg RTC_FLAG_ALRAF: Alarm A flag
   1974            *     @arg RTC_FLAG_INITF: Initialization mode flag
   1975            *     @arg RTC_FLAG_RSF: Registers Synchronized flag
   1976            *     @arg RTC_FLAG_INITS: Registers Configured flag
   1977            *     @arg RTC_FLAG_WUTWF: WakeUp Timer Write flag
   1978            *     @arg RTC_FLAG_ALRBWF: Alarm B Write flag
   1979            *     @arg RTC_FLAG_ALRAWF: Alarm A write flag
   1980            * @retval The new state of RTC_FLAG (SET or RESET).
   1981            */

   \                                 In section .text, align 2, keep-with-next
   1982          FlagStatus RTC_GetFlagStatus(uint32_t RTC_FLAG)
   1983          {
   \                     RTC_GetFlagStatus: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1984            FlagStatus bitstatus = RESET;
   \   00000004   0x2500             MOVS     R5,#+0
   1985            uint32_t tmpreg = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1986            
   1987            /* Check the parameters */
   1988            assert_param(IS_RTC_GET_FLAG(RTC_FLAG));
   \   00000008   0xF5B4 0x5F80      CMP      R4,#+4096
   \   0000000C   0xD01D             BEQ.N    ??RTC_GetFlagStatus_0
   \   0000000E   0xF5B4 0x6F00      CMP      R4,#+2048
   \   00000012   0xD01A             BEQ.N    ??RTC_GetFlagStatus_0
   \   00000014   0xF5B4 0x6F80      CMP      R4,#+1024
   \   00000018   0xD017             BEQ.N    ??RTC_GetFlagStatus_0
   \   0000001A   0xF5B4 0x7F00      CMP      R4,#+512
   \   0000001E   0xD014             BEQ.N    ??RTC_GetFlagStatus_0
   \   00000020   0xF5B4 0x7F80      CMP      R4,#+256
   \   00000024   0xD011             BEQ.N    ??RTC_GetFlagStatus_0
   \   00000026   0x2C40             CMP      R4,#+64
   \   00000028   0xD00F             BEQ.N    ??RTC_GetFlagStatus_0
   \   0000002A   0x2C20             CMP      R4,#+32
   \   0000002C   0xD00D             BEQ.N    ??RTC_GetFlagStatus_0
   \   0000002E   0x2C04             CMP      R4,#+4
   \   00000030   0xD00B             BEQ.N    ??RTC_GetFlagStatus_0
   \   00000032   0x2C02             CMP      R4,#+2
   \   00000034   0xD009             BEQ.N    ??RTC_GetFlagStatus_0
   \   00000036   0x2C01             CMP      R4,#+1
   \   00000038   0xD007             BEQ.N    ??RTC_GetFlagStatus_0
   \   0000003A   0xF5B4 0x5F00      CMP      R4,#+8192
   \   0000003E   0xD004             BEQ.N    ??RTC_GetFlagStatus_0
   \   00000040   0xF240 0x71C4      MOVW     R1,#+1988
   \   00000044   0x....             LDR.N    R0,??DataTable35_1
   \   00000046   0x.... 0x....      BL       assert_failed
   1989            
   1990            /* Get all the flags */
   1991            tmpreg = (uint32_t)(RTC->ISR & RTC_FLAGS_MASK);
   \                     ??RTC_GetFlagStatus_0: (+1)
   \   0000004A   0x....             LDR.N    R0,??DataTable35_10  ;; 0x4000280c
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0xF643 0x7177      MOVW     R1,#+16247
   \   00000052   0x4008             ANDS     R0,R1,R0
   \   00000054   0x0006             MOVS     R6,R0
   1992            
   1993            /* Return the status of the flag */
   1994            if ((tmpreg & RTC_FLAG) != (uint32_t)RESET)
   \   00000056   0x4226             TST      R6,R4
   \   00000058   0xD002             BEQ.N    ??RTC_GetFlagStatus_1
   1995            {
   1996              bitstatus = SET;
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0x0005             MOVS     R5,R0
   \   0000005E   0xE001             B.N      ??RTC_GetFlagStatus_2
   1997            }
   1998            else
   1999            {
   2000              bitstatus = RESET;
   \                     ??RTC_GetFlagStatus_1: (+1)
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x0005             MOVS     R5,R0
   2001            }
   2002            return bitstatus;
   \                     ??RTC_GetFlagStatus_2: (+1)
   \   00000064   0x0028             MOVS     R0,R5
   \   00000066   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000068   0xBD70             POP      {R4-R6,PC}       ;; return
   2003          }
   2004          
   2005          /**
   2006            * @brief  Clears the RTC's pending flags.
   2007            * @param  RTC_FLAG: specifies the RTC flag to clear.
   2008            *   This parameter can be any combination of the following values:
   2009            *     @arg RTC_FLAG_TAMP1F: Tamper 1 event flag
   2010            *     @arg RTC_FLAG_TSOVF: Time Stamp Overflow flag 
   2011            *     @arg RTC_FLAG_TSF: Time Stamp event flag
   2012            *     @arg RTC_FLAG_WUTF: WakeUp Timer flag
   2013            *     @arg RTC_FLAG_ALRBF: Alarm B flag
   2014            *     @arg RTC_FLAG_ALRAF: Alarm A flag
   2015            *     @arg RTC_FLAG_RSF: Registers Synchronized flag
   2016            * @retval None
   2017            */

   \                                 In section .text, align 2, keep-with-next
   2018          void RTC_ClearFlag(uint32_t RTC_FLAG)
   2019          {
   \                     RTC_ClearFlag: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2020            /* Check the parameters */
   2021            assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG));
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD002             BEQ.N    ??RTC_ClearFlag_0
   \   00000008   0x....             LDR.N    R0,??DataTable35_11  ;; 0xffffc0df
   \   0000000A   0x4204             TST      R4,R0
   \   0000000C   0xD004             BEQ.N    ??RTC_ClearFlag_1
   \                     ??RTC_ClearFlag_0: (+1)
   \   0000000E   0xF240 0x71E5      MOVW     R1,#+2021
   \   00000012   0x....             LDR.N    R0,??DataTable35_1
   \   00000014   0x.... 0x....      BL       assert_failed
   2022          
   2023            /* Clear the Flags in the RTC_ISR register */
   2024            RTC->ISR = (uint32_t)((uint32_t)(~((RTC_FLAG | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT)));  
   \                     ??RTC_ClearFlag_1: (+1)
   \   00000018   0xB2A0             UXTH     R0,R4            ;; ZeroExt  R0,R4,#+16,#+16
   \   0000001A   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000001E   0x....             LDR.N    R1,??DataTable35_10  ;; 0x4000280c
   \   00000020   0x6809             LDR      R1,[R1, #+0]
   \   00000022   0xF011 0x0180      ANDS     R1,R1,#0x80
   \   00000026   0xEA71 0x0000      ORNS     R0,R1,R0
   \   0000002A   0x....             LDR.N    R1,??DataTable35_10  ;; 0x4000280c
   \   0000002C   0x6008             STR      R0,[R1, #+0]
   2025          }
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
   2026          
   2027          /**
   2028            * @brief  Checks whether the specified RTC interrupt has occurred or not.
   2029            * @param  RTC_IT: specifies the RTC interrupt source to check.
   2030            *   This parameter can be one of the following values:
   2031            *     @arg RTC_IT_TS: Time Stamp interrupt 
   2032            *     @arg RTC_IT_WUT: WakeUp Timer interrupt 
   2033            *     @arg RTC_IT_ALRB: Alarm B interrupt 
   2034            *     @arg RTC_IT_ALRA: Alarm A interrupt 
   2035            *     @arg RTC_IT_TAMP1: Tamper 1 event interrupt 
   2036            * @retval The new state of RTC_IT (SET or RESET).
   2037            */

   \                                 In section .text, align 2, keep-with-next
   2038          ITStatus RTC_GetITStatus(uint32_t RTC_IT)
   2039          {
   \                     RTC_GetITStatus: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2040            ITStatus bitstatus = RESET;
   \   00000004   0x2500             MOVS     R5,#+0
   2041            uint32_t tmpreg = 0, enablestatus = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0x2700             MOVS     R7,#+0
   2042           
   2043            /* Check the parameters */
   2044            assert_param(IS_RTC_GET_IT(RTC_IT));
   \   0000000A   0xF5B4 0x4F00      CMP      R4,#+32768
   \   0000000E   0xD010             BEQ.N    ??RTC_GetITStatus_0
   \   00000010   0xF5B4 0x4F80      CMP      R4,#+16384
   \   00000014   0xD00D             BEQ.N    ??RTC_GetITStatus_0
   \   00000016   0xF5B4 0x5F00      CMP      R4,#+8192
   \   0000001A   0xD00A             BEQ.N    ??RTC_GetITStatus_0
   \   0000001C   0xF5B4 0x5F80      CMP      R4,#+4096
   \   00000020   0xD007             BEQ.N    ??RTC_GetITStatus_0
   \   00000022   0xF5B4 0x3F00      CMP      R4,#+131072
   \   00000026   0xD004             BEQ.N    ??RTC_GetITStatus_0
   \   00000028   0xF240 0x71FC      MOVW     R1,#+2044
   \   0000002C   0x....             LDR.N    R0,??DataTable35_1
   \   0000002E   0x.... 0x....      BL       assert_failed
   2045            
   2046            /* Get the TAMPER Interrupt enable bit and pending bit */
   2047            tmpreg = (uint32_t)(RTC->TAFCR & (RTC_TAFCR_TAMPIE));
   \                     ??RTC_GetITStatus_0: (+1)
   \   00000032   0x....             LDR.N    R0,??DataTable35_7  ;; 0x40002840
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0xF010 0x0004      ANDS     R0,R0,#0x4
   \   0000003A   0x0006             MOVS     R6,R0
   2048           
   2049            /* Get the Interrupt enable Status */
   2050            enablestatus = (uint32_t)((RTC->CR & RTC_IT) | (tmpreg & (RTC_IT >> 15)));
   \   0000003C   0x....             LDR.N    R0,??DataTable35  ;; 0x40002808
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x4020             ANDS     R0,R4,R0
   \   00000042   0xEA16 0x31D4      ANDS     R1,R6,R4, LSR #+15
   \   00000046   0x4308             ORRS     R0,R1,R0
   \   00000048   0x0007             MOVS     R7,R0
   2051            
   2052            /* Get the Interrupt pending bit */
   2053            tmpreg = (uint32_t)((RTC->ISR & (uint32_t)(RTC_IT >> 4)));
   \   0000004A   0x....             LDR.N    R0,??DataTable35_10  ;; 0x4000280c
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0xEA10 0x1014      ANDS     R0,R0,R4, LSR #+4
   \   00000052   0x0006             MOVS     R6,R0
   2054            
   2055            /* Get the status of the Interrupt */
   2056            if ((enablestatus != (uint32_t)RESET) && ((tmpreg & 0x0000FFFF) != (uint32_t)RESET))
   \   00000054   0x2F00             CMP      R7,#+0
   \   00000056   0xD004             BEQ.N    ??RTC_GetITStatus_1
   \   00000058   0x0430             LSLS     R0,R6,#+16
   \   0000005A   0xD002             BEQ.N    ??RTC_GetITStatus_1
   2057            {
   2058              bitstatus = SET;
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0x0005             MOVS     R5,R0
   \   00000060   0xE001             B.N      ??RTC_GetITStatus_2
   2059            }
   2060            else
   2061            {
   2062              bitstatus = RESET;
   \                     ??RTC_GetITStatus_1: (+1)
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x0005             MOVS     R5,R0
   2063            }
   2064            return bitstatus;
   \                     ??RTC_GetITStatus_2: (+1)
   \   00000066   0x0028             MOVS     R0,R5
   \   00000068   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   2065          }
   2066          
   2067          /**
   2068            * @brief  Clears the RTC's interrupt pending bits.
   2069            * @param  RTC_IT: specifies the RTC interrupt pending bit to clear.
   2070            *   This parameter can be any combination of the following values:
   2071            *     @arg RTC_IT_TS: Time Stamp interrupt 
   2072            *     @arg RTC_IT_WUT: WakeUp Timer interrupt 
   2073            *     @arg RTC_IT_ALRB: Alarm B interrupt 
   2074            *     @arg RTC_IT_ALRA: Alarm A interrupt 
   2075            *     @arg RTC_IT_TAMP1: Tamper 1 event interrupt 
   2076            * @retval None
   2077            */

   \                                 In section .text, align 2, keep-with-next
   2078          void RTC_ClearITPendingBit(uint32_t RTC_IT)
   2079          {
   \                     RTC_ClearITPendingBit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2080            uint32_t tmpreg = 0;
   \   00000004   0x2500             MOVS     R5,#+0
   2081          
   2082            /* Check the parameters */
   2083            assert_param(IS_RTC_CLEAR_IT(RTC_IT));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD003             BEQ.N    ??RTC_ClearITPendingBit_0
   \   0000000A   0xF434 0x303C      BICS     R0,R4,#0x2F000
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD004             BEQ.N    ??RTC_ClearITPendingBit_1
   \                     ??RTC_ClearITPendingBit_0: (+1)
   \   00000012   0xF640 0x0123      MOVW     R1,#+2083
   \   00000016   0x....             LDR.N    R0,??DataTable35_1
   \   00000018   0x.... 0x....      BL       assert_failed
   2084          
   2085            /* Get the RTC_ISR Interrupt pending bits mask */
   2086            tmpreg = (uint32_t)(RTC_IT >> 4);
   \                     ??RTC_ClearITPendingBit_1: (+1)
   \   0000001C   0x0920             LSRS     R0,R4,#+4
   \   0000001E   0x0005             MOVS     R5,R0
   2087          
   2088            /* Clear the interrupt pending bits in the RTC_ISR register */
   2089            RTC->ISR = (uint32_t)((uint32_t)(~((tmpreg | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT))); 
   \   00000020   0xB2A8             UXTH     R0,R5            ;; ZeroExt  R0,R5,#+16,#+16
   \   00000022   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000026   0x....             LDR.N    R1,??DataTable35_10  ;; 0x4000280c
   \   00000028   0x6809             LDR      R1,[R1, #+0]
   \   0000002A   0xF011 0x0180      ANDS     R1,R1,#0x80
   \   0000002E   0xEA71 0x0000      ORNS     R0,R1,R0
   \   00000032   0x....             LDR.N    R1,??DataTable35_10  ;; 0x4000280c
   \   00000034   0x6008             STR      R0,[R1, #+0]
   2090          }
   \   00000036   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2091          
   2092          /**
   2093            * @}
   2094            */
   2095          
   2096          /**
   2097            * @brief  Converts a 2 digit decimal to BCD format.
   2098            * @param  Value: Byte to be converted.
   2099            * @retval Converted byte
   2100            */

   \                                 In section .text, align 2, keep-with-next
   2101          static uint8_t RTC_ByteToBcd2(uint8_t Value)
   2102          {
   2103            uint8_t bcdhigh = 0;
   \                     RTC_ByteToBcd2: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   2104            
   2105            while (Value >= 10)
   \                     ??RTC_ByteToBcd2_0: (+1)
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x280A             CMP      R0,#+10
   \   00000006   0xDB02             BLT.N    ??RTC_ByteToBcd2_1
   2106            {
   2107              bcdhigh++;
   \   00000008   0x1C49             ADDS     R1,R1,#+1
   2108              Value -= 10;
   \   0000000A   0x380A             SUBS     R0,R0,#+10
   \   0000000C   0xE7F9             B.N      ??RTC_ByteToBcd2_0
   2109            }
   2110            
   2111            return  ((uint8_t)(bcdhigh << 4) | Value);
   \                     ??RTC_ByteToBcd2_1: (+1)
   \   0000000E   0xEA50 0x1001      ORRS     R0,R0,R1, LSL #+4
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x4770             BX       LR               ;; return
   2112          }
   2113          
   2114          /**
   2115            * @brief  Convert from 2 digit BCD to Binary.
   2116            * @param  Value: BCD value to be converted.
   2117            * @retval Converted word
   2118            */

   \                                 In section .text, align 2, keep-with-next
   2119          static uint8_t RTC_Bcd2ToByte(uint8_t Value)
   2120          {
   2121            uint8_t tmp = 0;
   \                     RTC_Bcd2ToByte: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   2122            tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x0902             LSRS     R2,R0,#+4
   \   00000006   0x230A             MOVS     R3,#+10
   \   00000008   0x435A             MULS     R2,R3,R2
   \   0000000A   0x0011             MOVS     R1,R2
   2123            return (tmp + (Value & (uint8_t)0x0F));
   \   0000000C   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000010   0x1840             ADDS     R0,R0,R1
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x4770             BX       LR               ;; return
   2124          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x40002800         DC32     0x40002800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x40002804         DC32     0x40002804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0x40002808         DC32     0x40002808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   0x40002814         DC32     0x40002814

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   0x007F00FF         DC32     0x7f00ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   0x40002810         DC32     0x40002810

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \   00000000   0x40002818         DC32     0x40002818

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \   00000000   0x4000281C         DC32     0x4000281c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \   00000000   0x40002820         DC32     0x40002820

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x40002840         DC32     0x40002840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x40002824         DC32     0x40002824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x4000280C         DC32     0x4000280c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0x4000280C         DC32     0x4000280c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_1:
   \   00000000   0x40002824         DC32     0x40002824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \   00000000   0x007F7F7F         DC32     0x7f7f7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30:
   \   00000000   0x00FFFF3F         DC32     0xffff3f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35:
   \   00000000   0x40002808         DC32     0x40002808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_2:
   \   00000000   0x40002818         DC32     0x40002818

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_3:
   \   00000000   0x40002824         DC32     0x40002824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_4:
   \   00000000   0xFFFFF7F7         DC32     0xfffff7f7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_5:
   \   00000000   0x40002830         DC32     0x40002830

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_6:
   \   00000000   0x40002834         DC32     0x40002834

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_7:
   \   00000000   0x40002840         DC32     0x40002840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_8:
   \   00000000   0x40002850         DC32     0x40002850

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_9:
   \   00000000   0xFFFF0FFB         DC32     0xffff0ffb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_10:
   \   00000000   0x4000280C         DC32     0x4000280c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_11:
   \   00000000   0xFFFFC0DF         DC32     0xffffc0df

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x45 0x3A          DC8 45H, 3AH, 5CH, 41H, 43H, 51H, 5CH, 50H
   \              0x5C 0x41    
   \              0x43 0x51    
   \              0x5C 0x50    
   \   00000008   0x72 0x6F          DC8 72H, 6FH, 6AH, 5FH, 76H, 65H, 72H, 30H
   \              0x6A 0x5F    
   \              0x76 0x65    
   \              0x72 0x30    
   \   00000010   0x39 0x61          DC8 39H, 61H, 5FH, 31H, 35H, 31H, 30H, 32H
   \              0x5F 0x31    
   \              0x35 0x31    
   \              0x30 0x32    
   \   00000018   0x30 0x31          DC8 30H, 31H, 35H, 5CH, 45H, 6EH, 64H, 5FH
   \              0x35 0x5C    
   \              0x45 0x6E    
   \              0x64 0x5F    
   \   00000020   0x30 0x32          DC8 30H, 32H, 5CH, 32H, 30H, 31H, 33H, 5FH
   \              0x5C 0x32    
   \              0x30 0x31    
   \              0x33 0x5F    
   \   00000028   0x31 0x31          DC8 31H, 31H, 5FH, 32H, 35H, 5FH, 53H, 70H
   \              0x5F 0x32    
   \              0x35 0x5F    
   \              0x53 0x70    
   \   00000030   0x69 0x72          DC8 69H, 72H, 69H, 74H, 31H, 5FH, 45H, 6CH
   \              0x69 0x74    
   \              0x31 0x5F    
   \              0x45 0x6C    
   \   00000038   0x65 0x6B          DC8 65H, 6BH, 74H, 72H, 6FH, 6CH, 75H, 78H
   \              0x74 0x72    
   \              0x6F 0x6C    
   \              0x75 0x78    
   \   00000040   0x5C 0x53          DC8 5CH, 53H, 54H, 4DH, 33H, 32H, 4CH, 5CH
   \              0x54 0x4D    
   \              0x33 0x32    
   \              0x4C 0x5C    
   \   00000048   0x53 0x54          DC8 53H, 54H, 4DH, 33H, 32H, 4CH, 31H, 78H
   \              0x4D 0x33    
   \              0x32 0x4C    
   \              0x31 0x78    
   \   00000050   0x78 0x5F          DC8 78H, 5FH, 53H, 74H, 64H, 50H, 65H, 72H
   \              0x53 0x74    
   \              0x64 0x50    
   \              0x65 0x72    
   \   00000058   0x69 0x70          DC8 69H, 70H, 68H, 5FH, 4CH, 69H, 62H, 5CH
   \              0x68 0x5F    
   \              0x4C 0x69    
   \              0x62 0x5C    
   \   00000060   0x53 0x6F          DC8 53H, 6FH, 75H, 72H, 63H, 65H, 5CH, 53H
   \              0x75 0x72    
   \              0x63 0x65    
   \              0x5C 0x53    
   \   00000068   0x54 0x4D          DC8 54H, 4DH, 33H, 32H, 4CH, 31H, 78H, 78H
   \              0x33 0x32    
   \              0x4C 0x31    
   \              0x78 0x78    
   \   00000070   0x5F 0x53          DC8 5FH, 53H, 74H, 64H, 50H, 65H, 72H, 69H
   \              0x74 0x64    
   \              0x50 0x65    
   \              0x72 0x69    
   \   00000078   0x70 0x68          DC8 70H, 68H, 5FH, 44H, 72H, 69H, 76H, 65H
   \              0x5F 0x44    
   \              0x72 0x69    
   \              0x76 0x65    
   \   00000080   0x72 0x5C          DC8 72H, 5CH, 73H, 72H, 63H, 5CH, 73H, 74H
   \              0x73 0x72    
   \              0x63 0x5C    
   \              0x73 0x74    
   \   00000088   0x6D 0x33          DC8 6DH, 33H, 32H, 6CH, 31H, 78H, 78H, 5FH
   \              0x32 0x6C    
   \              0x31 0x78    
   \              0x78 0x5F    
   \   00000090   0x72 0x74          DC8 72H, 74H, 63H, 2EH, 63H, 0
   \              0x63 0x2E    
   \              0x63 0x00    
   \   00000096   0x00 0x00          DC8 0, 0
   2125          
   2126          /**
   2127            * @}
   2128            */ 
   2129          
   2130          /**
   2131            * @}
   2132            */ 
   2133          
   2134          /**
   2135            * @}
   2136            */ 
   2137          
   2138          /******************* (C) COPYRIGHT 2010 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   RTC_AlarmCmd
        24   -> assert_failed
       0   RTC_AlarmStructInit
       0   RTC_Bcd2ToByte
       0   RTC_ByteToBcd2
       8   RTC_CalibOutputCmd
         8   -> assert_failed
       8   RTC_ClearFlag
         8   -> assert_failed
      16   RTC_ClearITPendingBit
        16   -> assert_failed
       0   RTC_DateStructInit
      16   RTC_DayLightSavingConfig
        16   -> assert_failed
      16   RTC_DeInit
        16   -> RTC_EnterInitMode
        16   -> RTC_WaitForSynchro
      16   RTC_DigitalCalibCmd
        16   -> RTC_EnterInitMode
        16   -> RTC_ExitInitMode
        16   -> assert_failed
      16   RTC_DigitalCalibConfig
        16   -> RTC_EnterInitMode
        16   -> RTC_ExitInitMode
        16   -> assert_failed
       4   RTC_EnterInitMode
       0   RTC_ExitInitMode
      24   RTC_GetAlarm
        24   -> RTC_Bcd2ToByte
        24   -> assert_failed
      16   RTC_GetDate
        16   -> RTC_Bcd2ToByte
        16   -> assert_failed
      16   RTC_GetFlagStatus
        16   -> assert_failed
      24   RTC_GetITStatus
        24   -> assert_failed
       0   RTC_GetStoreOperation
      16   RTC_GetTime
        16   -> RTC_Bcd2ToByte
        16   -> assert_failed
      24   RTC_GetTimeStamp
        24   -> RTC_Bcd2ToByte
        24   -> assert_failed
       0   RTC_GetWakeUpCounter
      16   RTC_ITConfig
        16   -> assert_failed
      16   RTC_Init
        16   -> RTC_EnterInitMode
        16   -> RTC_ExitInitMode
        16   -> assert_failed
      16   RTC_OutputConfig
        16   -> assert_failed
       8   RTC_OutputTypeConfig
         8   -> assert_failed
      16   RTC_ReadBackupRegister
        16   -> assert_failed
      16   RTC_RefClockCmd
        16   -> RTC_EnterInitMode
        16   -> RTC_ExitInitMode
        16   -> assert_failed
      32   RTC_SetAlarm
        32   -> RTC_Bcd2ToByte
        32   -> RTC_ByteToBcd2
        32   -> assert_failed
      32   RTC_SetDate
        32   -> RTC_Bcd2ToByte
        32   -> RTC_ByteToBcd2
        32   -> RTC_EnterInitMode
        32   -> RTC_ExitInitMode
        32   -> RTC_WaitForSynchro
        32   -> assert_failed
      32   RTC_SetTime
        32   -> RTC_Bcd2ToByte
        32   -> RTC_ByteToBcd2
        32   -> RTC_EnterInitMode
        32   -> RTC_ExitInitMode
        32   -> RTC_WaitForSynchro
        32   -> assert_failed
       8   RTC_SetWakeUpCounter
         8   -> assert_failed
       0   RTC_StructInit
      16   RTC_TamperCmd
        16   -> assert_failed
      16   RTC_TamperTriggerConfig
        16   -> assert_failed
      16   RTC_TimeStampCmd
        16   -> assert_failed
       0   RTC_TimeStructInit
       4   RTC_WaitForSynchro
       8   RTC_WakeUpClockConfig
         8   -> assert_failed
      24   RTC_WakeUpCmd
        24   -> assert_failed
      16   RTC_WriteBackupRegister
        16   -> assert_failed
       8   RTC_WriteProtectionCmd
         8   -> assert_failed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable18
       4  ??DataTable19
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable26
       4  ??DataTable30
       4  ??DataTable35
       4  ??DataTable35_1
       4  ??DataTable35_10
       4  ??DataTable35_11
       4  ??DataTable35_2
       4  ??DataTable35_3
       4  ??DataTable35_4
       4  ??DataTable35_5
       4  ??DataTable35_6
       4  ??DataTable35_7
       4  ??DataTable35_8
       4  ??DataTable35_9
     152  ?_0
     156  RTC_AlarmCmd
      30  RTC_AlarmStructInit
      22  RTC_Bcd2ToByte
      22  RTC_ByteToBcd2
      94  RTC_CalibOutputCmd
      48  RTC_ClearFlag
      56  RTC_ClearITPendingBit
      18  RTC_DateStructInit
     106  RTC_DayLightSavingConfig
     226  RTC_DeInit
     122  RTC_DigitalCalibCmd
     100  RTC_DigitalCalibConfig
      92  RTC_EnterInitMode
      18  RTC_ExitInitMode
     158  RTC_GetAlarm
     104  RTC_GetDate
     106  RTC_GetFlagStatus
     108  RTC_GetITStatus
      12  RTC_GetStoreOperation
     102  RTC_GetTime
     180  RTC_GetTimeStamp
       8  RTC_GetWakeUpCounter
     132  RTC_ITConfig
     178  RTC_Init
     116  RTC_OutputConfig
      48  RTC_OutputTypeConfig
     118  RTC_ReadBackupRegister
     122  RTC_RefClockCmd
     698  RTC_SetAlarm
     418  RTC_SetDate
     448  RTC_SetTime
      44  RTC_SetWakeUpCounter
      14  RTC_StructInit
      82  RTC_TamperCmd
      82  RTC_TamperTriggerConfig
     114  RTC_TimeStampCmd
      18  RTC_TimeStructInit
     106  RTC_WaitForSynchro
      80  RTC_WakeUpClockConfig
     150  RTC_WakeUpCmd
     118  RTC_WriteBackupRegister
      62  RTC_WriteProtectionCmd

 
   152 bytes in section .rodata
 5 152 bytes in section .text
 
 5 152 bytes of CODE  memory
   152 bytes of CONST memory

Errors: none
Warnings: none
