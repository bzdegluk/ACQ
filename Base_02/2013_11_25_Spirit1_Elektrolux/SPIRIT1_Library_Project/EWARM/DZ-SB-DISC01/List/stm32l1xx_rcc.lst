###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        20/Nov/2015  05:05:48
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_rcc.c
#    Command line =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_rcc.c
#        -D USE_STDPERIPH_DRIVER -D VECT_TAB_FLASH -D STM32L1XX_MD -D
#        IAR_ARM_CM3 -D USE_FULL_ASSERT -D SPIRIT_USE_FULL_ASSERT -D
#        USE_SYSTICK_DELAY -D SDK -lC
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\List\
#        -o
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\.\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\examples\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\runtime\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\SDK_Eval_STM32L\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\SPIRIT1_Library\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\SDK_Eval_Util\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\SDK_Virtual_Com\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32_USB-FS-Device_Lib\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\ACQ\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\CMSIS\Include\"
#    List file    =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\List\stm32l1xx_rcc.lst
#    Object file  =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\Obj\stm32l1xx_rcc.o
#
###############################################################################

E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_rcc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_rcc.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    31-December-2010
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Reset and clock control (RCC) peripheral:           
      9            *           - Internal/external clocks, PLL, CSS and MCO configuration
     10            *           - System, AHB and APB busses clocks configuration
     11            *           - Peripheral clocks configuration
     12            *           - Interrupts and flags management
     13            *
     14            *  @verbatim
     15            *               
     16            *          ===================================================================
     17            *                               RCC specific features
     18            *          ===================================================================
     19            *    
     20            *          After reset the device is running from MSI (2 MHz) with Flash 0 WS, 
     21            *          all peripherals are off except internal SRAM, Flash and JTAG.
     22            *           - There is no prescaler on High speed (AHB) and Low speed (APB) busses;
     23            *             all peripherals mapped on these busses are running at MSI speed.
     24            *       	  - The clock for all peripherals is switched off, except the SRAM and FLASH.
     25            *           - All GPIOs are in input floating state, except the JTAG pins which
     26            *             are assigned to be used for debug purpose.
     27            *        
     28            *          Once the device started from reset, the user application has to:        
     29            *           - Configure the clock source to be used to drive the System clock
     30            *             (if the application needs higher frequency/performance)
     31            *           - Configure the System clock frequency and Flash settings  
     32            *           - Configure the AHB and APB busses prescalers
     33            *           - Enable the clock for the peripheral(s) to be used
     34            *           - Configure the clock source(s) for peripherals whose clocks are not
     35            *             derived from the System clock (ADC, RTC/LCD and IWDG)      
     36            *                        
     37            *  @endverbatim
     38            *    
     39            ******************************************************************************
     40            * @attention
     41            *
     42            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     43            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     44            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     45            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     46            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     47            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     48            *
     49            * <h2><center>&copy; COPYRIGHT 2010 STMicroelectronics</center></h2>
     50            ******************************************************************************  
     51            */ 
     52          
     53          /* Includes ------------------------------------------------------------------*/
     54          #include "stm32l1xx_rcc.h"
     55          
     56          /** @addtogroup STM32L1xx_StdPeriph_Driver
     57            * @{
     58            */
     59          
     60          /** @defgroup RCC 
     61            * @brief RCC driver modules
     62            * @{
     63            */ 
     64          
     65          /* Private typedef -----------------------------------------------------------*/
     66          /* Private define ------------------------------------------------------------*/
     67          
     68          /* ------------ RCC registers bit address in the alias region ----------- */
     69          #define RCC_OFFSET                (RCC_BASE - PERIPH_BASE)
     70          
     71          /* --- CR Register ---*/
     72          
     73          /* Alias word address of HSION bit */
     74          #define CR_OFFSET                 (RCC_OFFSET + 0x00)
     75          #define HSION_BitNumber           0x00
     76          #define CR_HSION_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (HSION_BitNumber * 4))
     77          
     78          /* Alias word address of MSION bit */
     79          #define MSION_BitNumber           0x08
     80          #define CR_MSION_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (MSION_BitNumber * 4))
     81          
     82          /* Alias word address of PLLON bit */
     83          #define PLLON_BitNumber           0x18
     84          #define CR_PLLON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLLON_BitNumber * 4))
     85          
     86          /* Alias word address of CSSON bit */
     87          #define CSSON_BitNumber           0x1C
     88          #define CR_CSSON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (CSSON_BitNumber * 4))
     89          
     90          /* --- CSR Register ---*/
     91          
     92          /* Alias word address of LSION bit */
     93          #define CSR_OFFSET                (RCC_OFFSET + 0x34)
     94          #define LSION_BitNumber           0x00
     95          #define CSR_LSION_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (LSION_BitNumber * 4))
     96          
     97          /* Alias word address of RTCEN bit */
     98          #define RTCEN_BitNumber           0x16
     99          #define CSR_RTCEN_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (RTCEN_BitNumber * 4))
    100          
    101          /* Alias word address of RTCRST bit */
    102          #define RTCRST_BitNumber          0x17
    103          #define CSR_RTCRST_BB             (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (RTCRST_BitNumber * 4))
    104          
    105          
    106          /* ---------------------- RCC registers mask -------------------------------- */
    107          /* RCC Flag Mask */
    108          #define FLAG_MASK                 ((uint8_t)0x1F)
    109          
    110          /* CR register byte 3 (Bits[23:16]) base address */
    111          #define CR_BYTE3_ADDRESS          ((uint32_t)0x40023802)
    112          
    113          /* ICSCR register byte 4 (Bits[31:24]) base address */
    114          #define ICSCR_BYTE4_ADDRESS       ((uint32_t)0x40023807)
    115          
    116          /* CFGR register byte 3 (Bits[23:16]) base address */
    117          #define CFGR_BYTE3_ADDRESS        ((uint32_t)0x4002380A)
    118          
    119          /* CFGR register byte 4 (Bits[31:24]) base address */
    120          #define CFGR_BYTE4_ADDRESS        ((uint32_t)0x4002380B)
    121          
    122          /* CIR register byte 2 (Bits[15:8]) base address */
    123          #define CIR_BYTE2_ADDRESS         ((uint32_t)0x4002380D)
    124          
    125          /* CIR register byte 3 (Bits[23:16]) base address */
    126          #define CIR_BYTE3_ADDRESS         ((uint32_t)0x4002380E)
    127          
    128          /* CSR register byte 2 (Bits[15:8]) base address */
    129          #define CSR_BYTE2_ADDRESS         ((uint32_t)0x40023835)
    130          
    131          /* Private macro -------------------------------------------------------------*/
    132          /* Private variables ---------------------------------------------------------*/
    133          

   \                                 In section .data, align 4
    134          static __I uint8_t PLLMulTable[9] = {3, 4, 6, 8, 12, 16, 24, 32, 48};
   \                     PLLMulTable:
   \   00000000   0x03 0x04          DC8 3, 4, 6, 8, 12, 16, 24, 32, 48, 0, 0, 0
   \              0x06 0x08    
   \              0x0C 0x10    
   \              0x18 0x20    
   \              0x30 0x00    
   \              0x00 0x00    

   \                                 In section .data, align 4
    135          static __I uint8_t APBAHBPrescTable[16] = {0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9};
   \                     APBAHBPrescTable:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9
   \              0x00 0x00    
   \              0x01 0x02    
   \              0x03 0x04    
   \              0x01 0x02    
   \              0x03 0x04    
   \              0x06 0x07    
   \              0x08 0x09    
    136          
    137          /* Private function prototypes -----------------------------------------------*/
    138          /* Private functions ---------------------------------------------------------*/
    139          
    140          /** @defgroup RCC_Private_Functions
    141            * @{
    142            */
    143          
    144          /** @defgroup RCC_Group1 Internal and external clocks, PLL, CSS and MCO configuration functions
    145           *  @brief   Internal and external clocks, PLL, CSS and MCO configuration functions 
    146           *
    147          @verbatim   
    148           ===============================================================================
    149                Internal/external clocks, PLL, CSS and MCO configuration functions
    150           ===============================================================================  
    151          
    152            This section provide functions allowing to configure the internal/external clocks,
    153            PLL, CSS and MCO.
    154            
    155            1. HSI (high-speed internal), 16 MHz factory-trimmed RC used directly or through
    156               the PLL as System clock source.
    157          
    158            2. MSI (multi-speed internal), multispeed low power RC (65.536 KHz to 4.194 MHz)
    159               MHz used as System clock source.
    160          
    161            3. LSI (low-speed internal), 37 KHz low consumption RC used as IWDG and/or RTC
    162               clock source.
    163          
    164            4. HSE (high-speed external), 1 to 24 MHz crystal oscillator used directly or
    165               through the PLL as System clock source. Can be used also as RTC clock source.
    166          
    167            5. LSE (low-speed external), 32 KHz oscillator used as RTC clock source.   
    168          
    169            6. PLL (clocked by HSI or HSE), for System clock and USB (48 MHz).
    170          
    171            7. CSS (Clock security system), once enable and if a HSE clock failure occurs 
    172               (HSE used directly or through PLL as System clock source), the System clock
    173               is automatically switched to MSI and an interrupt is generated if enabled. 
    174               The interrupt is linked to the Cortex-M3 NMI (Non-Maskable Interrupt) 
    175               exception vector.   
    176          
    177            8. MCO (microcontroller clock output), used to output SYSCLK, HSI, MSI, HSE, PLL,
    178               LSI or LSE clock (through a configurable prescaler) on PA8 pin.
    179          
    180          @endverbatim
    181            * @{
    182            */
    183          
    184          /**
    185            * @brief  Resets the RCC clock configuration to the default reset state.
    186            * @note   - The default reset state of the clock configuration is given below:
    187            *            - MSI ON and used as system clock source (MSI range is not modified
    188            *              by this function, it keep the value configured by user application)
    189            *            - HSI, HSE and PLL OFF
    190            *            - AHB, APB1 and APB2 prescaler set to 1.
    191            *            - CSS and MCO OFF
    192            *            - All interrupts disabled
    193            *         - However, this function doesn't modify the configuration of the
    194            *            - Peripheral clocks
    195            *            - LSI, LSE and RTC clocks                  
    196            * @param  None
    197            * @retval None
    198            */

   \                                 In section .text, align 2, keep-with-next
    199          void RCC_DeInit(void)
    200          {
    201            
    202            /* Set MSION bit */
    203            RCC->CR |= (uint32_t)0x00000100;
   \                     RCC_DeInit: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable33  ;; 0x40023800
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable33  ;; 0x40023800
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    204          
    205            /* Reset SW[1:0], HPRE[3:0], PPRE1[2:0], PPRE2[2:0], MCOSEL[2:0] and MCOPRE[2:0] bits */
    206            RCC->CFGR &= (uint32_t)0x88FFC00C;
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable33_1  ;; 0x40023808
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable33_2  ;; 0x88ffc00c
   \   0000001A   0x4008             ANDS     R0,R1,R0
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable33_1  ;; 0x40023808
   \   00000020   0x6008             STR      R0,[R1, #+0]
    207            
    208            /* Reset HSION, HSEON, CSSON and PLLON bits */
    209            RCC->CR &= (uint32_t)0xEEFEFFFE;
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable33  ;; 0x40023800
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable34  ;; 0xeefefffe
   \   0000002C   0x4008             ANDS     R0,R1,R0
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable33  ;; 0x40023800
   \   00000032   0x6008             STR      R0,[R1, #+0]
    210          
    211            /* Reset HSEBYP bit */
    212            RCC->CR &= (uint32_t)0xFFFBFFFF;
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable33  ;; 0x40023800
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0xF430 0x2080      BICS     R0,R0,#0x40000
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable33  ;; 0x40023800
   \   00000042   0x6008             STR      R0,[R1, #+0]
    213          
    214            /* Reset PLLSRC, PLLMUL[3:0] and PLLDIV[1:0] bits */
    215            RCC->CFGR &= (uint32_t)0xFF02FFFF;
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable33_1  ;; 0x40023808
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0xF430 0x007D      BICS     R0,R0,#0xFD0000
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable33_1  ;; 0x40023808
   \   00000052   0x6008             STR      R0,[R1, #+0]
    216          
    217            /* Disable all interrupts */
    218            RCC->CIR = 0x00000000;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable35  ;; 0x4002380c
   \   0000005A   0x6008             STR      R0,[R1, #+0]
    219          }
   \   0000005C   0x4770             BX       LR               ;; return
    220          
    221          /**
    222            * @brief  Configures the External High Speed oscillator (HSE).
    223            * @note   - After enabling the HSE (RCC_HSE_ON or RCC_HSE_Bypass), the application
    224            *           software should wait on HSERDY flag to be set indicating that HSE clock
    225            *           is stable and can be used to clock the PLL and/or system clock.
    226            *         - HSE state can not be changed if it is used directly or through the
    227            *           PLL as system clock. In this case, you have to select another source
    228            *           of the system clock then change the HSE state (ex. disable it).
    229            *         - The HSE is stopped by hardware when entering STOP and STANDBY modes.         
    230            * @note   This function reset the CSSON bit, so if the Clock security system(CSS)
    231            *         was previously enabled you have to enable it again after calling this
    232            *         function.
    233            * @param RCC_HSE: specifies the new state of the HSE.
    234            *   This parameter can be one of the following values:
    235            *     @arg RCC_HSE_OFF: turn OFF the HSE oscillator, HSERDY flag goes low after
    236            *                       6 HSE oscillator clock cycles.
    237            *     @arg RCC_HSE_ON: turn ON the HSE oscillator
    238            *     @arg RCC_HSE_Bypass: HSE oscillator bypassed with external clock
    239            * @retval None
    240            */

   \                                 In section .text, align 2, keep-with-next
    241          void RCC_HSEConfig(uint8_t RCC_HSE)
    242          {
   \                     RCC_HSEConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    243            /* Check the parameters */
    244            assert_param(IS_RCC_HSE(RCC_HSE));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD00A             BEQ.N    ??RCC_HSEConfig_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD007             BEQ.N    ??RCC_HSEConfig_0
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C05             CMP      R4,#+5
   \   00000014   0xD004             BEQ.N    ??RCC_HSEConfig_0
   \   00000016   0x21F4             MOVS     R1,#+244
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   0000001C   0x.... 0x....      BL       assert_failed
    245          
    246            /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
    247            *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE_OFF;
   \                     ??RCC_HSEConfig_0: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable35_2  ;; 0x40023802
   \   00000026   0x7008             STRB     R0,[R1, #+0]
    248          
    249            /* Set the new HSE configuration -------------------------------------------*/
    250            *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE;
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable35_2  ;; 0x40023802
   \   0000002C   0x7004             STRB     R4,[R0, #+0]
    251          
    252          }
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
    253          
    254          /**
    255            * @brief  Waits for HSE start-up.
    256            * @note   This functions waits on HSERDY flag to be set and return SUCCESS if 
    257            *         this flag is set, otherwise returns ERROR if the timeout is reached 
    258            *         and this flag is not set. The timeout value is defined by the constant
    259            *         HSE_STARTUP_TIMEOUT in stm32l1xx.h file. You can tailor it depending
    260            *         on the HSE crystal used in your application. 
    261            * @param  None
    262            * @retval An ErrorStatus enumeration value:
    263            *          - SUCCESS: HSE oscillator is stable and ready to use
    264            *          - ERROR: HSE oscillator not yet ready
    265            */

   \                                 In section .text, align 2, keep-with-next
    266          ErrorStatus RCC_WaitForHSEStartUp(void)
    267          {
   \                     RCC_WaitForHSEStartUp: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    268            __IO uint32_t StartUpCounter = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x9000             STR      R0,[SP, #+0]
    269            ErrorStatus status = ERROR;
   \   00000006   0x2400             MOVS     R4,#+0
    270            FlagStatus HSEStatus = RESET;
   \   00000008   0x2500             MOVS     R5,#+0
    271            
    272            /* Wait till HSE is ready and if timeout is reached exit */
    273            do
    274            {
    275              HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
   \                     ??RCC_WaitForHSEStartUp_0: (+1)
   \   0000000A   0x2031             MOVS     R0,#+49
   \   0000000C   0x.... 0x....      BL       RCC_GetFlagStatus
   \   00000010   0x0005             MOVS     R5,R0
    276              StartUpCounter++;  
   \   00000012   0x9800             LDR      R0,[SP, #+0]
   \   00000014   0x1C40             ADDS     R0,R0,#+1
   \   00000016   0x9000             STR      R0,[SP, #+0]
    277            } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
   \   00000018   0x9800             LDR      R0,[SP, #+0]
   \   0000001A   0xF5B0 0x6FA0      CMP      R0,#+1280
   \   0000001E   0xD002             BEQ.N    ??RCC_WaitForHSEStartUp_1
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD0F1             BEQ.N    ??RCC_WaitForHSEStartUp_0
    278            
    279            if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
   \                     ??RCC_WaitForHSEStartUp_1: (+1)
   \   00000026   0x2031             MOVS     R0,#+49
   \   00000028   0x.... 0x....      BL       RCC_GetFlagStatus
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD002             BEQ.N    ??RCC_WaitForHSEStartUp_2
    280            {
    281              status = SUCCESS;
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x0004             MOVS     R4,R0
   \   00000034   0xE001             B.N      ??RCC_WaitForHSEStartUp_3
    282            }
    283            else
    284            {
    285              status = ERROR;
   \                     ??RCC_WaitForHSEStartUp_2: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x0004             MOVS     R4,R0
    286            }  
    287            return (status);
   \                     ??RCC_WaitForHSEStartUp_3: (+1)
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    288          }
    289          
    290          /**
    291            * @brief  Adjusts the Internal Multi Speed oscillator (MSI) calibration value.
    292            * @note   The calibration is used to compensate for the variations in voltage
    293            *         and temperature that influence the frequency of the internal MSI RC.
    294            *         Refer to the Application Note AN3300 for more details on how to  
    295            *         calibrate the MSI.
    296            * @param  MSICalibrationValue: specifies the MSI calibration trimming value.
    297            *   This parameter must be a number between 0 and 0xFF.
    298            * @retval None
    299            */

   \                                 In section .text, align 2, keep-with-next
    300          void RCC_AdjustMSICalibrationValue(uint8_t MSICalibrationValue)
    301          {
   \                     RCC_AdjustMSICalibrationValue: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    302            
    303            /* Check the parameters */
    304            assert_param(IS_RCC_MSI_CALIBRATION_VALUE(MSICalibrationValue));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C40             CMP      R4,#+64
   \   00000008   0xDB05             BLT.N    ??RCC_AdjustMSICalibrationValue_0
   \   0000000A   0xF44F 0x7198      MOV      R1,#+304
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   00000012   0x.... 0x....      BL       assert_failed
    305          
    306            *(__IO uint8_t *) ICSCR_BYTE4_ADDRESS = MSICalibrationValue;  
   \                     ??RCC_AdjustMSICalibrationValue_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable35_3  ;; 0x40023807
   \   0000001A   0x7004             STRB     R4,[R0, #+0]
    307          }
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    308          
    309          /**
    310            * @brief  Configures the Internal Multi Speed oscillator (MSI) clock range.
    311            * @note   - After restart from Reset or wakeup from STANDBY, the MSI clock is 
    312            *           around 2.097 MHz. The MSI clock does not change after wake-up from
    313            *           STOP mode.
    314            *         - The MSI clock range can be modified on the fly.     
    315            * @param  RCC_MSIRange: specifies the MSI Clock range.
    316            *   This parameter must be one of the following values:
    317            *     @arg RCC_MSIRange_0: MSI clock is around 65.536 KHz
    318            *     @arg RCC_MSIRange_1: MSI clock is around 131.072 KHz
    319            *     @arg RCC_MSIRange_2: MSI clock is around 262.144 KHz
    320            *     @arg RCC_MSIRange_3: MSI clock is around 524.288 KHz
    321            *     @arg RCC_MSIRange_4: MSI clock is around 1.048 MHz
    322            *     @arg RCC_MSIRange_5: MSI clock is around 2.097 MHz (default after Reset or wake-up from STANDBY)
    323            *     @arg RCC_MSIRange_6: MSI clock is around 
    324            *                   
    325            * @retval None
    326            */

   \                                 In section .text, align 2, keep-with-next
    327          void RCC_MSIRangeConfig(uint32_t RCC_MSIRange)
    328          {
   \                     RCC_MSIRangeConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    329            uint32_t tmpreg = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    330            
    331            /* Check the parameters */
    332            assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_MSIRange));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD017             BEQ.N    ??RCC_MSIRangeConfig_0
   \   0000000A   0xF5B4 0x5F00      CMP      R4,#+8192
   \   0000000E   0xD014             BEQ.N    ??RCC_MSIRangeConfig_0
   \   00000010   0xF5B4 0x4F80      CMP      R4,#+16384
   \   00000014   0xD011             BEQ.N    ??RCC_MSIRangeConfig_0
   \   00000016   0xF5B4 0x4FC0      CMP      R4,#+24576
   \   0000001A   0xD00E             BEQ.N    ??RCC_MSIRangeConfig_0
   \   0000001C   0xF5B4 0x4F00      CMP      R4,#+32768
   \   00000020   0xD00B             BEQ.N    ??RCC_MSIRangeConfig_0
   \   00000022   0xF5B4 0x4F20      CMP      R4,#+40960
   \   00000026   0xD008             BEQ.N    ??RCC_MSIRangeConfig_0
   \   00000028   0xF5B4 0x4F40      CMP      R4,#+49152
   \   0000002C   0xD005             BEQ.N    ??RCC_MSIRangeConfig_0
   \   0000002E   0xF44F 0x71A6      MOV      R1,#+332
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   00000036   0x.... 0x....      BL       assert_failed
    333            
    334            tmpreg = RCC->ICSCR;
   \                     ??RCC_MSIRangeConfig_0: (+1)
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable35_4  ;; 0x40023804
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x0005             MOVS     R5,R0
    335            
    336            /* Clear MSIRANGE[2:0] bits */
    337            tmpreg &= ~RCC_ICSCR_MSIRANGE;
   \   00000042   0xF435 0x4560      BICS     R5,R5,#0xE000
    338            
    339            /* Set the MSIRANGE[2:0] bits according to RCC_MSIRange value */
    340            tmpreg |= (uint32_t)RCC_MSIRange;
   \   00000046   0x4325             ORRS     R5,R4,R5
    341          
    342            /* Store the new value */
    343            RCC->ICSCR = tmpreg;
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable35_4  ;; 0x40023804
   \   0000004C   0x6005             STR      R5,[R0, #+0]
    344          }
   \   0000004E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    345          
    346          /**
    347            * @brief  Enables or disables the Internal Multi Speed oscillator (MSI).
    348            * @note   - The MSI is stopped by hardware when entering STOP and STANDBY modes.
    349            *           It is used (enabled by hardware) as system clock source after
    350            *           startup from Reset, wakeup from STOP and STANDBY mode, or in case
    351            *           of failure of the HSE used directly or indirectly as system clock
    352            *           (if the Clock Security System CSS is enabled).             
    353            *         - MSI can not be stopped if it is used as system clock source.
    354            *           In this case, you have to select another source of the system
    355            *           clock then stop the MSI.  
    356            *         - After enabling the MSI, the application software should wait on
    357            *           MSIRDY flag to be set indicating that MSI clock is stable and can
    358            *           be used as system clock source.                                       
    359            * @param  NewState: new state of the MSI.
    360            *   This parameter can be: ENABLE or DISABLE.
    361            * @note   When the MSI is stopped, MSIRDY flag goes low after 6 MSI oscillator
    362            *         clock cycles.  
    363            * @retval None
    364            */

   \                                 In section .text, align 2, keep-with-next
    365          void RCC_MSICmd(FunctionalState NewState)
    366          {
   \                     RCC_MSICmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    367            /* Check the parameters */
    368            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD008             BEQ.N    ??RCC_MSICmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD005             BEQ.N    ??RCC_MSICmd_0
   \   00000010   0xF44F 0x71B8      MOV      R1,#+368
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   00000018   0x.... 0x....      BL       assert_failed
    369            
    370            *(__IO uint32_t *) CR_MSION_BB = (uint32_t)NewState;
   \                     ??RCC_MSICmd_0: (+1)
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable35_5  ;; 0x42470020
   \   00000022   0x6004             STR      R4,[R0, #+0]
    371          }
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    372          
    373          /**
    374            * @brief  Adjusts the Internal High Speed oscillator (HSI) calibration value.
    375            * @note   The calibration is used to compensate for the variations in voltage
    376            *         and temperature that influence the frequency of the internal HSI RC.
    377            *         Refer to the Application Note AN3300 for more details on how to  
    378            *         calibrate the HSI.
    379            * @param  HSICalibrationValue: specifies the HSI calibration trimming value.
    380            *   This parameter must be a number between 0 and 0x1F.
    381            * @retval None
    382            */

   \                                 In section .text, align 2, keep-with-next
    383          void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
    384          {
   \                     RCC_AdjustHSICalibrationValue: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    385            uint32_t tmpreg = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    386            
    387            /* Check the parameters */
    388            assert_param(IS_RCC_HSI_CALIBRATION_VALUE(HSICalibrationValue));
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C20             CMP      R4,#+32
   \   0000000A   0xDB05             BLT.N    ??RCC_AdjustHSICalibrationValue_0
   \   0000000C   0xF44F 0x71C2      MOV      R1,#+388
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   00000014   0x.... 0x....      BL       assert_failed
    389            
    390            tmpreg = RCC->ICSCR;
   \                     ??RCC_AdjustHSICalibrationValue_0: (+1)
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable35_4  ;; 0x40023804
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x0005             MOVS     R5,R0
    391            
    392            /* Clear HSITRIM[4:0] bits */
    393            tmpreg &= ~RCC_ICSCR_HSITRIM;
   \   00000020   0xF435 0x55F8      BICS     R5,R5,#0x1F00
    394            
    395            /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
    396            tmpreg |= (uint32_t)HSICalibrationValue << 8;
   \   00000024   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000026   0xEA55 0x2504      ORRS     R5,R5,R4, LSL #+8
    397          
    398            /* Store the new value */
    399            RCC->ICSCR = tmpreg;
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable35_4  ;; 0x40023804
   \   0000002E   0x6005             STR      R5,[R0, #+0]
    400          }
   \   00000030   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    401          
    402          /**
    403            * @brief  Enables or disables the Internal High Speed oscillator (HSI).
    404            * @note   - After enabling the HSI, the application software should wait on 
    405            *           HSIRDY flag to be set indicating that HSI clock is stable and can
    406            *           be used to clock the PLL and/or system clock.
    407            *         - HSI can not be stopped if it is used directly or through the PLL
    408            *           as system clock. In this case, you have to select another source 
    409            *           of the system clock then stop the HSI.
    410            *         - The HSI is stopped by hardware when entering STOP and STANDBY modes. 
    411            * @param  NewState: new state of the HSI.
    412            *   This parameter can be: ENABLE or DISABLE.
    413            * @note   When the HSI is stopped, HSIRDY flag goes low after 6 HSI oscillator
    414            *         clock cycles.  
    415            * @retval None
    416            */

   \                                 In section .text, align 2, keep-with-next
    417          void RCC_HSICmd(FunctionalState NewState)
    418          {
   \                     RCC_HSICmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    419            /* Check the parameters */
    420            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD008             BEQ.N    ??RCC_HSICmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD005             BEQ.N    ??RCC_HSICmd_0
   \   00000010   0xF44F 0x71D2      MOV      R1,#+420
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   00000018   0x.... 0x....      BL       assert_failed
    421            
    422            *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
   \                     ??RCC_HSICmd_0: (+1)
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable35_6  ;; 0x42470000
   \   00000022   0x6004             STR      R4,[R0, #+0]
    423          }
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    424          
    425          /**
    426            * @brief  Configures the External Low Speed oscillator (LSE).
    427            * @note   - As the LSE is in the RTC domain and write access is denied to this
    428            *           domain after reset, you have to enable write access using 
    429            *           PWR_RTCAccessCmd(ENABLE) function before to configure the LSE
    430            *           (to be done once after reset).  
    431            *         - After enabling the LSE (RCC_LSE_ON or RCC_LSE_Bypass), the application
    432            *           software should wait on LSERDY flag to be set indicating that LSE clock
    433            *           is stable and can be used to clock the RTC.
    434            * @param  RCC_LSE: specifies the new state of the LSE.
    435            *   This parameter can be one of the following values:
    436            *     @arg RCC_LSE_OFF: turn OFF the LSE oscillator, LSERDY flag goes low after
    437            *                       6 LSE oscillator clock cycles.
    438            *     @arg RCC_LSE_ON: turn ON the LSE oscillator
    439            *     @arg RCC_LSE_Bypass: LSE oscillator bypassed with external clock
    440            * @retval None
    441            */

   \                                 In section .text, align 2, keep-with-next
    442          void RCC_LSEConfig(uint8_t RCC_LSE)
    443          {
   \                     RCC_LSEConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    444            /* Check the parameters */
    445            assert_param(IS_RCC_LSE(RCC_LSE));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD00B             BEQ.N    ??RCC_LSEConfig_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD008             BEQ.N    ??RCC_LSEConfig_0
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C05             CMP      R4,#+5
   \   00000014   0xD005             BEQ.N    ??RCC_LSEConfig_0
   \   00000016   0xF240 0x11BD      MOVW     R1,#+445
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   0000001E   0x.... 0x....      BL       assert_failed
    446            
    447            /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
    448            *(__IO uint8_t *) CSR_BYTE2_ADDRESS = RCC_LSE_OFF;
   \                     ??RCC_LSEConfig_0: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable35_7  ;; 0x40023835
   \   00000028   0x7008             STRB     R0,[R1, #+0]
    449          
    450            /* Set the new LSE configuration -------------------------------------------*/
    451            *(__IO uint8_t *) CSR_BYTE2_ADDRESS = RCC_LSE;  
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable35_7  ;; 0x40023835
   \   0000002E   0x7004             STRB     R4,[R0, #+0]
    452          }
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    453          
    454          /**
    455            * @brief  Enables or disables the Internal Low Speed oscillator (LSI).  
    456            * @note   - After enabling the LSI, the application software should wait on 
    457            *           LSIRDY flag to be set indicating that LSI clock is stable and can
    458            *           be used to clock the IWDG and/or the RTC.
    459            *         - LSI can not be disabled if the IWDG is running.  
    460            * @param  NewState: new state of the LSI.
    461            *   This parameter can be: ENABLE or DISABLE.
    462            * @note   When the LSI is stopped, LSIRDY flag goes low after 6 LSI oscillator
    463            *         clock cycles. 
    464            * @retval None
    465            */

   \                                 In section .text, align 2, keep-with-next
    466          void RCC_LSICmd(FunctionalState NewState)
    467          {
   \                     RCC_LSICmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    468            /* Check the parameters */
    469            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD008             BEQ.N    ??RCC_LSICmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD005             BEQ.N    ??RCC_LSICmd_0
   \   00000010   0xF240 0x11D5      MOVW     R1,#+469
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   00000018   0x.... 0x....      BL       assert_failed
    470            
    471            *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
   \                     ??RCC_LSICmd_0: (+1)
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable35_8  ;; 0x42470680
   \   00000022   0x6004             STR      R4,[R0, #+0]
    472          }
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    473          
    474          /**
    475            * @brief  Configures the PLL clock source and multiplication factor.
    476            * @note   This function must be used only when the PLL is disabled.
    477            *   
    478            * @param  RCC_PLLSource: specifies the PLL entry clock source.
    479            *   This parameter can be one of the following values:
    480            *     @arg RCC_PLLSource_HSI: HSI oscillator clock selected as PLL clock source
    481            *     @arg RCC_PLLSource_HSE: HSE oscillator clock selected as PLL clock source
    482            * @note   The minimum input clock frequency for PLL is 2 MHz (when using HSE as
    483            *         PLL source).
    484            *               
    485            * @param  RCC_PLLMul: specifies the PLL multiplication factor, which drive the PLLVCO clock
    486            *   This parameter can be:
    487            *     @arg RCC_PLLMul_3: PLL clock source multiplied by 3
    488            *     @arg RCC_PLLMul_4: PLL clock source multiplied by 4
    489            *     @arg RCC_PLLMul_6: PLL clock source multiplied by 6
    490            *     @arg RCC_PLLMul_8: PLL clock source multiplied by 8
    491            *     @arg RCC_PLLMul_12: PLL clock source multiplied by 12
    492            *     @arg RCC_PLLMul_16: PLL clock source multiplied by 16  
    493            *     @arg RCC_PLLMul_24: PLL clock source multiplied by 24
    494            *     @arg RCC_PLLMul_32: PLL clock source multiplied by 32
    495            *     @arg RCC_PLLMul_48: PLL clock source multiplied by 48
    496            * @note   The application software must set correctly the PLL multiplication
    497            *         factor to avoid exceeding
    498            *             - 96 MHz as PLLVCO when the product is in range 1
    499            *             - 48 MHz as PLLVCO when the product is in range 2
    500            *             - 24 MHz when the product is in range 3
    501            * @note   When using the USB the PLLVCO should be 96MHz
    502            *                                   
    503            * @param  RCC_PLLDiv: specifies the PLL division factor.
    504            *   This parameter can be:
    505            *     @arg RCC_PLLDiv_2: PLL Clock output divided by 2  
    506            *     @arg RCC_PLLDiv_3: PLL Clock output divided by 3         
    507            *     @arg RCC_PLLDiv_4: PLL Clock output divided by 4  
    508            * @note   The application software must set correctly the output division to avoid
    509            *         exceeding 32 MHz as SYSCLK.
    510            *            
    511            * @retval None
    512            */

   \                                 In section .text, align 2, keep-with-next
    513          void RCC_PLLConfig(uint8_t RCC_PLLSource, uint8_t RCC_PLLMul, uint8_t RCC_PLLDiv)
    514          {
   \                     RCC_PLLConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    515            /* Check the parameters */
    516            assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD008             BEQ.N    ??RCC_PLLConfig_0
   \   0000000E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000010   0x2C01             CMP      R4,#+1
   \   00000012   0xD005             BEQ.N    ??RCC_PLLConfig_0
   \   00000014   0xF44F 0x7101      MOV      R1,#+516
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   0000001C   0x.... 0x....      BL       assert_failed
    517            assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
   \                     ??RCC_PLLConfig_0: (+1)
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD01D             BEQ.N    ??RCC_PLLConfig_1
   \   00000026   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000028   0x2D04             CMP      R5,#+4
   \   0000002A   0xD01A             BEQ.N    ??RCC_PLLConfig_1
   \   0000002C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002E   0x2D08             CMP      R5,#+8
   \   00000030   0xD017             BEQ.N    ??RCC_PLLConfig_1
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D0C             CMP      R5,#+12
   \   00000036   0xD014             BEQ.N    ??RCC_PLLConfig_1
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0x2D10             CMP      R5,#+16
   \   0000003C   0xD011             BEQ.N    ??RCC_PLLConfig_1
   \   0000003E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000040   0x2D14             CMP      R5,#+20
   \   00000042   0xD00E             BEQ.N    ??RCC_PLLConfig_1
   \   00000044   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000046   0x2D18             CMP      R5,#+24
   \   00000048   0xD00B             BEQ.N    ??RCC_PLLConfig_1
   \   0000004A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004C   0x2D1C             CMP      R5,#+28
   \   0000004E   0xD008             BEQ.N    ??RCC_PLLConfig_1
   \   00000050   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000052   0x2D20             CMP      R5,#+32
   \   00000054   0xD005             BEQ.N    ??RCC_PLLConfig_1
   \   00000056   0xF240 0x2105      MOVW     R1,#+517
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   0000005E   0x.... 0x....      BL       assert_failed
    518            assert_param(IS_RCC_PLL_DIV(RCC_PLLDiv));
   \                     ??RCC_PLLConfig_1: (+1)
   \   00000062   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000064   0x2E40             CMP      R6,#+64
   \   00000066   0xD00B             BEQ.N    ??RCC_PLLConfig_2
   \   00000068   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000006A   0x2E80             CMP      R6,#+128
   \   0000006C   0xD008             BEQ.N    ??RCC_PLLConfig_2
   \   0000006E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000070   0x2EC0             CMP      R6,#+192
   \   00000072   0xD005             BEQ.N    ??RCC_PLLConfig_2
   \   00000074   0xF240 0x2106      MOVW     R1,#+518
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   0000007C   0x.... 0x....      BL       assert_failed
    519            
    520            *(__IO uint8_t *) CFGR_BYTE3_ADDRESS = (uint8_t)(RCC_PLLSource | ((uint8_t)(RCC_PLLMul | (uint8_t)(RCC_PLLDiv))));
   \                     ??RCC_PLLConfig_2: (+1)
   \   00000080   0xEA56 0x0005      ORRS     R0,R6,R5
   \   00000084   0x4320             ORRS     R0,R0,R4
   \   00000086   0x.... 0x....      LDR.W    R1,??DataTable35_9  ;; 0x4002380a
   \   0000008A   0x7008             STRB     R0,[R1, #+0]
    521          }
   \   0000008C   0xBD70             POP      {R4-R6,PC}       ;; return
    522          
    523          /**
    524            * @brief  Enables or disables the PLL.
    525            * @note   - After enabling the PLL, the application software should wait on 
    526            *           PLLRDY flag to be set indicating that PLL clock is stable and can
    527            *           be used as system clock source.
    528            *         - The PLL can not be disabled if it is used as system clock source
    529            *         - The PLL is disabled by hardware when entering STOP and STANDBY modes.    
    530            * @param  NewState: new state of the PLL.
    531            *   This parameter can be: ENABLE or DISABLE.
    532            * @retval None
    533            */

   \                                 In section .text, align 2, keep-with-next
    534          void RCC_PLLCmd(FunctionalState NewState)
    535          {
   \                     RCC_PLLCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    536            /* Check the parameters */
    537            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD008             BEQ.N    ??RCC_PLLCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD005             BEQ.N    ??RCC_PLLCmd_0
   \   00000010   0xF240 0x2119      MOVW     R1,#+537
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   00000018   0x.... 0x....      BL       assert_failed
    538            
    539            *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
   \                     ??RCC_PLLCmd_0: (+1)
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable35_10  ;; 0x42470060
   \   00000022   0x6004             STR      R4,[R0, #+0]
    540          }
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    541          
    542          /**
    543            * @brief  Enables or disables the Clock Security System.
    544            * @note   If a failure is detected on the HSE oscillator clock, this oscillator
    545            *         is automatically disabled and an interrupt is generated to inform the
    546            *         software about the failure (Clock Security System Interrupt, CSSI),
    547            *         allowing the MCU to perform rescue operations. The CSSI is linked to 
    548            *         the Cortex-M3 NMI (Non-Maskable Interrupt) exception vector.  
    549            * @param  NewState: new state of the Clock Security System.
    550            *         This parameter can be: ENABLE or DISABLE.
    551            * @retval None
    552            */

   \                                 In section .text, align 2, keep-with-next
    553          void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
    554          {
   \                     RCC_ClockSecuritySystemCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    555            /* Check the parameters */
    556            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD008             BEQ.N    ??RCC_ClockSecuritySystemCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD005             BEQ.N    ??RCC_ClockSecuritySystemCmd_0
   \   00000010   0xF44F 0x710B      MOV      R1,#+556
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   00000018   0x.... 0x....      BL       assert_failed
    557            
    558            *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
   \                     ??RCC_ClockSecuritySystemCmd_0: (+1)
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable35_11  ;; 0x42470070
   \   00000022   0x6004             STR      R4,[R0, #+0]
    559          }
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    560          
    561          /**
    562            * @brief  Selects the clock source to output on MCO pin (PA8).
    563            * @note   PA8 should be configured in alternate function mode.   
    564            * @param  RCC_MCOSource: specifies the clock source to output.
    565            *   This parameter can be one of the following values:
    566            *     @arg RCC_MCOSource_NoClock: No clock selected
    567            *     @arg RCC_MCOSource_SYSCLK: System clock selected
    568            *     @arg RCC_MCOSource_HSI: HSI oscillator clock selected
    569            *     @arg RCC_MCOSource_MSI: MSI oscillator clock selected  
    570            *     @arg RCC_MCOSource_HSE: HSE oscillator clock selected
    571            *     @arg RCC_MCOSource_PLLCLK: PLL clock selected
    572            *     @arg RCC_MCOSource_LSI: LSI clock selected
    573            *     @arg RCC_MCOSource_LSE: LSE clock selected    
    574            * @param  RCC_MCODiv: specifies the MCO prescaler.
    575            *   This parameter can be one of the following values: 
    576            *     @arg RCC_MCODiv_1: no division applied to MCO clock 
    577            *     @arg RCC_MCODiv_2: division by 2 applied to MCO clock
    578            *     @arg RCC_MCODiv_4: division by 4 applied to MCO clock
    579            *     @arg RCC_MCODiv_8: division by 8 applied to MCO clock
    580            *     @arg RCC_MCODiv_16: division by 16 applied to MCO clock             
    581            * @retval None
    582            */

   \                                 In section .text, align 2, keep-with-next
    583          void RCC_MCOConfig(uint8_t RCC_MCOSource, uint8_t RCC_MCODiv)
    584          {
   \                     RCC_MCOConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    585            /* Check the parameters */
    586            assert_param(IS_RCC_MCO_SOURCE(RCC_MCOSource));
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD01A             BEQ.N    ??RCC_MCOConfig_0
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x2C01             CMP      R4,#+1
   \   00000010   0xD017             BEQ.N    ??RCC_MCOConfig_0
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0x2C02             CMP      R4,#+2
   \   00000016   0xD014             BEQ.N    ??RCC_MCOConfig_0
   \   00000018   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001A   0x2C03             CMP      R4,#+3
   \   0000001C   0xD011             BEQ.N    ??RCC_MCOConfig_0
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0x2C04             CMP      R4,#+4
   \   00000022   0xD00E             BEQ.N    ??RCC_MCOConfig_0
   \   00000024   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000026   0x2C05             CMP      R4,#+5
   \   00000028   0xD00B             BEQ.N    ??RCC_MCOConfig_0
   \   0000002A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002C   0x2C06             CMP      R4,#+6
   \   0000002E   0xD008             BEQ.N    ??RCC_MCOConfig_0
   \   00000030   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000032   0x2C07             CMP      R4,#+7
   \   00000034   0xD005             BEQ.N    ??RCC_MCOConfig_0
   \   00000036   0xF240 0x214A      MOVW     R1,#+586
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   0000003E   0x.... 0x....      BL       assert_failed
    587            assert_param(IS_RCC_MCO_DIV(RCC_MCODiv));
   \                     ??RCC_MCOConfig_0: (+1)
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0x2D00             CMP      R5,#+0
   \   00000046   0xD011             BEQ.N    ??RCC_MCOConfig_1
   \   00000048   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004A   0x2D10             CMP      R5,#+16
   \   0000004C   0xD00E             BEQ.N    ??RCC_MCOConfig_1
   \   0000004E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000050   0x2D20             CMP      R5,#+32
   \   00000052   0xD00B             BEQ.N    ??RCC_MCOConfig_1
   \   00000054   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000056   0x2D30             CMP      R5,#+48
   \   00000058   0xD008             BEQ.N    ??RCC_MCOConfig_1
   \   0000005A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005C   0x2D40             CMP      R5,#+64
   \   0000005E   0xD005             BEQ.N    ??RCC_MCOConfig_1
   \   00000060   0xF240 0x214B      MOVW     R1,#+587
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   00000068   0x.... 0x....      BL       assert_failed
    588              
    589            /* Select MCO clock source and prescaler */
    590            *(__IO uint8_t *) CFGR_BYTE4_ADDRESS =  RCC_MCOSource | RCC_MCODiv; 
   \                     ??RCC_MCOConfig_1: (+1)
   \   0000006C   0xEA55 0x0004      ORRS     R0,R5,R4
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable35_12  ;; 0x4002380b
   \   00000074   0x7008             STRB     R0,[R1, #+0]
    591          }
   \   00000076   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    592          
    593          /**
    594            * @}
    595            */
    596          
    597          /** @defgroup RCC_Group2 System AHB and APB busses clocks configuration functions
    598           *  @brief   System, AHB and APB busses clocks configuration functions
    599           *
    600          @verbatim   
    601           ===============================================================================
    602                       System, AHB and APB busses clocks configuration functions
    603           ===============================================================================  
    604          
    605            This section provide functions allowing to configure the System, AHB, APB1 and 
    606            APB2 busses clocks.
    607            
    608            1. Several clock sources can be used to drive the System clock (SYSCLK): MSI, HSI,
    609               HSE and PLL.
    610               The AHB clock (HCLK) is derived from System clock through configurable prescaler
    611               and used to clock the CPU, memory and peripherals mapped on AHB bus (DMA and GPIO).
    612               APB1 (PCLK1) and APB2 (PCLK2) clocks are derived from AHB clock through 
    613               configurable prescalers and used to clock the peripherals mapped on these busses.
    614               You can use "RCC_GetClocksFreq()" function to retrieve the frequencies of these clocks.  
    615          
    616          Note: All the peripheral clocks are derived from the System clock (SYSCLK) except:
    617          ====   - The USB 48 MHz clock which is derived from the PLL VCO clock.
    618                 - The ADC clock which is always the HSI clock. A divider by 1, 2 or 4 allows
    619                   to adapt the clock frequency to the device operating conditions. 
    620                 - The RTC/LCD clock which is derived from the LSE, LSI or 1 MHz HSE_RTC (HSE
    621                   divided by a programmable prescaler).
    622                   The System clock (SYSCLK) frequency must be higher or equal to the RTC/LCD
    623                   clock frequency.
    624                 - IWDG clock which is always the LSI clock.
    625                 
    626            2. The maximum frequency of the SYSCLK, HCLK, PCLK1 and PCLK2 is 32 MHz.
    627               Depending on the device voltage range, the maximum frequency should be 
    628               adapted accordingly:
    629                  +----------------------------------------------------------------+     
    630                  |  Wait states  |                HCLK clock frequency (MHz)      |
    631                  |               |------------------------------------------------|     
    632                  |   (Latency)   |            voltage range       | voltage range | 
    633                  |               |            1.65 V - 3.6 V      | 2.0 V - 3.6 V |
    634                  |               |----------------|---------------|---------------| 
    635                  |               |  VCORE = 1.2 V | VCORE = 1.5 V | VCORE = 1.8 V |
    636                  |-------------- |----------------|---------------|---------------|             
    637                  |0WS(1CPU cycle)|0 < HCLK <= 2   |0 < HCLK <= 8  |0 < HCLK <= 16 |
    638                  |---------------|----------------|---------------|---------------|  
    639                  |1WS(2CPU cycle)|2 < HCLK <= 4   |8 < HCLK <= 16 |16 < HCLK <= 32| 
    640                  +----------------------------------------------------------------+   
    641          
    642            3. After reset, the System clock source is the MSI (2 MHz) with 0 WS, Flash
    643               32-bit access is enabled and prefetch is disabled.
    644            
    645               It is recommended to use the following software sequences to tune the number
    646               of wait states needed to access the Flash memory with the CPU frequency (HCLK).
    647                - Increasing the CPU frequency (in the same voltage range)
    648                   - Program the Flash 64-bit access, using "FLASH_ReadAccess64Cmd(ENABLE)" function
    649                   - Check that 64-bit access is taken into account by reading FLASH_ACR
    650                   - Program Flash WS to 1, using "FLASH_SetLatency(FLASH_Latency_1)" function
    651                   - Check that the new number of WS is taken into account by reading FLASH_ACR
    652                   - Modify the CPU clock source, using "RCC_SYSCLKConfig()" function
    653                   - If needed, modify the CPU clock prescaler by using "RCC_HCLKConfig()" function
    654                   - Check that the new CPU clock source is taken into account by reading 
    655                     the clock source status, using "RCC_GetSYSCLKSource()" function 
    656                - Decreasing the CPU frequency (in the same voltage range)
    657                   - Modify the CPU clock source, using "RCC_SYSCLKConfig()" function
    658                   - If needed, modify the CPU clock prescaler by using "RCC_HCLKConfig()" function
    659                   - Check that the new CPU clock source is taken into account by reading 
    660                     the clock source status, using "RCC_GetSYSCLKSource()" function
    661                   - Program the new number of WS, using "FLASH_SetLatency()" function
    662                   - Check that the new number of WS is taken into account by reading FLASH_ACR
    663                   - Enable the Flash 32-bit access, using "FLASH_ReadAccess64Cmd(DISABLE)" function
    664                   - Check that 32-bit access is taken into account by reading FLASH_ACR
    665          
    666          @endverbatim
    667            * @{
    668            */
    669          
    670          /**
    671            * @brief  Configures the system clock (SYSCLK).
    672            * @note   - The MSI is used (enabled by hardware) as system clock source after
    673            *           startup from Reset, wake-up from STOP and STANDBY mode, or in case
    674            *           of failure of the HSE used directly or indirectly as system clock
    675            *           (if the Clock Security System CSS is enabled).
    676            *         - A switch from one clock source to another occurs only if the target
    677            *           clock source is ready (clock stable after startup delay or PLL locked). 
    678            *           If a clock source which is not yet ready is selected, the switch will
    679            *           occur when the clock source will be ready. 
    680            *           You can use RCC_GetSYSCLKSource() function to know which clock is
    681            *           currently used as system clock source.  
    682            * @param  RCC_SYSCLKSource: specifies the clock source used as system clock source 
    683            *   This parameter can be one of the following values:
    684            *     @arg RCC_SYSCLKSource_MSI:    MSI selected as system clock source
    685            *     @arg RCC_SYSCLKSource_HSI:    HSI selected as system clock source
    686            *     @arg RCC_SYSCLKSource_HSE:    HSE selected as system clock source
    687            *     @arg RCC_SYSCLKSource_PLLCLK: PLL selected as system clock source
    688            * @retval None
    689            */

   \                                 In section .text, align 2, keep-with-next
    690          void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
    691          {
   \                     RCC_SYSCLKConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    692            uint32_t tmpreg = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    693            
    694            /* Check the parameters */
    695            assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD00B             BEQ.N    ??RCC_SYSCLKConfig_0
   \   0000000A   0x2C01             CMP      R4,#+1
   \   0000000C   0xD009             BEQ.N    ??RCC_SYSCLKConfig_0
   \   0000000E   0x2C02             CMP      R4,#+2
   \   00000010   0xD007             BEQ.N    ??RCC_SYSCLKConfig_0
   \   00000012   0x2C03             CMP      R4,#+3
   \   00000014   0xD005             BEQ.N    ??RCC_SYSCLKConfig_0
   \   00000016   0xF240 0x21B7      MOVW     R1,#+695
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   0000001E   0x.... 0x....      BL       assert_failed
    696            
    697            tmpreg = RCC->CFGR;
   \                     ??RCC_SYSCLKConfig_0: (+1)
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable33_1  ;; 0x40023808
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x0005             MOVS     R5,R0
    698            
    699            /* Clear SW[1:0] bits */
    700            tmpreg &= ~RCC_CFGR_SW;
   \   0000002A   0x08AD             LSRS     R5,R5,#+2
   \   0000002C   0x00AD             LSLS     R5,R5,#+2
    701            
    702            /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
    703            tmpreg |= RCC_SYSCLKSource;
   \   0000002E   0x4325             ORRS     R5,R4,R5
    704            
    705            /* Store the new value */
    706            RCC->CFGR = tmpreg;
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable33_1  ;; 0x40023808
   \   00000034   0x6005             STR      R5,[R0, #+0]
    707          }
   \   00000036   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    708          
    709          /**
    710            * @brief  Returns the clock source used as system clock.
    711            * @param  None
    712            * @retval The clock source used as system clock. The returned value can be one 
    713            *         of the following values:
    714            *              - 0x00: MSI used as system clock
    715            *              - 0x04: HSI used as system clock  
    716            *              - 0x08: HSE used as system clock
    717            *              - 0x0C: PLL used as system clock
    718            */

   \                                 In section .text, align 2, keep-with-next
    719          uint8_t RCC_GetSYSCLKSource(void)
    720          {
    721            return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
   \                     RCC_GetSYSCLKSource: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable33_1  ;; 0x40023808
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   0000000A   0x4770             BX       LR               ;; return
    722          }
    723          
    724          /**
    725            * @brief  Configures the AHB clock (HCLK).
    726            * @note   Depending on the device voltage range, the software has to set correctly
    727            *         these bits to ensure that the system frequency does not exceed the
    728            *         maximum allowed frequency (for more details refer to section above
    729            *         "CPU, AHB and APB busses clocks configuration functions")
    730            * @param  RCC_SYSCLK: defines the AHB clock divider. This clock is derived from 
    731            *                     the system clock (SYSCLK).
    732            *   This parameter can be one of the following values:
    733            *     @arg RCC_SYSCLK_Div1:   AHB clock = SYSCLK
    734            *     @arg RCC_SYSCLK_Div2:   AHB clock = SYSCLK/2
    735            *     @arg RCC_SYSCLK_Div4:   AHB clock = SYSCLK/4
    736            *     @arg RCC_SYSCLK_Div8:   AHB clock = SYSCLK/8
    737            *     @arg RCC_SYSCLK_Div16:  AHB clock = SYSCLK/16
    738            *     @arg RCC_SYSCLK_Div64:  AHB clock = SYSCLK/64
    739            *     @arg RCC_SYSCLK_Div128: AHB clock = SYSCLK/128
    740            *     @arg RCC_SYSCLK_Div256: AHB clock = SYSCLK/256
    741            *     @arg RCC_SYSCLK_Div512: AHB clock = SYSCLK/512
    742            * @retval None
    743            */

   \                                 In section .text, align 2, keep-with-next
    744          void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
    745          {
   \                     RCC_HCLKConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    746            uint32_t tmpreg = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    747            
    748            /* Check the parameters */
    749            assert_param(IS_RCC_HCLK(RCC_SYSCLK));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD015             BEQ.N    ??RCC_HCLKConfig_0
   \   0000000A   0x2C80             CMP      R4,#+128
   \   0000000C   0xD013             BEQ.N    ??RCC_HCLKConfig_0
   \   0000000E   0x2C90             CMP      R4,#+144
   \   00000010   0xD011             BEQ.N    ??RCC_HCLKConfig_0
   \   00000012   0x2CA0             CMP      R4,#+160
   \   00000014   0xD00F             BEQ.N    ??RCC_HCLKConfig_0
   \   00000016   0x2CB0             CMP      R4,#+176
   \   00000018   0xD00D             BEQ.N    ??RCC_HCLKConfig_0
   \   0000001A   0x2CC0             CMP      R4,#+192
   \   0000001C   0xD00B             BEQ.N    ??RCC_HCLKConfig_0
   \   0000001E   0x2CD0             CMP      R4,#+208
   \   00000020   0xD009             BEQ.N    ??RCC_HCLKConfig_0
   \   00000022   0x2CE0             CMP      R4,#+224
   \   00000024   0xD007             BEQ.N    ??RCC_HCLKConfig_0
   \   00000026   0x2CF0             CMP      R4,#+240
   \   00000028   0xD005             BEQ.N    ??RCC_HCLKConfig_0
   \   0000002A   0xF240 0x21ED      MOVW     R1,#+749
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   00000032   0x.... 0x....      BL       assert_failed
    750            
    751            tmpreg = RCC->CFGR;
   \                     ??RCC_HCLKConfig_0: (+1)
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable33_1  ;; 0x40023808
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x0005             MOVS     R5,R0
    752            
    753            /* Clear HPRE[3:0] bits */
    754            tmpreg &= ~RCC_CFGR_HPRE;
   \   0000003E   0xF035 0x05F0      BICS     R5,R5,#0xF0
    755            
    756            /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
    757            tmpreg |= RCC_SYSCLK;
   \   00000042   0x4325             ORRS     R5,R4,R5
    758            
    759            /* Store the new value */
    760            RCC->CFGR = tmpreg;
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable33_1  ;; 0x40023808
   \   00000048   0x6005             STR      R5,[R0, #+0]
    761          }
   \   0000004A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    762          
    763          /**
    764            * @brief  Configures the Low Speed APB clock (PCLK1).
    765            * @param  RCC_HCLK: defines the APB1 clock divider. This clock is derived from 
    766            *                   the AHB clock (HCLK).
    767            *   This parameter can be one of the following values:
    768            *     @arg RCC_HCLK_Div1:  APB1 clock = HCLK
    769            *     @arg RCC_HCLK_Div2:  APB1 clock = HCLK/2
    770            *     @arg RCC_HCLK_Div4:  APB1 clock = HCLK/4
    771            *     @arg RCC_HCLK_Div8:  APB1 clock = HCLK/8
    772            *     @arg RCC_HCLK_Div16: APB1 clock = HCLK/16
    773            * @retval None
    774            */

   \                                 In section .text, align 2, keep-with-next
    775          void RCC_PCLK1Config(uint32_t RCC_HCLK)
    776          {
   \                     RCC_PCLK1Config: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    777            uint32_t tmpreg = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    778            
    779            /* Check the parameters */
    780            assert_param(IS_RCC_PCLK(RCC_HCLK));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD011             BEQ.N    ??RCC_PCLK1Config_0
   \   0000000A   0xF5B4 0x6F80      CMP      R4,#+1024
   \   0000000E   0xD00E             BEQ.N    ??RCC_PCLK1Config_0
   \   00000010   0xF5B4 0x6FA0      CMP      R4,#+1280
   \   00000014   0xD00B             BEQ.N    ??RCC_PCLK1Config_0
   \   00000016   0xF5B4 0x6FC0      CMP      R4,#+1536
   \   0000001A   0xD008             BEQ.N    ??RCC_PCLK1Config_0
   \   0000001C   0xF5B4 0x6FE0      CMP      R4,#+1792
   \   00000020   0xD005             BEQ.N    ??RCC_PCLK1Config_0
   \   00000022   0xF44F 0x7143      MOV      R1,#+780
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   0000002A   0x.... 0x....      BL       assert_failed
    781            
    782            tmpreg = RCC->CFGR;
   \                     ??RCC_PCLK1Config_0: (+1)
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable33_1  ;; 0x40023808
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x0005             MOVS     R5,R0
    783            
    784            /* Clear PPRE1[2:0] bits */
    785            tmpreg &= ~RCC_CFGR_PPRE1;
   \   00000036   0xF435 0x65E0      BICS     R5,R5,#0x700
    786            
    787            /* Set PPRE1[2:0] bits according to RCC_HCLK value */
    788            tmpreg |= RCC_HCLK;
   \   0000003A   0x4325             ORRS     R5,R4,R5
    789            
    790            /* Store the new value */
    791            RCC->CFGR = tmpreg;
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable33_1  ;; 0x40023808
   \   00000040   0x6005             STR      R5,[R0, #+0]
    792          }
   \   00000042   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    793          
    794          /**
    795            * @brief  Configures the High Speed APB clock (PCLK2).
    796            * @param  RCC_HCLK: defines the APB2 clock divider. This clock is derived from 
    797            *                   the AHB clock (HCLK).
    798            *   This parameter can be one of the following values:
    799            *     @arg RCC_HCLK_Div1:  APB2 clock = HCLK
    800            *     @arg RCC_HCLK_Div2:  APB2 clock = HCLK/2
    801            *     @arg RCC_HCLK_Div4:  APB2 clock = HCLK/4
    802            *     @arg RCC_HCLK_Div8:  APB2 clock = HCLK/8
    803            *     @arg RCC_HCLK_Div16: APB2 clock = HCLK/16
    804            * @retval None
    805            */

   \                                 In section .text, align 2, keep-with-next
    806          void RCC_PCLK2Config(uint32_t RCC_HCLK)
    807          {
   \                     RCC_PCLK2Config: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    808            uint32_t tmpreg = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    809            
    810            /* Check the parameters */
    811            assert_param(IS_RCC_PCLK(RCC_HCLK));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD011             BEQ.N    ??RCC_PCLK2Config_0
   \   0000000A   0xF5B4 0x6F80      CMP      R4,#+1024
   \   0000000E   0xD00E             BEQ.N    ??RCC_PCLK2Config_0
   \   00000010   0xF5B4 0x6FA0      CMP      R4,#+1280
   \   00000014   0xD00B             BEQ.N    ??RCC_PCLK2Config_0
   \   00000016   0xF5B4 0x6FC0      CMP      R4,#+1536
   \   0000001A   0xD008             BEQ.N    ??RCC_PCLK2Config_0
   \   0000001C   0xF5B4 0x6FE0      CMP      R4,#+1792
   \   00000020   0xD005             BEQ.N    ??RCC_PCLK2Config_0
   \   00000022   0xF240 0x312B      MOVW     R1,#+811
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   0000002A   0x.... 0x....      BL       assert_failed
    812            
    813            tmpreg = RCC->CFGR;
   \                     ??RCC_PCLK2Config_0: (+1)
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable33_1  ;; 0x40023808
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x0005             MOVS     R5,R0
    814            
    815            /* Clear PPRE2[2:0] bits */
    816            tmpreg &= ~RCC_CFGR_PPRE2;
   \   00000036   0xF435 0x5560      BICS     R5,R5,#0x3800
    817            
    818            /* Set PPRE2[2:0] bits according to RCC_HCLK value */
    819            tmpreg |= RCC_HCLK << 3;
   \   0000003A   0xEA55 0x05C4      ORRS     R5,R5,R4, LSL #+3
    820            
    821            /* Store the new value */
    822            RCC->CFGR = tmpreg;
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable33_1  ;; 0x40023808
   \   00000042   0x6005             STR      R5,[R0, #+0]
    823          }
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    824          
    825          /**
    826            * @brief  Returns the frequencies of the System, AHB and APB busses clocks.
    827            * @note   - The frequency returned by this function is not the real frequency
    828            *           in the chip. It is calculated based on the predefined constant and
    829            *           the source selected by RCC_SYSCLKConfig():
    830            *             
    831            *           - If SYSCLK source is MSI, function returns constant the MSI value
    832            *             as defined by the MSI range, refer to RCC_MSIRangeConfig()
    833            *                                   
    834            *           - If SYSCLK source is HSI, function returns constant HSI_VALUE(*)
    835            *                                              
    836            *           - If SYSCLK source is HSE, function returns constant HSE_VALUE(**)
    837            *                          
    838            *           - If SYSCLK source is PLL, function returns constant HSE_VALUE(**) 
    839            *             or HSI_VALUE(*) multiplied/divided by the PLL factors.
    840            *         
    841            *         (*) HSI_VALUE is a constant defined in stm32l1xx.h file (default value
    842            *             16 MHz) but the real value may vary depending on the variations
    843            *             in voltage and temperature, refer to RCC_AdjustHSICalibrationValue().   
    844            *    
    845            *         (**) HSE_VALUE is a constant defined in stm32l1xx.h file (default value
    846            *              8 MHz), user has to ensure that HSE_VALUE is same as the real
    847            *              frequency of the crystal used. Otherwise, this function may
    848            *              return wrong result.
    849            *                
    850            *         - The result of this function could be not correct when using fractional
    851            *           value for HSE crystal.   
    852            *             
    853            * @param  RCC_Clocks: pointer to a RCC_ClocksTypeDef structure which will hold 
    854            *         the clocks frequencies. 
    855            * @retval None
    856            */

   \                                 In section .text, align 2, keep-with-next
    857          void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
    858          {
   \                     RCC_GetClocksFreq: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    859            uint32_t tmp = 0, pllmul = 0, plldiv = 0, pllsource = 0, presc = 0, msirange = 0;
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x2400             MOVS     R4,#+0
   \   0000000A   0x2500             MOVS     R5,#+0
   \   0000000C   0x2600             MOVS     R6,#+0
    860          
    861            /* Get SYSCLK source -------------------------------------------------------*/
    862            tmp = RCC->CFGR & RCC_CFGR_SWS;
   \   0000000E   0x.... 0x....      LDR.W    R7,??DataTable33_1  ;; 0x40023808
   \   00000012   0x683F             LDR      R7,[R7, #+0]
   \   00000014   0xF017 0x070C      ANDS     R7,R7,#0xC
   \   00000018   0x0039             MOVS     R1,R7
    863            
    864            switch (tmp)
   \   0000001A   0x000F             MOVS     R7,R1
   \   0000001C   0x2F00             CMP      R7,#+0
   \   0000001E   0xD006             BEQ.N    ??RCC_GetClocksFreq_0
   \   00000020   0x2F04             CMP      R7,#+4
   \   00000022   0xD015             BEQ.N    ??RCC_GetClocksFreq_1
   \   00000024   0x2F08             CMP      R7,#+8
   \   00000026   0xD017             BEQ.N    ??RCC_GetClocksFreq_2
   \   00000028   0x2F0C             CMP      R7,#+12
   \   0000002A   0xD019             BEQ.N    ??RCC_GetClocksFreq_3
   \   0000002C   0xE042             B.N      ??RCC_GetClocksFreq_4
    865            {
    866              case 0x00:  /* MSI used as system clock */
    867                msirange = (RCC->ICSCR & RCC_ICSCR_MSIRANGE ) >> 13;
   \                     ??RCC_GetClocksFreq_0: (+1)
   \   0000002E   0x.... 0x....      LDR.W    R7,??DataTable35_4  ;; 0x40023804
   \   00000032   0x683F             LDR      R7,[R7, #+0]
   \   00000034   0xF3C7 0x3742      UBFX     R7,R7,#+13,#+3
   \   00000038   0x003E             MOVS     R6,R7
    868                RCC_Clocks->SYSCLK_Frequency = (32768 * (1 << (msirange + 1)));
   \   0000003A   0x2701             MOVS     R7,#+1
   \   0000003C   0xF116 0x0C01      ADDS     R12,R6,#+1
   \   00000040   0xFA17 0xF70C      LSLS     R7,R7,R12
   \   00000044   0xF44F 0x4C00      MOV      R12,#+32768
   \   00000048   0xFB0C 0xF707      MUL      R7,R12,R7
   \   0000004C   0x6007             STR      R7,[R0, #+0]
    869                break;
   \   0000004E   0xE041             B.N      ??RCC_GetClocksFreq_5
    870              case 0x04:  /* HSI used as system clock */
    871                RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
   \                     ??RCC_GetClocksFreq_1: (+1)
   \   00000050   0x.... 0x....      LDR.W    R7,??DataTable35_13  ;; 0xf42400
   \   00000054   0x6007             STR      R7,[R0, #+0]
    872                break;
   \   00000056   0xE03D             B.N      ??RCC_GetClocksFreq_5
    873              case 0x08:  /* HSE used as system clock */
    874                RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
   \                     ??RCC_GetClocksFreq_2: (+1)
   \   00000058   0x.... 0x....      LDR.W    R7,??DataTable35_14  ;; 0x7a1200
   \   0000005C   0x6007             STR      R7,[R0, #+0]
    875                break;
   \   0000005E   0xE039             B.N      ??RCC_GetClocksFreq_5
    876              case 0x0C:  /* PLL used as system clock */
    877                /* Get PLL clock source and multiplication factor ----------------------*/
    878                pllmul = RCC->CFGR & RCC_CFGR_PLLMUL;
   \                     ??RCC_GetClocksFreq_3: (+1)
   \   00000060   0x.... 0x....      LDR.W    R7,??DataTable33_1  ;; 0x40023808
   \   00000064   0x683F             LDR      R7,[R7, #+0]
   \   00000066   0xF417 0x1770      ANDS     R7,R7,#0x3C0000
   \   0000006A   0x003A             MOVS     R2,R7
    879                plldiv = RCC->CFGR & RCC_CFGR_PLLDIV;
   \   0000006C   0x.... 0x....      LDR.W    R7,??DataTable33_1  ;; 0x40023808
   \   00000070   0x683F             LDR      R7,[R7, #+0]
   \   00000072   0xF417 0x0740      ANDS     R7,R7,#0xC00000
   \   00000076   0x003B             MOVS     R3,R7
    880                pllmul = PLLMulTable[(pllmul >> 18)];
   \   00000078   0x.... 0x....      LDR.W    R7,??DataTable35_15
   \   0000007C   0x0C92             LSRS     R2,R2,#+18
   \   0000007E   0x5DD2             LDRB     R2,[R2, R7]
    881                plldiv = (plldiv >> 22) + 1;
   \   00000080   0x0D9B             LSRS     R3,R3,#+22
   \   00000082   0x1C5B             ADDS     R3,R3,#+1
    882                
    883                pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
   \   00000084   0x.... 0x....      LDR.W    R7,??DataTable33_1  ;; 0x40023808
   \   00000088   0x683F             LDR      R7,[R7, #+0]
   \   0000008A   0xF417 0x3780      ANDS     R7,R7,#0x10000
   \   0000008E   0x003C             MOVS     R4,R7
    884          
    885                if (pllsource == 0x00)
   \   00000090   0x2C00             CMP      R4,#+0
   \   00000092   0xD107             BNE.N    ??RCC_GetClocksFreq_6
    886                {
    887                  /* HSI oscillator clock selected as PLL clock source */
    888                  RCC_Clocks->SYSCLK_Frequency = (((HSI_VALUE) * pllmul) / plldiv);
   \   00000094   0x.... 0x....      LDR.W    R7,??DataTable35_13  ;; 0xf42400
   \   00000098   0xFB07 0xF702      MUL      R7,R7,R2
   \   0000009C   0xFBB7 0xF7F3      UDIV     R7,R7,R3
   \   000000A0   0x6007             STR      R7,[R0, #+0]
   \   000000A2   0xE006             B.N      ??RCC_GetClocksFreq_7
    889                }
    890                else
    891                {
    892                  /* HSE selected as PLL clock source */
    893                  RCC_Clocks->SYSCLK_Frequency = (((HSE_VALUE) * pllmul) / plldiv);
   \                     ??RCC_GetClocksFreq_6: (+1)
   \   000000A4   0x.... 0x....      LDR.W    R7,??DataTable35_14  ;; 0x7a1200
   \   000000A8   0xFB07 0xF702      MUL      R7,R7,R2
   \   000000AC   0xFBB7 0xF7F3      UDIV     R7,R7,R3
   \   000000B0   0x6007             STR      R7,[R0, #+0]
    894                }
    895                break;
   \                     ??RCC_GetClocksFreq_7: (+1)
   \   000000B2   0xE00F             B.N      ??RCC_GetClocksFreq_5
    896              default: /* MSI used as system clock */
    897                msirange = (RCC->ICSCR & RCC_ICSCR_MSIRANGE ) >> 13;
   \                     ??RCC_GetClocksFreq_4: (+1)
   \   000000B4   0x.... 0x....      LDR.W    R7,??DataTable35_4  ;; 0x40023804
   \   000000B8   0x683F             LDR      R7,[R7, #+0]
   \   000000BA   0xF3C7 0x3742      UBFX     R7,R7,#+13,#+3
   \   000000BE   0x003E             MOVS     R6,R7
    898                RCC_Clocks->SYSCLK_Frequency = (32768 * (1 << (msirange + 1)));
   \   000000C0   0x2701             MOVS     R7,#+1
   \   000000C2   0xF116 0x0C01      ADDS     R12,R6,#+1
   \   000000C6   0xFA17 0xF70C      LSLS     R7,R7,R12
   \   000000CA   0xF44F 0x4C00      MOV      R12,#+32768
   \   000000CE   0xFB0C 0xF707      MUL      R7,R12,R7
   \   000000D2   0x6007             STR      R7,[R0, #+0]
    899                break;
    900            }
    901            /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
    902            /* Get HCLK prescaler */
    903            tmp = RCC->CFGR & RCC_CFGR_HPRE;
   \                     ??RCC_GetClocksFreq_5: (+1)
   \   000000D4   0x.... 0x....      LDR.W    R7,??DataTable33_1  ;; 0x40023808
   \   000000D8   0x683F             LDR      R7,[R7, #+0]
   \   000000DA   0xF017 0x07F0      ANDS     R7,R7,#0xF0
   \   000000DE   0x0039             MOVS     R1,R7
    904            tmp = tmp >> 4;
   \   000000E0   0x0909             LSRS     R1,R1,#+4
    905            presc = APBAHBPrescTable[tmp]; 
   \   000000E2   0x.... 0x....      LDR.W    R7,??DataTable35_16
   \   000000E6   0x5DCF             LDRB     R7,[R1, R7]
   \   000000E8   0x003D             MOVS     R5,R7
    906            /* HCLK clock frequency */
    907            RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
   \   000000EA   0x6807             LDR      R7,[R0, #+0]
   \   000000EC   0x46BC             MOV      R12,R7
   \   000000EE   0xFA3C 0xFC05      LSRS     R12,R12,R5
   \   000000F2   0xF8C0 0xC004      STR      R12,[R0, #+4]
    908          
    909            /* Get PCLK1 prescaler */
    910            tmp = RCC->CFGR & RCC_CFGR_PPRE1;
   \   000000F6   0x.... 0x....      LDR.W    R7,??DataTable33_1  ;; 0x40023808
   \   000000FA   0x683F             LDR      R7,[R7, #+0]
   \   000000FC   0xF417 0x67E0      ANDS     R7,R7,#0x700
   \   00000100   0x0039             MOVS     R1,R7
    911            tmp = tmp >> 8;
   \   00000102   0x0A09             LSRS     R1,R1,#+8
    912            presc = APBAHBPrescTable[tmp];
   \   00000104   0x.... 0x....      LDR.W    R7,??DataTable35_16
   \   00000108   0x5DCF             LDRB     R7,[R1, R7]
   \   0000010A   0x003D             MOVS     R5,R7
    913            /* PCLK1 clock frequency */
    914            RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
   \   0000010C   0x6847             LDR      R7,[R0, #+4]
   \   0000010E   0x46BC             MOV      R12,R7
   \   00000110   0xFA3C 0xFC05      LSRS     R12,R12,R5
   \   00000114   0xF8C0 0xC008      STR      R12,[R0, #+8]
    915          
    916            /* Get PCLK2 prescaler */
    917            tmp = RCC->CFGR & RCC_CFGR_PPRE2;
   \   00000118   0x.... 0x....      LDR.W    R7,??DataTable33_1  ;; 0x40023808
   \   0000011C   0x683F             LDR      R7,[R7, #+0]
   \   0000011E   0xF417 0x5760      ANDS     R7,R7,#0x3800
   \   00000122   0x0039             MOVS     R1,R7
    918            tmp = tmp >> 11;
   \   00000124   0x0AC9             LSRS     R1,R1,#+11
    919            presc = APBAHBPrescTable[tmp];
   \   00000126   0x.... 0x....      LDR.W    R7,??DataTable35_16
   \   0000012A   0x5DCF             LDRB     R7,[R1, R7]
   \   0000012C   0x003D             MOVS     R5,R7
    920            /* PCLK2 clock frequency */
    921            RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
   \   0000012E   0x6847             LDR      R7,[R0, #+4]
   \   00000130   0x46BC             MOV      R12,R7
   \   00000132   0xFA3C 0xFC05      LSRS     R12,R12,R5
   \   00000136   0xF8C0 0xC00C      STR      R12,[R0, #+12]
    922          }
   \   0000013A   0xBCF0             POP      {R4-R7}
   \   0000013C   0x4770             BX       LR               ;; return
    923          
    924          /**
    925            * @}
    926            */
    927          
    928          /** @defgroup RCC_Group3 Peripheral clocks configuration functions
    929           *  @brief   Peripheral clocks configuration functions 
    930           *
    931          @verbatim   
    932           ===============================================================================
    933                             Peripheral clocks configuration functions
    934           ===============================================================================  
    935          
    936            This section provide functions allowing to configure the Peripheral clocks. 
    937            
    938            1. The RTC/LCD clock which is derived from the LSE, LSI or 1 MHz HSE_RTC (HSE
    939               divided by a programmable prescaler).
    940               
    941            2. After restart from Reset or wakeup from STANDBY, all peripherals are off
    942               except internal SRAM, Flash and JTAG. Before to start using a peripheral you
    943               have to enable its interface clock. You can do this using RCC_AHBPeriphClockCmd()
    944               , RCC_APB2PeriphClockCmd() and RCC_APB1PeriphClockCmd() functions.
    945          
    946            3. To reset the peripherals configuration (to the default state after device reset)
    947               you can use RCC_AHBPeriphResetCmd(), RCC_APB2PeriphResetCmd() and 
    948               RCC_APB1PeriphResetCmd() functions.
    949               
    950            4. To further reduce power consumption in SLEEP mode the peripheral clocks can
    951               be disabled prior to executing the WFI or WFE instructions. You can do this
    952               using RCC_AHBPeriphClockLPModeCmd(), RCC_APB2PeriphClockLPModeCmd() and
    953               RCC_APB1PeriphClockLPModeCmd() functions.  
    954          
    955          @endverbatim
    956            * @{
    957            */
    958          
    959          /**
    960            * @brief  Configures the RTC and LCD clock (RTCCLK / LCDCLK).
    961            * @note   - As the RTC clock configuration bits are in the RTC domain and write
    962            *           access is denied to this domain after reset, you have to enable write
    963            *           access using PWR_RTCAccessCmd(ENABLE) function before to configure
    964            *           the RTC clock source (to be done once after reset).    
    965            *         - Once the RTC clock is configured it can't be changed unless the RTC
    966            *           is reset using RCC_RTCResetCmd function, or by a Power On Reset (POR)
    967            *         - The RTC clock (RTCCLK) is used also to clock the LCD (LCDCLK).
    968            *             
    969            * @param  RCC_RTCCLKSource: specifies the RTC clock source.
    970            *   This parameter can be one of the following values:
    971            *     @arg RCC_RTCCLKSource_LSE: LSE selected as RTC clock
    972            *     @arg RCC_RTCCLKSource_LSI: LSI selected as RTC clock
    973            *     @arg RCC_RTCCLKSource_HSE_Div2: HSE divided by 2 selected as RTC clock
    974            *     @arg RCC_RTCCLKSource_HSE_Div4: HSE divided by 4 selected as RTC clock
    975            *     @arg RCC_RTCCLKSource_HSE_Div8: HSE divided by 8 selected as RTC clock
    976            *     @arg RCC_RTCCLKSource_HSE_Div16: HSE divided by 16 selected as RTC clock
    977            *       
    978            * @note   - If the LSE or LSI is used as RTC clock source, the RTC continues to
    979            *           work in STOP and STANDBY modes, and can be used as wakeup source.
    980            *           However, when the HSE clock is used as RTC clock source, the RTC
    981            *           cannot be used in STOP and STANDBY modes.
    982            *             
    983            *         - The maximum input clock frequency for RTC is 1MHz (when using HSE as
    984            *           RTC clock source).
    985            *                          
    986            * @retval None
    987            */

   \                                 In section .text, align 2, keep-with-next
    988          void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
    989          {
   \                     RCC_RTCCLKConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    990            uint32_t 	tmpreg = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    991          
    992            /* Check the parameters */
    993            assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
   \   00000006   0xF5B4 0x3F80      CMP      R4,#+65536
   \   0000000A   0xD017             BEQ.N    ??RCC_RTCCLKConfig_0
   \   0000000C   0xF5B4 0x3F00      CMP      R4,#+131072
   \   00000010   0xD014             BEQ.N    ??RCC_RTCCLKConfig_0
   \   00000012   0xF5B4 0x3F40      CMP      R4,#+196608
   \   00000016   0xD011             BEQ.N    ??RCC_RTCCLKConfig_0
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable35_17  ;; 0x20030000
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD00D             BEQ.N    ??RCC_RTCCLKConfig_0
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable35_18  ;; 0x40030000
   \   00000024   0x4284             CMP      R4,R0
   \   00000026   0xD009             BEQ.N    ??RCC_RTCCLKConfig_0
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable35_19  ;; 0x60030000
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD005             BEQ.N    ??RCC_RTCCLKConfig_0
   \   00000030   0xF240 0x31E1      MOVW     R1,#+993
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   00000038   0x.... 0x....      BL       assert_failed
    994            
    995            if ((RCC_RTCCLKSource & RCC_CSR_RTCSEL_HSE) == RCC_CSR_RTCSEL_HSE)
   \                     ??RCC_RTCCLKConfig_0: (+1)
   \   0000003C   0xF414 0x3040      ANDS     R0,R4,#0x30000
   \   00000040   0xF5B0 0x3F40      CMP      R0,#+196608
   \   00000044   0xD10B             BNE.N    ??RCC_RTCCLKConfig_1
    996            { 
    997              /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
    998              tmpreg = RCC->CR;
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable33  ;; 0x40023800
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x0005             MOVS     R5,R0
    999          
   1000              /* Clear RTCPRE[1:0] bits */
   1001              tmpreg &= ~RCC_CR_RTCPRE;
   \   0000004E   0xF035 0x45C0      BICS     R5,R5,#0x60000000
   1002          
   1003              /* Configure HSE division factor for RTC clock */
   1004              tmpreg |= (RCC_RTCCLKSource & RCC_CR_RTCPRE);
   \   00000052   0xF014 0x40C0      ANDS     R0,R4,#0x60000000
   \   00000056   0x4305             ORRS     R5,R0,R5
   1005          
   1006              /* Store the new value */
   1007              RCC->CR = tmpreg;
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable33  ;; 0x40023800
   \   0000005C   0x6005             STR      R5,[R0, #+0]
   1008            }
   1009                   
   1010            RCC->CSR &= ~RCC_CSR_RTCSEL;
   \                     ??RCC_RTCCLKConfig_1: (+1)
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable35_20  ;; 0x40023834
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0xF430 0x3040      BICS     R0,R0,#0x30000
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable35_20  ;; 0x40023834
   \   0000006C   0x6008             STR      R0,[R1, #+0]
   1011            
   1012            /* Select the RTC clock source */
   1013            RCC->CSR |= (RCC_RTCCLKSource & RCC_CSR_RTCSEL);
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable35_20  ;; 0x40023834
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0xF414 0x3140      ANDS     R1,R4,#0x30000
   \   00000078   0x4308             ORRS     R0,R1,R0
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable35_20  ;; 0x40023834
   \   0000007E   0x6008             STR      R0,[R1, #+0]
   1014          }
   \   00000080   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1015          
   1016          /**
   1017            * @brief  Enables or disables the RTC clock.
   1018            * @note   This function must be used only after the RTC clock source was selected
   1019            *         using the RCC_RTCCLKConfig function.
   1020            * @param  NewState: new state of the RTC clock.
   1021            *   This parameter can be: ENABLE or DISABLE.
   1022            * @retval None
   1023            */

   \                                 In section .text, align 2, keep-with-next
   1024          void RCC_RTCCLKCmd(FunctionalState NewState)
   1025          {
   \                     RCC_RTCCLKCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1026            /* Check the parameters */
   1027            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD008             BEQ.N    ??RCC_RTCCLKCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD005             BEQ.N    ??RCC_RTCCLKCmd_0
   \   00000010   0xF240 0x4103      MOVW     R1,#+1027
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   00000018   0x.... 0x....      BL       assert_failed
   1028            
   1029            *(__IO uint32_t *) CSR_RTCEN_BB = (uint32_t)NewState;
   \                     ??RCC_RTCCLKCmd_0: (+1)
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable35_21  ;; 0x424706d8
   \   00000022   0x6004             STR      R4,[R0, #+0]
   1030          }
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
   1031          
   1032          /**
   1033            * @brief  Forces or releases the RTC peripheral and associated resources reset.
   1034            * @note   This function resets the RTC peripheral, RTC clock source selection
   1035            *         (in RCC_CSR) and the backup registers.
   1036            * @param  NewState: new state of the RTC reset.
   1037            *   This parameter can be: ENABLE or DISABLE.
   1038            * @retval None
   1039            */

   \                                 In section .text, align 2, keep-with-next
   1040          void RCC_RTCResetCmd(FunctionalState NewState)
   1041          {
   \                     RCC_RTCResetCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1042            /* Check the parameters */
   1043            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD008             BEQ.N    ??RCC_RTCResetCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD005             BEQ.N    ??RCC_RTCResetCmd_0
   \   00000010   0xF240 0x4113      MOVW     R1,#+1043
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   00000018   0x.... 0x....      BL       assert_failed
   1044            
   1045            *(__IO uint32_t *) CSR_RTCRST_BB = (uint32_t)NewState;
   \                     ??RCC_RTCResetCmd_0: (+1)
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable35_22  ;; 0x424706dc
   \   00000022   0x6004             STR      R4,[R0, #+0]
   1046          }
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
   1047          
   1048          /**
   1049            * @brief  Enables or disables the AHB peripheral clock.
   1050            * @note   After reset, the peripheral clock (used for registers read/write access)
   1051            *         is disabled and the application software has to enable this clock before 
   1052            *         using it.    
   1053            * @param  RCC_AHBPeriph: specifies the AHB peripheral to gates its clock.
   1054            *   This parameter can be any combination of the following values:
   1055            *     @arg RCC_AHBPeriph_GPIOA
   1056            *     @arg RCC_AHBPeriph_GPIOB
   1057            *     @arg RCC_AHBPeriph_GPIOC  
   1058            *     @arg RCC_AHBPeriph_GPIOD
   1059            *     @arg RCC_AHBPeriph_GPIOE
   1060            *     @arg RCC_AHBPeriph_GPIOH
   1061            *     @arg RCC_AHBPeriph_CRC
   1062            *     @arg RCC_AHBPeriph_FLITF (has effect only when the Flash memory is in power down mode)  
   1063            *     @arg RCC_AHBPeriph_DMA1
   1064            * @param  NewState: new state of the specified peripheral clock.
   1065            *         This parameter can be: ENABLE or DISABLE.
   1066            * @retval None
   1067            */

   \                                 In section .text, align 2, keep-with-next
   1068          void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
   1069          {
   \                     RCC_AHBPeriphClockCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1070            /* Check the parameters */
   1071            assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable35_23  ;; 0xfeff6fc0
   \   0000000A   0x4204             TST      R4,R0
   \   0000000C   0xD101             BNE.N    ??RCC_AHBPeriphClockCmd_0
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD105             BNE.N    ??RCC_AHBPeriphClockCmd_1
   \                     ??RCC_AHBPeriphClockCmd_0: (+1)
   \   00000012   0xF240 0x412F      MOVW     R1,#+1071
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   0000001A   0x.... 0x....      BL       assert_failed
   1072            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_AHBPeriphClockCmd_1: (+1)
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD008             BEQ.N    ??RCC_AHBPeriphClockCmd_2
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0x2D01             CMP      R5,#+1
   \   00000028   0xD005             BEQ.N    ??RCC_AHBPeriphClockCmd_2
   \   0000002A   0xF44F 0x6186      MOV      R1,#+1072
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   00000032   0x.... 0x....      BL       assert_failed
   1073            
   1074            if (NewState != DISABLE)
   \                     ??RCC_AHBPeriphClockCmd_2: (+1)
   \   00000036   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000038   0x2D00             CMP      R5,#+0
   \   0000003A   0xD007             BEQ.N    ??RCC_AHBPeriphClockCmd_3
   1075            {
   1076              RCC->AHBENR |= RCC_AHBPeriph;
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable35_24  ;; 0x4002381c
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x4320             ORRS     R0,R4,R0
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable35_24  ;; 0x4002381c
   \   00000048   0x6008             STR      R0,[R1, #+0]
   \   0000004A   0xE006             B.N      ??RCC_AHBPeriphClockCmd_4
   1077            }
   1078            else
   1079            {
   1080              RCC->AHBENR &= ~RCC_AHBPeriph;
   \                     ??RCC_AHBPeriphClockCmd_3: (+1)
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable35_24  ;; 0x4002381c
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0x43A0             BICS     R0,R0,R4
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable35_24  ;; 0x4002381c
   \   00000058   0x6008             STR      R0,[R1, #+0]
   1081            }
   1082          }
   \                     ??RCC_AHBPeriphClockCmd_4: (+1)
   \   0000005A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1083          
   1084          /**
   1085            * @brief  Enables or disables the High Speed APB (APB2) peripheral clock.
   1086            * @note   After reset, the peripheral clock (used for registers read/write access)
   1087            *         is disabled and the application software has to enable this clock before 
   1088            *         using it.
   1089            * @param  RCC_APB2Periph: specifies the APB2 peripheral to gates its clock.
   1090            *   This parameter can be any combination of the following values:
   1091            *     @arg RCC_APB2Periph_SYSCFG
   1092            *     @arg RCC_APB2Periph_TIM9
   1093            *     @arg RCC_APB2Periph_TIM10
   1094            *     @arg RCC_APB2Periph_TIM11
   1095            *     @arg RCC_APB2Periph_ADC1
   1096            *     @arg RCC_APB2Periph_SPI1
   1097            *     @arg RCC_APB2Periph_USART1            
   1098            * @param  NewState: new state of the specified peripheral clock.
   1099            *         This parameter can be: ENABLE or DISABLE.
   1100            * @retval None
   1101            */

   \                                 In section .text, align 2, keep-with-next
   1102          void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
   1103          {
   \                     RCC_APB2PeriphClockCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1104            /* Check the parameters */
   1105            assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable35_25  ;; 0xffffade2
   \   0000000A   0x4204             TST      R4,R0
   \   0000000C   0xD101             BNE.N    ??RCC_APB2PeriphClockCmd_0
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD105             BNE.N    ??RCC_APB2PeriphClockCmd_1
   \                     ??RCC_APB2PeriphClockCmd_0: (+1)
   \   00000012   0xF240 0x4151      MOVW     R1,#+1105
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   0000001A   0x.... 0x....      BL       assert_failed
   1106            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_APB2PeriphClockCmd_1: (+1)
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD008             BEQ.N    ??RCC_APB2PeriphClockCmd_2
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0x2D01             CMP      R5,#+1
   \   00000028   0xD005             BEQ.N    ??RCC_APB2PeriphClockCmd_2
   \   0000002A   0xF240 0x4152      MOVW     R1,#+1106
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   00000032   0x.... 0x....      BL       assert_failed
   1107          
   1108            if (NewState != DISABLE)
   \                     ??RCC_APB2PeriphClockCmd_2: (+1)
   \   00000036   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000038   0x2D00             CMP      R5,#+0
   \   0000003A   0xD007             BEQ.N    ??RCC_APB2PeriphClockCmd_3
   1109            {
   1110              RCC->APB2ENR |= RCC_APB2Periph;
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable35_26  ;; 0x40023820
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x4320             ORRS     R0,R4,R0
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable35_26  ;; 0x40023820
   \   00000048   0x6008             STR      R0,[R1, #+0]
   \   0000004A   0xE006             B.N      ??RCC_APB2PeriphClockCmd_4
   1111            }
   1112            else
   1113            {
   1114              RCC->APB2ENR &= ~RCC_APB2Periph;
   \                     ??RCC_APB2PeriphClockCmd_3: (+1)
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable35_26  ;; 0x40023820
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0x43A0             BICS     R0,R0,R4
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable35_26  ;; 0x40023820
   \   00000058   0x6008             STR      R0,[R1, #+0]
   1115            }
   1116          }
   \                     ??RCC_APB2PeriphClockCmd_4: (+1)
   \   0000005A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1117          
   1118          /**
   1119            * @brief  Enables or disables the Low Speed APB (APB1) peripheral clock.
   1120            * @note   After reset, the peripheral clock (used for registers read/write access)
   1121            *         is disabled and the application software has to enable this clock before 
   1122            *         using it.
   1123            * @param  RCC_APB1Periph: specifies the APB1 peripheral to gates its clock.
   1124            *   This parameter can be any combination of the following values:
   1125            *     @arg RCC_APB1Periph_TIM2
   1126            *     @arg RCC_APB1Periph_TIM3
   1127            *     @arg RCC_APB1Periph_TIM4
   1128            *     @arg RCC_APB1Periph_TIM6
   1129            *     @arg RCC_APB1Periph_TIM7
   1130            *     @arg RCC_APB1Periph_LCD
   1131            *     @arg RCC_APB1Periph_WWDG
   1132            *     @arg RCC_APB1Periph_SPI2
   1133            *     @arg RCC_APB1Periph_USART2
   1134            *     @arg RCC_APB1Periph_USART3
   1135            *     @arg RCC_APB1Periph_I2C1
   1136            *     @arg RCC_APB1Periph_I2C2
   1137            *     @arg RCC_APB1Periph_USB
   1138            *     @arg RCC_APB1Periph_PWR
   1139            *     @arg RCC_APB1Periph_DAC
   1140            *     @arg RCC_APB1Periph_COMP                                
   1141            * @param  NewState: new state of the specified peripheral clock.
   1142            *         This parameter can be: ENABLE or DISABLE.
   1143            * @retval None
   1144            */

   \                                 In section .text, align 2, keep-with-next
   1145          void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
   1146          {
   \                     RCC_APB1PeriphClockCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1147            /* Check the parameters */
   1148            assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable35_27  ;; 0x4f19b5c8
   \   0000000A   0x4204             TST      R4,R0
   \   0000000C   0xD101             BNE.N    ??RCC_APB1PeriphClockCmd_0
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD105             BNE.N    ??RCC_APB1PeriphClockCmd_1
   \                     ??RCC_APB1PeriphClockCmd_0: (+1)
   \   00000012   0xF240 0x417C      MOVW     R1,#+1148
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   0000001A   0x.... 0x....      BL       assert_failed
   1149            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_APB1PeriphClockCmd_1: (+1)
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD008             BEQ.N    ??RCC_APB1PeriphClockCmd_2
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0x2D01             CMP      R5,#+1
   \   00000028   0xD005             BEQ.N    ??RCC_APB1PeriphClockCmd_2
   \   0000002A   0xF240 0x417D      MOVW     R1,#+1149
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   00000032   0x.... 0x....      BL       assert_failed
   1150          
   1151            if (NewState != DISABLE)
   \                     ??RCC_APB1PeriphClockCmd_2: (+1)
   \   00000036   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000038   0x2D00             CMP      R5,#+0
   \   0000003A   0xD007             BEQ.N    ??RCC_APB1PeriphClockCmd_3
   1152            {
   1153              RCC->APB1ENR |= RCC_APB1Periph;
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable35_28  ;; 0x40023824
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x4320             ORRS     R0,R4,R0
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable35_28  ;; 0x40023824
   \   00000048   0x6008             STR      R0,[R1, #+0]
   \   0000004A   0xE006             B.N      ??RCC_APB1PeriphClockCmd_4
   1154            }
   1155            else
   1156            {
   1157              RCC->APB1ENR &= ~RCC_APB1Periph;
   \                     ??RCC_APB1PeriphClockCmd_3: (+1)
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable35_28  ;; 0x40023824
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0x43A0             BICS     R0,R0,R4
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable35_28  ;; 0x40023824
   \   00000058   0x6008             STR      R0,[R1, #+0]
   1158            }
   1159          }
   \                     ??RCC_APB1PeriphClockCmd_4: (+1)
   \   0000005A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1160          
   1161          /**
   1162            * @brief  Forces or releases AHB peripheral reset.
   1163            * @param  RCC_AHBPeriph: specifies the AHB peripheral to reset.
   1164            *   This parameter can be any combination of the following values:
   1165            *     @arg RCC_AHBPeriph_GPIOA
   1166            *     @arg RCC_AHBPeriph_GPIOB
   1167            *     @arg RCC_AHBPeriph_GPIOC  
   1168            *     @arg RCC_AHBPeriph_GPIOD
   1169            *     @arg RCC_AHBPeriph_GPIOE
   1170            *     @arg RCC_AHBPeriph_GPIOH
   1171            *     @arg RCC_AHBPeriph_CRC
   1172            *     @arg RCC_AHBPeriph_FLITF (has effect only when the Flash memory is in power down mode)  
   1173            *     @arg RCC_AHBPeriph_DMA1   
   1174            * @param  NewState: new state of the specified peripheral reset.
   1175            *         This parameter can be: ENABLE or DISABLE.
   1176            * @retval None
   1177            */

   \                                 In section .text, align 2, keep-with-next
   1178          void RCC_AHBPeriphResetCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
   1179          {
   \                     RCC_AHBPeriphResetCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1180            /* Check the parameters */
   1181            assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable35_23  ;; 0xfeff6fc0
   \   0000000A   0x4204             TST      R4,R0
   \   0000000C   0xD101             BNE.N    ??RCC_AHBPeriphResetCmd_0
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD105             BNE.N    ??RCC_AHBPeriphResetCmd_1
   \                     ??RCC_AHBPeriphResetCmd_0: (+1)
   \   00000012   0xF240 0x419D      MOVW     R1,#+1181
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   0000001A   0x.... 0x....      BL       assert_failed
   1182            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_AHBPeriphResetCmd_1: (+1)
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD008             BEQ.N    ??RCC_AHBPeriphResetCmd_2
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0x2D01             CMP      R5,#+1
   \   00000028   0xD005             BEQ.N    ??RCC_AHBPeriphResetCmd_2
   \   0000002A   0xF240 0x419E      MOVW     R1,#+1182
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   00000032   0x.... 0x....      BL       assert_failed
   1183          
   1184            if (NewState != DISABLE)
   \                     ??RCC_AHBPeriphResetCmd_2: (+1)
   \   00000036   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000038   0x2D00             CMP      R5,#+0
   \   0000003A   0xD007             BEQ.N    ??RCC_AHBPeriphResetCmd_3
   1185            {
   1186              RCC->AHBRSTR |= RCC_AHBPeriph;
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable35_29  ;; 0x40023810
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x4320             ORRS     R0,R4,R0
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable35_29  ;; 0x40023810
   \   00000048   0x6008             STR      R0,[R1, #+0]
   \   0000004A   0xE006             B.N      ??RCC_AHBPeriphResetCmd_4
   1187            }
   1188            else
   1189            {
   1190              RCC->AHBRSTR &= ~RCC_AHBPeriph;
   \                     ??RCC_AHBPeriphResetCmd_3: (+1)
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable35_29  ;; 0x40023810
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0x43A0             BICS     R0,R0,R4
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable35_29  ;; 0x40023810
   \   00000058   0x6008             STR      R0,[R1, #+0]
   1191            }
   1192          }
   \                     ??RCC_AHBPeriphResetCmd_4: (+1)
   \   0000005A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1193          
   1194          /**
   1195            * @brief  Forces or releases High Speed APB (APB2) peripheral reset.
   1196            * @param  RCC_APB2Periph: specifies the APB2 peripheral to reset.
   1197            *   This parameter can be any combination of the following values:
   1198            *     @arg RCC_APB2Periph_SYSCFG
   1199            *     @arg RCC_APB2Periph_TIM9
   1200            *     @arg RCC_APB2Periph_TIM10
   1201            *     @arg RCC_APB2Periph_TIM11
   1202            *     @arg RCC_APB2Periph_ADC1
   1203            *     @arg RCC_APB2Periph_SPI1
   1204            *     @arg RCC_APB2Periph_USART1  
   1205            * @param  NewState: new state of the specified peripheral reset.
   1206            *         This parameter can be: ENABLE or DISABLE.
   1207            * @retval None
   1208            */

   \                                 In section .text, align 2, keep-with-next
   1209          void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
   1210          {
   \                     RCC_APB2PeriphResetCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1211            /* Check the parameters */
   1212            assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable35_25  ;; 0xffffade2
   \   0000000A   0x4204             TST      R4,R0
   \   0000000C   0xD101             BNE.N    ??RCC_APB2PeriphResetCmd_0
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD104             BNE.N    ??RCC_APB2PeriphResetCmd_1
   \                     ??RCC_APB2PeriphResetCmd_0: (+1)
   \   00000012   0xF240 0x41BC      MOVW     R1,#+1212
   \   00000016   0x....             LDR.N    R0,??DataTable35_1
   \   00000018   0x.... 0x....      BL       assert_failed
   1213            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_APB2PeriphResetCmd_1: (+1)
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD007             BEQ.N    ??RCC_APB2PeriphResetCmd_2
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D01             CMP      R5,#+1
   \   00000026   0xD004             BEQ.N    ??RCC_APB2PeriphResetCmd_2
   \   00000028   0xF240 0x41BD      MOVW     R1,#+1213
   \   0000002C   0x....             LDR.N    R0,??DataTable35_1
   \   0000002E   0x.... 0x....      BL       assert_failed
   1214          
   1215            if (NewState != DISABLE)
   \                     ??RCC_APB2PeriphResetCmd_2: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD007             BEQ.N    ??RCC_APB2PeriphResetCmd_3
   1216            {
   1217              RCC->APB2RSTR |= RCC_APB2Periph;
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable35_30  ;; 0x40023814
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x4320             ORRS     R0,R4,R0
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable35_30  ;; 0x40023814
   \   00000044   0x6008             STR      R0,[R1, #+0]
   \   00000046   0xE006             B.N      ??RCC_APB2PeriphResetCmd_4
   1218            }
   1219            else
   1220            {
   1221              RCC->APB2RSTR &= ~RCC_APB2Periph;
   \                     ??RCC_APB2PeriphResetCmd_3: (+1)
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable35_30  ;; 0x40023814
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x43A0             BICS     R0,R0,R4
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable35_30  ;; 0x40023814
   \   00000054   0x6008             STR      R0,[R1, #+0]
   1222            }
   1223          }
   \                     ??RCC_APB2PeriphResetCmd_4: (+1)
   \   00000056   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1224          
   1225          /**
   1226            * @brief  Forces or releases Low Speed APB (APB1) peripheral reset.
   1227            * @param  RCC_APB1Periph: specifies the APB1 peripheral to reset.
   1228            *   This parameter can be any combination of the following values:
   1229            *     @arg RCC_APB1Periph_TIM2
   1230            *     @arg RCC_APB1Periph_TIM3
   1231            *     @arg RCC_APB1Periph_TIM4
   1232            *     @arg RCC_APB1Periph_TIM6
   1233            *     @arg RCC_APB1Periph_TIM7
   1234            *     @arg RCC_APB1Periph_LCD
   1235            *     @arg RCC_APB1Periph_WWDG
   1236            *     @arg RCC_APB1Periph_SPI2
   1237            *     @arg RCC_APB1Periph_USART2
   1238            *     @arg RCC_APB1Periph_USART3
   1239            *     @arg RCC_APB1Periph_I2C1
   1240            *     @arg RCC_APB1Periph_I2C2
   1241            *     @arg RCC_APB1Periph_USB
   1242            *     @arg RCC_APB1Periph_PWR
   1243            *     @arg RCC_APB1Periph_DAC
   1244            *     @arg RCC_APB1Periph_COMP    
   1245            * @param  NewState: new state of the specified peripheral clock.
   1246            *         This parameter can be: ENABLE or DISABLE.
   1247            * @retval None
   1248            */

   \                                 In section .text, align 2, keep-with-next
   1249          void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
   1250          {
   \                     RCC_APB1PeriphResetCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1251            /* Check the parameters */
   1252            assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
   \   00000006   0x....             LDR.N    R0,??DataTable35_27  ;; 0x4f19b5c8
   \   00000008   0x4204             TST      R4,R0
   \   0000000A   0xD101             BNE.N    ??RCC_APB1PeriphResetCmd_0
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD104             BNE.N    ??RCC_APB1PeriphResetCmd_1
   \                     ??RCC_APB1PeriphResetCmd_0: (+1)
   \   00000010   0xF240 0x41E4      MOVW     R1,#+1252
   \   00000014   0x....             LDR.N    R0,??DataTable35_1
   \   00000016   0x.... 0x....      BL       assert_failed
   1253            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_APB1PeriphResetCmd_1: (+1)
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD007             BEQ.N    ??RCC_APB1PeriphResetCmd_2
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D01             CMP      R5,#+1
   \   00000024   0xD004             BEQ.N    ??RCC_APB1PeriphResetCmd_2
   \   00000026   0xF240 0x41E5      MOVW     R1,#+1253
   \   0000002A   0x....             LDR.N    R0,??DataTable35_1
   \   0000002C   0x.... 0x....      BL       assert_failed
   1254          
   1255            if (NewState != DISABLE)
   \                     ??RCC_APB1PeriphResetCmd_2: (+1)
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD005             BEQ.N    ??RCC_APB1PeriphResetCmd_3
   1256            {
   1257              RCC->APB1RSTR |= RCC_APB1Periph;
   \   00000036   0x....             LDR.N    R0,??DataTable35_31  ;; 0x40023818
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x4320             ORRS     R0,R4,R0
   \   0000003C   0x....             LDR.N    R1,??DataTable35_31  ;; 0x40023818
   \   0000003E   0x6008             STR      R0,[R1, #+0]
   \   00000040   0xE004             B.N      ??RCC_APB1PeriphResetCmd_4
   1258            }
   1259            else
   1260            {
   1261              RCC->APB1RSTR &= ~RCC_APB1Periph;
   \                     ??RCC_APB1PeriphResetCmd_3: (+1)
   \   00000042   0x....             LDR.N    R0,??DataTable35_31  ;; 0x40023818
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0x43A0             BICS     R0,R0,R4
   \   00000048   0x....             LDR.N    R1,??DataTable35_31  ;; 0x40023818
   \   0000004A   0x6008             STR      R0,[R1, #+0]
   1262            }
   1263          }
   \                     ??RCC_APB1PeriphResetCmd_4: (+1)
   \   0000004C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1264          
   1265          /**
   1266            * @brief  Enables or disables the AHB peripheral clock during SLEEP mode.
   1267            * @note   - Peripheral clock gating in SLEEP mode can be used to further reduce
   1268            *           power consumption.
   1269            *         - After wakeup from SLEEP mode, the peripheral clock is enabled again.
   1270            *         - By default, all peripheral clocks are enabled during SLEEP mode. 
   1271            * @param  RCC_AHBPeriph: specifies the AHB peripheral to gates its clock.
   1272            *   This parameter can be any combination of the following values:
   1273            *     @arg RCC_AHBPeriph_GPIOA
   1274            *     @arg RCC_AHBPeriph_GPIOB
   1275            *     @arg RCC_AHBPeriph_GPIOC  
   1276            *     @arg RCC_AHBPeriph_GPIOD
   1277            *     @arg RCC_AHBPeriph_GPIOE
   1278            *     @arg RCC_AHBPeriph_GPIOH
   1279            *     @arg RCC_AHBPeriph_CRC
   1280            *     @arg RCC_AHBPeriph_FLITF (has effect only when the Flash memory is in power down mode)  
   1281            *     @arg RCC_AHBPeriph_SRAM     
   1282            *     @arg RCC_AHBPeriph_DMA1
   1283            * @param  NewState: new state of the specified peripheral clock.
   1284            *         This parameter can be: ENABLE or DISABLE.
   1285            * @retval None
   1286            */

   \                                 In section .text, align 2, keep-with-next
   1287          void RCC_AHBPeriphClockLPModeCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
   1288          {
   \                     RCC_AHBPeriphClockLPModeCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1289            /* Check the parameters */
   1290            assert_param(IS_RCC_AHB_LPMODE_PERIPH(RCC_AHBPeriph));
   \   00000006   0x....             LDR.N    R0,??DataTable35_32  ;; 0xfefe6fc0
   \   00000008   0x4204             TST      R4,R0
   \   0000000A   0xD101             BNE.N    ??RCC_AHBPeriphClockLPModeCmd_0
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD104             BNE.N    ??RCC_AHBPeriphClockLPModeCmd_1
   \                     ??RCC_AHBPeriphClockLPModeCmd_0: (+1)
   \   00000010   0xF240 0x510A      MOVW     R1,#+1290
   \   00000014   0x....             LDR.N    R0,??DataTable35_1
   \   00000016   0x.... 0x....      BL       assert_failed
   1291            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_AHBPeriphClockLPModeCmd_1: (+1)
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD007             BEQ.N    ??RCC_AHBPeriphClockLPModeCmd_2
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D01             CMP      R5,#+1
   \   00000024   0xD004             BEQ.N    ??RCC_AHBPeriphClockLPModeCmd_2
   \   00000026   0xF240 0x510B      MOVW     R1,#+1291
   \   0000002A   0x....             LDR.N    R0,??DataTable35_1
   \   0000002C   0x.... 0x....      BL       assert_failed
   1292            
   1293            if (NewState != DISABLE)
   \                     ??RCC_AHBPeriphClockLPModeCmd_2: (+1)
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD005             BEQ.N    ??RCC_AHBPeriphClockLPModeCmd_3
   1294            {
   1295              RCC->AHBLPENR |= RCC_AHBPeriph;
   \   00000036   0x....             LDR.N    R0,??DataTable35_33  ;; 0x40023828
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x4320             ORRS     R0,R4,R0
   \   0000003C   0x....             LDR.N    R1,??DataTable35_33  ;; 0x40023828
   \   0000003E   0x6008             STR      R0,[R1, #+0]
   \   00000040   0xE004             B.N      ??RCC_AHBPeriphClockLPModeCmd_4
   1296            }
   1297            else
   1298            {
   1299              RCC->AHBLPENR &= ~RCC_AHBPeriph;
   \                     ??RCC_AHBPeriphClockLPModeCmd_3: (+1)
   \   00000042   0x....             LDR.N    R0,??DataTable35_33  ;; 0x40023828
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0x43A0             BICS     R0,R0,R4
   \   00000048   0x....             LDR.N    R1,??DataTable35_33  ;; 0x40023828
   \   0000004A   0x6008             STR      R0,[R1, #+0]
   1300            }
   1301          }
   \                     ??RCC_AHBPeriphClockLPModeCmd_4: (+1)
   \   0000004C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1302          
   1303          /**
   1304            * @brief  Enables or disables the APB2 peripheral clock during SLEEP mode.
   1305            * @note   - Peripheral clock gating in SLEEP mode can be used to further reduce
   1306            *           power consumption.
   1307            *         - After wakeup from SLEEP mode, the peripheral clock is enabled again.
   1308            *         - By default, all peripheral clocks are enabled during SLEEP mode. 
   1309            * @param  RCC_APB2Periph: specifies the APB2 peripheral to gates its clock.
   1310            *   This parameter can be any combination of the following values:
   1311            *     @arg RCC_APB2Periph_SYSCFG
   1312            *     @arg RCC_APB2Periph_TIM9
   1313            *     @arg RCC_APB2Periph_TIM10
   1314            *     @arg RCC_APB2Periph_TIM11
   1315            *     @arg RCC_APB2Periph_ADC1
   1316            *     @arg RCC_APB2Periph_SPI1
   1317            *     @arg RCC_APB2Periph_USART1            
   1318            * @param  NewState: new state of the specified peripheral clock.
   1319            *         This parameter can be: ENABLE or DISABLE.
   1320            * @retval None
   1321            */

   \                                 In section .text, align 2, keep-with-next
   1322          void RCC_APB2PeriphClockLPModeCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
   1323          {
   \                     RCC_APB2PeriphClockLPModeCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1324            /* Check the parameters */
   1325            assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
   \   00000006   0x....             LDR.N    R0,??DataTable35_25  ;; 0xffffade2
   \   00000008   0x4204             TST      R4,R0
   \   0000000A   0xD101             BNE.N    ??RCC_APB2PeriphClockLPModeCmd_0
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD104             BNE.N    ??RCC_APB2PeriphClockLPModeCmd_1
   \                     ??RCC_APB2PeriphClockLPModeCmd_0: (+1)
   \   00000010   0xF240 0x512D      MOVW     R1,#+1325
   \   00000014   0x....             LDR.N    R0,??DataTable35_1
   \   00000016   0x.... 0x....      BL       assert_failed
   1326            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_APB2PeriphClockLPModeCmd_1: (+1)
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD007             BEQ.N    ??RCC_APB2PeriphClockLPModeCmd_2
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D01             CMP      R5,#+1
   \   00000024   0xD004             BEQ.N    ??RCC_APB2PeriphClockLPModeCmd_2
   \   00000026   0xF240 0x512E      MOVW     R1,#+1326
   \   0000002A   0x....             LDR.N    R0,??DataTable35_1
   \   0000002C   0x.... 0x....      BL       assert_failed
   1327            
   1328            if (NewState != DISABLE)
   \                     ??RCC_APB2PeriphClockLPModeCmd_2: (+1)
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD005             BEQ.N    ??RCC_APB2PeriphClockLPModeCmd_3
   1329            {
   1330              RCC->APB2LPENR |= RCC_APB2Periph;
   \   00000036   0x....             LDR.N    R0,??DataTable35_34  ;; 0x4002382c
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x4320             ORRS     R0,R4,R0
   \   0000003C   0x....             LDR.N    R1,??DataTable35_34  ;; 0x4002382c
   \   0000003E   0x6008             STR      R0,[R1, #+0]
   \   00000040   0xE004             B.N      ??RCC_APB2PeriphClockLPModeCmd_4
   1331            }
   1332            else
   1333            {
   1334              RCC->APB2LPENR &= ~RCC_APB2Periph;
   \                     ??RCC_APB2PeriphClockLPModeCmd_3: (+1)
   \   00000042   0x....             LDR.N    R0,??DataTable35_34  ;; 0x4002382c
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0x43A0             BICS     R0,R0,R4
   \   00000048   0x....             LDR.N    R1,??DataTable35_34  ;; 0x4002382c
   \   0000004A   0x6008             STR      R0,[R1, #+0]
   1335            }
   1336          }
   \                     ??RCC_APB2PeriphClockLPModeCmd_4: (+1)
   \   0000004C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1337          
   1338          /**
   1339            * @brief  Enables or disables the APB1 peripheral clock during SLEEP mode.
   1340            * @note   - Peripheral clock gating in SLEEP mode can be used to further reduce
   1341            *           power consumption.
   1342            *         - After wakeup from SLEEP mode, the peripheral clock is enabled again.
   1343            *         - By default, all peripheral clocks are enabled during SLEEP mode.        
   1344            * @param  RCC_APB1Periph: specifies the APB1 peripheral to gates its clock.
   1345            *   This parameter can be any combination of the following values:
   1346            *     @arg RCC_APB1Periph_TIM2
   1347            *     @arg RCC_APB1Periph_TIM3
   1348            *     @arg RCC_APB1Periph_TIM4
   1349            *     @arg RCC_APB1Periph_TIM6
   1350            *     @arg RCC_APB1Periph_TIM7
   1351            *     @arg RCC_APB1Periph_LCD
   1352            *     @arg RCC_APB1Periph_WWDG
   1353            *     @arg RCC_APB1Periph_SPI2
   1354            *     @arg RCC_APB1Periph_USART2
   1355            *     @arg RCC_APB1Periph_USART3
   1356            *     @arg RCC_APB1Periph_I2C1
   1357            *     @arg RCC_APB1Periph_I2C2
   1358            *     @arg RCC_APB1Periph_USB
   1359            *     @arg RCC_APB1Periph_PWR
   1360            *     @arg RCC_APB1Periph_DAC
   1361            *     @arg RCC_APB1Periph_COMP                                
   1362            * @param  NewState: new state of the specified peripheral clock.
   1363            *         This parameter can be: ENABLE or DISABLE.
   1364            * @retval None
   1365            */

   \                                 In section .text, align 2, keep-with-next
   1366          void RCC_APB1PeriphClockLPModeCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
   1367          {
   \                     RCC_APB1PeriphClockLPModeCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1368            /* Check the parameters */
   1369            assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
   \   00000006   0x....             LDR.N    R0,??DataTable35_27  ;; 0x4f19b5c8
   \   00000008   0x4204             TST      R4,R0
   \   0000000A   0xD101             BNE.N    ??RCC_APB1PeriphClockLPModeCmd_0
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD104             BNE.N    ??RCC_APB1PeriphClockLPModeCmd_1
   \                     ??RCC_APB1PeriphClockLPModeCmd_0: (+1)
   \   00000010   0xF240 0x5159      MOVW     R1,#+1369
   \   00000014   0x....             LDR.N    R0,??DataTable35_1
   \   00000016   0x.... 0x....      BL       assert_failed
   1370            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_APB1PeriphClockLPModeCmd_1: (+1)
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD007             BEQ.N    ??RCC_APB1PeriphClockLPModeCmd_2
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D01             CMP      R5,#+1
   \   00000024   0xD004             BEQ.N    ??RCC_APB1PeriphClockLPModeCmd_2
   \   00000026   0xF240 0x515A      MOVW     R1,#+1370
   \   0000002A   0x....             LDR.N    R0,??DataTable35_1
   \   0000002C   0x.... 0x....      BL       assert_failed
   1371            
   1372            if (NewState != DISABLE)
   \                     ??RCC_APB1PeriphClockLPModeCmd_2: (+1)
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD005             BEQ.N    ??RCC_APB1PeriphClockLPModeCmd_3
   1373            {
   1374              RCC->APB1LPENR |= RCC_APB1Periph;
   \   00000036   0x....             LDR.N    R0,??DataTable35_35  ;; 0x40023830
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x4320             ORRS     R0,R4,R0
   \   0000003C   0x....             LDR.N    R1,??DataTable35_35  ;; 0x40023830
   \   0000003E   0x6008             STR      R0,[R1, #+0]
   \   00000040   0xE004             B.N      ??RCC_APB1PeriphClockLPModeCmd_4
   1375            }
   1376            else
   1377            {
   1378              RCC->APB1LPENR &= ~RCC_APB1Periph;
   \                     ??RCC_APB1PeriphClockLPModeCmd_3: (+1)
   \   00000042   0x....             LDR.N    R0,??DataTable35_35  ;; 0x40023830
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0x43A0             BICS     R0,R0,R4
   \   00000048   0x....             LDR.N    R1,??DataTable35_35  ;; 0x40023830
   \   0000004A   0x6008             STR      R0,[R1, #+0]
   1379            }
   1380          }
   \                     ??RCC_APB1PeriphClockLPModeCmd_4: (+1)
   \   0000004C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1381          
   1382          /**
   1383            * @}
   1384            */
   1385          
   1386          /** @defgroup RCC_Group4 Interrupts and flags management functions
   1387           *  @brief   Interrupts and flags management functions 
   1388           *
   1389          @verbatim   
   1390           ===============================================================================
   1391                             Interrupts and flags management functions
   1392           ===============================================================================  
   1393          
   1394          @endverbatim
   1395            * @{
   1396            */
   1397          
   1398          /**
   1399            * @brief  Enables or disables the specified RCC interrupts.
   1400            * @note   The CSS interrupt doesn't have an enable bit; once the CSS is enabled
   1401            *         and if the HSE clock fails, the CSS interrupt occurs and an NMI is
   1402            *         automatically generated. The NMI will be executed indefinitely, and 
   1403            *         since NMI has higher priority than any other IRQ (and main program)
   1404            *         the application will be stacked in the NMI ISR unless the CSS interrupt
   1405            *         pending bit is cleared.
   1406            * @param  RCC_IT: specifies the RCC interrupt sources to be enabled or disabled.
   1407            *   This parameter can be any combination of the following values:
   1408            *     @arg RCC_IT_LSIRDY: LSI ready interrupt
   1409            *     @arg RCC_IT_LSERDY: LSE ready interrupt
   1410            *     @arg RCC_IT_HSIRDY: HSI ready interrupt
   1411            *     @arg RCC_IT_HSERDY: HSE ready interrupt
   1412            *     @arg RCC_IT_PLLRDY: PLL ready interrupt
   1413            *     @arg RCC_IT_MSIRDY: MSI ready interrupt
   1414            * @param  NewState: new state of the specified RCC interrupts.
   1415            *   This parameter can be: ENABLE or DISABLE.
   1416            * @retval None
   1417            */

   \                                 In section .text, align 2, keep-with-next
   1418          void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
   1419          {
   \                     RCC_ITConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1420            /* Check the parameters */
   1421            assert_param(IS_RCC_IT(RCC_IT));
   \   00000006   0x20C0             MOVS     R0,#+192
   \   00000008   0x4204             TST      R4,R0
   \   0000000A   0xD102             BNE.N    ??RCC_ITConfig_0
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD104             BNE.N    ??RCC_ITConfig_1
   \                     ??RCC_ITConfig_0: (+1)
   \   00000012   0xF240 0x518D      MOVW     R1,#+1421
   \   00000016   0x....             LDR.N    R0,??DataTable35_1
   \   00000018   0x.... 0x....      BL       assert_failed
   1422            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_ITConfig_1: (+1)
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD007             BEQ.N    ??RCC_ITConfig_2
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D01             CMP      R5,#+1
   \   00000026   0xD004             BEQ.N    ??RCC_ITConfig_2
   \   00000028   0xF240 0x518E      MOVW     R1,#+1422
   \   0000002C   0x....             LDR.N    R0,??DataTable35_1
   \   0000002E   0x.... 0x....      BL       assert_failed
   1423            
   1424            if (NewState != DISABLE)
   \                     ??RCC_ITConfig_2: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD005             BEQ.N    ??RCC_ITConfig_3
   1425            {
   1426              /* Perform Byte access to RCC_CIR[12:8] bits to enable the selected interrupts */
   1427              *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
   \   00000038   0x....             LDR.N    R0,??DataTable35_36  ;; 0x4002380d
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0x4320             ORRS     R0,R4,R0
   \   0000003E   0x....             LDR.N    R1,??DataTable35_36  ;; 0x4002380d
   \   00000040   0x7008             STRB     R0,[R1, #+0]
   \   00000042   0xE004             B.N      ??RCC_ITConfig_4
   1428            }
   1429            else
   1430            {
   1431              /* Perform Byte access to RCC_CIR[12:8] bits to disable the selected interrupts */
   1432              *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
   \                     ??RCC_ITConfig_3: (+1)
   \   00000044   0x....             LDR.N    R0,??DataTable35_36  ;; 0x4002380d
   \   00000046   0x7800             LDRB     R0,[R0, #+0]
   \   00000048   0x43A0             BICS     R0,R0,R4
   \   0000004A   0x....             LDR.N    R1,??DataTable35_36  ;; 0x4002380d
   \   0000004C   0x7008             STRB     R0,[R1, #+0]
   1433            }
   1434          }
   \                     ??RCC_ITConfig_4: (+1)
   \   0000004E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1435          
   1436          /**
   1437            * @brief  Checks whether the specified RCC flag is set or not.
   1438            * @param  RCC_FLAG: specifies the flag to check.
   1439            *   This parameter can be one of the following values:
   1440            *     @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready
   1441            *     @arg RCC_FLAG_MSIRDY: MSI oscillator clock ready  
   1442            *     @arg RCC_FLAG_HSERDY: HSE oscillator clock ready
   1443            *     @arg RCC_FLAG_PLLRDY: PLL clock ready
   1444            *     @arg RCC_FLAG_LSERDY: LSE oscillator clock ready
   1445            *     @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready
   1446            *     @arg RCC_FLAG_OBLRST: Option Byte Loader (OBL) reset 
   1447            *     @arg RCC_FLAG_PINRST: Pin reset
   1448            *     @arg RCC_FLAG_PORRST: POR/PDR reset
   1449            *     @arg RCC_FLAG_SFTRST: Software reset
   1450            *     @arg RCC_FLAG_IWDGRST: Independent Watchdog reset
   1451            *     @arg RCC_FLAG_WWDGRST: Window Watchdog reset
   1452            *     @arg RCC_FLAG_LPWRRST: Low Power reset
   1453            * @retval The new state of RCC_FLAG (SET or RESET).
   1454            */

   \                                 In section .text, align 2, keep-with-next
   1455          FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
   1456          {
   \                     RCC_GetFlagStatus: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1457            uint32_t tmp = 0;
   \   00000004   0x2500             MOVS     R5,#+0
   1458            uint32_t statusreg = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1459            FlagStatus bitstatus = RESET;
   \   00000008   0x2700             MOVS     R7,#+0
   1460          
   1461            /* Check the parameters */
   1462            assert_param(IS_RCC_FLAG(RCC_FLAG));
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C21             CMP      R4,#+33
   \   0000000E   0xD028             BEQ.N    ??RCC_GetFlagStatus_0
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C31             CMP      R4,#+49
   \   00000014   0xD025             BEQ.N    ??RCC_GetFlagStatus_0
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0x2C29             CMP      R4,#+41
   \   0000001A   0xD022             BEQ.N    ??RCC_GetFlagStatus_0
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x2C39             CMP      R4,#+57
   \   00000020   0xD01F             BEQ.N    ??RCC_GetFlagStatus_0
   \   00000022   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000024   0x2C49             CMP      R4,#+73
   \   00000026   0xD01C             BEQ.N    ??RCC_GetFlagStatus_0
   \   00000028   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002A   0x2C41             CMP      R4,#+65
   \   0000002C   0xD019             BEQ.N    ??RCC_GetFlagStatus_0
   \   0000002E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000030   0x2C5A             CMP      R4,#+90
   \   00000032   0xD016             BEQ.N    ??RCC_GetFlagStatus_0
   \   00000034   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000036   0x2C5B             CMP      R4,#+91
   \   00000038   0xD013             BEQ.N    ??RCC_GetFlagStatus_0
   \   0000003A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003C   0x2C5C             CMP      R4,#+92
   \   0000003E   0xD010             BEQ.N    ??RCC_GetFlagStatus_0
   \   00000040   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000042   0x2C5D             CMP      R4,#+93
   \   00000044   0xD00D             BEQ.N    ??RCC_GetFlagStatus_0
   \   00000046   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000048   0x2C5E             CMP      R4,#+94
   \   0000004A   0xD00A             BEQ.N    ??RCC_GetFlagStatus_0
   \   0000004C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004E   0x2C5F             CMP      R4,#+95
   \   00000050   0xD007             BEQ.N    ??RCC_GetFlagStatus_0
   \   00000052   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000054   0x2C5E             CMP      R4,#+94
   \   00000056   0xD004             BEQ.N    ??RCC_GetFlagStatus_0
   \   00000058   0xF240 0x51B6      MOVW     R1,#+1462
   \   0000005C   0x....             LDR.N    R0,??DataTable35_1
   \   0000005E   0x.... 0x....      BL       assert_failed
   1463          
   1464            /* Get the RCC register index */
   1465            tmp = RCC_FLAG >> 5;
   \                     ??RCC_GetFlagStatus_0: (+1)
   \   00000062   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000064   0x0960             LSRS     R0,R4,#+5
   \   00000066   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000068   0x0005             MOVS     R5,R0
   1466          
   1467            if (tmp == 1)               /* The flag to check is in CR register */
   \   0000006A   0x2D01             CMP      R5,#+1
   \   0000006C   0xD103             BNE.N    ??RCC_GetFlagStatus_1
   1468            {
   1469              statusreg = RCC->CR;
   \   0000006E   0x....             LDR.N    R0,??DataTable33  ;; 0x40023800
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0x0006             MOVS     R6,R0
   \   00000074   0xE002             B.N      ??RCC_GetFlagStatus_2
   1470            }
   1471            else          /* The flag to check is in CSR register (tmp == 2) */
   1472            {
   1473              statusreg = RCC->CSR;
   \                     ??RCC_GetFlagStatus_1: (+1)
   \   00000076   0x....             LDR.N    R0,??DataTable35_20  ;; 0x40023834
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x0006             MOVS     R6,R0
   1474            }
   1475          
   1476            /* Get the flag position */
   1477            tmp = RCC_FLAG & FLAG_MASK;
   \                     ??RCC_GetFlagStatus_2: (+1)
   \   0000007C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007E   0xF014 0x001F      ANDS     R0,R4,#0x1F
   \   00000082   0x0005             MOVS     R5,R0
   1478          
   1479            if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
   \   00000084   0x0030             MOVS     R0,R6
   \   00000086   0x40E8             LSRS     R0,R0,R5
   \   00000088   0x07C0             LSLS     R0,R0,#+31
   \   0000008A   0xD502             BPL.N    ??RCC_GetFlagStatus_3
   1480            {
   1481              bitstatus = SET;
   \   0000008C   0x2001             MOVS     R0,#+1
   \   0000008E   0x0007             MOVS     R7,R0
   \   00000090   0xE001             B.N      ??RCC_GetFlagStatus_4
   1482            }
   1483            else
   1484            {
   1485              bitstatus = RESET;
   \                     ??RCC_GetFlagStatus_3: (+1)
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x0007             MOVS     R7,R0
   1486            }
   1487            /* Return the flag status */
   1488            return bitstatus;
   \                     ??RCC_GetFlagStatus_4: (+1)
   \   00000096   0x0038             MOVS     R0,R7
   \   00000098   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1489          }
   1490          
   1491          /**
   1492            * @brief  Clears the RCC reset flags.
   1493            *         The reset flags are: RCC_FLAG_OBLRST, RCC_FLAG_PINRST, RCC_FLAG_PORRST, 
   1494            *         RCC_FLAG_SFTRST, RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST, RCC_FLAG_LPWRRST.
   1495            * @param  None
   1496            * @retval None
   1497            */

   \                                 In section .text, align 2, keep-with-next
   1498          void RCC_ClearFlag(void)
   1499          {
   1500            /* Set RMVF bit to clear the reset flags */
   1501            RCC->CSR |= RCC_CSR_RMVF;
   \                     RCC_ClearFlag: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable35_20  ;; 0x40023834
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF050 0x7080      ORRS     R0,R0,#0x1000000
   \   00000008   0x....             LDR.N    R1,??DataTable35_20  ;; 0x40023834
   \   0000000A   0x6008             STR      R0,[R1, #+0]
   1502          }
   \   0000000C   0x4770             BX       LR               ;; return
   1503          
   1504          /**
   1505            * @brief  Checks whether the specified RCC interrupt has occurred or not.
   1506            * @param  RCC_IT: specifies the RCC interrupt source to check.
   1507            *   This parameter can be one of the following values:
   1508            *     @arg RCC_IT_LSIRDY: LSI ready interrupt
   1509            *     @arg RCC_IT_LSERDY: LSE ready interrupt
   1510            *     @arg RCC_IT_HSIRDY: HSI ready interrupt
   1511            *     @arg RCC_IT_HSERDY: HSE ready interrupt
   1512            *     @arg RCC_IT_PLLRDY: PLL ready interrupt
   1513            *     @arg RCC_IT_MSIRDY: MSI ready interrupt 
   1514            *     @arg RCC_IT_CSS: Clock Security System interrupt
   1515            * @retval The new state of RCC_IT (SET or RESET).
   1516            */

   \                                 In section .text, align 2, keep-with-next
   1517          ITStatus RCC_GetITStatus(uint8_t RCC_IT)
   1518          {
   \                     RCC_GetITStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1519            ITStatus bitstatus = RESET;
   \   00000004   0x2500             MOVS     R5,#+0
   1520            /* Check the parameters */
   1521            assert_param(IS_RCC_GET_IT(RCC_IT));
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C01             CMP      R4,#+1
   \   0000000A   0xD016             BEQ.N    ??RCC_GetITStatus_0
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x2C02             CMP      R4,#+2
   \   00000010   0xD013             BEQ.N    ??RCC_GetITStatus_0
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0x2C04             CMP      R4,#+4
   \   00000016   0xD010             BEQ.N    ??RCC_GetITStatus_0
   \   00000018   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001A   0x2C08             CMP      R4,#+8
   \   0000001C   0xD00D             BEQ.N    ??RCC_GetITStatus_0
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0x2C10             CMP      R4,#+16
   \   00000022   0xD00A             BEQ.N    ??RCC_GetITStatus_0
   \   00000024   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000026   0x2C20             CMP      R4,#+32
   \   00000028   0xD007             BEQ.N    ??RCC_GetITStatus_0
   \   0000002A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002C   0x2C80             CMP      R4,#+128
   \   0000002E   0xD004             BEQ.N    ??RCC_GetITStatus_0
   \   00000030   0xF240 0x51F1      MOVW     R1,#+1521
   \   00000034   0x....             LDR.N    R0,??DataTable35_1
   \   00000036   0x.... 0x....      BL       assert_failed
   1522            
   1523            /* Check the status of the specified RCC interrupt */
   1524            if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
   \                     ??RCC_GetITStatus_0: (+1)
   \   0000003A   0x....             LDR.N    R0,??DataTable35  ;; 0x4002380c
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000040   0x4220             TST      R0,R4
   \   00000042   0xD002             BEQ.N    ??RCC_GetITStatus_1
   1525            {
   1526              bitstatus = SET;
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x0005             MOVS     R5,R0
   \   00000048   0xE001             B.N      ??RCC_GetITStatus_2
   1527            }
   1528            else
   1529            {
   1530              bitstatus = RESET;
   \                     ??RCC_GetITStatus_1: (+1)
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x0005             MOVS     R5,R0
   1531            }
   1532            /* Return the RCC_IT status */
   1533            return  bitstatus;
   \                     ??RCC_GetITStatus_2: (+1)
   \   0000004E   0x0028             MOVS     R0,R5
   \   00000050   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000052   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1534          }
   1535          
   1536          /**
   1537            * @brief  Clears the RCC's interrupt pending bits.
   1538            * @param  RCC_IT: specifies the interrupt pending bit to clear.
   1539            *   This parameter can be any combination of the following values:
   1540            *     @arg RCC_IT_LSIRDY: LSI ready interrupt
   1541            *     @arg RCC_IT_LSERDY: LSE ready interrupt
   1542            *     @arg RCC_IT_HSIRDY: HSI ready interrupt
   1543            *     @arg RCC_IT_HSERDY: HSE ready interrupt
   1544            *     @arg RCC_IT_PLLRDY: PLL ready interrupt
   1545            *     @arg RCC_IT_MSIRDY: MSI ready interrupt  
   1546            *     @arg RCC_IT_CSS: Clock Security System interrupt
   1547            * @retval None
   1548            */

   \                                 In section .text, align 2, keep-with-next
   1549          void RCC_ClearITPendingBit(uint8_t RCC_IT)
   1550          {
   \                     RCC_ClearITPendingBit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1551            /* Check the parameters */
   1552            assert_param(IS_RCC_CLEAR_IT(RCC_IT));
   \   00000004   0x0660             LSLS     R0,R4,#+25
   \   00000006   0xD402             BMI.N    ??RCC_ClearITPendingBit_0
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD104             BNE.N    ??RCC_ClearITPendingBit_1
   \                     ??RCC_ClearITPendingBit_0: (+1)
   \   0000000E   0xF44F 0x61C2      MOV      R1,#+1552
   \   00000012   0x....             LDR.N    R0,??DataTable35_1
   \   00000014   0x.... 0x....      BL       assert_failed
   1553            
   1554            /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
   1555               pending bits */
   1556            *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
   \                     ??RCC_ClearITPendingBit_1: (+1)
   \   00000018   0x....             LDR.N    R0,??DataTable35_37  ;; 0x4002380e
   \   0000001A   0x7004             STRB     R4,[R0, #+0]
   1557          }
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33:
   \   00000000   0x40023800         DC32     0x40023800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33_1:
   \   00000000   0x40023808         DC32     0x40023808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33_2:
   \   00000000   0x88FFC00C         DC32     0x88ffc00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34:
   \   00000000   0xEEFEFFFE         DC32     0xeefefffe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35:
   \   00000000   0x4002380C         DC32     0x4002380c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_2:
   \   00000000   0x40023802         DC32     0x40023802

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_3:
   \   00000000   0x40023807         DC32     0x40023807

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_4:
   \   00000000   0x40023804         DC32     0x40023804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_5:
   \   00000000   0x42470020         DC32     0x42470020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_6:
   \   00000000   0x42470000         DC32     0x42470000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_7:
   \   00000000   0x40023835         DC32     0x40023835

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_8:
   \   00000000   0x42470680         DC32     0x42470680

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_9:
   \   00000000   0x4002380A         DC32     0x4002380a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_10:
   \   00000000   0x42470060         DC32     0x42470060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_11:
   \   00000000   0x42470070         DC32     0x42470070

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_12:
   \   00000000   0x4002380B         DC32     0x4002380b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_13:
   \   00000000   0x00F42400         DC32     0xf42400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_14:
   \   00000000   0x007A1200         DC32     0x7a1200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_15:
   \   00000000   0x........         DC32     PLLMulTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_16:
   \   00000000   0x........         DC32     APBAHBPrescTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_17:
   \   00000000   0x20030000         DC32     0x20030000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_18:
   \   00000000   0x40030000         DC32     0x40030000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_19:
   \   00000000   0x60030000         DC32     0x60030000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_20:
   \   00000000   0x40023834         DC32     0x40023834

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_21:
   \   00000000   0x424706D8         DC32     0x424706d8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_22:
   \   00000000   0x424706DC         DC32     0x424706dc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_23:
   \   00000000   0xFEFF6FC0         DC32     0xfeff6fc0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_24:
   \   00000000   0x4002381C         DC32     0x4002381c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_25:
   \   00000000   0xFFFFADE2         DC32     0xffffade2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_26:
   \   00000000   0x40023820         DC32     0x40023820

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_27:
   \   00000000   0x4F19B5C8         DC32     0x4f19b5c8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_28:
   \   00000000   0x40023824         DC32     0x40023824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_29:
   \   00000000   0x40023810         DC32     0x40023810

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_30:
   \   00000000   0x40023814         DC32     0x40023814

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_31:
   \   00000000   0x40023818         DC32     0x40023818

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_32:
   \   00000000   0xFEFE6FC0         DC32     0xfefe6fc0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_33:
   \   00000000   0x40023828         DC32     0x40023828

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_34:
   \   00000000   0x4002382C         DC32     0x4002382c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_35:
   \   00000000   0x40023830         DC32     0x40023830

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_36:
   \   00000000   0x4002380D         DC32     0x4002380d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_37:
   \   00000000   0x4002380E         DC32     0x4002380e

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x45 0x3A          DC8 45H, 3AH, 5CH, 41H, 43H, 51H, 5CH, 50H
   \              0x5C 0x41    
   \              0x43 0x51    
   \              0x5C 0x50    
   \   00000008   0x72 0x6F          DC8 72H, 6FH, 6AH, 5FH, 76H, 65H, 72H, 30H
   \              0x6A 0x5F    
   \              0x76 0x65    
   \              0x72 0x30    
   \   00000010   0x39 0x61          DC8 39H, 61H, 5FH, 31H, 35H, 31H, 30H, 32H
   \              0x5F 0x31    
   \              0x35 0x31    
   \              0x30 0x32    
   \   00000018   0x30 0x31          DC8 30H, 31H, 35H, 5CH, 42H, 61H, 73H, 65H
   \              0x35 0x5C    
   \              0x42 0x61    
   \              0x73 0x65    
   \   00000020   0x5F 0x30          DC8 5FH, 30H, 32H, 5CH, 32H, 30H, 31H, 33H
   \              0x32 0x5C    
   \              0x32 0x30    
   \              0x31 0x33    
   \   00000028   0x5F 0x31          DC8 5FH, 31H, 31H, 5FH, 32H, 35H, 5FH, 53H
   \              0x31 0x5F    
   \              0x32 0x35    
   \              0x5F 0x53    
   \   00000030   0x70 0x69          DC8 70H, 69H, 72H, 69H, 74H, 31H, 5FH, 45H
   \              0x72 0x69    
   \              0x74 0x31    
   \              0x5F 0x45    
   \   00000038   0x6C 0x65          DC8 6CH, 65H, 6BH, 74H, 72H, 6FH, 6CH, 75H
   \              0x6B 0x74    
   \              0x72 0x6F    
   \              0x6C 0x75    
   \   00000040   0x78 0x5C          DC8 78H, 5CH, 53H, 54H, 4DH, 33H, 32H, 4CH
   \              0x53 0x54    
   \              0x4D 0x33    
   \              0x32 0x4C    
   \   00000048   0x5C 0x53          DC8 5CH, 53H, 54H, 4DH, 33H, 32H, 4CH, 31H
   \              0x54 0x4D    
   \              0x33 0x32    
   \              0x4C 0x31    
   \   00000050   0x78 0x78          DC8 78H, 78H, 5FH, 53H, 74H, 64H, 50H, 65H
   \              0x5F 0x53    
   \              0x74 0x64    
   \              0x50 0x65    
   \   00000058   0x72 0x69          DC8 72H, 69H, 70H, 68H, 5FH, 4CH, 69H, 62H
   \              0x70 0x68    
   \              0x5F 0x4C    
   \              0x69 0x62    
   \   00000060   0x5C 0x53          DC8 5CH, 53H, 6FH, 75H, 72H, 63H, 65H, 5CH
   \              0x6F 0x75    
   \              0x72 0x63    
   \              0x65 0x5C    
   \   00000068   0x53 0x54          DC8 53H, 54H, 4DH, 33H, 32H, 4CH, 31H, 78H
   \              0x4D 0x33    
   \              0x32 0x4C    
   \              0x31 0x78    
   \   00000070   0x78 0x5F          DC8 78H, 5FH, 53H, 74H, 64H, 50H, 65H, 72H
   \              0x53 0x74    
   \              0x64 0x50    
   \              0x65 0x72    
   \   00000078   0x69 0x70          DC8 69H, 70H, 68H, 5FH, 44H, 72H, 69H, 76H
   \              0x68 0x5F    
   \              0x44 0x72    
   \              0x69 0x76    
   \   00000080   0x65 0x72          DC8 65H, 72H, 5CH, 73H, 72H, 63H, 5CH, 73H
   \              0x5C 0x73    
   \              0x72 0x63    
   \              0x5C 0x73    
   \   00000088   0x74 0x6D          DC8 74H, 6DH, 33H, 32H, 6CH, 31H, 78H, 78H
   \              0x33 0x32    
   \              0x6C 0x31    
   \              0x78 0x78    
   \   00000090   0x5F 0x72          DC8 5FH, 72H, 63H, 63H, 2EH, 63H, 0
   \              0x63 0x63    
   \              0x2E 0x63    
   \              0x00         
   \   00000097   0x00               DC8 0
   1558          
   1559          /**
   1560            * @}
   1561            */
   1562          
   1563          /**
   1564            * @}
   1565            */
   1566          
   1567          /**
   1568            * @}
   1569            */
   1570          
   1571          /**
   1572            * @}
   1573            */
   1574          
   1575          /******************* (C) COPYRIGHT 2010 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   RCC_AHBPeriphClockCmd
        16   -> assert_failed
      16   RCC_AHBPeriphClockLPModeCmd
        16   -> assert_failed
      16   RCC_AHBPeriphResetCmd
        16   -> assert_failed
      16   RCC_APB1PeriphClockCmd
        16   -> assert_failed
      16   RCC_APB1PeriphClockLPModeCmd
        16   -> assert_failed
      16   RCC_APB1PeriphResetCmd
        16   -> assert_failed
      16   RCC_APB2PeriphClockCmd
        16   -> assert_failed
      16   RCC_APB2PeriphClockLPModeCmd
        16   -> assert_failed
      16   RCC_APB2PeriphResetCmd
        16   -> assert_failed
      16   RCC_AdjustHSICalibrationValue
        16   -> assert_failed
       8   RCC_AdjustMSICalibrationValue
         8   -> assert_failed
       0   RCC_ClearFlag
       8   RCC_ClearITPendingBit
         8   -> assert_failed
       8   RCC_ClockSecuritySystemCmd
         8   -> assert_failed
       0   RCC_DeInit
      16   RCC_GetClocksFreq
      24   RCC_GetFlagStatus
        24   -> assert_failed
      16   RCC_GetITStatus
        16   -> assert_failed
       0   RCC_GetSYSCLKSource
      16   RCC_HCLKConfig
        16   -> assert_failed
       8   RCC_HSEConfig
         8   -> assert_failed
       8   RCC_HSICmd
         8   -> assert_failed
      16   RCC_ITConfig
        16   -> assert_failed
       8   RCC_LSEConfig
         8   -> assert_failed
       8   RCC_LSICmd
         8   -> assert_failed
      16   RCC_MCOConfig
        16   -> assert_failed
       8   RCC_MSICmd
         8   -> assert_failed
      16   RCC_MSIRangeConfig
        16   -> assert_failed
      16   RCC_PCLK1Config
        16   -> assert_failed
      16   RCC_PCLK2Config
        16   -> assert_failed
       8   RCC_PLLCmd
         8   -> assert_failed
      16   RCC_PLLConfig
        16   -> assert_failed
       8   RCC_RTCCLKCmd
         8   -> assert_failed
      16   RCC_RTCCLKConfig
        16   -> assert_failed
       8   RCC_RTCResetCmd
         8   -> assert_failed
      16   RCC_SYSCLKConfig
        16   -> assert_failed
      16   RCC_WaitForHSEStartUp
        16   -> RCC_GetFlagStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable33
       4  ??DataTable33_1
       4  ??DataTable33_2
       4  ??DataTable34
       4  ??DataTable35
       4  ??DataTable35_1
       4  ??DataTable35_10
       4  ??DataTable35_11
       4  ??DataTable35_12
       4  ??DataTable35_13
       4  ??DataTable35_14
       4  ??DataTable35_15
       4  ??DataTable35_16
       4  ??DataTable35_17
       4  ??DataTable35_18
       4  ??DataTable35_19
       4  ??DataTable35_2
       4  ??DataTable35_20
       4  ??DataTable35_21
       4  ??DataTable35_22
       4  ??DataTable35_23
       4  ??DataTable35_24
       4  ??DataTable35_25
       4  ??DataTable35_26
       4  ??DataTable35_27
       4  ??DataTable35_28
       4  ??DataTable35_29
       4  ??DataTable35_3
       4  ??DataTable35_30
       4  ??DataTable35_31
       4  ??DataTable35_32
       4  ??DataTable35_33
       4  ??DataTable35_34
       4  ??DataTable35_35
       4  ??DataTable35_36
       4  ??DataTable35_37
       4  ??DataTable35_4
       4  ??DataTable35_5
       4  ??DataTable35_6
       4  ??DataTable35_7
       4  ??DataTable35_8
       4  ??DataTable35_9
     152  ?_0
      16  APBAHBPrescTable
      12  PLLMulTable
      92  RCC_AHBPeriphClockCmd
      78  RCC_AHBPeriphClockLPModeCmd
      92  RCC_AHBPeriphResetCmd
      92  RCC_APB1PeriphClockCmd
      78  RCC_APB1PeriphClockLPModeCmd
      78  RCC_APB1PeriphResetCmd
      92  RCC_APB2PeriphClockCmd
      78  RCC_APB2PeriphClockLPModeCmd
      88  RCC_APB2PeriphResetCmd
      50  RCC_AdjustHSICalibrationValue
      30  RCC_AdjustMSICalibrationValue
      14  RCC_ClearFlag
      30  RCC_ClearITPendingBit
      38  RCC_ClockSecuritySystemCmd
      94  RCC_DeInit
     318  RCC_GetClocksFreq
     156  RCC_GetFlagStatus
      84  RCC_GetITStatus
      12  RCC_GetSYSCLKSource
      76  RCC_HCLKConfig
      48  RCC_HSEConfig
      38  RCC_HSICmd
      80  RCC_ITConfig
      50  RCC_LSEConfig
      38  RCC_LSICmd
     120  RCC_MCOConfig
      38  RCC_MSICmd
      80  RCC_MSIRangeConfig
      68  RCC_PCLK1Config
      70  RCC_PCLK2Config
      38  RCC_PLLCmd
     142  RCC_PLLConfig
      38  RCC_RTCCLKCmd
     130  RCC_RTCCLKConfig
      38  RCC_RTCResetCmd
      56  RCC_SYSCLKConfig
      64  RCC_WaitForHSEStartUp

 
    28 bytes in section .data
   152 bytes in section .rodata
 2 974 bytes in section .text
 
 2 974 bytes of CODE  memory
   152 bytes of CONST memory
    28 bytes of DATA  memory

Errors: none
Warnings: none
