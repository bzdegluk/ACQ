###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        20/Nov/2015  05:05:40
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_dac.c
#    Command line =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_dac.c
#        -D USE_STDPERIPH_DRIVER -D VECT_TAB_FLASH -D STM32L1XX_MD -D
#        IAR_ARM_CM3 -D USE_FULL_ASSERT -D SPIRIT_USE_FULL_ASSERT -D
#        USE_SYSTICK_DELAY -D SDK -lC
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\List\
#        -o
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\.\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\examples\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\runtime\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\SDK_Eval_STM32L\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\SPIRIT1_Library\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\SDK_Eval_Util\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\SDK_Virtual_Com\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32_USB-FS-Device_Lib\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\ACQ\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\CMSIS\Include\"
#    List file    =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\List\stm32l1xx_dac.lst
#    Object file  =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\Obj\stm32l1xx_dac.o
#
###############################################################################

E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_dac.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_dac.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    31-December-2010
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Digital-to-Analog Converter (DAC) peripheral: 
      9            *           - DAC channels configuration: trigger, output buffer, data format
     10            *           - DMA management      
     11            *           - Interrupts and flags management
     12            *
     13            *  @verbatim
     14            *    
     15            *          ===================================================================
     16            *                             DAC Peripheral features
     17            *          ===================================================================
     18            *          The device integrates two 12-bit Digital Analog Converters that can 
     19            *          be used independently or simultaneously (dual mode):
     20            *            1- DAC channel1 with DAC_OUT1 (PA4) as output
     21            *            1- DAC channel2 with DAC_OUT2 (PA5) as output
     22            *
     23            *          Digital to Analog conversion can be non-triggered using DAC_Trigger_None
     24            *          and DAC_OUT1/DAC_OUT2 is available once writing to DHRx register using 
     25            *          DAC_SetChannel1Data()/DAC_SetChannel2Data.
     26            *   
     27            *         Digital to Analog conversion can be triggered by:
     28            *             1- External event: EXTI Line 9 (any GPIOx_Pin9) using DAC_Trigger_Ext_IT9.
     29            *                The used pin (GPIOx_Pin9) must be configured in input mode.
     30            *
     31            *             2- Timers TRGO: TIM2, TIM4, TIM6, TIM7 and TIM9 
     32            *                (DAC_Trigger_T2_TRGO, DAC_Trigger_T4_TRGO...)
     33            *                The timer TRGO event should be selected using TIM_SelectOutputTrigger()
     34            *
     35            *             3- Software using DAC_Trigger_Software
     36            *
     37            *          Each DAC channel integrates an output buffer that can be used to 
     38            *          reduce the output impedance, and to drive external loads directly
     39            *          without having to add an external operational amplifier.
     40            *          To enable, the output buffer use  
     41            *              DAC_InitStructure.DAC_OutputBuffer = DAC_OutputBuffer_Enable;
     42            *          
     43            *          Refer to the device datasheet for more details about output impedance
     44            *          value with and without output buffer.
     45            *
     46            *          Both DAC channels can be used to generate
     47            *             1- Noise wave using DAC_WaveGeneration_Noise
     48            *             2- Triangle wave using DAC_WaveGeneration_Triangle
     49            *        
     50            *          Wave generation can be disabled using DAC_WaveGeneration_None
     51            *
     52            *          The DAC data format can be:
     53            *             1- 8-bit right alignment using DAC_Align_8b_R
     54            *             2- 12-bit left alignment using DAC_Align_12b_L
     55            *             3- 12-bit right alignment using DAC_Align_12b_R
     56            *
     57            *          The analog output voltage on each DAC channel pin is determined
     58            *          by the following equation: DAC_OUTx = VREF+ * DOR / 4095
     59            *             with  DOR is the Data Output Register
     60            *                   VEF+ is the input voltage reference (refer to the device datasheet)
     61            *          e.g. To set DAC_OUT1 to 0.7V, use
     62            *            DAC_SetChannel1Data(DAC_Align_12b_R, 868);
     63            *          Assuming that VREF+ = 3.3, DAC_OUT1 = (3.3 * 868) / 4095 = 0.7V
     64            *
     65            *          A DMA1 request can be generated when an external trigger (but not
     66            *          a software trigger) occurs if DMA1 requests are enabled using
     67            *          DAC_DMACmd()
     68            *          DMA1 requests are mapped as following:
     69            *             1- DAC channel1 is mapped on DMA1 channel3 which must be already 
     70            *                configured
     71            *             2- DAC channel2 is mapped on DMA1 channel4 which must be already 
     72            *                configured
     73            *
     74            *          ===================================================================      
     75            *                              How to use this driver 
     76            *          ===================================================================          
     77            *            - DAC APB clock must be enabled to get write access to DAC
     78            *              registers using
     79            *              RCC_APB1PeriphClockCmd(RCC_APB1Periph_DAC, ENABLE)
     80            *            - Configure DAC_OUTx (DAC_OUT1: PA4, DAC_OUT2: PA5) in analog mode.
     81            *            - Configure the DAC channel using DAC_Init()
     82            *            - Enable the DAC channel using DAC_Cmd()
     83            * 
     84            *  @endverbatim
     85            *    
     86            ******************************************************************************
     87            * @attention
     88            *
     89            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     90            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     91            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     92            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     93            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     94            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     95            *
     96            * <h2><center>&copy; COPYRIGHT 2010 STMicroelectronics</center></h2>
     97            ******************************************************************************  
     98            */ 
     99          
    100          /* Includes ------------------------------------------------------------------*/
    101          #include "stm32l1xx_dac.h"
    102          #include "stm32l1xx_rcc.h"
    103          
    104          /** @addtogroup STM32L1xx_StdPeriph_Driver
    105            * @{
    106            */
    107          
    108          /** @defgroup DAC 
    109            * @brief DAC driver modules
    110            * @{
    111            */ 
    112          
    113          /* Private typedef -----------------------------------------------------------*/
    114          /* Private define ------------------------------------------------------------*/
    115          /* CR register Mask */
    116          #define CR_CLEAR_MASK              ((uint32_t)0x00000FFE)
    117          
    118          /* DAC Dual Channels SWTRIG masks */
    119          #define DUAL_SWTRIG_SET            ((uint32_t)0x00000003)
    120          #define DUAL_SWTRIG_RESET          ((uint32_t)0xFFFFFFFC)
    121          
    122          /* DHR registers offsets */
    123          #define DHR12R1_OFFSET             ((uint32_t)0x00000008)
    124          #define DHR12R2_OFFSET             ((uint32_t)0x00000014)
    125          #define DHR12RD_OFFSET             ((uint32_t)0x00000020)
    126          
    127          /* DOR register offset */
    128          #define DOR_OFFSET                 ((uint32_t)0x0000002C)
    129          
    130          /* Private macro -------------------------------------------------------------*/
    131          /* Private variables ---------------------------------------------------------*/
    132          /* Private function prototypes -----------------------------------------------*/
    133          /* Private functions ---------------------------------------------------------*/
    134          
    135          /** @defgroup DAC_Private_Functions
    136            * @{
    137            */ 
    138          
    139          /** @defgroup DAC_Group1 DAC channels configuration
    140           *  @brief   DAC channels configuration: trigger, output buffer, data format 
    141           *
    142          @verbatim   
    143           ===============================================================================
    144                    DAC channels configuration: trigger, output buffer, data format
    145           ===============================================================================  
    146          
    147          @endverbatim
    148            * @{
    149            */
    150          
    151          /**
    152            * @brief  Deinitializes the DAC peripheral registers to their default reset values.
    153            * @param  None
    154            * @retval None
    155            */

   \                                 In section .text, align 2, keep-with-next
    156          void DAC_DeInit(void)
    157          {
   \                     DAC_DeInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    158            /* Enable DAC reset state */
    159            RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0xF05F 0x5000      MOVS     R0,#+536870912
   \   00000008   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    160            /* Release DAC from reset state */
    161            RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, DISABLE);
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0xF05F 0x5000      MOVS     R0,#+536870912
   \   00000012   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    162          }
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    163          
    164          /**
    165            * @brief  Initializes the DAC peripheral according to the specified 
    166            *         parameters in the DAC_InitStruct.
    167            * @param  DAC_Channel: the selected DAC channel. 
    168            *   This parameter can be one of the following values:
    169            *     @arg DAC_Channel_1: DAC Channel1 selected
    170            *     @arg DAC_Channel_2: DAC Channel2 selected
    171            * @param  DAC_InitStruct: pointer to a DAC_InitTypeDef structure that
    172            *         contains the configuration information for the specified DAC channel.
    173            *         DAC_Trigger selects the trigger source: EXTI Line 9, TIM2, TIM4....
    174            *         DAC_WaveGeneration selects the waveform to be generated: noise, triangle
    175            *         DAC_LFSRUnmask_TriangleAmplitude 
    176            *             defines the LFSR when noise waveform is selected by DAC_WaveGeneration
    177            *             or defines the amplitude of the triangle waveform when it is 
    178            *             selected by DAC_WaveGeneration
    179            *         DAC_OutputBuffer enables/disables the output buffer on DAC_OUTx
    180            * @retval None
    181            */

   \                                 In section .text, align 2, keep-with-next
    182          void DAC_Init(uint32_t DAC_Channel, DAC_InitTypeDef* DAC_InitStruct)
    183          {
   \                     DAC_Init: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    184            uint32_t tmpreg1 = 0, tmpreg2 = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0x2700             MOVS     R7,#+0
    185          
    186            /* Check the DAC parameters */
    187            assert_param(IS_DAC_TRIGGER(DAC_InitStruct->DAC_Trigger));
   \   0000000A   0x6828             LDR      R0,[R5, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD019             BEQ.N    ??DAC_Init_0
   \   00000010   0x6828             LDR      R0,[R5, #+0]
   \   00000012   0x2804             CMP      R0,#+4
   \   00000014   0xD016             BEQ.N    ??DAC_Init_0
   \   00000016   0x6828             LDR      R0,[R5, #+0]
   \   00000018   0x2814             CMP      R0,#+20
   \   0000001A   0xD013             BEQ.N    ??DAC_Init_0
   \   0000001C   0x6828             LDR      R0,[R5, #+0]
   \   0000001E   0x281C             CMP      R0,#+28
   \   00000020   0xD010             BEQ.N    ??DAC_Init_0
   \   00000022   0x6828             LDR      R0,[R5, #+0]
   \   00000024   0x2824             CMP      R0,#+36
   \   00000026   0xD00D             BEQ.N    ??DAC_Init_0
   \   00000028   0x6828             LDR      R0,[R5, #+0]
   \   0000002A   0x282C             CMP      R0,#+44
   \   0000002C   0xD00A             BEQ.N    ??DAC_Init_0
   \   0000002E   0x6828             LDR      R0,[R5, #+0]
   \   00000030   0x2834             CMP      R0,#+52
   \   00000032   0xD007             BEQ.N    ??DAC_Init_0
   \   00000034   0x6828             LDR      R0,[R5, #+0]
   \   00000036   0x283C             CMP      R0,#+60
   \   00000038   0xD004             BEQ.N    ??DAC_Init_0
   \   0000003A   0x21BB             MOVS     R1,#+187
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000040   0x.... 0x....      BL       assert_failed
    188            assert_param(IS_DAC_GENERATE_WAVE(DAC_InitStruct->DAC_WaveGeneration));
   \                     ??DAC_Init_0: (+1)
   \   00000044   0x6868             LDR      R0,[R5, #+4]
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD00A             BEQ.N    ??DAC_Init_1
   \   0000004A   0x6868             LDR      R0,[R5, #+4]
   \   0000004C   0x2840             CMP      R0,#+64
   \   0000004E   0xD007             BEQ.N    ??DAC_Init_1
   \   00000050   0x6868             LDR      R0,[R5, #+4]
   \   00000052   0x2880             CMP      R0,#+128
   \   00000054   0xD004             BEQ.N    ??DAC_Init_1
   \   00000056   0x21BC             MOVS     R1,#+188
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable14
   \   0000005C   0x.... 0x....      BL       assert_failed
    189            assert_param(IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude));
   \                     ??DAC_Init_1: (+1)
   \   00000060   0x68A8             LDR      R0,[R5, #+8]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD05F             BEQ.N    ??DAC_Init_2
   \   00000066   0x68A8             LDR      R0,[R5, #+8]
   \   00000068   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000006C   0xD05B             BEQ.N    ??DAC_Init_2
   \   0000006E   0x68A8             LDR      R0,[R5, #+8]
   \   00000070   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000074   0xD057             BEQ.N    ??DAC_Init_2
   \   00000076   0x68A8             LDR      R0,[R5, #+8]
   \   00000078   0xF5B0 0x7F40      CMP      R0,#+768
   \   0000007C   0xD053             BEQ.N    ??DAC_Init_2
   \   0000007E   0x68A8             LDR      R0,[R5, #+8]
   \   00000080   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000084   0xD04F             BEQ.N    ??DAC_Init_2
   \   00000086   0x68A8             LDR      R0,[R5, #+8]
   \   00000088   0xF5B0 0x6FA0      CMP      R0,#+1280
   \   0000008C   0xD04B             BEQ.N    ??DAC_Init_2
   \   0000008E   0x68A8             LDR      R0,[R5, #+8]
   \   00000090   0xF5B0 0x6FC0      CMP      R0,#+1536
   \   00000094   0xD047             BEQ.N    ??DAC_Init_2
   \   00000096   0x68A8             LDR      R0,[R5, #+8]
   \   00000098   0xF5B0 0x6FE0      CMP      R0,#+1792
   \   0000009C   0xD043             BEQ.N    ??DAC_Init_2
   \   0000009E   0x68A8             LDR      R0,[R5, #+8]
   \   000000A0   0xF5B0 0x6F00      CMP      R0,#+2048
   \   000000A4   0xD03F             BEQ.N    ??DAC_Init_2
   \   000000A6   0x68A8             LDR      R0,[R5, #+8]
   \   000000A8   0xF5B0 0x6F10      CMP      R0,#+2304
   \   000000AC   0xD03B             BEQ.N    ??DAC_Init_2
   \   000000AE   0x68A8             LDR      R0,[R5, #+8]
   \   000000B0   0xF5B0 0x6F20      CMP      R0,#+2560
   \   000000B4   0xD037             BEQ.N    ??DAC_Init_2
   \   000000B6   0x68A8             LDR      R0,[R5, #+8]
   \   000000B8   0xF5B0 0x6F30      CMP      R0,#+2816
   \   000000BC   0xD033             BEQ.N    ??DAC_Init_2
   \   000000BE   0x68A8             LDR      R0,[R5, #+8]
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xD030             BEQ.N    ??DAC_Init_2
   \   000000C4   0x68A8             LDR      R0,[R5, #+8]
   \   000000C6   0xF5B0 0x7F80      CMP      R0,#+256
   \   000000CA   0xD02C             BEQ.N    ??DAC_Init_2
   \   000000CC   0x68A8             LDR      R0,[R5, #+8]
   \   000000CE   0xF5B0 0x7F00      CMP      R0,#+512
   \   000000D2   0xD028             BEQ.N    ??DAC_Init_2
   \   000000D4   0x68A8             LDR      R0,[R5, #+8]
   \   000000D6   0xF5B0 0x7F40      CMP      R0,#+768
   \   000000DA   0xD024             BEQ.N    ??DAC_Init_2
   \   000000DC   0x68A8             LDR      R0,[R5, #+8]
   \   000000DE   0xF5B0 0x6F80      CMP      R0,#+1024
   \   000000E2   0xD020             BEQ.N    ??DAC_Init_2
   \   000000E4   0x68A8             LDR      R0,[R5, #+8]
   \   000000E6   0xF5B0 0x6FA0      CMP      R0,#+1280
   \   000000EA   0xD01C             BEQ.N    ??DAC_Init_2
   \   000000EC   0x68A8             LDR      R0,[R5, #+8]
   \   000000EE   0xF5B0 0x6FC0      CMP      R0,#+1536
   \   000000F2   0xD018             BEQ.N    ??DAC_Init_2
   \   000000F4   0x68A8             LDR      R0,[R5, #+8]
   \   000000F6   0xF5B0 0x6FE0      CMP      R0,#+1792
   \   000000FA   0xD014             BEQ.N    ??DAC_Init_2
   \   000000FC   0x68A8             LDR      R0,[R5, #+8]
   \   000000FE   0xF5B0 0x6F00      CMP      R0,#+2048
   \   00000102   0xD010             BEQ.N    ??DAC_Init_2
   \   00000104   0x68A8             LDR      R0,[R5, #+8]
   \   00000106   0xF5B0 0x6F10      CMP      R0,#+2304
   \   0000010A   0xD00C             BEQ.N    ??DAC_Init_2
   \   0000010C   0x68A8             LDR      R0,[R5, #+8]
   \   0000010E   0xF5B0 0x6F20      CMP      R0,#+2560
   \   00000112   0xD008             BEQ.N    ??DAC_Init_2
   \   00000114   0x68A8             LDR      R0,[R5, #+8]
   \   00000116   0xF5B0 0x6F30      CMP      R0,#+2816
   \   0000011A   0xD004             BEQ.N    ??DAC_Init_2
   \   0000011C   0x21BD             MOVS     R1,#+189
   \   0000011E   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000122   0x.... 0x....      BL       assert_failed
    190            assert_param(IS_DAC_OUTPUT_BUFFER_STATE(DAC_InitStruct->DAC_OutputBuffer));
   \                     ??DAC_Init_2: (+1)
   \   00000126   0x68E8             LDR      R0,[R5, #+12]
   \   00000128   0x2800             CMP      R0,#+0
   \   0000012A   0xD007             BEQ.N    ??DAC_Init_3
   \   0000012C   0x68E8             LDR      R0,[R5, #+12]
   \   0000012E   0x2802             CMP      R0,#+2
   \   00000130   0xD004             BEQ.N    ??DAC_Init_3
   \   00000132   0x21BE             MOVS     R1,#+190
   \   00000134   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000138   0x.... 0x....      BL       assert_failed
    191          
    192          /*---------------------------- DAC CR Configuration --------------------------*/
    193            /* Get the DAC CR value */
    194            tmpreg1 = DAC->CR;
   \                     ??DAC_Init_3: (+1)
   \   0000013C   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40007400
   \   00000140   0x6800             LDR      R0,[R0, #+0]
   \   00000142   0x0006             MOVS     R6,R0
    195            /* Clear BOFFx, TENx, TSELx, WAVEx and MAMPx bits */
    196            tmpreg1 &= ~(CR_CLEAR_MASK << DAC_Channel);
   \   00000144   0xF640 0x70FE      MOVW     R0,#+4094
   \   00000148   0x40A0             LSLS     R0,R0,R4
   \   0000014A   0x4386             BICS     R6,R6,R0
    197            /* Configure for the selected DAC channel: buffer output, trigger, wave generation,
    198               mask/amplitude for wave generation */
    199            /* Set TSELx and TENx bits according to DAC_Trigger value */
    200            /* Set WAVEx bits according to DAC_WaveGeneration value */
    201            /* Set MAMPx bits according to DAC_LFSRUnmask_TriangleAmplitude value */ 
    202            /* Set BOFFx bit according to DAC_OutputBuffer value */   
    203            tmpreg2 = (DAC_InitStruct->DAC_Trigger | DAC_InitStruct->DAC_WaveGeneration |
    204                       DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude | DAC_InitStruct->DAC_OutputBuffer);
   \   0000014C   0x6828             LDR      R0,[R5, #+0]
   \   0000014E   0x6869             LDR      R1,[R5, #+4]
   \   00000150   0x4308             ORRS     R0,R1,R0
   \   00000152   0x68A9             LDR      R1,[R5, #+8]
   \   00000154   0x4308             ORRS     R0,R1,R0
   \   00000156   0x68E9             LDR      R1,[R5, #+12]
   \   00000158   0x4308             ORRS     R0,R1,R0
   \   0000015A   0x0007             MOVS     R7,R0
    205            /* Calculate CR register value depending on DAC_Channel */
    206            tmpreg1 |= tmpreg2 << DAC_Channel;
   \   0000015C   0xFA17 0xF004      LSLS     R0,R7,R4
   \   00000160   0x4306             ORRS     R6,R0,R6
    207            /* Write to DAC CR */
    208            DAC->CR = tmpreg1;
   \   00000162   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40007400
   \   00000166   0x6006             STR      R6,[R0, #+0]
    209          }
   \   00000168   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    210          
    211          /**
    212            * @brief  Fills each DAC_InitStruct member with its default value.
    213            * @param  DAC_InitStruct : pointer to a DAC_InitTypeDef structure which will 
    214            *         be initialized.
    215            * @retval None
    216            */

   \                                 In section .text, align 2, keep-with-next
    217          void DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct)
    218          {
    219          /*--------------- Reset DAC init structure parameters values -----------------*/
    220            /* Initialize the DAC_Trigger member */
    221            DAC_InitStruct->DAC_Trigger = DAC_Trigger_None;
   \                     DAC_StructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    222            /* Initialize the DAC_WaveGeneration member */
    223            DAC_InitStruct->DAC_WaveGeneration = DAC_WaveGeneration_None;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6041             STR      R1,[R0, #+4]
    224            /* Initialize the DAC_LFSRUnmask_TriangleAmplitude member */
    225            DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude = DAC_LFSRUnmask_Bit0;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6081             STR      R1,[R0, #+8]
    226            /* Initialize the DAC_OutputBuffer member */
    227            DAC_InitStruct->DAC_OutputBuffer = DAC_OutputBuffer_Enable;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x60C1             STR      R1,[R0, #+12]
    228          }
   \   00000010   0x4770             BX       LR               ;; return
    229          
    230          /**
    231            * @brief  Enables or disables the specified DAC channel.
    232            * @param  DAC_Channel: The selected DAC channel. 
    233            *   This parameter can be one of the following values:
    234            *     @arg DAC_Channel_1: DAC Channel1 selected
    235            *     @arg DAC_Channel_2: DAC Channel2 selected
    236            * @param  NewState: new state of the DAC channel. 
    237            *      This parameter can be: ENABLE or DISABLE.
    238            * @note When the DAC channel is enabled the trigger source can no more
    239            *       be modified.
    240            * @retval None
    241            */

   \                                 In section .text, align 2, keep-with-next
    242          void DAC_Cmd(uint32_t DAC_Channel, FunctionalState NewState)
    243          {
   \                     DAC_Cmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    244            /* Check the parameters */
    245            assert_param(IS_DAC_CHANNEL(DAC_Channel));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD006             BEQ.N    ??DAC_Cmd_0
   \   0000000A   0x2C10             CMP      R4,#+16
   \   0000000C   0xD004             BEQ.N    ??DAC_Cmd_0
   \   0000000E   0x21F5             MOVS     R1,#+245
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000014   0x.... 0x....      BL       assert_failed
    246            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??DAC_Cmd_0: (+1)
   \   00000018   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   0x2D00             CMP      R5,#+0
   \   0000001C   0xD007             BEQ.N    ??DAC_Cmd_1
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D01             CMP      R5,#+1
   \   00000022   0xD004             BEQ.N    ??DAC_Cmd_1
   \   00000024   0x21F6             MOVS     R1,#+246
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable14
   \   0000002A   0x.... 0x....      BL       assert_failed
    247          
    248            if (NewState != DISABLE)
   \                     ??DAC_Cmd_1: (+1)
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0x2D00             CMP      R5,#+0
   \   00000032   0xD009             BEQ.N    ??DAC_Cmd_2
    249            {
    250              /* Enable the selected DAC channel */
    251              DAC->CR |= (DAC_CR_EN1 << DAC_Channel);
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40007400
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x2101             MOVS     R1,#+1
   \   0000003C   0x40A1             LSLS     R1,R1,R4
   \   0000003E   0x4308             ORRS     R0,R1,R0
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable14_1  ;; 0x40007400
   \   00000044   0x6008             STR      R0,[R1, #+0]
   \   00000046   0xE008             B.N      ??DAC_Cmd_3
    252            }
    253            else
    254            {
    255              /* Disable the selected DAC channel */
    256              DAC->CR &= (~(DAC_CR_EN1 << DAC_Channel));
   \                     ??DAC_Cmd_2: (+1)
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40007400
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x2101             MOVS     R1,#+1
   \   00000050   0x40A1             LSLS     R1,R1,R4
   \   00000052   0x4388             BICS     R0,R0,R1
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable14_1  ;; 0x40007400
   \   00000058   0x6008             STR      R0,[R1, #+0]
    257            }
    258          }
   \                     ??DAC_Cmd_3: (+1)
   \   0000005A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    259          
    260          /**
    261            * @brief  Enables or disables the selected DAC channel software trigger.
    262            * @param  DAC_Channel: the selected DAC channel. 
    263            *   This parameter can be one of the following values:
    264            *     @arg DAC_Channel_1: DAC Channel1 selected
    265            *     @arg DAC_Channel_2: DAC Channel2 selected
    266            * @param  NewState: new state of the selected DAC channel software trigger.
    267            *   This parameter can be: ENABLE or DISABLE.
    268            * @retval None
    269            */

   \                                 In section .text, align 2, keep-with-next
    270          void DAC_SoftwareTriggerCmd(uint32_t DAC_Channel, FunctionalState NewState)
    271          {
   \                     DAC_SoftwareTriggerCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    272            /* Check the parameters */
    273            assert_param(IS_DAC_CHANNEL(DAC_Channel));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??DAC_SoftwareTriggerCmd_0
   \   0000000A   0x2C10             CMP      R4,#+16
   \   0000000C   0xD005             BEQ.N    ??DAC_SoftwareTriggerCmd_0
   \   0000000E   0xF240 0x1111      MOVW     R1,#+273
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000016   0x.... 0x....      BL       assert_failed
    274            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??DAC_SoftwareTriggerCmd_0: (+1)
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD008             BEQ.N    ??DAC_SoftwareTriggerCmd_1
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D01             CMP      R5,#+1
   \   00000024   0xD005             BEQ.N    ??DAC_SoftwareTriggerCmd_1
   \   00000026   0xF44F 0x7189      MOV      R1,#+274
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable14
   \   0000002E   0x.... 0x....      BL       assert_failed
    275          
    276            if (NewState != DISABLE)
   \                     ??DAC_SoftwareTriggerCmd_1: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD00A             BEQ.N    ??DAC_SoftwareTriggerCmd_2
    277            {
    278              /* Enable software trigger for the selected DAC channel */
    279              DAC->SWTRIGR |= (uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4);
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable14_2  ;; 0x40007404
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x2101             MOVS     R1,#+1
   \   00000040   0x0922             LSRS     R2,R4,#+4
   \   00000042   0x4091             LSLS     R1,R1,R2
   \   00000044   0x4308             ORRS     R0,R1,R0
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable14_2  ;; 0x40007404
   \   0000004A   0x6008             STR      R0,[R1, #+0]
   \   0000004C   0xE009             B.N      ??DAC_SoftwareTriggerCmd_3
    280            }
    281            else
    282            {
    283              /* Disable software trigger for the selected DAC channel */
    284              DAC->SWTRIGR &= ~((uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4));
   \                     ??DAC_SoftwareTriggerCmd_2: (+1)
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable14_2  ;; 0x40007404
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x2101             MOVS     R1,#+1
   \   00000056   0x0922             LSRS     R2,R4,#+4
   \   00000058   0x4091             LSLS     R1,R1,R2
   \   0000005A   0x4388             BICS     R0,R0,R1
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable14_2  ;; 0x40007404
   \   00000060   0x6008             STR      R0,[R1, #+0]
    285            }
    286          }
   \                     ??DAC_SoftwareTriggerCmd_3: (+1)
   \   00000062   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    287          
    288          /**
    289            * @brief  Enables or disables simultaneously the two DAC channels software
    290            *         triggers.
    291            * @param  NewState: new state of the DAC channels software triggers.
    292            *   This parameter can be: ENABLE or DISABLE.
    293            * @retval None
    294            */

   \                                 In section .text, align 2, keep-with-next
    295          void DAC_DualSoftwareTriggerCmd(FunctionalState NewState)
    296          {
   \                     DAC_DualSoftwareTriggerCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    297            /* Check the parameters */
    298            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD008             BEQ.N    ??DAC_DualSoftwareTriggerCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD005             BEQ.N    ??DAC_DualSoftwareTriggerCmd_0
   \   00000010   0xF44F 0x7195      MOV      R1,#+298
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000018   0x.... 0x....      BL       assert_failed
    299          
    300            if (NewState != DISABLE)
   \                     ??DAC_DualSoftwareTriggerCmd_0: (+1)
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD008             BEQ.N    ??DAC_DualSoftwareTriggerCmd_1
    301            {
    302              /* Enable software trigger for both DAC channels */
    303              DAC->SWTRIGR |= DUAL_SWTRIG_SET;
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable14_2  ;; 0x40007404
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0xF050 0x0003      ORRS     R0,R0,#0x3
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable14_2  ;; 0x40007404
   \   00000030   0x6008             STR      R0,[R1, #+0]
   \   00000032   0xE007             B.N      ??DAC_DualSoftwareTriggerCmd_2
    304            }
    305            else
    306            {
    307              /* Disable software trigger for both DAC channels */
    308              DAC->SWTRIGR &= DUAL_SWTRIG_RESET;
   \                     ??DAC_DualSoftwareTriggerCmd_1: (+1)
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable14_2  ;; 0x40007404
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x0880             LSRS     R0,R0,#+2
   \   0000003C   0x0080             LSLS     R0,R0,#+2
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable14_2  ;; 0x40007404
   \   00000042   0x6008             STR      R0,[R1, #+0]
    309            }
    310          }
   \                     ??DAC_DualSoftwareTriggerCmd_2: (+1)
   \   00000044   0xBD10             POP      {R4,PC}          ;; return
    311          
    312          /**
    313            * @brief  Enables or disables the selected DAC channel wave generation.
    314            * @param  DAC_Channel: the selected DAC channel. 
    315            *   This parameter can be one of the following values:
    316            *     @arg DAC_Channel_1: DAC Channel1 selected
    317            *     @arg DAC_Channel_2: DAC Channel2 selected
    318            * @param  DAC_Wave: Specifies the wave type to enable or disable.
    319            *   This parameter can be one of the following values:
    320            *     @arg DAC_Wave_Noise: noise wave generation
    321            *     @arg DAC_Wave_Triangle: triangle wave generation
    322            * @param  NewState: new state of the selected DAC channel wave generation.
    323            *   This parameter can be: ENABLE or DISABLE.
    324            * @note   
    325            * @retval None
    326            */

   \                                 In section .text, align 2, keep-with-next
    327          void DAC_WaveGenerationCmd(uint32_t DAC_Channel, uint32_t DAC_Wave, FunctionalState NewState)
    328          {
   \                     DAC_WaveGenerationCmd: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    329            /* Check the parameters */
    330            assert_param(IS_DAC_CHANNEL(DAC_Channel));
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD007             BEQ.N    ??DAC_WaveGenerationCmd_0
   \   0000000C   0x2C10             CMP      R4,#+16
   \   0000000E   0xD005             BEQ.N    ??DAC_WaveGenerationCmd_0
   \   00000010   0xF44F 0x71A5      MOV      R1,#+330
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000018   0x.... 0x....      BL       assert_failed
    331            assert_param(IS_DAC_WAVE(DAC_Wave)); 
   \                     ??DAC_WaveGenerationCmd_0: (+1)
   \   0000001C   0x2D40             CMP      R5,#+64
   \   0000001E   0xD007             BEQ.N    ??DAC_WaveGenerationCmd_1
   \   00000020   0x2D80             CMP      R5,#+128
   \   00000022   0xD005             BEQ.N    ??DAC_WaveGenerationCmd_1
   \   00000024   0xF240 0x114B      MOVW     R1,#+331
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable14
   \   0000002C   0x.... 0x....      BL       assert_failed
    332            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??DAC_WaveGenerationCmd_1: (+1)
   \   00000030   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000032   0x2E00             CMP      R6,#+0
   \   00000034   0xD008             BEQ.N    ??DAC_WaveGenerationCmd_2
   \   00000036   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000038   0x2E01             CMP      R6,#+1
   \   0000003A   0xD005             BEQ.N    ??DAC_WaveGenerationCmd_2
   \   0000003C   0xF44F 0x71A6      MOV      R1,#+332
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000044   0x.... 0x....      BL       assert_failed
    333          
    334            if (NewState != DISABLE)
   \                     ??DAC_WaveGenerationCmd_2: (+1)
   \   00000048   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004A   0x2E00             CMP      R6,#+0
   \   0000004C   0xD007             BEQ.N    ??DAC_WaveGenerationCmd_3
    335            {
    336              /* Enable the selected wave generation for the selected DAC channel */
    337              DAC->CR |= DAC_Wave << DAC_Channel;
   \   0000004E   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40007400
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0xFA15 0xF104      LSLS     R1,R5,R4
   \   00000056   0x4308             ORRS     R0,R1,R0
   \   00000058   0x....             LDR.N    R1,??DataTable14_1  ;; 0x40007400
   \   0000005A   0x6008             STR      R0,[R1, #+0]
   \   0000005C   0xE006             B.N      ??DAC_WaveGenerationCmd_4
    338            }
    339            else
    340            {
    341              /* Disable the selected wave generation for the selected DAC channel */
    342              DAC->CR &= ~(DAC_Wave << DAC_Channel);
   \                     ??DAC_WaveGenerationCmd_3: (+1)
   \   0000005E   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40007400
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0xFA15 0xF104      LSLS     R1,R5,R4
   \   00000066   0x4388             BICS     R0,R0,R1
   \   00000068   0x....             LDR.N    R1,??DataTable14_1  ;; 0x40007400
   \   0000006A   0x6008             STR      R0,[R1, #+0]
    343            }
    344          }
   \                     ??DAC_WaveGenerationCmd_4: (+1)
   \   0000006C   0xBD70             POP      {R4-R6,PC}       ;; return
    345          
    346          /**
    347            * @brief  Set the specified data holding register value for DAC channel1.
    348            * @param  DAC_Align: Specifies the data alignment for DAC channel1.
    349            *   This parameter can be one of the following values:
    350            *     @arg DAC_Align_8b_R: 8bit right data alignment selected
    351            *     @arg DAC_Align_12b_L: 12bit left data alignment selected
    352            *     @arg DAC_Align_12b_R: 12bit right data alignment selected
    353            * @param  Data : Data to be loaded in the selected data holding register.
    354            * @retval None
    355            */

   \                                 In section .text, align 2, keep-with-next
    356          void DAC_SetChannel1Data(uint32_t DAC_Align, uint16_t Data)
    357          {  
   \                     DAC_SetChannel1Data: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    358            __IO uint32_t tmp = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
    359            
    360            /* Check the parameters */
    361            assert_param(IS_DAC_ALIGN(DAC_Align));
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD008             BEQ.N    ??DAC_SetChannel1Data_0
   \   0000000E   0x2C04             CMP      R4,#+4
   \   00000010   0xD006             BEQ.N    ??DAC_SetChannel1Data_0
   \   00000012   0x2C08             CMP      R4,#+8
   \   00000014   0xD004             BEQ.N    ??DAC_SetChannel1Data_0
   \   00000016   0xF240 0x1169      MOVW     R1,#+361
   \   0000001A   0x....             LDR.N    R0,??DataTable14
   \   0000001C   0x.... 0x....      BL       assert_failed
    362            assert_param(IS_DAC_DATA(Data));
   \                     ??DAC_SetChannel1Data_0: (+1)
   \   00000020   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000022   0xF64F 0x70F1      MOVW     R0,#+65521
   \   00000026   0x4285             CMP      R5,R0
   \   00000028   0xDB04             BLT.N    ??DAC_SetChannel1Data_1
   \   0000002A   0xF44F 0x71B5      MOV      R1,#+362
   \   0000002E   0x....             LDR.N    R0,??DataTable14
   \   00000030   0x.... 0x....      BL       assert_failed
    363            
    364            tmp = (uint32_t)DAC_BASE; 
   \                     ??DAC_SetChannel1Data_1: (+1)
   \   00000034   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40007400
   \   00000036   0x9000             STR      R0,[SP, #+0]
    365            tmp += DHR12R1_OFFSET + DAC_Align;
   \   00000038   0x9800             LDR      R0,[SP, #+0]
   \   0000003A   0xF114 0x0108      ADDS     R1,R4,#+8
   \   0000003E   0x1808             ADDS     R0,R1,R0
   \   00000040   0x9000             STR      R0,[SP, #+0]
    366          
    367            /* Set the DAC channel1 selected data holding register */
    368            *(__IO uint32_t *) tmp = Data;
   \   00000042   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000044   0x9800             LDR      R0,[SP, #+0]
   \   00000046   0x6005             STR      R5,[R0, #+0]
    369          }
   \   00000048   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    370          
    371          /**
    372            * @brief  Set the specified data holding register value for DAC channel2.
    373            * @param  DAC_Align: Specifies the data alignment for DAC channel2.
    374            *   This parameter can be one of the following values:
    375            *     @arg DAC_Align_8b_R: 8bit right data alignment selected
    376            *     @arg DAC_Align_12b_L: 12bit left data alignment selected
    377            *     @arg DAC_Align_12b_R: 12bit right data alignment selected
    378            * @param  Data : Data to be loaded in the selected data holding register.
    379            * @retval None
    380            */

   \                                 In section .text, align 2, keep-with-next
    381          void DAC_SetChannel2Data(uint32_t DAC_Align, uint16_t Data)
    382          {
   \                     DAC_SetChannel2Data: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    383            __IO uint32_t tmp = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
    384          
    385            /* Check the parameters */
    386            assert_param(IS_DAC_ALIGN(DAC_Align));
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD008             BEQ.N    ??DAC_SetChannel2Data_0
   \   0000000E   0x2C04             CMP      R4,#+4
   \   00000010   0xD006             BEQ.N    ??DAC_SetChannel2Data_0
   \   00000012   0x2C08             CMP      R4,#+8
   \   00000014   0xD004             BEQ.N    ??DAC_SetChannel2Data_0
   \   00000016   0xF44F 0x71C1      MOV      R1,#+386
   \   0000001A   0x....             LDR.N    R0,??DataTable14
   \   0000001C   0x.... 0x....      BL       assert_failed
    387            assert_param(IS_DAC_DATA(Data));
   \                     ??DAC_SetChannel2Data_0: (+1)
   \   00000020   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000022   0xF64F 0x70F1      MOVW     R0,#+65521
   \   00000026   0x4285             CMP      R5,R0
   \   00000028   0xDB04             BLT.N    ??DAC_SetChannel2Data_1
   \   0000002A   0xF240 0x1183      MOVW     R1,#+387
   \   0000002E   0x....             LDR.N    R0,??DataTable14
   \   00000030   0x.... 0x....      BL       assert_failed
    388            
    389            tmp = (uint32_t)DAC_BASE;
   \                     ??DAC_SetChannel2Data_1: (+1)
   \   00000034   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40007400
   \   00000036   0x9000             STR      R0,[SP, #+0]
    390            tmp += DHR12R2_OFFSET + DAC_Align;
   \   00000038   0x9800             LDR      R0,[SP, #+0]
   \   0000003A   0xF114 0x0114      ADDS     R1,R4,#+20
   \   0000003E   0x1808             ADDS     R0,R1,R0
   \   00000040   0x9000             STR      R0,[SP, #+0]
    391          
    392            /* Set the DAC channel2 selected data holding register */
    393            *(__IO uint32_t *)tmp = Data;
   \   00000042   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000044   0x9800             LDR      R0,[SP, #+0]
   \   00000046   0x6005             STR      R5,[R0, #+0]
    394          }
   \   00000048   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    395          
    396          /**
    397            * @brief  Set the specified data holding register value for dual channel DAC.
    398            * @param  DAC_Align: Specifies the data alignment for dual channel DAC.
    399            *   This parameter can be one of the following values:
    400            *     @arg DAC_Align_8b_R: 8bit right data alignment selected
    401            *     @arg DAC_Align_12b_L: 12bit left data alignment selected
    402            *     @arg DAC_Align_12b_R: 12bit right data alignment selected
    403            * @param  Data2: Data for DAC Channel2 to be loaded in the selected data 
    404            *         holding register.
    405            * @param  Data1: Data for DAC Channel1 to be loaded in the selected data 
    406            *         holding register.
    407            * @note In dual mode, a unique register access is required to write in both
    408            *       DAC channels at the same time.
    409            * @retval None
    410            */

   \                                 In section .text, align 2, keep-with-next
    411          void DAC_SetDualChannelData(uint32_t DAC_Align, uint16_t Data2, uint16_t Data1)
    412          {
   \                     DAC_SetDualChannelData: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    413            uint32_t data = 0, tmp = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
    414            
    415            /* Check the parameters */
    416            assert_param(IS_DAC_ALIGN(DAC_Align));
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD008             BEQ.N    ??DAC_SetDualChannelData_0
   \   00000014   0x2C04             CMP      R4,#+4
   \   00000016   0xD006             BEQ.N    ??DAC_SetDualChannelData_0
   \   00000018   0x2C08             CMP      R4,#+8
   \   0000001A   0xD004             BEQ.N    ??DAC_SetDualChannelData_0
   \   0000001C   0xF44F 0x71D0      MOV      R1,#+416
   \   00000020   0x....             LDR.N    R0,??DataTable14
   \   00000022   0x.... 0x....      BL       assert_failed
    417            assert_param(IS_DAC_DATA(Data1));
   \                     ??DAC_SetDualChannelData_0: (+1)
   \   00000026   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000028   0xF64F 0x70F1      MOVW     R0,#+65521
   \   0000002C   0x4286             CMP      R6,R0
   \   0000002E   0xDB04             BLT.N    ??DAC_SetDualChannelData_1
   \   00000030   0xF240 0x11A1      MOVW     R1,#+417
   \   00000034   0x....             LDR.N    R0,??DataTable14
   \   00000036   0x.... 0x....      BL       assert_failed
    418            assert_param(IS_DAC_DATA(Data2));
   \                     ??DAC_SetDualChannelData_1: (+1)
   \   0000003A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000003C   0xF64F 0x70F1      MOVW     R0,#+65521
   \   00000040   0x4285             CMP      R5,R0
   \   00000042   0xDB04             BLT.N    ??DAC_SetDualChannelData_2
   \   00000044   0xF44F 0x71D1      MOV      R1,#+418
   \   00000048   0x....             LDR.N    R0,??DataTable14
   \   0000004A   0x.... 0x....      BL       assert_failed
    419            
    420            /* Calculate and set dual DAC data holding register value */
    421            if (DAC_Align == DAC_Align_8b_R)
   \                     ??DAC_SetDualChannelData_2: (+1)
   \   0000004E   0x2C08             CMP      R4,#+8
   \   00000050   0xD105             BNE.N    ??DAC_SetDualChannelData_3
    422            {
    423              data = ((uint32_t)Data2 << 8) | Data1; 
   \   00000052   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000054   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000056   0xEA56 0x2005      ORRS     R0,R6,R5, LSL #+8
   \   0000005A   0x0007             MOVS     R7,R0
   \   0000005C   0xE004             B.N      ??DAC_SetDualChannelData_4
    424            }
    425            else
    426            {
    427              data = ((uint32_t)Data2 << 16) | Data1;
   \                     ??DAC_SetDualChannelData_3: (+1)
   \   0000005E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000060   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000062   0xEA56 0x4005      ORRS     R0,R6,R5, LSL #+16
   \   00000066   0x0007             MOVS     R7,R0
    428            }
    429            
    430            tmp = (uint32_t)DAC_BASE;
   \                     ??DAC_SetDualChannelData_4: (+1)
   \   00000068   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40007400
   \   0000006A   0x4680             MOV      R8,R0
    431            tmp += DHR12RD_OFFSET + DAC_Align;
   \   0000006C   0xF114 0x0020      ADDS     R0,R4,#+32
   \   00000070   0xEB10 0x0808      ADDS     R8,R0,R8
    432          
    433            /* Set the dual DAC selected data holding register */
    434            *(__IO uint32_t *)tmp = data;
   \   00000074   0xF8C8 0x7000      STR      R7,[R8, #+0]
    435          }
   \   00000078   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    436          
    437          /**
    438            * @brief  Returns the last data output value of the selected DAC channel.
    439            * @param  DAC_Channel: the selected DAC channel. 
    440            *   This parameter can be one of the following values:
    441            *     @arg DAC_Channel_1: DAC Channel1 selected
    442            *     @arg DAC_Channel_2: DAC Channel2 selected
    443            * @retval The selected DAC channel data output value.
    444            */

   \                                 In section .text, align 2, keep-with-next
    445          uint16_t DAC_GetDataOutputValue(uint32_t DAC_Channel)
    446          {
   \                     DAC_GetDataOutputValue: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    447            __IO uint32_t tmp = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
    448            
    449            /* Check the parameters */
    450            assert_param(IS_DAC_CHANNEL(DAC_Channel));
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD006             BEQ.N    ??DAC_GetDataOutputValue_0
   \   0000000E   0x2C10             CMP      R4,#+16
   \   00000010   0xD004             BEQ.N    ??DAC_GetDataOutputValue_0
   \   00000012   0xF44F 0x71E1      MOV      R1,#+450
   \   00000016   0x....             LDR.N    R0,??DataTable14
   \   00000018   0x.... 0x....      BL       assert_failed
    451            
    452            tmp = (uint32_t) DAC_BASE ;
   \                     ??DAC_GetDataOutputValue_0: (+1)
   \   0000001C   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40007400
   \   0000001E   0x9000             STR      R0,[SP, #+0]
    453            tmp += DOR_OFFSET + ((uint32_t)DAC_Channel >> 2);
   \   00000020   0x9800             LDR      R0,[SP, #+0]
   \   00000022   0x08A1             LSRS     R1,R4,#+2
   \   00000024   0x312C             ADDS     R1,R1,#+44
   \   00000026   0x1808             ADDS     R0,R1,R0
   \   00000028   0x9000             STR      R0,[SP, #+0]
    454            
    455            /* Returns the DAC channel data output register value */
    456            return (uint16_t) (*(__IO uint32_t*) tmp);
   \   0000002A   0x9800             LDR      R0,[SP, #+0]
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000030   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    457          }
    458          
    459          /**
    460            * @}
    461            */
    462          
    463          /** @defgroup DAC_Group2 DMA management functions
    464           *  @brief   DMA management functions
    465           *
    466          @verbatim   
    467           ===============================================================================
    468                                    DMA management functions
    469           ===============================================================================  
    470          
    471          @endverbatim
    472            * @{
    473            */
    474          
    475          /**
    476            * @brief  Enables or disables the specified DAC channel DMA request.
    477            *         When enabled DMA1 is generated when an external trigger (EXTI Line9,
    478            *         TIM2, TIM4, TIM6, TIM7 or TIM9  but not a software trigger) occurs
    479            * @param  DAC_Channel: the selected DAC channel.
    480            *   This parameter can be one of the following values:
    481            *     @arg DAC_Channel_1: DAC Channel1 selected
    482            *     @arg DAC_Channel_2: DAC Channel2 selected
    483            * @param  NewState: new state of the selected DAC channel DMA request.
    484            *   This parameter can be: ENABLE or DISABLE.
    485            *  The DAC channel1 (channel2) is mapped on DMA1 channel3 (channel4) which 
    486            *  must be already configured. 
    487            * @retval None
    488            */

   \                                 In section .text, align 2, keep-with-next
    489          void DAC_DMACmd(uint32_t DAC_Channel, FunctionalState NewState)
    490          {
   \                     DAC_DMACmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    491            /* Check the parameters */
    492            assert_param(IS_DAC_CHANNEL(DAC_Channel));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD006             BEQ.N    ??DAC_DMACmd_0
   \   0000000A   0x2C10             CMP      R4,#+16
   \   0000000C   0xD004             BEQ.N    ??DAC_DMACmd_0
   \   0000000E   0xF44F 0x71F6      MOV      R1,#+492
   \   00000012   0x....             LDR.N    R0,??DataTable14
   \   00000014   0x.... 0x....      BL       assert_failed
    493            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??DAC_DMACmd_0: (+1)
   \   00000018   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   0x2D00             CMP      R5,#+0
   \   0000001C   0xD007             BEQ.N    ??DAC_DMACmd_1
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D01             CMP      R5,#+1
   \   00000022   0xD004             BEQ.N    ??DAC_DMACmd_1
   \   00000024   0xF240 0x11ED      MOVW     R1,#+493
   \   00000028   0x....             LDR.N    R0,??DataTable14
   \   0000002A   0x.... 0x....      BL       assert_failed
    494          
    495            if (NewState != DISABLE)
   \                     ??DAC_DMACmd_1: (+1)
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0x2D00             CMP      R5,#+0
   \   00000032   0xD008             BEQ.N    ??DAC_DMACmd_2
    496            {
    497              /* Enable the selected DAC channel DMA request */
    498              DAC->CR |= (DAC_CR_DMAEN1 << DAC_Channel);
   \   00000034   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40007400
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF44F 0x5180      MOV      R1,#+4096
   \   0000003C   0x40A1             LSLS     R1,R1,R4
   \   0000003E   0x4308             ORRS     R0,R1,R0
   \   00000040   0x....             LDR.N    R1,??DataTable14_1  ;; 0x40007400
   \   00000042   0x6008             STR      R0,[R1, #+0]
   \   00000044   0xE007             B.N      ??DAC_DMACmd_3
    499            }
    500            else
    501            {
    502              /* Disable the selected DAC channel DMA request */
    503              DAC->CR &= (~(DAC_CR_DMAEN1 << DAC_Channel));
   \                     ??DAC_DMACmd_2: (+1)
   \   00000046   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40007400
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0xF44F 0x5180      MOV      R1,#+4096
   \   0000004E   0x40A1             LSLS     R1,R1,R4
   \   00000050   0x4388             BICS     R0,R0,R1
   \   00000052   0x....             LDR.N    R1,??DataTable14_1  ;; 0x40007400
   \   00000054   0x6008             STR      R0,[R1, #+0]
    504            }
    505          }
   \                     ??DAC_DMACmd_3: (+1)
   \   00000056   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    506          
    507          /**
    508            * @}
    509            */
    510          
    511          /** @defgroup DAC_Group3 Interrupts and flags management functions
    512           *  @brief   Interrupts and flags management functions
    513           *
    514          @verbatim   
    515           ===============================================================================
    516                             Interrupts and flags management functions
    517           ===============================================================================  
    518          
    519          @endverbatim
    520            * @{
    521            */
    522          
    523          /**
    524            * @brief  Enables or disables the specified DAC interrupts.
    525            * @param  DAC_Channel: the selected DAC channel. 
    526            *   This parameter can be one of the following values:
    527            *     @arg DAC_Channel_1: DAC Channel1 selected
    528            *     @arg DAC_Channel_2: DAC Channel2 selected
    529            * @param  DAC_IT: specifies the DAC interrupt sources to be enabled or disabled. 
    530            *   This parameter can be the following values:
    531            *     @arg DAC_IT_DMAUDR: DMA underrun interrupt mask
    532            * @note The DMA underrun occurs when a second external trigger arrives before
    533            *       the acknowledgement for the first external trigger is received (first request).
    534            * @param  NewState: new state of the specified DAC interrupts.
    535            *   This parameter can be: ENABLE or DISABLE.
    536            * @retval None
    537            */ 

   \                                 In section .text, align 2, keep-with-next
    538          void DAC_ITConfig(uint32_t DAC_Channel, uint32_t DAC_IT, FunctionalState NewState)  
    539          {
   \                     DAC_ITConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    540            /* Check the parameters */
    541            assert_param(IS_DAC_CHANNEL(DAC_Channel));
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD006             BEQ.N    ??DAC_ITConfig_0
   \   0000000C   0x2C10             CMP      R4,#+16
   \   0000000E   0xD004             BEQ.N    ??DAC_ITConfig_0
   \   00000010   0xF240 0x211D      MOVW     R1,#+541
   \   00000014   0x....             LDR.N    R0,??DataTable14
   \   00000016   0x.... 0x....      BL       assert_failed
    542            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??DAC_ITConfig_0: (+1)
   \   0000001A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000001C   0x2E00             CMP      R6,#+0
   \   0000001E   0xD007             BEQ.N    ??DAC_ITConfig_1
   \   00000020   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000022   0x2E01             CMP      R6,#+1
   \   00000024   0xD004             BEQ.N    ??DAC_ITConfig_1
   \   00000026   0xF240 0x211E      MOVW     R1,#+542
   \   0000002A   0x....             LDR.N    R0,??DataTable14
   \   0000002C   0x.... 0x....      BL       assert_failed
    543            assert_param(IS_DAC_IT(DAC_IT)); 
   \                     ??DAC_ITConfig_1: (+1)
   \   00000030   0xF5B5 0x5F00      CMP      R5,#+8192
   \   00000034   0xD004             BEQ.N    ??DAC_ITConfig_2
   \   00000036   0xF240 0x211F      MOVW     R1,#+543
   \   0000003A   0x....             LDR.N    R0,??DataTable14
   \   0000003C   0x.... 0x....      BL       assert_failed
    544          
    545            if (NewState != DISABLE)
   \                     ??DAC_ITConfig_2: (+1)
   \   00000040   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000042   0x2E00             CMP      R6,#+0
   \   00000044   0xD007             BEQ.N    ??DAC_ITConfig_3
    546            {
    547              /* Enable the selected DAC interrupts */
    548              DAC->CR |=  (DAC_IT << DAC_Channel);
   \   00000046   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40007400
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0xFA15 0xF104      LSLS     R1,R5,R4
   \   0000004E   0x4308             ORRS     R0,R1,R0
   \   00000050   0x....             LDR.N    R1,??DataTable14_1  ;; 0x40007400
   \   00000052   0x6008             STR      R0,[R1, #+0]
   \   00000054   0xE006             B.N      ??DAC_ITConfig_4
    549            }
    550            else
    551            {
    552              /* Disable the selected DAC interrupts */
    553              DAC->CR &= (~(uint32_t)(DAC_IT << DAC_Channel));
   \                     ??DAC_ITConfig_3: (+1)
   \   00000056   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40007400
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0xFA15 0xF104      LSLS     R1,R5,R4
   \   0000005E   0x4388             BICS     R0,R0,R1
   \   00000060   0x....             LDR.N    R1,??DataTable14_1  ;; 0x40007400
   \   00000062   0x6008             STR      R0,[R1, #+0]
    554            }
    555          }
   \                     ??DAC_ITConfig_4: (+1)
   \   00000064   0xBD70             POP      {R4-R6,PC}       ;; return
    556          
    557          /**
    558            * @brief  Checks whether the specified DAC flag is set or not.
    559            * @param  DAC_Channel: thee selected DAC channel. 
    560            *   This parameter can be one of the following values:
    561            *     @arg DAC_Channel_1: DAC Channel1 selected
    562            *     @arg DAC_Channel_2: DAC Channel2 selected
    563            * @param  DAC_FLAG: specifies the flag to check. 
    564            *   This parameter can be only of the following value:
    565            *     @arg DAC_FLAG_DMAUDR: DMA underrun flag
    566            * @note The DMA underrun occurs when a second external trigger arrives before
    567            *       the acknowledgement for the first external trigger is received (first request).
    568            * @retval The new state of DAC_FLAG (SET or RESET).
    569            */

   \                                 In section .text, align 2, keep-with-next
    570          FlagStatus DAC_GetFlagStatus(uint32_t DAC_Channel, uint32_t DAC_FLAG)
    571          {
   \                     DAC_GetFlagStatus: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    572            FlagStatus bitstatus = RESET;
   \   00000006   0x2600             MOVS     R6,#+0
    573            /* Check the parameters */
    574            assert_param(IS_DAC_CHANNEL(DAC_Channel));
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD006             BEQ.N    ??DAC_GetFlagStatus_0
   \   0000000C   0x2C10             CMP      R4,#+16
   \   0000000E   0xD004             BEQ.N    ??DAC_GetFlagStatus_0
   \   00000010   0xF240 0x213E      MOVW     R1,#+574
   \   00000014   0x....             LDR.N    R0,??DataTable14
   \   00000016   0x.... 0x....      BL       assert_failed
    575            assert_param(IS_DAC_FLAG(DAC_FLAG));
   \                     ??DAC_GetFlagStatus_0: (+1)
   \   0000001A   0xF5B5 0x5F00      CMP      R5,#+8192
   \   0000001E   0xD004             BEQ.N    ??DAC_GetFlagStatus_1
   \   00000020   0xF240 0x213F      MOVW     R1,#+575
   \   00000024   0x....             LDR.N    R0,??DataTable14
   \   00000026   0x.... 0x....      BL       assert_failed
    576          
    577            /* Check the status of the specified DAC flag */
    578            if ((DAC->SR & (DAC_FLAG << DAC_Channel)) != (uint8_t)RESET)
   \                     ??DAC_GetFlagStatus_1: (+1)
   \   0000002A   0x....             LDR.N    R0,??DataTable14_3  ;; 0x40007434
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0xFA15 0xF104      LSLS     R1,R5,R4
   \   00000032   0x4208             TST      R0,R1
   \   00000034   0xD002             BEQ.N    ??DAC_GetFlagStatus_2
    579            {
    580              /* DAC_FLAG is set */
    581              bitstatus = SET;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x0006             MOVS     R6,R0
   \   0000003A   0xE001             B.N      ??DAC_GetFlagStatus_3
    582            }
    583            else
    584            {
    585              /* DAC_FLAG is reset */
    586              bitstatus = RESET;
   \                     ??DAC_GetFlagStatus_2: (+1)
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x0006             MOVS     R6,R0
    587            }
    588            /* Return the DAC_FLAG status */
    589            return  bitstatus;
   \                     ??DAC_GetFlagStatus_3: (+1)
   \   00000040   0x0030             MOVS     R0,R6
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0xBD70             POP      {R4-R6,PC}       ;; return
    590          }
    591          
    592          /**
    593            * @brief  Clears the DAC channel's pending flags.
    594            * @param  DAC_Channel: the selected DAC channel. 
    595            *   This parameter can be one of the following values:
    596            *     @arg DAC_Channel_1: DAC Channel1 selected
    597            *     @arg DAC_Channel_2: DAC Channel2 selected
    598            * @param  DAC_FLAG: specifies the flag to clear. 
    599            *   This parameter can be of the following value:
    600            *     @arg DAC_FLAG_DMAUDR: DMA underrun flag                          
    601            * @retval None
    602            */

   \                                 In section .text, align 2, keep-with-next
    603          void DAC_ClearFlag(uint32_t DAC_Channel, uint32_t DAC_FLAG)
    604          {
   \                     DAC_ClearFlag: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    605            /* Check the parameters */
    606            assert_param(IS_DAC_CHANNEL(DAC_Channel));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD006             BEQ.N    ??DAC_ClearFlag_0
   \   0000000A   0x2C10             CMP      R4,#+16
   \   0000000C   0xD004             BEQ.N    ??DAC_ClearFlag_0
   \   0000000E   0xF240 0x215E      MOVW     R1,#+606
   \   00000012   0x....             LDR.N    R0,??DataTable14
   \   00000014   0x.... 0x....      BL       assert_failed
    607            assert_param(IS_DAC_FLAG(DAC_FLAG));
   \                     ??DAC_ClearFlag_0: (+1)
   \   00000018   0xF5B5 0x5F00      CMP      R5,#+8192
   \   0000001C   0xD004             BEQ.N    ??DAC_ClearFlag_1
   \   0000001E   0xF240 0x215F      MOVW     R1,#+607
   \   00000022   0x....             LDR.N    R0,??DataTable14
   \   00000024   0x.... 0x....      BL       assert_failed
    608          
    609            /* Clear the selected DAC flags */
    610            DAC->SR = (DAC_FLAG << DAC_Channel);
   \                     ??DAC_ClearFlag_1: (+1)
   \   00000028   0xFA15 0xF004      LSLS     R0,R5,R4
   \   0000002C   0x....             LDR.N    R1,??DataTable14_3  ;; 0x40007434
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    611          }
   \   00000030   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    612          
    613          /**
    614            * @brief  Checks whether the specified DAC interrupt has occurred or not.
    615            * @param  DAC_Channel: the selected DAC channel. 
    616            *   This parameter can be one of the following values:
    617            *     @arg DAC_Channel_1: DAC Channel1 selected
    618            *     @arg DAC_Channel_2: DAC Channel2 selected
    619            * @param  DAC_IT: specifies the DAC interrupt source to check. 
    620            *   This parameter can be the following values:
    621            *     @arg DAC_IT_DMAUDR: DMA underrun interrupt mask
    622            * @note The DMA underrun occurs when a second external trigger arrives before
    623            *       the acknowledgement for the first external trigger is received (first request).
    624            * @retval The new state of DAC_IT (SET or RESET).
    625            */

   \                                 In section .text, align 2, keep-with-next
    626          ITStatus DAC_GetITStatus(uint32_t DAC_Channel, uint32_t DAC_IT)
    627          {
   \                     DAC_GetITStatus: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    628            ITStatus bitstatus = RESET;
   \   00000006   0x2600             MOVS     R6,#+0
    629            uint32_t enablestatus = 0;
   \   00000008   0x2700             MOVS     R7,#+0
    630            
    631            /* Check the parameters */
    632            assert_param(IS_DAC_CHANNEL(DAC_Channel));
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD006             BEQ.N    ??DAC_GetITStatus_0
   \   0000000E   0x2C10             CMP      R4,#+16
   \   00000010   0xD004             BEQ.N    ??DAC_GetITStatus_0
   \   00000012   0xF44F 0x711E      MOV      R1,#+632
   \   00000016   0x....             LDR.N    R0,??DataTable14
   \   00000018   0x.... 0x....      BL       assert_failed
    633            assert_param(IS_DAC_IT(DAC_IT));
   \                     ??DAC_GetITStatus_0: (+1)
   \   0000001C   0xF5B5 0x5F00      CMP      R5,#+8192
   \   00000020   0xD004             BEQ.N    ??DAC_GetITStatus_1
   \   00000022   0xF240 0x2179      MOVW     R1,#+633
   \   00000026   0x....             LDR.N    R0,??DataTable14
   \   00000028   0x.... 0x....      BL       assert_failed
    634          
    635            /* Get the DAC_IT enable bit status */
    636            enablestatus = (DAC->CR & (DAC_IT << DAC_Channel)) ;
   \                     ??DAC_GetITStatus_1: (+1)
   \   0000002C   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40007400
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xFA15 0xF104      LSLS     R1,R5,R4
   \   00000034   0x4008             ANDS     R0,R1,R0
   \   00000036   0x0007             MOVS     R7,R0
    637            
    638            /* Check the status of the specified DAC interrupt */
    639            if (((DAC->SR & (DAC_IT << DAC_Channel)) != (uint32_t)RESET) && enablestatus)
   \   00000038   0x....             LDR.N    R0,??DataTable14_3  ;; 0x40007434
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0xFA15 0xF104      LSLS     R1,R5,R4
   \   00000040   0x4208             TST      R0,R1
   \   00000042   0xD004             BEQ.N    ??DAC_GetITStatus_2
   \   00000044   0x2F00             CMP      R7,#+0
   \   00000046   0xD002             BEQ.N    ??DAC_GetITStatus_2
    640            {
    641              /* DAC_IT is set */
    642              bitstatus = SET;
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0x0006             MOVS     R6,R0
   \   0000004C   0xE001             B.N      ??DAC_GetITStatus_3
    643            }
    644            else
    645            {
    646              /* DAC_IT is reset */
    647              bitstatus = RESET;
   \                     ??DAC_GetITStatus_2: (+1)
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x0006             MOVS     R6,R0
    648            }
    649            /* Return the DAC_IT status */
    650            return  bitstatus;
   \                     ??DAC_GetITStatus_3: (+1)
   \   00000052   0x0030             MOVS     R0,R6
   \   00000054   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000056   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    651          }
    652          
    653          /**
    654            * @brief  Clears the DAC channels interrupt pending bits.
    655            * @param  DAC_Channel: the selected DAC channel. 
    656            *   This parameter can be one of the following values:
    657            *     @arg DAC_Channel_1: DAC Channel1 selected
    658            *     @arg DAC_Channel_2: DAC Channel2 selected
    659            * @param  DAC_IT: specifies the DAC interrupt pending bit to clear.
    660            *   This parameter can be the following values:
    661            *     @arg DAC_IT_DMAUDR: DMA underrun interrupt mask                         
    662            * @retval None
    663            */

   \                                 In section .text, align 2, keep-with-next
    664          void DAC_ClearITPendingBit(uint32_t DAC_Channel, uint32_t DAC_IT)
    665          {
   \                     DAC_ClearITPendingBit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    666            /* Check the parameters */
    667            assert_param(IS_DAC_CHANNEL(DAC_Channel));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD006             BEQ.N    ??DAC_ClearITPendingBit_0
   \   0000000A   0x2C10             CMP      R4,#+16
   \   0000000C   0xD004             BEQ.N    ??DAC_ClearITPendingBit_0
   \   0000000E   0xF240 0x219B      MOVW     R1,#+667
   \   00000012   0x....             LDR.N    R0,??DataTable14
   \   00000014   0x.... 0x....      BL       assert_failed
    668            assert_param(IS_DAC_IT(DAC_IT)); 
   \                     ??DAC_ClearITPendingBit_0: (+1)
   \   00000018   0xF5B5 0x5F00      CMP      R5,#+8192
   \   0000001C   0xD004             BEQ.N    ??DAC_ClearITPendingBit_1
   \   0000001E   0xF44F 0x7127      MOV      R1,#+668
   \   00000022   0x....             LDR.N    R0,??DataTable14
   \   00000024   0x.... 0x....      BL       assert_failed
    669          
    670            /* Clear the selected DAC interrupt pending bits */
    671            DAC->SR = (DAC_IT << DAC_Channel);
   \                     ??DAC_ClearITPendingBit_1: (+1)
   \   00000028   0xFA15 0xF004      LSLS     R0,R5,R4
   \   0000002C   0x....             LDR.N    R1,??DataTable14_3  ;; 0x40007434
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    672          }
   \   00000030   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x40007400         DC32     0x40007400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x40007404         DC32     0x40007404

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \   00000000   0x40007434         DC32     0x40007434

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x45 0x3A          DC8 45H, 3AH, 5CH, 41H, 43H, 51H, 5CH, 50H
   \              0x5C 0x41    
   \              0x43 0x51    
   \              0x5C 0x50    
   \   00000008   0x72 0x6F          DC8 72H, 6FH, 6AH, 5FH, 76H, 65H, 72H, 30H
   \              0x6A 0x5F    
   \              0x76 0x65    
   \              0x72 0x30    
   \   00000010   0x39 0x61          DC8 39H, 61H, 5FH, 31H, 35H, 31H, 30H, 32H
   \              0x5F 0x31    
   \              0x35 0x31    
   \              0x30 0x32    
   \   00000018   0x30 0x31          DC8 30H, 31H, 35H, 5CH, 42H, 61H, 73H, 65H
   \              0x35 0x5C    
   \              0x42 0x61    
   \              0x73 0x65    
   \   00000020   0x5F 0x30          DC8 5FH, 30H, 32H, 5CH, 32H, 30H, 31H, 33H
   \              0x32 0x5C    
   \              0x32 0x30    
   \              0x31 0x33    
   \   00000028   0x5F 0x31          DC8 5FH, 31H, 31H, 5FH, 32H, 35H, 5FH, 53H
   \              0x31 0x5F    
   \              0x32 0x35    
   \              0x5F 0x53    
   \   00000030   0x70 0x69          DC8 70H, 69H, 72H, 69H, 74H, 31H, 5FH, 45H
   \              0x72 0x69    
   \              0x74 0x31    
   \              0x5F 0x45    
   \   00000038   0x6C 0x65          DC8 6CH, 65H, 6BH, 74H, 72H, 6FH, 6CH, 75H
   \              0x6B 0x74    
   \              0x72 0x6F    
   \              0x6C 0x75    
   \   00000040   0x78 0x5C          DC8 78H, 5CH, 53H, 54H, 4DH, 33H, 32H, 4CH
   \              0x53 0x54    
   \              0x4D 0x33    
   \              0x32 0x4C    
   \   00000048   0x5C 0x53          DC8 5CH, 53H, 54H, 4DH, 33H, 32H, 4CH, 31H
   \              0x54 0x4D    
   \              0x33 0x32    
   \              0x4C 0x31    
   \   00000050   0x78 0x78          DC8 78H, 78H, 5FH, 53H, 74H, 64H, 50H, 65H
   \              0x5F 0x53    
   \              0x74 0x64    
   \              0x50 0x65    
   \   00000058   0x72 0x69          DC8 72H, 69H, 70H, 68H, 5FH, 4CH, 69H, 62H
   \              0x70 0x68    
   \              0x5F 0x4C    
   \              0x69 0x62    
   \   00000060   0x5C 0x53          DC8 5CH, 53H, 6FH, 75H, 72H, 63H, 65H, 5CH
   \              0x6F 0x75    
   \              0x72 0x63    
   \              0x65 0x5C    
   \   00000068   0x53 0x54          DC8 53H, 54H, 4DH, 33H, 32H, 4CH, 31H, 78H
   \              0x4D 0x33    
   \              0x32 0x4C    
   \              0x31 0x78    
   \   00000070   0x78 0x5F          DC8 78H, 5FH, 53H, 74H, 64H, 50H, 65H, 72H
   \              0x53 0x74    
   \              0x64 0x50    
   \              0x65 0x72    
   \   00000078   0x69 0x70          DC8 69H, 70H, 68H, 5FH, 44H, 72H, 69H, 76H
   \              0x68 0x5F    
   \              0x44 0x72    
   \              0x69 0x76    
   \   00000080   0x65 0x72          DC8 65H, 72H, 5CH, 73H, 72H, 63H, 5CH, 73H
   \              0x5C 0x73    
   \              0x72 0x63    
   \              0x5C 0x73    
   \   00000088   0x74 0x6D          DC8 74H, 6DH, 33H, 32H, 6CH, 31H, 78H, 78H
   \              0x33 0x32    
   \              0x6C 0x31    
   \              0x78 0x78    
   \   00000090   0x5F 0x64          DC8 5FH, 64H, 61H, 63H, 2EH, 63H, 0
   \              0x61 0x63    
   \              0x2E 0x63    
   \              0x00         
   \   00000097   0x00               DC8 0
    673          
    674          /**
    675            * @}
    676            */
    677          
    678          /**
    679            * @}
    680            */ 
    681          
    682          /**
    683            * @}
    684            */ 
    685          
    686          /**
    687            * @}
    688            */ 
    689          
    690          /******************* (C) COPYRIGHT 2010 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   DAC_ClearFlag
        16   -> assert_failed
      16   DAC_ClearITPendingBit
        16   -> assert_failed
      16   DAC_Cmd
        16   -> assert_failed
      16   DAC_DMACmd
        16   -> assert_failed
       8   DAC_DeInit
         8   -> RCC_APB1PeriphResetCmd
       8   DAC_DualSoftwareTriggerCmd
         8   -> assert_failed
      16   DAC_GetDataOutputValue
        16   -> assert_failed
      16   DAC_GetFlagStatus
        16   -> assert_failed
      24   DAC_GetITStatus
        24   -> assert_failed
      16   DAC_ITConfig
        16   -> assert_failed
      24   DAC_Init
        24   -> assert_failed
      16   DAC_SetChannel1Data
        16   -> assert_failed
      16   DAC_SetChannel2Data
        16   -> assert_failed
      24   DAC_SetDualChannelData
        24   -> assert_failed
      16   DAC_SoftwareTriggerCmd
        16   -> assert_failed
       0   DAC_StructInit
      16   DAC_WaveGenerationCmd
        16   -> assert_failed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
     152  ?_0
      50  DAC_ClearFlag
      50  DAC_ClearITPendingBit
      92  DAC_Cmd
      88  DAC_DMACmd
      24  DAC_DeInit
      70  DAC_DualSoftwareTriggerCmd
      50  DAC_GetDataOutputValue
      70  DAC_GetFlagStatus
      88  DAC_GetITStatus
     102  DAC_ITConfig
     362  DAC_Init
      74  DAC_SetChannel1Data
      74  DAC_SetChannel2Data
     124  DAC_SetDualChannelData
     100  DAC_SoftwareTriggerCmd
      18  DAC_StructInit
     110  DAC_WaveGenerationCmd

 
   152 bytes in section .rodata
 1 562 bytes in section .text
 
 1 562 bytes of CODE  memory
   152 bytes of CONST memory

Errors: none
Warnings: none
