###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        20/Nov/2015  05:05:53
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_usart.c
#    Command line =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_usart.c
#        -D USE_STDPERIPH_DRIVER -D VECT_TAB_FLASH -D STM32L1XX_MD -D
#        IAR_ARM_CM3 -D USE_FULL_ASSERT -D SPIRIT_USE_FULL_ASSERT -D
#        USE_SYSTICK_DELAY -D SDK -lC
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\List\
#        -o
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\.\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\examples\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\runtime\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\SDK_Eval_STM32L\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\SPIRIT1_Library\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\SDK_Eval_Util\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\SDK_Virtual_Com\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32_USB-FS-Device_Lib\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\ACQ\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\CMSIS\Include\"
#    List file    =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\List\stm32l1xx_usart.lst
#    Object file  =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\Obj\stm32l1xx_usart.o
#
###############################################################################

E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_usart.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_usart.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    31-December-2010
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Universal synchronous asynchronous receiver
      9            *          transmitter (USART):           
     10            *           - Initialization and Configuration
     11            *           - Data transfers
     12            *           - Multi-Processor Communication
     13            *           - LIN mode
     14            *           - Half-duplex mode
     15            *           - Smartcard mode
     16            *           - IrDA mode
     17            *           - DMA transfers management
     18            *           - Interrupts and flags management 
     19            *           
     20            *  @verbatim
     21            *      
     22            *          ===================================================================
     23            *                                 How to use this driver
     24            *          ===================================================================
     25            *          1. Enable peripheral clock using RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE)
     26            *             function for USART1 or using RCC_APB1PeriphClockCmd(RCC_APB1Periph_USARTx, ENABLE)
     27            *             function for USART2 and USART3.
     28            *
     29            *          2.  According to the USART mode, enable the GPIO clocks using 
     30            *              RCC_AHBPeriphClockCmd() function. (The I/O can be TX, RX, CTS, 
     31            *              or and SCLK). 
     32            *
     33            *          3. Peripheral’s alternate function: 
     34            *                 - Connect the pin to the desired peripherals' Alternate 
     35            *                   Function (AF) using GPIO_PinAFConfig() function
     36            *                 - Configure the desired pin in alternate function by:
     37            *                   GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
     38            *                 - Select the type, pull-up/pull-down and output speed via 
     39            *                   GPIO_PuPd, GPIO_OType and GPIO_Speed members
     40            *                 - Call GPIO_Init() function
     41            *        
     42            *          4. Program the Baud Rate, Word Length , Stop Bit, Parity, Hardware 
     43            *             flow control and Mode(Receiver/Transmitter) using the SPI_Init()
     44            *             function.
     45            *
     46            *          5. For synchronous mode, enable the clock and program the polarity,
     47            *             phase and last bit using the USART_ClockInit() function.
     48            *
     49            *          5. Enable the NVIC and the corresponding interrupt using the function 
     50            *             USART_ITConfig() if you need to use interrupt mode. 
     51            *
     52            *          6. When using the DMA mode 
     53            *                   - Configure the DMA using DMA_Init() function
     54            *                   - Active the needed channel Request using USART_DMACmd() function
     55            * 
     56            *          7. Enable the USART using the USART_Cmd() function.
     57            * 
     58            *          8. Enable the DMA using the DMA_Cmd() function, when using DMA mode. 
     59            *
     60            *          Refer to Multi-Processor, LIN, half-duplex, Smartcard, IrDA sub-sections
     61            *          for more details
     62            *          
     63            *  @endverbatim
     64            *        
     65            ******************************************************************************
     66            * @attention
     67            *
     68            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     69            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     70            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     71            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     72            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     73            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     74            *
     75            * <h2><center>&copy; COPYRIGHT 2010 STMicroelectronics</center></h2>
     76            ******************************************************************************  
     77            */ 
     78          
     79          /* Includes ------------------------------------------------------------------*/
     80          #include "stm32l1xx_usart.h"
     81          #include "stm32l1xx_rcc.h"
     82          
     83          /** @addtogroup STM32L1xx_StdPeriph_Driver
     84            * @{
     85            */
     86          
     87          /** @defgroup USART 
     88            * @brief USART driver modules
     89            * @{
     90            */
     91          
     92          /* Private typedef -----------------------------------------------------------*/
     93          /* Private define ------------------------------------------------------------*/
     94          
     95          /*!< USART CR1 register clear Mask ((~(uint16_t)0xE9F3)) */
     96          #define CR1_CLEAR_MASK            ((uint16_t)(USART_CR1_M | USART_CR1_PCE | \
     97                                                        USART_CR1_PS | USART_CR1_TE | \
     98                                                        USART_CR1_RE))
     99          
    100          /*!< USART CR2 register clock bits clear Mask ((~(uint16_t)0xF0FF)) */
    101          #define CR2_CLOCK_CLEAR_MASK      ((uint16_t)(USART_CR2_CLKEN | USART_CR2_CPOL | \
    102                                                        USART_CR2_CPHA | USART_CR2_LBCL))
    103          
    104          /*!< USART CR3 register clear Mask ((~(uint16_t)0xFCFF)) */
    105          #define CR3_CLEAR_MASK            ((uint16_t)(USART_CR3_RTSE | USART_CR3_CTSE))
    106          
    107          /*!< USART Interrupts mask */
    108          #define IT_MASK                   ((uint16_t)0x001F)
    109          
    110          /* Private macro -------------------------------------------------------------*/
    111          /* Private variables ---------------------------------------------------------*/
    112          /* Private function prototypes -----------------------------------------------*/
    113          /* Private functions ---------------------------------------------------------*/
    114          
    115          /** @defgroup USART_Private_Functions
    116            * @{
    117            */
    118          
    119          /** @defgroup USART_Group1 Initialization and Configuration functions
    120           *  @brief   Initialization and Configuration functions 
    121           *
    122          @verbatim   
    123           ===============================================================================
    124                            Initialization and Configuration functions
    125           ===============================================================================  
    126          
    127            This subsection provides a set of functions allowing to initialize the USART 
    128            in asynchronous and in synchronous modes.
    129             - For the asynchronous mode only these parameters can be configured: 
    130                  - Baud Rate
    131                  - Word Length 
    132                  - Stop Bit
    133                  - Parity: If the parity is enabled, then the MSB bit of the data written
    134                    in the data register is transmitted but is changed by the parity bit.
    135                    Depending on the frame length defined by the M bit (8-bits or 9-bits),
    136                    the possible USART frame formats are as listed in the following table:
    137             +-------------------------------------------------------------+     
    138             |   M bit |  PCE bit  |            USART frame                |
    139             |---------------------|---------------------------------------|             
    140             |    0    |    0      |    | SB | 8 bit data | STB |          |
    141             |---------|-----------|---------------------------------------|  
    142             |    0    |    1      |    | SB | 7 bit data | PB | STB |     |
    143             |---------|-----------|---------------------------------------|  
    144             |    1    |    0      |    | SB | 9 bit data | STB |          |
    145             |---------|-----------|---------------------------------------|  
    146             |    1    |    1      |    | SB | 8 bit data | PB | STB |     |
    147             +-------------------------------------------------------------+            
    148                  - Hardware flow control
    149                  - Receiver/transmitter modes
    150          
    151            The USART_Init() function follows the USART  asynchronous configuration procedure
    152            (details for the procedure are available in reference manual (RM0038)).
    153          
    154            - For the synchronous mode in addition to the asynchronous mode parameters these 
    155              parameters should be also configured:
    156                  - USART Clock Enabled
    157                  - USART polarity
    158                  - USART phase
    159                  - USART LastBit
    160            
    161            These parameters can be configured using the USART_ClockInit() function.
    162          
    163          @endverbatim
    164            * @{
    165            */
    166            
    167          /**
    168            * @brief  Deinitializes the USARTx peripheral registers to their default reset values.
    169            * @param  USARTx: Select the USART peripheral. 
    170            *   This parameter can be one of the following values: USART1, USART2 or USART3.
    171            * @retval None
    172            */

   \                                 In section .text, align 2, keep-with-next
    173          void USART_DeInit(USART_TypeDef* USARTx)
    174          {
   \                     USART_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    175            /* Check the parameters */
    176            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable22  ;; 0x40013800
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00C             BEQ.N    ??USART_DeInit_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable22_1  ;; 0x40004400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD008             BEQ.N    ??USART_DeInit_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x40004800
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD004             BEQ.N    ??USART_DeInit_0
   \   0000001C   0x21B0             MOVS     R1,#+176
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \   00000022   0x.... 0x....      BL       assert_failed
    177          
    178            if (USARTx == USART1)
   \                     ??USART_DeInit_0: (+1)
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable22  ;; 0x40013800
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD10A             BNE.N    ??USART_DeInit_1
    179            {
    180              RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
   \   0000002E   0x2101             MOVS     R1,#+1
   \   00000030   0xF44F 0x4080      MOV      R0,#+16384
   \   00000034   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    181              RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0xF44F 0x4080      MOV      R0,#+16384
   \   0000003E   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
   \   00000042   0xE01C             B.N      ??USART_DeInit_2
    182            }
    183            else if (USARTx == USART2)
   \                     ??USART_DeInit_1: (+1)
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable22_1  ;; 0x40004400
   \   00000048   0x4284             CMP      R4,R0
   \   0000004A   0xD10A             BNE.N    ??USART_DeInit_3
    184            {
    185              RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
   \   0000004C   0x2101             MOVS     R1,#+1
   \   0000004E   0xF45F 0x3000      MOVS     R0,#+131072
   \   00000052   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    186              RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0xF45F 0x3000      MOVS     R0,#+131072
   \   0000005C   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
   \   00000060   0xE00D             B.N      ??USART_DeInit_2
    187            }
    188            else 
    189            {
    190              if (USARTx == USART3)
   \                     ??USART_DeInit_3: (+1)
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable26  ;; 0x40004800
   \   00000066   0x4284             CMP      R4,R0
   \   00000068   0xD109             BNE.N    ??USART_DeInit_2
    191              {
    192                RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
   \   0000006A   0x2101             MOVS     R1,#+1
   \   0000006C   0xF45F 0x2080      MOVS     R0,#+262144
   \   00000070   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    193                RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);    
   \   00000074   0x2100             MOVS     R1,#+0
   \   00000076   0xF45F 0x2080      MOVS     R0,#+262144
   \   0000007A   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    194              }
    195            }    
    196          }
   \                     ??USART_DeInit_2: (+1)
   \   0000007E   0xBD10             POP      {R4,PC}          ;; return
    197          
    198          /**
    199            * @brief  Initializes the USARTx peripheral according to the specified
    200            *   parameters in the USART_InitStruct .
    201            * @param  USARTx: Select the USART peripheral. 
    202            *   This parameter can be one of the following values:
    203            *   USART1, USART2 or USART3.
    204            * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
    205            *   that contains the configuration information for the specified USART peripheral.
    206            * @retval None
    207            */

   \                                 In section .text, align 2, keep-with-next
    208          void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
    209          {
   \                     USART_Init: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
    210            uint32_t tmpreg = 0x00, apbclock = 0x00;
   \   0000000A   0x2600             MOVS     R6,#+0
   \   0000000C   0x2700             MOVS     R7,#+0
    211            uint32_t integerdivider = 0x00;
   \   0000000E   0xF05F 0x0800      MOVS     R8,#+0
    212            uint32_t fractionaldivider = 0x00;
   \   00000012   0xF05F 0x0900      MOVS     R9,#+0
    213            RCC_ClocksTypeDef RCC_ClocksStatus;
    214          
    215            /* Check the parameters */
    216            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable26_1  ;; 0x40013800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD00C             BEQ.N    ??USART_Init_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable22_1  ;; 0x40004400
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD008             BEQ.N    ??USART_Init_0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40004800
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD004             BEQ.N    ??USART_Init_0
   \   0000002E   0x21D8             MOVS     R1,#+216
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \   00000034   0x.... 0x....      BL       assert_failed
    217            assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
   \                     ??USART_Init_0: (+1)
   \   00000038   0x6828             LDR      R0,[R5, #+0]
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD004             BEQ.N    ??USART_Init_1
   \   0000003E   0x6828             LDR      R0,[R5, #+0]
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable24_1  ;; 0x3d0901
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xD304             BCC.N    ??USART_Init_2
   \                     ??USART_Init_1: (+1)
   \   00000048   0x21D9             MOVS     R1,#+217
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \   0000004E   0x.... 0x....      BL       assert_failed
    218            assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
   \                     ??USART_Init_2: (+1)
   \   00000052   0x88A8             LDRH     R0,[R5, #+4]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD008             BEQ.N    ??USART_Init_3
   \   00000058   0x88A8             LDRH     R0,[R5, #+4]
   \   0000005A   0xF5B0 0x5F80      CMP      R0,#+4096
   \   0000005E   0xD004             BEQ.N    ??USART_Init_3
   \   00000060   0x21DA             MOVS     R1,#+218
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \   00000066   0x.... 0x....      BL       assert_failed
    219            assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
   \                     ??USART_Init_3: (+1)
   \   0000006A   0x88E8             LDRH     R0,[R5, #+6]
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD010             BEQ.N    ??USART_Init_4
   \   00000070   0x88E8             LDRH     R0,[R5, #+6]
   \   00000072   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000076   0xD00C             BEQ.N    ??USART_Init_4
   \   00000078   0x88E8             LDRH     R0,[R5, #+6]
   \   0000007A   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000007E   0xD008             BEQ.N    ??USART_Init_4
   \   00000080   0x88E8             LDRH     R0,[R5, #+6]
   \   00000082   0xF5B0 0x5F40      CMP      R0,#+12288
   \   00000086   0xD004             BEQ.N    ??USART_Init_4
   \   00000088   0x21DB             MOVS     R1,#+219
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \   0000008E   0x.... 0x....      BL       assert_failed
    220            assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
   \                     ??USART_Init_4: (+1)
   \   00000092   0x8928             LDRH     R0,[R5, #+8]
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD00C             BEQ.N    ??USART_Init_5
   \   00000098   0x8928             LDRH     R0,[R5, #+8]
   \   0000009A   0xF5B0 0x6F80      CMP      R0,#+1024
   \   0000009E   0xD008             BEQ.N    ??USART_Init_5
   \   000000A0   0x8928             LDRH     R0,[R5, #+8]
   \   000000A2   0xF5B0 0x6FC0      CMP      R0,#+1536
   \   000000A6   0xD004             BEQ.N    ??USART_Init_5
   \   000000A8   0x21DC             MOVS     R1,#+220
   \   000000AA   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \   000000AE   0x.... 0x....      BL       assert_failed
    221            assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
   \                     ??USART_Init_5: (+1)
   \   000000B2   0x8968             LDRH     R0,[R5, #+10]
   \   000000B4   0xF64F 0x71F3      MOVW     R1,#+65523
   \   000000B8   0x4208             TST      R0,R1
   \   000000BA   0xD102             BNE.N    ??USART_Init_6
   \   000000BC   0x8968             LDRH     R0,[R5, #+10]
   \   000000BE   0x2800             CMP      R0,#+0
   \   000000C0   0xD104             BNE.N    ??USART_Init_7
   \                     ??USART_Init_6: (+1)
   \   000000C2   0x21DD             MOVS     R1,#+221
   \   000000C4   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \   000000C8   0x.... 0x....      BL       assert_failed
    222            assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
   \                     ??USART_Init_7: (+1)
   \   000000CC   0x89A8             LDRH     R0,[R5, #+12]
   \   000000CE   0x2800             CMP      R0,#+0
   \   000000D0   0xD010             BEQ.N    ??USART_Init_8
   \   000000D2   0x89A8             LDRH     R0,[R5, #+12]
   \   000000D4   0xF5B0 0x7F80      CMP      R0,#+256
   \   000000D8   0xD00C             BEQ.N    ??USART_Init_8
   \   000000DA   0x89A8             LDRH     R0,[R5, #+12]
   \   000000DC   0xF5B0 0x7F00      CMP      R0,#+512
   \   000000E0   0xD008             BEQ.N    ??USART_Init_8
   \   000000E2   0x89A8             LDRH     R0,[R5, #+12]
   \   000000E4   0xF5B0 0x7F40      CMP      R0,#+768
   \   000000E8   0xD004             BEQ.N    ??USART_Init_8
   \   000000EA   0x21DE             MOVS     R1,#+222
   \   000000EC   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \   000000F0   0x.... 0x....      BL       assert_failed
    223            
    224          /*---------------------------- USART CR2 Configuration -----------------------*/
    225            tmpreg = USARTx->CR2;
   \                     ??USART_Init_8: (+1)
   \   000000F4   0x8A20             LDRH     R0,[R4, #+16]
   \   000000F6   0x0006             MOVS     R6,R0
    226            /* Clear STOP[13:12] bits */
    227            tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
   \   000000F8   0xF436 0x5640      BICS     R6,R6,#0x3000
    228          
    229            /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
    230            /* Set STOP[13:12] bits according to USART_StopBits value */
    231            tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
   \   000000FC   0x88E8             LDRH     R0,[R5, #+6]
   \   000000FE   0x4306             ORRS     R6,R0,R6
    232            
    233            /* Write to USART CR2 */
    234            USARTx->CR2 = (uint16_t)tmpreg;
   \   00000100   0x8226             STRH     R6,[R4, #+16]
    235          
    236          /*---------------------------- USART CR1 Configuration -----------------------*/
    237            tmpreg = USARTx->CR1;
   \   00000102   0x89A0             LDRH     R0,[R4, #+12]
   \   00000104   0x0006             MOVS     R6,R0
    238            /* Clear M, PCE, PS, TE and RE bits */
    239            tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
   \   00000106   0x.... 0x....      LDR.W    R0,??DataTable25  ;; 0xffffe9f3
   \   0000010A   0x4006             ANDS     R6,R0,R6
    240          
    241            /* Configure the USART Word Length, Parity and mode ----------------------- */
    242            /* Set the M bits according to USART_WordLength value */
    243            /* Set PCE and PS bits according to USART_Parity value */
    244            /* Set TE and RE bits according to USART_Mode value */
    245            tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
    246                      USART_InitStruct->USART_Mode;
   \   0000010C   0x88A8             LDRH     R0,[R5, #+4]
   \   0000010E   0x8929             LDRH     R1,[R5, #+8]
   \   00000110   0x4308             ORRS     R0,R1,R0
   \   00000112   0x8969             LDRH     R1,[R5, #+10]
   \   00000114   0x4308             ORRS     R0,R1,R0
   \   00000116   0x4306             ORRS     R6,R0,R6
    247          
    248            /* Write to USART CR1 */
    249            USARTx->CR1 = (uint16_t)tmpreg;
   \   00000118   0x81A6             STRH     R6,[R4, #+12]
    250          
    251          /*---------------------------- USART CR3 Configuration -----------------------*/  
    252            tmpreg = USARTx->CR3;
   \   0000011A   0x8AA0             LDRH     R0,[R4, #+20]
   \   0000011C   0x0006             MOVS     R6,R0
    253            /* Clear CTSE and RTSE bits */
    254            tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
   \   0000011E   0xF436 0x7640      BICS     R6,R6,#0x300
    255          
    256            /* Configure the USART HFC -------------------------------------------------*/
    257            /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
    258            tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
   \   00000122   0x89A8             LDRH     R0,[R5, #+12]
   \   00000124   0x4306             ORRS     R6,R0,R6
    259          
    260            /* Write to USART CR3 */
    261            USARTx->CR3 = (uint16_t)tmpreg;
   \   00000126   0x82A6             STRH     R6,[R4, #+20]
    262          
    263          /*---------------------------- USART BRR Configuration -----------------------*/
    264            /* Configure the USART Baud Rate -------------------------------------------*/
    265            RCC_GetClocksFreq(&RCC_ClocksStatus);
   \   00000128   0xA800             ADD      R0,SP,#+0
   \   0000012A   0x.... 0x....      BL       RCC_GetClocksFreq
    266            if (USARTx == USART1) 
   \   0000012E   0x.... 0x....      LDR.W    R0,??DataTable26_1  ;; 0x40013800
   \   00000132   0x4284             CMP      R4,R0
   \   00000134   0xD102             BNE.N    ??USART_Init_9
    267            {
    268              apbclock = RCC_ClocksStatus.PCLK2_Frequency;
   \   00000136   0x9803             LDR      R0,[SP, #+12]
   \   00000138   0x0007             MOVS     R7,R0
   \   0000013A   0xE001             B.N      ??USART_Init_10
    269            }
    270            else
    271            {
    272              apbclock = RCC_ClocksStatus.PCLK1_Frequency;
   \                     ??USART_Init_9: (+1)
   \   0000013C   0x9802             LDR      R0,[SP, #+8]
   \   0000013E   0x0007             MOVS     R7,R0
    273            }
    274          
    275            /* Determine the integer part */
    276            if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
   \                     ??USART_Init_10: (+1)
   \   00000140   0x89A0             LDRH     R0,[R4, #+12]
   \   00000142   0x0400             LSLS     R0,R0,#+16
   \   00000144   0xD508             BPL.N    ??USART_Init_11
    277            {
    278              /* Integer part computing in case Oversampling mode is 8 Samples */
    279              integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
   \   00000146   0x2019             MOVS     R0,#+25
   \   00000148   0xFB00 0xF007      MUL      R0,R0,R7
   \   0000014C   0x6829             LDR      R1,[R5, #+0]
   \   0000014E   0x0049             LSLS     R1,R1,#+1
   \   00000150   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000154   0x4680             MOV      R8,R0
   \   00000156   0xE007             B.N      ??USART_Init_12
    280            }
    281            else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
    282            {
    283              /* Integer part computing in case Oversampling mode is 16 Samples */
    284              integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
   \                     ??USART_Init_11: (+1)
   \   00000158   0x2019             MOVS     R0,#+25
   \   0000015A   0xFB00 0xF007      MUL      R0,R0,R7
   \   0000015E   0x6829             LDR      R1,[R5, #+0]
   \   00000160   0x0089             LSLS     R1,R1,#+2
   \   00000162   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000166   0x4680             MOV      R8,R0
    285            }
    286            tmpreg = (integerdivider / 100) << 4;
   \                     ??USART_Init_12: (+1)
   \   00000168   0x2064             MOVS     R0,#+100
   \   0000016A   0xFBB8 0xF0F0      UDIV     R0,R8,R0
   \   0000016E   0x0100             LSLS     R0,R0,#+4
   \   00000170   0x0006             MOVS     R6,R0
    287          
    288            /* Determine the fractional part */
    289            fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
   \   00000172   0x0930             LSRS     R0,R6,#+4
   \   00000174   0x2164             MOVS     R1,#+100
   \   00000176   0xFB01 0x8010      MLS      R0,R1,R0,R8
   \   0000017A   0x4681             MOV      R9,R0
    290          
    291            /* Implement the fractional part in the register */
    292            if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
   \   0000017C   0x89A0             LDRH     R0,[R4, #+12]
   \   0000017E   0x0400             LSLS     R0,R0,#+16
   \   00000180   0xD509             BPL.N    ??USART_Init_13
    293            {
    294              tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
   \   00000182   0xEA5F 0x00C9      LSLS     R0,R9,#+3
   \   00000186   0x3032             ADDS     R0,R0,#+50
   \   00000188   0x2164             MOVS     R1,#+100
   \   0000018A   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000018E   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000192   0x4306             ORRS     R6,R0,R6
   \   00000194   0xE008             B.N      ??USART_Init_14
    295            }
    296            else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
    297            {
    298              tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
   \                     ??USART_Init_13: (+1)
   \   00000196   0xEA5F 0x1009      LSLS     R0,R9,#+4
   \   0000019A   0x3032             ADDS     R0,R0,#+50
   \   0000019C   0x2164             MOVS     R1,#+100
   \   0000019E   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000001A2   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   000001A6   0x4306             ORRS     R6,R0,R6
    299            }
    300           
    301            /* Write to USART BRR */
    302            USARTx->BRR = (uint16_t)tmpreg;
   \                     ??USART_Init_14: (+1)
   \   000001A8   0x8126             STRH     R6,[R4, #+8]
    303          }
   \   000001AA   0xB005             ADD      SP,SP,#+20
   \   000001AC   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    304          
    305          /**
    306            * @brief  Fills each USART_InitStruct member with its default value.
    307            * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
    308            *   which will be initialized.
    309            * @retval None
    310            */

   \                                 In section .text, align 2, keep-with-next
    311          void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
    312          {
    313            /* USART_InitStruct members default value */
    314            USART_InitStruct->USART_BaudRate = 9600;
   \                     USART_StructInit: (+1)
   \   00000000   0xF44F 0x5116      MOV      R1,#+9600
   \   00000004   0x6001             STR      R1,[R0, #+0]
    315            USART_InitStruct->USART_WordLength = USART_WordLength_8b;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x8081             STRH     R1,[R0, #+4]
    316            USART_InitStruct->USART_StopBits = USART_StopBits_1;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x80C1             STRH     R1,[R0, #+6]
    317            USART_InitStruct->USART_Parity = USART_Parity_No ;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x8101             STRH     R1,[R0, #+8]
    318            USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
   \   00000012   0x210C             MOVS     R1,#+12
   \   00000014   0x8141             STRH     R1,[R0, #+10]
    319            USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x8181             STRH     R1,[R0, #+12]
    320          }
   \   0000001A   0x4770             BX       LR               ;; return
    321          
    322          /**
    323            * @brief  Initializes the USARTx peripheral Clock according to the 
    324            *   specified parameters in the USART_ClockInitStruct .
    325            * @param  USARTx: where x can be 1, 2, 3 to select the USART peripheral.
    326            * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef
    327            *   structure that contains the configuration information for the specified 
    328            *   USART peripheral.  
    329            * @retval None
    330            */

   \                                 In section .text, align 2, keep-with-next
    331          void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
    332          {
   \                     USART_ClockInit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    333            uint32_t tmpreg = 0x00;
   \   00000006   0x2600             MOVS     R6,#+0
    334            /* Check the parameters */
    335            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable22  ;; 0x40013800
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD00D             BEQ.N    ??USART_ClockInit_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable22_1  ;; 0x40004400
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD009             BEQ.N    ??USART_ClockInit_0
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40004800
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD005             BEQ.N    ??USART_ClockInit_0
   \   00000020   0xF240 0x114F      MOVW     R1,#+335
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \   00000028   0x.... 0x....      BL       assert_failed
    336            assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
   \                     ??USART_ClockInit_0: (+1)
   \   0000002C   0x8828             LDRH     R0,[R5, #+0]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD009             BEQ.N    ??USART_ClockInit_1
   \   00000032   0x8828             LDRH     R0,[R5, #+0]
   \   00000034   0xF5B0 0x6F00      CMP      R0,#+2048
   \   00000038   0xD005             BEQ.N    ??USART_ClockInit_1
   \   0000003A   0xF44F 0x71A8      MOV      R1,#+336
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \   00000042   0x.... 0x....      BL       assert_failed
    337            assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
   \                     ??USART_ClockInit_1: (+1)
   \   00000046   0x8868             LDRH     R0,[R5, #+2]
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD009             BEQ.N    ??USART_ClockInit_2
   \   0000004C   0x8868             LDRH     R0,[R5, #+2]
   \   0000004E   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000052   0xD005             BEQ.N    ??USART_ClockInit_2
   \   00000054   0xF240 0x1151      MOVW     R1,#+337
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \   0000005C   0x.... 0x....      BL       assert_failed
    338            assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
   \                     ??USART_ClockInit_2: (+1)
   \   00000060   0x88A8             LDRH     R0,[R5, #+4]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD009             BEQ.N    ??USART_ClockInit_3
   \   00000066   0x88A8             LDRH     R0,[R5, #+4]
   \   00000068   0xF5B0 0x7F00      CMP      R0,#+512
   \   0000006C   0xD005             BEQ.N    ??USART_ClockInit_3
   \   0000006E   0xF44F 0x71A9      MOV      R1,#+338
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \   00000076   0x.... 0x....      BL       assert_failed
    339            assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
   \                     ??USART_ClockInit_3: (+1)
   \   0000007A   0x88E8             LDRH     R0,[R5, #+6]
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD009             BEQ.N    ??USART_ClockInit_4
   \   00000080   0x88E8             LDRH     R0,[R5, #+6]
   \   00000082   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000086   0xD005             BEQ.N    ??USART_ClockInit_4
   \   00000088   0xF240 0x1153      MOVW     R1,#+339
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \   00000090   0x.... 0x....      BL       assert_failed
    340            
    341          /*---------------------------- USART CR2 Configuration -----------------------*/
    342            tmpreg = USARTx->CR2;
   \                     ??USART_ClockInit_4: (+1)
   \   00000094   0x8A20             LDRH     R0,[R4, #+16]
   \   00000096   0x0006             MOVS     R6,R0
    343            /* Clear CLKEN, CPOL, CPHA and LBCL bits */
    344            tmpreg &= (uint32_t)~((uint32_t)CR2_CLOCK_CLEAR_MASK);
   \   00000098   0xF436 0x6670      BICS     R6,R6,#0xF00
    345            /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
    346            /* Set CLKEN bit according to USART_Clock value */
    347            /* Set CPOL bit according to USART_CPOL value */
    348            /* Set CPHA bit according to USART_CPHA value */
    349            /* Set LBCL bit according to USART_LastBit value */
    350            tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
    351                           USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
   \   0000009C   0x8828             LDRH     R0,[R5, #+0]
   \   0000009E   0x8869             LDRH     R1,[R5, #+2]
   \   000000A0   0x4308             ORRS     R0,R1,R0
   \   000000A2   0x88A9             LDRH     R1,[R5, #+4]
   \   000000A4   0x4308             ORRS     R0,R1,R0
   \   000000A6   0x88E9             LDRH     R1,[R5, #+6]
   \   000000A8   0x4308             ORRS     R0,R1,R0
   \   000000AA   0x4306             ORRS     R6,R0,R6
    352            /* Write to USART CR2 */
    353            USARTx->CR2 = (uint16_t)tmpreg;
   \   000000AC   0x8226             STRH     R6,[R4, #+16]
    354          }
   \   000000AE   0xBD70             POP      {R4-R6,PC}       ;; return
    355          
    356          /**
    357            * @brief  Fills each USART_ClockInitStruct member with its default value.
    358            * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef
    359            *   structure which will be initialized.
    360            * @retval None
    361            */

   \                                 In section .text, align 2, keep-with-next
    362          void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
    363          {
    364            /* USART_ClockInitStruct members default value */
    365            USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
   \                     USART_ClockStructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x8001             STRH     R1,[R0, #+0]
    366            USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x8041             STRH     R1,[R0, #+2]
    367            USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x8081             STRH     R1,[R0, #+4]
    368            USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x80C1             STRH     R1,[R0, #+6]
    369          }
   \   00000010   0x4770             BX       LR               ;; return
    370          
    371          /**
    372            * @brief  Enables or disables the specified USART peripheral.
    373            * @param  USARTx: Select the USART peripheral. 
    374            *   This parameter can be one of the following values:
    375            *   USART1, USART2 or USART3.
    376            * @param  NewState: new state of the USARTx peripheral.
    377            *   This parameter can be: ENABLE or DISABLE.
    378            * @retval None
    379            */

   \                                 In section .text, align 2, keep-with-next
    380          void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
    381          {
   \                     USART_Cmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    382            /* Check the parameters */
    383            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable22  ;; 0x40013800
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??USART_Cmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable22_1  ;; 0x40004400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??USART_Cmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40004800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??USART_Cmd_0
   \   0000001E   0xF240 0x117F      MOVW     R1,#+383
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \   00000026   0x.... 0x....      BL       assert_failed
    384            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??USART_Cmd_0: (+1)
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0x2D00             CMP      R5,#+0
   \   0000002E   0xD008             BEQ.N    ??USART_Cmd_1
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D01             CMP      R5,#+1
   \   00000034   0xD005             BEQ.N    ??USART_Cmd_1
   \   00000036   0xF44F 0x71C0      MOV      R1,#+384
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \   0000003E   0x.... 0x....      BL       assert_failed
    385            
    386            if (NewState != DISABLE)
   \                     ??USART_Cmd_1: (+1)
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0x2D00             CMP      R5,#+0
   \   00000046   0xD004             BEQ.N    ??USART_Cmd_2
    387            {
    388              /* Enable the selected USART by setting the UE bit in the CR1 register */
    389              USARTx->CR1 |= USART_CR1_UE;
   \   00000048   0x89A0             LDRH     R0,[R4, #+12]
   \   0000004A   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   0000004E   0x81A0             STRH     R0,[R4, #+12]
   \   00000050   0xE004             B.N      ??USART_Cmd_3
    390            }
    391            else
    392            {
    393              /* Disable the selected USART by clearing the UE bit in the CR1 register */
    394              USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_UE);
   \                     ??USART_Cmd_2: (+1)
   \   00000052   0x89A0             LDRH     R0,[R4, #+12]
   \   00000054   0xF64D 0x71FF      MOVW     R1,#+57343
   \   00000058   0x4008             ANDS     R0,R1,R0
   \   0000005A   0x81A0             STRH     R0,[R4, #+12]
    395            }
    396          }
   \                     ??USART_Cmd_3: (+1)
   \   0000005C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    397          
    398          /**
    399            * @brief  Sets the system clock prescaler.
    400            * @param  USARTx: Select the USART peripheral. 
    401            *   This parameter can be one of the following values:
    402            *   USART1, USART2 or USART3.
    403            * @param  USART_Prescaler: specifies the prescaler clock.  
    404            * @retval None
    405            */

   \                                 In section .text, align 2, keep-with-next
    406          void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
    407          { 
   \                     USART_SetPrescaler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    408            /* Check the parameters */
    409            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable22  ;; 0x40013800
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??USART_SetPrescaler_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable22_1  ;; 0x40004400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??USART_SetPrescaler_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40004800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??USART_SetPrescaler_0
   \   0000001E   0xF240 0x1199      MOVW     R1,#+409
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \   00000026   0x.... 0x....      BL       assert_failed
    410            
    411            /* Clear the USART prescaler */
    412            USARTx->GTPR &= USART_GTPR_GT;
   \                     ??USART_SetPrescaler_0: (+1)
   \   0000002A   0x8B20             LDRH     R0,[R4, #+24]
   \   0000002C   0xF410 0x407F      ANDS     R0,R0,#0xFF00
   \   00000030   0x8320             STRH     R0,[R4, #+24]
    413            /* Set the USART prescaler */
    414            USARTx->GTPR |= USART_Prescaler;
   \   00000032   0x8B20             LDRH     R0,[R4, #+24]
   \   00000034   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000036   0x4328             ORRS     R0,R5,R0
   \   00000038   0x8320             STRH     R0,[R4, #+24]
    415          }
   \   0000003A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    416          
    417          /**
    418            * @brief  Enables or disables the USART's 8x oversampling mode.
    419            * @param USARTx: Select the USART peripheral. 
    420            *   This parameter can be one of the following values:
    421            *     USART1, USART2, USART3.
    422            * @param NewState: new state of the USART 8x oversampling mode.
    423            *   This parameter can be: ENABLE or DISABLE.
    424            *
    425            * @note
    426            *   This function has to be called before calling USART_Init()
    427            *   function in order to have correct baudrate Divider value.
    428            * @retval : None
    429            */

   \                                 In section .text, align 2, keep-with-next
    430          void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
    431          {
   \                     USART_OverSampling8Cmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    432            /* Check the parameters */
    433            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable22  ;; 0x40013800
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??USART_OverSampling8Cmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable22_1  ;; 0x40004400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??USART_OverSampling8Cmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40004800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??USART_OverSampling8Cmd_0
   \   0000001E   0xF240 0x11B1      MOVW     R1,#+433
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \   00000026   0x.... 0x....      BL       assert_failed
    434            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??USART_OverSampling8Cmd_0: (+1)
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0x2D00             CMP      R5,#+0
   \   0000002E   0xD008             BEQ.N    ??USART_OverSampling8Cmd_1
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D01             CMP      R5,#+1
   \   00000034   0xD005             BEQ.N    ??USART_OverSampling8Cmd_1
   \   00000036   0xF44F 0x71D9      MOV      R1,#+434
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \   0000003E   0x.... 0x....      BL       assert_failed
    435            
    436            if (NewState != DISABLE)
   \                     ??USART_OverSampling8Cmd_1: (+1)
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0x2D00             CMP      R5,#+0
   \   00000046   0xD004             BEQ.N    ??USART_OverSampling8Cmd_2
    437            {
    438              /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
    439              USARTx->CR1 |= USART_CR1_OVER8;
   \   00000048   0x89A0             LDRH     R0,[R4, #+12]
   \   0000004A   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   0000004E   0x81A0             STRH     R0,[R4, #+12]
   \   00000050   0xE003             B.N      ??USART_OverSampling8Cmd_3
    440            }
    441            else
    442            {
    443              /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
    444              USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_OVER8);
   \                     ??USART_OverSampling8Cmd_2: (+1)
   \   00000052   0x89A0             LDRH     R0,[R4, #+12]
   \   00000054   0x0440             LSLS     R0,R0,#+17       ;; ZeroExtS R0,R0,#+17,#+17
   \   00000056   0x0C40             LSRS     R0,R0,#+17
   \   00000058   0x81A0             STRH     R0,[R4, #+12]
    445            }
    446          }  
   \                     ??USART_OverSampling8Cmd_3: (+1)
   \   0000005A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    447          
    448          /**
    449            * @brief  Enables or disables the USART's one bit sampling method.
    450            * @param USARTx: Select the USART peripheral. 
    451            *   This parameter can be one of the following values:
    452            *   USART1, USART2, USART3.
    453            * @param NewState: new state of the USART one bit sampling method.
    454            *   This parameter can be: ENABLE or DISABLE.
    455            * @retval : None
    456            */

   \                                 In section .text, align 2, keep-with-next
    457          void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    458          {
   \                     USART_OneBitMethodCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    459            /* Check the parameters */
    460            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable22  ;; 0x40013800
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??USART_OneBitMethodCmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable22_1  ;; 0x40004400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??USART_OneBitMethodCmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40004800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??USART_OneBitMethodCmd_0
   \   0000001E   0xF44F 0x71E6      MOV      R1,#+460
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \   00000026   0x.... 0x....      BL       assert_failed
    461            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??USART_OneBitMethodCmd_0: (+1)
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0x2D00             CMP      R5,#+0
   \   0000002E   0xD008             BEQ.N    ??USART_OneBitMethodCmd_1
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D01             CMP      R5,#+1
   \   00000034   0xD005             BEQ.N    ??USART_OneBitMethodCmd_1
   \   00000036   0xF240 0x11CD      MOVW     R1,#+461
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \   0000003E   0x.... 0x....      BL       assert_failed
    462            
    463            if (NewState != DISABLE)
   \                     ??USART_OneBitMethodCmd_1: (+1)
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0x2D00             CMP      R5,#+0
   \   00000046   0xD004             BEQ.N    ??USART_OneBitMethodCmd_2
    464            {
    465              /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
    466              USARTx->CR3 |= USART_CR3_ONEBIT;
   \   00000048   0x8AA0             LDRH     R0,[R4, #+20]
   \   0000004A   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   0000004E   0x82A0             STRH     R0,[R4, #+20]
   \   00000050   0xE004             B.N      ??USART_OneBitMethodCmd_3
    467            }
    468            else
    469            {
    470              /* Disable the one bit method by clearing the ONEBITE bit in the CR3 register */
    471              USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_ONEBIT);
   \                     ??USART_OneBitMethodCmd_2: (+1)
   \   00000052   0x8AA0             LDRH     R0,[R4, #+20]
   \   00000054   0xF24F 0x71FF      MOVW     R1,#+63487
   \   00000058   0x4008             ANDS     R0,R1,R0
   \   0000005A   0x82A0             STRH     R0,[R4, #+20]
    472            }
    473          }
   \                     ??USART_OneBitMethodCmd_3: (+1)
   \   0000005C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    474          
    475          /**
    476            * @}
    477            */
    478          
    479          /** @defgroup USART_Group2 Data transfers functions
    480           *  @brief   Data transfers functions 
    481           *
    482          @verbatim   
    483           ===============================================================================
    484                                      Data transfers functions
    485           ===============================================================================  
    486          
    487            This subsection provides a set of functions allowing to manage the USART data 
    488            transfers.
    489            
    490            During an USART reception, data shifts in least significant bit first through 
    491            the RX pin. In this mode, the USART_DR register consists of a buffer (RDR) 
    492            between the internal bus and the received shift register.
    493          
    494            When a transmission is taking place, a write instruction to the USART_DR register 
    495            stores the data in the TDR register and which is copied in the shift register 
    496            at the end of the current transmission.
    497          
    498            The read access of the USART_DR register can be done using the USART_ReceiveData()
    499            function and returns the RDR buffered value. Whereas a write access to the USART_DR 
    500            can be done using USART_SendData() function and stores the written data into 
    501            TDR buffer.
    502          
    503          @endverbatim
    504            * @{
    505            */
    506          
    507          /**
    508            * @brief  Transmits single data through the USARTx peripheral.
    509            * @param  USARTx: Select the USART peripheral. 
    510            *   This parameter can be one of the following values:
    511            *   USART1, USART2 or USART3.
    512            * @param  Data: the data to transmit.
    513            * @retval None
    514            */

   \                                 In section .text, align 2, keep-with-next
    515          void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
    516          {
   \                     USART_SendData: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    517            /* Check the parameters */
    518            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable22  ;; 0x40013800
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??USART_SendData_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable22_1  ;; 0x40004400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??USART_SendData_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40004800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??USART_SendData_0
   \   0000001E   0xF240 0x2106      MOVW     R1,#+518
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \   00000026   0x.... 0x....      BL       assert_failed
    519            assert_param(IS_USART_DATA(Data)); 
   \                     ??USART_SendData_0: (+1)
   \   0000002A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002C   0xF5B5 0x7F00      CMP      R5,#+512
   \   00000030   0xDB05             BLT.N    ??USART_SendData_1
   \   00000032   0xF240 0x2107      MOVW     R1,#+519
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \   0000003A   0x.... 0x....      BL       assert_failed
    520              
    521            /* Transmit Data */
    522            USARTx->DR = (Data & (uint16_t)0x01FF);
   \                     ??USART_SendData_1: (+1)
   \   0000003E   0x05E8             LSLS     R0,R5,#+23       ;; ZeroExtS R0,R5,#+23,#+23
   \   00000040   0x0DC0             LSRS     R0,R0,#+23
   \   00000042   0x80A0             STRH     R0,[R4, #+4]
    523          }
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    524          
    525          /**
    526            * @brief  Returns the most recent received data by the USARTx peripheral.
    527            * @param  USARTx: Select the USART peripheral. 
    528            *   This parameter can be one of the following values:
    529            *   USART1, USART2 or USART3.
    530            * @retval The received data.
    531            */

   \                                 In section .text, align 2, keep-with-next
    532          uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
    533          {
   \                     USART_ReceiveData: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    534            /* Check the parameters */
    535            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable22  ;; 0x40013800
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00D             BEQ.N    ??USART_ReceiveData_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable22_1  ;; 0x40004400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD009             BEQ.N    ??USART_ReceiveData_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40004800
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD005             BEQ.N    ??USART_ReceiveData_0
   \   0000001C   0xF240 0x2117      MOVW     R1,#+535
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \   00000024   0x.... 0x....      BL       assert_failed
    536            
    537            /* Receive Data */
    538            return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
   \                     ??USART_ReceiveData_0: (+1)
   \   00000028   0x88A0             LDRH     R0,[R4, #+4]
   \   0000002A   0x05C0             LSLS     R0,R0,#+23       ;; ZeroExtS R0,R0,#+23,#+23
   \   0000002C   0x0DC0             LSRS     R0,R0,#+23
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
    539          }
    540          
    541          /**
    542            * @}
    543            */
    544          
    545          /** @defgroup USART_Group3 MultiProcessor Communication functions
    546           *  @brief   Multi-Processor Communication functions 
    547           *
    548          @verbatim   
    549           ===============================================================================
    550                              Multi-Processor Communication functions
    551           ===============================================================================  
    552          
    553            This subsection provides a set of functions allowing to manage the USART 
    554            multiprocessor communication.
    555            
    556            For instance one of the USARTs can be the master, its TX output is connected to 
    557            the RX input of the other USART. The others are slaves, their respective TX outputs 
    558            are logically ANDed together and connected to the RX input of the master.
    559          
    560            USART multiprocessor communication is possible through the following procedure:
    561               1. Program the Baud rate, Word length = 9 bits, Stop bits, Parity, Mode transmitter 
    562                  or Mode receiver and hardware flow control values using the USART_Init()
    563                  function.
    564               2. Configures the USART address using the USART_SetAddress() function.
    565               3. Configures the wake up methode (USART_WakeUp_IdleLine or USART_WakeUp_AddressMark)
    566                  using USART_WakeUpConfig() function only for the slaves.
    567               4. Enable the USART using the USART_Cmd() function.
    568               5. Enter the USART slaves in mute mode using USART_ReceiverWakeUpCmd() function.
    569          
    570            The USART Slave exit from mute mode when receive the wake up condition.
    571          
    572          @endverbatim
    573            * @{
    574            */
    575          
    576          /**
    577            * @brief  Sets the address of the USART node.
    578            * @param  USARTx: Select the USART peripheral. 
    579            *   This parameter can be one of the following values:
    580            *   USART1, USART2 or USART3.
    581            * @param  USART_Address: Indicates the address of the USART node.
    582            * @retval None
    583            */

   \                                 In section .text, align 2, keep-with-next
    584          void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
    585          {
   \                     USART_SetAddress: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    586            /* Check the parameters */
    587            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable22  ;; 0x40013800
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??USART_SetAddress_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable22_1  ;; 0x40004400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??USART_SetAddress_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40004800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??USART_SetAddress_0
   \   0000001E   0xF240 0x214B      MOVW     R1,#+587
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \   00000026   0x.... 0x....      BL       assert_failed
    588            assert_param(IS_USART_ADDRESS(USART_Address)); 
   \                     ??USART_SetAddress_0: (+1)
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0x2D10             CMP      R5,#+16
   \   0000002E   0xDB05             BLT.N    ??USART_SetAddress_1
   \   00000030   0xF44F 0x7113      MOV      R1,#+588
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \   00000038   0x.... 0x....      BL       assert_failed
    589              
    590            /* Clear the USART address */
    591            USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_ADD);
   \                     ??USART_SetAddress_1: (+1)
   \   0000003C   0x8A20             LDRH     R0,[R4, #+16]
   \   0000003E   0xF64F 0x71F0      MOVW     R1,#+65520
   \   00000042   0x4008             ANDS     R0,R1,R0
   \   00000044   0x8220             STRH     R0,[R4, #+16]
    592            /* Set the USART address node */
    593            USARTx->CR2 |= USART_Address;
   \   00000046   0x8A20             LDRH     R0,[R4, #+16]
   \   00000048   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004A   0x4328             ORRS     R0,R5,R0
   \   0000004C   0x8220             STRH     R0,[R4, #+16]
    594          }
   \   0000004E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    595          
    596          /**
    597            * @brief  Determines if the USART is in mute mode or not.
    598            * @param  USARTx: Select the USART peripheral. 
    599            *   This parameter can be one of the following values:
    600            *   USART1, USART2 or USART3.
    601            * @param  NewState: new state of the USART mute mode.
    602            *   This parameter can be: ENABLE or DISABLE.
    603            * @retval None
    604            */

   \                                 In section .text, align 2, keep-with-next
    605          void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    606          {
   \                     USART_ReceiverWakeUpCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    607            /* Check the parameters */
    608            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable22  ;; 0x40013800
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??USART_ReceiverWakeUpCmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable22_1  ;; 0x40004400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??USART_ReceiverWakeUpCmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40004800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??USART_ReceiverWakeUpCmd_0
   \   0000001E   0xF44F 0x7118      MOV      R1,#+608
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \   00000026   0x.... 0x....      BL       assert_failed
    609            assert_param(IS_FUNCTIONAL_STATE(NewState)); 
   \                     ??USART_ReceiverWakeUpCmd_0: (+1)
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0x2D00             CMP      R5,#+0
   \   0000002E   0xD008             BEQ.N    ??USART_ReceiverWakeUpCmd_1
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D01             CMP      R5,#+1
   \   00000034   0xD005             BEQ.N    ??USART_ReceiverWakeUpCmd_1
   \   00000036   0xF240 0x2161      MOVW     R1,#+609
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \   0000003E   0x.... 0x....      BL       assert_failed
    610            
    611            if (NewState != DISABLE)
   \                     ??USART_ReceiverWakeUpCmd_1: (+1)
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0x2D00             CMP      R5,#+0
   \   00000046   0xD004             BEQ.N    ??USART_ReceiverWakeUpCmd_2
    612            {
    613              /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
    614              USARTx->CR1 |= USART_CR1_RWU;
   \   00000048   0x89A0             LDRH     R0,[R4, #+12]
   \   0000004A   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000004E   0x81A0             STRH     R0,[R4, #+12]
   \   00000050   0xE004             B.N      ??USART_ReceiverWakeUpCmd_3
    615            }
    616            else
    617            {
    618              /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
    619              USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_RWU);
   \                     ??USART_ReceiverWakeUpCmd_2: (+1)
   \   00000052   0x89A0             LDRH     R0,[R4, #+12]
   \   00000054   0xF64F 0x71FD      MOVW     R1,#+65533
   \   00000058   0x4008             ANDS     R0,R1,R0
   \   0000005A   0x81A0             STRH     R0,[R4, #+12]
    620            }
    621          }
   \                     ??USART_ReceiverWakeUpCmd_3: (+1)
   \   0000005C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    622          /**
    623            * @brief  Selects the USART WakeUp method.
    624            * @param  USARTx: Select the USART peripheral. 
    625            *   This parameter can be one of the following values:
    626            *   USART1, USART2 or USART3.
    627            * @param  USART_WakeUp: specifies the USART wakeup method.
    628            *   This parameter can be one of the following values:
    629            *     @arg USART_WakeUp_IdleLine: WakeUp by an idle line detection
    630            *     @arg USART_WakeUp_AddressMark: WakeUp by an address mark
    631            * @retval None
    632            */

   \                                 In section .text, align 2, keep-with-next
    633          void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp)
    634          {
   \                     USART_WakeUpConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    635            /* Check the parameters */
    636            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable22  ;; 0x40013800
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??USART_WakeUpConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable22_1  ;; 0x40004400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??USART_WakeUpConfig_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40004800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??USART_WakeUpConfig_0
   \   0000001E   0xF44F 0x711F      MOV      R1,#+636
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \   00000026   0x.... 0x....      BL       assert_failed
    637            assert_param(IS_USART_WAKEUP(USART_WakeUp));
   \                     ??USART_WakeUpConfig_0: (+1)
   \   0000002A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002C   0x2D00             CMP      R5,#+0
   \   0000002E   0xD009             BEQ.N    ??USART_WakeUpConfig_1
   \   00000030   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000032   0xF5B5 0x6F00      CMP      R5,#+2048
   \   00000036   0xD005             BEQ.N    ??USART_WakeUpConfig_1
   \   00000038   0xF240 0x217D      MOVW     R1,#+637
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \   00000040   0x.... 0x....      BL       assert_failed
    638            
    639            USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_WAKE);
   \                     ??USART_WakeUpConfig_1: (+1)
   \   00000044   0x89A0             LDRH     R0,[R4, #+12]
   \   00000046   0xF24F 0x71FF      MOVW     R1,#+63487
   \   0000004A   0x4008             ANDS     R0,R1,R0
   \   0000004C   0x81A0             STRH     R0,[R4, #+12]
    640            USARTx->CR1 |= USART_WakeUp;
   \   0000004E   0x89A0             LDRH     R0,[R4, #+12]
   \   00000050   0x4328             ORRS     R0,R5,R0
   \   00000052   0x81A0             STRH     R0,[R4, #+12]
    641          }
   \   00000054   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    642          
    643          /**
    644            * @}
    645            */
    646          
    647          /** @defgroup USART_Group4 LIN mode functions
    648           *  @brief   LIN mode functions 
    649           *
    650          @verbatim   
    651           ===============================================================================
    652                                          LIN mode functions
    653           ===============================================================================  
    654          
    655            This subsection provides a set of functions allowing to manage the USART LIN 
    656            Mode communication.
    657            
    658            In LIN mode, 8-bit data format with 1 stop bit is required in accordance with 
    659            the LIN standard.
    660          
    661            Only this LIN Feature is supported by the USART IP:
    662              - LIN Master Synchronous Break send capability and LIN slave break detection
    663                capability :  13-bit break generation and 10/11 bit break detection
    664          
    665          
    666            USART LIN Master transmitter communication is possible through the following procedure:
    667               1. Program the Baud rate, Word length = 8bits, Stop bits = 1bit, Parity, 
    668                  Mode transmitter or Mode receiver and hardware flow control values using 
    669                  the USART_Init() function.
    670               2. Enable the USART using the USART_Cmd() function.
    671               3. Enable the LIN mode using the USART_LINCmd() function.
    672               4. Send the break character using USART_SendBreak() function.
    673          
    674            USART LIN Master receiver communication is possible through the following procedure:
    675               1. Program the Baud rate, Word length = 8bits, Stop bits = 1bit, Parity, 
    676                  Mode transmitter or Mode receiver and hardware flow control values using 
    677                  the USART_Init() function.
    678               2. Enable the USART using the USART_Cmd() function.
    679               3. Configures the break detection length using the USART_LINBreakDetectLengthConfig()
    680                  function.
    681               4. Enable the LIN mode using the USART_LINCmd() function.
    682          
    683          Note:
    684          ----
    685            1. In LIN mode, the following bits must be kept cleared:
    686               - CLKEN in the USART_CR2 register,
    687               - STOP[1:0], SCEN, HDSEL and IREN in the USART_CR3 register.
    688          
    689          @endverbatim
    690            * @{
    691            */
    692          
    693          /**
    694            * @brief  Sets the USART LIN Break detection length.
    695            * @param  USARTx: Select the USART peripheral. 
    696            *   This parameter can be one of the following values:
    697            *   USART1, USART2 or USART3.
    698            * @param  USART_LINBreakDetectLength: specifies the LIN break detection length.
    699            *   This parameter can be one of the following values:
    700            *     @arg USART_LINBreakDetectLength_10b: 10-bit break detection
    701            *     @arg USART_LINBreakDetectLength_11b: 11-bit break detection
    702            * @retval None
    703            */

   \                                 In section .text, align 2, keep-with-next
    704          void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength)
    705          {
   \                     USART_LINBreakDetectLengthConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    706            /* Check the parameters */
    707            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable22  ;; 0x40013800
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??USART_LINBreakDetectLengthConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable22_1  ;; 0x40004400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??USART_LINBreakDetectLengthConfig_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40004800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??USART_LINBreakDetectLengthConfig_0
   \   0000001E   0xF240 0x21C3      MOVW     R1,#+707
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \   00000026   0x.... 0x....      BL       assert_failed
    708            assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
   \                     ??USART_LINBreakDetectLengthConfig_0: (+1)
   \   0000002A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002C   0x2D00             CMP      R5,#+0
   \   0000002E   0xD008             BEQ.N    ??USART_LINBreakDetectLengthConfig_1
   \   00000030   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000032   0x2D20             CMP      R5,#+32
   \   00000034   0xD005             BEQ.N    ??USART_LINBreakDetectLengthConfig_1
   \   00000036   0xF44F 0x7131      MOV      R1,#+708
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \   0000003E   0x.... 0x....      BL       assert_failed
    709            
    710            USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LBDL);
   \                     ??USART_LINBreakDetectLengthConfig_1: (+1)
   \   00000042   0x8A20             LDRH     R0,[R4, #+16]
   \   00000044   0xF64F 0x71DF      MOVW     R1,#+65503
   \   00000048   0x4008             ANDS     R0,R1,R0
   \   0000004A   0x8220             STRH     R0,[R4, #+16]
    711            USARTx->CR2 |= USART_LINBreakDetectLength;  
   \   0000004C   0x8A20             LDRH     R0,[R4, #+16]
   \   0000004E   0x4328             ORRS     R0,R5,R0
   \   00000050   0x8220             STRH     R0,[R4, #+16]
    712          }
   \   00000052   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    713          
    714          /**
    715            * @brief  Enables or disables the USART’s LIN mode.
    716            * @param  USARTx: Select the USART peripheral. 
    717            *   This parameter can be one of the following values:
    718            *   USART1, USART2 or USART3.
    719            * @param  NewState: new state of the USART LIN mode.
    720            *   This parameter can be: ENABLE or DISABLE.
    721            * @retval None
    722            */

   \                                 In section .text, align 2, keep-with-next
    723          void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    724          {
   \                     USART_LINCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    725            /* Check the parameters */
    726            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable22  ;; 0x40013800
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??USART_LINCmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable22_1  ;; 0x40004400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??USART_LINCmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40004800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??USART_LINCmd_0
   \   0000001E   0xF240 0x21D6      MOVW     R1,#+726
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \   00000026   0x.... 0x....      BL       assert_failed
    727            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??USART_LINCmd_0: (+1)
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0x2D00             CMP      R5,#+0
   \   0000002E   0xD008             BEQ.N    ??USART_LINCmd_1
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D01             CMP      R5,#+1
   \   00000034   0xD005             BEQ.N    ??USART_LINCmd_1
   \   00000036   0xF240 0x21D7      MOVW     R1,#+727
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \   0000003E   0x.... 0x....      BL       assert_failed
    728            
    729            if (NewState != DISABLE)
   \                     ??USART_LINCmd_1: (+1)
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0x2D00             CMP      R5,#+0
   \   00000046   0xD004             BEQ.N    ??USART_LINCmd_2
    730            {
    731              /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
    732              USARTx->CR2 |= USART_CR2_LINEN;
   \   00000048   0x8A20             LDRH     R0,[R4, #+16]
   \   0000004A   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \   0000004E   0x8220             STRH     R0,[R4, #+16]
   \   00000050   0xE004             B.N      ??USART_LINCmd_3
    733            }
    734            else
    735            {
    736              /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
    737              USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LINEN);
   \                     ??USART_LINCmd_2: (+1)
   \   00000052   0x8A20             LDRH     R0,[R4, #+16]
   \   00000054   0xF64B 0x71FF      MOVW     R1,#+49151
   \   00000058   0x4008             ANDS     R0,R1,R0
   \   0000005A   0x8220             STRH     R0,[R4, #+16]
    738            }
    739          }
   \                     ??USART_LINCmd_3: (+1)
   \   0000005C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    740          
    741          /**
    742            * @brief  Transmits break characters.
    743            * @param  USARTx: Select the USART peripheral. 
    744            *   This parameter can be one of the following values:
    745            *   USART1, USART2 or USART3.
    746            * @retval None
    747            */

   \                                 In section .text, align 2, keep-with-next
    748          void USART_SendBreak(USART_TypeDef* USARTx)
    749          {
   \                     USART_SendBreak: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    750            /* Check the parameters */
    751            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable22  ;; 0x40013800
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00D             BEQ.N    ??USART_SendBreak_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable22_1  ;; 0x40004400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD009             BEQ.N    ??USART_SendBreak_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40004800
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD005             BEQ.N    ??USART_SendBreak_0
   \   0000001C   0xF240 0x21EF      MOVW     R1,#+751
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \   00000024   0x.... 0x....      BL       assert_failed
    752            
    753            /* Send break characters */
    754            USARTx->CR1 |= USART_CR1_SBK;
   \                     ??USART_SendBreak_0: (+1)
   \   00000028   0x89A0             LDRH     R0,[R4, #+12]
   \   0000002A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000002E   0x81A0             STRH     R0,[R4, #+12]
    755          }
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    756          
    757          /**
    758            * @}
    759            */
    760          
    761          /** @defgroup USART_Group5 Halfduplex mode function
    762           *  @brief   Half-duplex mode function 
    763           *
    764          @verbatim   
    765           ===============================================================================
    766                                   Half-duplex mode function
    767           ===============================================================================  
    768          
    769            This subsection provides a set of functions allowing to manage the USART 
    770            Half-duplex communication.
    771            
    772            The USART can be configured to follow a single-wire half-duplex protocol where 
    773            the TX and RX lines are internally connected.
    774          
    775            USART Half duplex communication is possible through the following procedure:
    776               1. Program the Baud rate, Word length, Stop bits, Parity, Mode transmitter 
    777                  or Mode receiver and hardware flow control values using the USART_Init()
    778                  function.
    779               2. Configures the USART address using the USART_SetAddress() function.
    780               3. Enable the USART using the USART_Cmd() function.
    781               4. Enable the half duplex mode using USART_HalfDuplexCmd() function.
    782          
    783          Note:
    784          ----
    785            1. The RX pin is no longer used
    786            2. In Half-duplex mode the following bits must be kept cleared:
    787                 - LINEN and CLKEN bits in the USART_CR2 register.
    788                 - SCEN and IREN bits in the USART_CR3 register.
    789          
    790          @endverbatim
    791            * @{
    792            */
    793          
    794          /**
    795            * @brief  Enables or disables the USART’s Half Duplex communication.
    796            * @param  USARTx: Select the USART peripheral. 
    797            *   This parameter can be one of the following values:
    798            *   USART1, USART2 or USART3.
    799            * @param  NewState: new state of the USART Communication.
    800            *   This parameter can be: ENABLE or DISABLE.
    801            * @retval None
    802            */

   \                                 In section .text, align 2, keep-with-next
    803          void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    804          {
   \                     USART_HalfDuplexCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    805            /* Check the parameters */
    806            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable22  ;; 0x40013800
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00C             BEQ.N    ??USART_HalfDuplexCmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable22_1  ;; 0x40004400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD008             BEQ.N    ??USART_HalfDuplexCmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40004800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD004             BEQ.N    ??USART_HalfDuplexCmd_0
   \   0000001E   0xF240 0x3126      MOVW     R1,#+806
   \   00000022   0x....             LDR.N    R0,??DataTable22_2
   \   00000024   0x.... 0x....      BL       assert_failed
    807            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??USART_HalfDuplexCmd_0: (+1)
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD007             BEQ.N    ??USART_HalfDuplexCmd_1
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0x2D01             CMP      R5,#+1
   \   00000032   0xD004             BEQ.N    ??USART_HalfDuplexCmd_1
   \   00000034   0xF240 0x3127      MOVW     R1,#+807
   \   00000038   0x....             LDR.N    R0,??DataTable22_2
   \   0000003A   0x.... 0x....      BL       assert_failed
    808            
    809            if (NewState != DISABLE)
   \                     ??USART_HalfDuplexCmd_1: (+1)
   \   0000003E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000040   0x2D00             CMP      R5,#+0
   \   00000042   0xD004             BEQ.N    ??USART_HalfDuplexCmd_2
    810            {
    811              /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
    812              USARTx->CR3 |= USART_CR3_HDSEL;
   \   00000044   0x8AA0             LDRH     R0,[R4, #+20]
   \   00000046   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000004A   0x82A0             STRH     R0,[R4, #+20]
   \   0000004C   0xE004             B.N      ??USART_HalfDuplexCmd_3
    813            }
    814            else
    815            {
    816              /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
    817              USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_HDSEL);
   \                     ??USART_HalfDuplexCmd_2: (+1)
   \   0000004E   0x8AA0             LDRH     R0,[R4, #+20]
   \   00000050   0xF64F 0x71F7      MOVW     R1,#+65527
   \   00000054   0x4008             ANDS     R0,R1,R0
   \   00000056   0x82A0             STRH     R0,[R4, #+20]
    818            }
    819          }
   \                     ??USART_HalfDuplexCmd_3: (+1)
   \   00000058   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    820          
    821          /**
    822            * @}
    823            */
    824          
    825          
    826          /** @defgroup USART_Group6 Smartcard mode functions
    827           *  @brief   Smartcard mode functions 
    828           *
    829          @verbatim   
    830           ===============================================================================
    831                                         Smartcard mode functions
    832           ===============================================================================  
    833          
    834            This subsection provides a set of functions allowing to manage the USART 
    835            Smartcard communication.
    836            
    837            The Smartcard interface is designed to support asynchronous protocol Smartcards as
    838            defined in the ISO 7816-3 standard.
    839          
    840            The USART can provide a clock to the smartcard through the SCLK output.
    841            In smartcard mode, SCLK is not associated to the communication but is simply derived 
    842            from the internal peripheral input clock through a 5-bit prescaler.
    843          
    844            Smartcard communication is possible through the following procedure:
    845               1. Configures the Smartcard Prsecaler using the USART_SetPrescaler() function.
    846               2. Configures the Smartcard Guard Time using the USART_SetGuardTime() function.
    847               3. Program the USART clock using the USART_ClockInit() function as following:
    848                  - USART Clock enabled
    849                  - USART CPOL Low
    850                  - USART CPHA on first edge
    851                  - USART Last Bit Clock Enabled
    852               4. Program the Smartcard interface using the USART_Init() function as following:
    853                  - Word Length = 9 Bits
    854                  - 1.5 Stop Bit
    855                  - Even parity
    856                  - BaudRate = 12096 baud
    857                  - Hardware flow control disabled (RTS and CTS signals)
    858                  - Tx and Rx enabled
    859               5. Optionally you can enable the parity error interrupt using the USART_ITConfig()
    860                  function
    861               6. Enable the USART using the USART_Cmd() function.
    862               7. Enable the Smartcard NACK using the USART_SmartCardNACKCmd() function.
    863               8. Enable the Smartcard interface using the USART_SmartCardCmd() function.
    864          
    865            Please refer to the ISO 7816-3 specification for more details.
    866          
    867          Note: 
    868          -----
    869            1.  It is also possible to choose 0.5 stop bit for receiving but it is recommended 
    870                to use 1.5 stop bits for both transmitting and receiving to avoid switching 
    871                between the two configurations.
    872            2. In smartcard mode, the following bits must be kept cleared:
    873               - LINEN bit in the USART_CR2 register.
    874               - HDSEL and IREN bits in the USART_CR3 register.
    875          
    876          @endverbatim
    877            * @{
    878            */
    879          
    880          /**
    881            * @brief  Sets the specified USART guard time.
    882            * @param  USARTx: Select the USART peripheral. 
    883            *   This parameter can be one of the following values:
    884            *   USART1, USART2 or USART3.
    885            * @param  USART_GuardTime: specifies the guard time.   
    886            * @retval None
    887            */

   \                                 In section .text, align 2, keep-with-next
    888          void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
    889          {    
   \                     USART_SetGuardTime: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    890            /* Check the parameters */
    891            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x....             LDR.N    R0,??DataTable22  ;; 0x40013800
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00B             BEQ.N    ??USART_SetGuardTime_0
   \   0000000C   0x....             LDR.N    R0,??DataTable22_1  ;; 0x40004400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD008             BEQ.N    ??USART_SetGuardTime_0
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40004800
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD004             BEQ.N    ??USART_SetGuardTime_0
   \   0000001A   0xF240 0x317B      MOVW     R1,#+891
   \   0000001E   0x....             LDR.N    R0,??DataTable22_2
   \   00000020   0x.... 0x....      BL       assert_failed
    892            
    893            /* Clear the USART Guard time */
    894            USARTx->GTPR &= USART_GTPR_PSC;
   \                     ??USART_SetGuardTime_0: (+1)
   \   00000024   0x8B20             LDRH     R0,[R4, #+24]
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x8320             STRH     R0,[R4, #+24]
    895            /* Set the USART guard time */
    896            USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
   \   0000002A   0x8B20             LDRH     R0,[R4, #+24]
   \   0000002C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002E   0xEA50 0x2005      ORRS     R0,R0,R5, LSL #+8
   \   00000032   0x8320             STRH     R0,[R4, #+24]
    897          }
   \   00000034   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    898          
    899          /**
    900            * @brief  Enables or disables the USART’s Smart Card mode.
    901            * @param  USARTx: Select the USART peripheral. 
    902            *   This parameter can be one of the following values:
    903            *   USART1, USART2 or USART3.
    904            * @param  NewState: new state of the Smart Card mode.
    905            *   This parameter can be: ENABLE or DISABLE.      
    906            * @retval None
    907            */

   \                                 In section .text, align 2, keep-with-next
    908          void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    909          {
   \                     USART_SmartCardCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    910            /* Check the parameters */
    911            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x....             LDR.N    R0,??DataTable22  ;; 0x40013800
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00B             BEQ.N    ??USART_SmartCardCmd_0
   \   0000000C   0x....             LDR.N    R0,??DataTable22_1  ;; 0x40004400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD008             BEQ.N    ??USART_SmartCardCmd_0
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40004800
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD004             BEQ.N    ??USART_SmartCardCmd_0
   \   0000001A   0xF240 0x318F      MOVW     R1,#+911
   \   0000001E   0x....             LDR.N    R0,??DataTable22_2
   \   00000020   0x.... 0x....      BL       assert_failed
    912            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??USART_SmartCardCmd_0: (+1)
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0x2D00             CMP      R5,#+0
   \   00000028   0xD007             BEQ.N    ??USART_SmartCardCmd_1
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0x2D01             CMP      R5,#+1
   \   0000002E   0xD004             BEQ.N    ??USART_SmartCardCmd_1
   \   00000030   0xF44F 0x7164      MOV      R1,#+912
   \   00000034   0x....             LDR.N    R0,??DataTable22_2
   \   00000036   0x.... 0x....      BL       assert_failed
    913            if (NewState != DISABLE)
   \                     ??USART_SmartCardCmd_1: (+1)
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x2D00             CMP      R5,#+0
   \   0000003E   0xD004             BEQ.N    ??USART_SmartCardCmd_2
    914            {
    915              /* Enable the SC mode by setting the SCEN bit in the CR3 register */
    916              USARTx->CR3 |= USART_CR3_SCEN;
   \   00000040   0x8AA0             LDRH     R0,[R4, #+20]
   \   00000042   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000046   0x82A0             STRH     R0,[R4, #+20]
   \   00000048   0xE004             B.N      ??USART_SmartCardCmd_3
    917            }
    918            else
    919            {
    920              /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
    921              USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_SCEN);
   \                     ??USART_SmartCardCmd_2: (+1)
   \   0000004A   0x8AA0             LDRH     R0,[R4, #+20]
   \   0000004C   0xF64F 0x71DF      MOVW     R1,#+65503
   \   00000050   0x4008             ANDS     R0,R1,R0
   \   00000052   0x82A0             STRH     R0,[R4, #+20]
    922            }
    923          }
   \                     ??USART_SmartCardCmd_3: (+1)
   \   00000054   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    924          
    925          /**
    926            * @brief  Enables or disables NACK transmission.
    927            * @param  USARTx: Select the USART peripheral. 
    928            *   This parameter can be one of the following values:
    929            *   USART1, USART2 or USART3.
    930            * @param  NewState: new state of the NACK transmission.
    931            *   This parameter can be: ENABLE or DISABLE.  
    932            * @retval None
    933            */

   \                                 In section .text, align 2, keep-with-next
    934          void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    935          {
   \                     USART_SmartCardNACKCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    936            /* Check the parameters */
    937            assert_param(IS_USART_ALL_PERIPH(USARTx)); 
   \   00000006   0x....             LDR.N    R0,??DataTable22  ;; 0x40013800
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00A             BEQ.N    ??USART_SmartCardNACKCmd_0
   \   0000000C   0x....             LDR.N    R0,??DataTable22_1  ;; 0x40004400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD007             BEQ.N    ??USART_SmartCardNACKCmd_0
   \   00000012   0x....             LDR.N    R0,??DataTable24  ;; 0x40004800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD004             BEQ.N    ??USART_SmartCardNACKCmd_0
   \   00000018   0xF240 0x31A9      MOVW     R1,#+937
   \   0000001C   0x....             LDR.N    R0,??DataTable22_2
   \   0000001E   0x.... 0x....      BL       assert_failed
    938            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??USART_SmartCardNACKCmd_0: (+1)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD007             BEQ.N    ??USART_SmartCardNACKCmd_1
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD004             BEQ.N    ??USART_SmartCardNACKCmd_1
   \   0000002E   0xF240 0x31AA      MOVW     R1,#+938
   \   00000032   0x....             LDR.N    R0,??DataTable22_2
   \   00000034   0x.... 0x....      BL       assert_failed
    939            if (NewState != DISABLE)
   \                     ??USART_SmartCardNACKCmd_1: (+1)
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0xD004             BEQ.N    ??USART_SmartCardNACKCmd_2
    940            {
    941              /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
    942              USARTx->CR3 |= USART_CR3_NACK;
   \   0000003E   0x8AA0             LDRH     R0,[R4, #+20]
   \   00000040   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000044   0x82A0             STRH     R0,[R4, #+20]
   \   00000046   0xE004             B.N      ??USART_SmartCardNACKCmd_3
    943            }
    944            else
    945            {
    946              /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
    947              USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_NACK);
   \                     ??USART_SmartCardNACKCmd_2: (+1)
   \   00000048   0x8AA0             LDRH     R0,[R4, #+20]
   \   0000004A   0xF64F 0x71EF      MOVW     R1,#+65519
   \   0000004E   0x4008             ANDS     R0,R1,R0
   \   00000050   0x82A0             STRH     R0,[R4, #+20]
    948            }
    949          }
   \                     ??USART_SmartCardNACKCmd_3: (+1)
   \   00000052   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    950          
    951          /**
    952            * @}
    953            */
    954          
    955          /** @defgroup USART_Group7 IrDA mode functions
    956           *  @brief   IrDA mode functions 
    957           *
    958          @verbatim   
    959           ===============================================================================
    960                                          IrDA mode functions
    961           ===============================================================================  
    962          
    963            This subsection provides a set of functions allowing to manage the USART 
    964            IrDA communication.
    965            
    966            IrDA is a half duplex communication protocol. If the Transmitter is busy, any data
    967            on the IrDA receive line will be ignored by the IrDA decoder and if the Receiver 
    968            is busy, data on the TX from the USART to IrDA will not be encoded by IrDA.
    969            While receiving data, transmission should be avoided as the data to be transmitted
    970            could be corrupted.
    971          
    972            IrDA communication is possible through the following procedure:
    973               1. Program the Baud rate, Word length = 8 bits, Stop bits, Parity, Transmitter/Receiver 
    974                  modes and hardware flow control values using the USART_Init() function.
    975               2. Enable the USART using the USART_Cmd() function.
    976               3. Configures the IrDA pulse width by configuring the prescaler using  
    977                  the USART_SetPrescaler() function.
    978               4. Configures the IrDA  USART_IrDAMode_LowPower or USART_IrDAMode_Normal mode
    979                  using the USART_IrDAConfig() function.
    980               5. Enable the IrDA using the USART_IrDACmd() function.
    981          
    982          Note: 
    983          -----
    984            1. A pulse of width less than two and greater than one PSC period(s) may or may
    985               not be rejected.
    986            2. The receiver set up time should be managed by software. The IrDA physical layer
    987               specification specifies a minimum of 10 ms delay between transmission and 
    988               reception (IrDA is a half duplex protocol).
    989            3. In IrDA mode, the following bits must be kept cleared:
    990              - LINEN, STOP and CLKEN bits in the USART_CR2 register.
    991              - SCEN and HDSEL bits in the USART_CR3 register.
    992          
    993          @endverbatim
    994            * @{
    995            */
    996          
    997          /**
    998            * @brief  Configures the USART’s IrDA interface.
    999            * @param  USARTx: Select the USART peripheral. 
   1000            *   This parameter can be one of the following values:
   1001            *   USART1, USART2 or USART3.
   1002            * @param  USART_IrDAMode: specifies the IrDA mode.
   1003            *   This parameter can be one of the following values:
   1004            *     @arg USART_IrDAMode_LowPower
   1005            *     @arg USART_IrDAMode_Normal
   1006            * @retval None
   1007            */

   \                                 In section .text, align 2, keep-with-next
   1008          void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode)
   1009          {
   \                     USART_IrDAConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1010            /* Check the parameters */
   1011            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x....             LDR.N    R0,??DataTable22  ;; 0x40013800
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00A             BEQ.N    ??USART_IrDAConfig_0
   \   0000000C   0x....             LDR.N    R0,??DataTable22_1  ;; 0x40004400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD007             BEQ.N    ??USART_IrDAConfig_0
   \   00000012   0x....             LDR.N    R0,??DataTable24  ;; 0x40004800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD004             BEQ.N    ??USART_IrDAConfig_0
   \   00000018   0xF240 0x31F3      MOVW     R1,#+1011
   \   0000001C   0x....             LDR.N    R0,??DataTable22_2
   \   0000001E   0x.... 0x....      BL       assert_failed
   1012            assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
   \                     ??USART_IrDAConfig_0: (+1)
   \   00000022   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000024   0x2D04             CMP      R5,#+4
   \   00000026   0xD007             BEQ.N    ??USART_IrDAConfig_1
   \   00000028   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD004             BEQ.N    ??USART_IrDAConfig_1
   \   0000002E   0xF44F 0x717D      MOV      R1,#+1012
   \   00000032   0x....             LDR.N    R0,??DataTable22_2
   \   00000034   0x.... 0x....      BL       assert_failed
   1013              
   1014            USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IRLP);
   \                     ??USART_IrDAConfig_1: (+1)
   \   00000038   0x8AA0             LDRH     R0,[R4, #+20]
   \   0000003A   0xF64F 0x71FB      MOVW     R1,#+65531
   \   0000003E   0x4008             ANDS     R0,R1,R0
   \   00000040   0x82A0             STRH     R0,[R4, #+20]
   1015            USARTx->CR3 |= USART_IrDAMode;
   \   00000042   0x8AA0             LDRH     R0,[R4, #+20]
   \   00000044   0x4328             ORRS     R0,R5,R0
   \   00000046   0x82A0             STRH     R0,[R4, #+20]
   1016          }
   \   00000048   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1017          
   1018          /**
   1019            * @brief  Enables or disables the USART’s IrDA interface.
   1020            * @param  USARTx: Select the USART peripheral. 
   1021            *   This parameter can be one of the following values:
   1022            *   USART1, USART2 or USART3.
   1023            * @param  NewState: new state of the IrDA mode.
   1024            *   This parameter can be: ENABLE or DISABLE.
   1025            * @retval None
   1026            */

   \                                 In section .text, align 2, keep-with-next
   1027          void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
   1028          {
   \                     USART_IrDACmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1029            /* Check the parameters */
   1030            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x....             LDR.N    R0,??DataTable22  ;; 0x40013800
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00A             BEQ.N    ??USART_IrDACmd_0
   \   0000000C   0x....             LDR.N    R0,??DataTable22_1  ;; 0x40004400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD007             BEQ.N    ??USART_IrDACmd_0
   \   00000012   0x....             LDR.N    R0,??DataTable24  ;; 0x40004800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD004             BEQ.N    ??USART_IrDACmd_0
   \   00000018   0xF240 0x4106      MOVW     R1,#+1030
   \   0000001C   0x....             LDR.N    R0,??DataTable22_2
   \   0000001E   0x.... 0x....      BL       assert_failed
   1031            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??USART_IrDACmd_0: (+1)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD007             BEQ.N    ??USART_IrDACmd_1
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD004             BEQ.N    ??USART_IrDACmd_1
   \   0000002E   0xF240 0x4107      MOVW     R1,#+1031
   \   00000032   0x....             LDR.N    R0,??DataTable22_2
   \   00000034   0x.... 0x....      BL       assert_failed
   1032              
   1033            if (NewState != DISABLE)
   \                     ??USART_IrDACmd_1: (+1)
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0xD004             BEQ.N    ??USART_IrDACmd_2
   1034            {
   1035              /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
   1036              USARTx->CR3 |= USART_CR3_IREN;
   \   0000003E   0x8AA0             LDRH     R0,[R4, #+20]
   \   00000040   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000044   0x82A0             STRH     R0,[R4, #+20]
   \   00000046   0xE004             B.N      ??USART_IrDACmd_3
   1037            }
   1038            else
   1039            {
   1040              /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
   1041              USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IREN);
   \                     ??USART_IrDACmd_2: (+1)
   \   00000048   0x8AA0             LDRH     R0,[R4, #+20]
   \   0000004A   0xF64F 0x71FD      MOVW     R1,#+65533
   \   0000004E   0x4008             ANDS     R0,R1,R0
   \   00000050   0x82A0             STRH     R0,[R4, #+20]
   1042            }
   1043          }
   \                     ??USART_IrDACmd_3: (+1)
   \   00000052   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1044          
   1045          /**
   1046            * @}
   1047            */
   1048          
   1049          /** @defgroup USART_Group8 DMA transfers management functions
   1050           *  @brief   DMA transfers management functions
   1051           *
   1052          @verbatim   
   1053           ===============================================================================
   1054                                DMA transfers management functions
   1055           ===============================================================================  
   1056          
   1057          @endverbatim
   1058            * @{
   1059            */
   1060            
   1061          /**
   1062            * @brief  Enables or disables the USART’s DMA interface.
   1063            * @param  USARTx: Select the USART peripheral. 
   1064            *   This parameter can be one of the following values:
   1065            *   USART1, USART2 or USART3.
   1066            * @param  USART_DMAReq: specifies the DMA request.
   1067            *   This parameter can be any combination of the following values:
   1068            *     @arg USART_DMAReq_Tx: USART DMA transmit request
   1069            *     @arg USART_DMAReq_Rx: USART DMA receive request
   1070            * @param  NewState: new state of the DMA Request sources.
   1071            *   This parameter can be: ENABLE or DISABLE.  
   1072            * @retval None
   1073            */

   \                                 In section .text, align 2, keep-with-next
   1074          void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
   1075          {
   \                     USART_DMACmd: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1076            /* Check the parameters */
   1077            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000008   0x....             LDR.N    R0,??DataTable22  ;; 0x40013800
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00A             BEQ.N    ??USART_DMACmd_0
   \   0000000E   0x....             LDR.N    R0,??DataTable22_1  ;; 0x40004400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD007             BEQ.N    ??USART_DMACmd_0
   \   00000014   0x....             LDR.N    R0,??DataTable24  ;; 0x40004800
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD004             BEQ.N    ??USART_DMACmd_0
   \   0000001A   0xF240 0x4135      MOVW     R1,#+1077
   \   0000001E   0x....             LDR.N    R0,??DataTable22_2
   \   00000020   0x.... 0x....      BL       assert_failed
   1078            assert_param(IS_USART_DMAREQ(USART_DMAReq));  
   \                     ??USART_DMACmd_0: (+1)
   \   00000024   0xF64F 0x703F      MOVW     R0,#+65343
   \   00000028   0x4205             TST      R5,R0
   \   0000002A   0xD102             BNE.N    ??USART_DMACmd_1
   \   0000002C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002E   0x2D00             CMP      R5,#+0
   \   00000030   0xD104             BNE.N    ??USART_DMACmd_2
   \                     ??USART_DMACmd_1: (+1)
   \   00000032   0xF240 0x4136      MOVW     R1,#+1078
   \   00000036   0x....             LDR.N    R0,??DataTable22_2
   \   00000038   0x.... 0x....      BL       assert_failed
   1079            assert_param(IS_FUNCTIONAL_STATE(NewState)); 
   \                     ??USART_DMACmd_2: (+1)
   \   0000003C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003E   0x2E00             CMP      R6,#+0
   \   00000040   0xD007             BEQ.N    ??USART_DMACmd_3
   \   00000042   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000044   0x2E01             CMP      R6,#+1
   \   00000046   0xD004             BEQ.N    ??USART_DMACmd_3
   \   00000048   0xF240 0x4137      MOVW     R1,#+1079
   \   0000004C   0x....             LDR.N    R0,??DataTable22_2
   \   0000004E   0x.... 0x....      BL       assert_failed
   1080          
   1081            if (NewState != DISABLE)
   \                     ??USART_DMACmd_3: (+1)
   \   00000052   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000054   0x2E00             CMP      R6,#+0
   \   00000056   0xD003             BEQ.N    ??USART_DMACmd_4
   1082            {
   1083              /* Enable the DMA transfer for selected requests by setting the DMAT and/or
   1084                 DMAR bits in the USART CR3 register */
   1085              USARTx->CR3 |= USART_DMAReq;
   \   00000058   0x8AA0             LDRH     R0,[R4, #+20]
   \   0000005A   0x4328             ORRS     R0,R5,R0
   \   0000005C   0x82A0             STRH     R0,[R4, #+20]
   \   0000005E   0xE002             B.N      ??USART_DMACmd_5
   1086            }
   1087            else
   1088            {
   1089              /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
   1090                 DMAR bits in the USART CR3 register */
   1091              USARTx->CR3 &= (uint16_t)~USART_DMAReq;
   \                     ??USART_DMACmd_4: (+1)
   \   00000060   0x8AA0             LDRH     R0,[R4, #+20]
   \   00000062   0x43A8             BICS     R0,R0,R5
   \   00000064   0x82A0             STRH     R0,[R4, #+20]
   1092            }
   1093          }
   \                     ??USART_DMACmd_5: (+1)
   \   00000066   0xBD70             POP      {R4-R6,PC}       ;; return
   1094          
   1095          /**
   1096            * @}
   1097            */
   1098            
   1099          /** @defgroup USART_Group9 Interrupts and flags management functions
   1100           *  @brief   Interrupts and flags management functions 
   1101           *
   1102          @verbatim   
   1103           ===============================================================================
   1104                             Interrupts and flags management functions
   1105           ===============================================================================  
   1106          
   1107            This subsection provides a set of functions allowing to configure the USART 
   1108            Interrupts sources, DMA channels requests and check or clear the flags or 
   1109            pending bits status.
   1110            The user should identify which mode will be used in his application to manage 
   1111            the communication: Polling mode, Interrupt mode or DMA mode. 
   1112              
   1113            Polling Mode
   1114            =============
   1115            In Polling Mode, the SPI communication can be managed by 10 flags:
   1116               1. USART_FLAG_TXE : to indicate the status of the transmit buffer register
   1117               2. USART_FLAG_RXNE : to indicate the status of the receive buffer register
   1118               3. USART_FLAG_TC : to indicate the status of the transmit operation
   1119               4. USART_FLAG_IDLE : to indicate the status of the Idle Line             
   1120               5. USART_FLAG_CTS : to indicate the status of the nCTS input
   1121               6. USART_FLAG_LBD : to indicate the status of the LIN break detection
   1122               7. USART_FLAG_NE : to indicate if a noise error occur
   1123               8. USART_FLAG_FE : to indicate if a frame error occur
   1124               9. USART_FLAG_PE : to indicate if a parity error occur
   1125               10. USART_FLAG_ORE : to indicate if an Overrun error occur
   1126          
   1127            In this Mode it is advised to use the following functions:
   1128                - FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG);
   1129                - void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG);
   1130          
   1131            Interrupt Mode
   1132            ===============
   1133            In Interrupt Mode, the USART communication can be managed by 8 interrupt sources
   1134            and 10 pending bits: 
   1135          
   1136            Pending Bits:
   1137            ------------- 
   1138               1. USART_IT_TXE : to indicate the status of the transmit buffer register
   1139               2. USART_IT_RXNE : to indicate the status of the receive buffer register
   1140               3. USART_IT_TC : to indicate the status of the transmit operation
   1141               4. USART_IT_IDLE : to indicate the status of the Idle Line             
   1142               5. USART_IT_CTS : to indicate the status of the nCTS input
   1143               6. USART_IT_LBD : to indicate the status of the LIN break detection
   1144               7. USART_IT_NE : to indicate if a noise error occur
   1145               8. USART_IT_FE : to indicate if a frame error occur
   1146               9. USART_IT_PE : to indicate if a parity error occur
   1147               10. USART_IT_ORE : to indicate if an Overrun error occur
   1148          
   1149            Interrupt Source:
   1150            -----------------
   1151               1. USART_IT_TXE : specifies the interrupt source for the Tx buffer empty 
   1152                                 interrupt. 
   1153               2. USART_IT_RXNE : specifies the interrupt source for the Rx buffer not 
   1154                                  empty interrupt.
   1155               3. USART_IT_TC : specifies the interrupt source for the Transmit complete 
   1156                                 interrupt. 
   1157               4. USART_IT_IDLE : specifies the interrupt source for the Idle Line interrupt.             
   1158               5. USART_IT_CTS : specifies the interrupt source for the CTS interrupt. 
   1159               6. USART_IT_LBD : specifies the interrupt source for the LIN break detection
   1160                                 interrupt. 
   1161               7. USART_IT_PE : specifies the interrupt source for theparity error interrupt. 
   1162               8. USART_IT_ERR :  specifies the interrupt source for the errors interrupt.
   1163          
   1164              Note: Some parameters are coded in order to use them as interrupt source or 
   1165              ----  as pending bits.
   1166          
   1167            In this Mode it is advised to use the following functions:
   1168               - void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState);
   1169               - ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT);
   1170               - void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT);
   1171          
   1172            DMA Mode
   1173            ========
   1174            In DMA Mode, the USART communication can be managed by 2 DMA Channel requests:
   1175               1. USART_DMAReq_Tx: specifies the Tx buffer DMA transfer request
   1176               2. USART_DMAReq_Rx: specifies the Rx buffer DMA transfer request
   1177          
   1178            In this Mode it is advised to use the following function:
   1179               - void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState);
   1180          
   1181          @endverbatim
   1182            * @{
   1183            */
   1184          
   1185          /**
   1186            * @brief  Enables or disables the specified USART interrupts.
   1187            * @param  USARTx: Select the USART peripheral. 
   1188            *   This parameter can be one of the following values:
   1189            *   USART1, USART2 or USART3.
   1190            * @param  USART_IT: specifies the USART interrupt sources to be enabled or disabled.
   1191            *   This parameter can be one of the following values:
   1192            *     @arg USART_IT_CTS:  CTS change interrupt
   1193            *     @arg USART_IT_LBD:  LIN Break detection interrupt
   1194            *     @arg USART_IT_TXE:  Tansmit Data Register empty interrupt
   1195            *     @arg USART_IT_TC:   Transmission complete interrupt
   1196            *     @arg USART_IT_RXNE: Receive Data register not empty interrupt
   1197            *     @arg USART_IT_IDLE: Idle line detection interrupt
   1198            *     @arg USART_IT_PE:   Parity Error interrupt
   1199            *     @arg USART_IT_ERR:  Error interrupt(Frame error, noise error, overrun error)
   1200            * @param  NewState: new state of the specified USARTx interrupts.
   1201            *   This parameter can be: ENABLE or DISABLE.
   1202            * @retval None
   1203            */

   \                                 In section .text, align 2, keep-with-next
   1204          void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
   1205          {
   \                     USART_ITConfig: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1206            uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
   \   0000000A   0x2700             MOVS     R7,#+0
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   \   00000010   0xF05F 0x0900      MOVS     R9,#+0
   1207            uint32_t usartxbase = 0x00;
   \   00000014   0xF05F 0x0A00      MOVS     R10,#+0
   1208            /* Check the parameters */
   1209            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000018   0x....             LDR.N    R0,??DataTable22  ;; 0x40013800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD00A             BEQ.N    ??USART_ITConfig_0
   \   0000001E   0x....             LDR.N    R0,??DataTable22_1  ;; 0x40004400
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD007             BEQ.N    ??USART_ITConfig_0
   \   00000024   0x....             LDR.N    R0,??DataTable24  ;; 0x40004800
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD004             BEQ.N    ??USART_ITConfig_0
   \   0000002A   0xF240 0x41B9      MOVW     R1,#+1209
   \   0000002E   0x....             LDR.N    R0,??DataTable22_2
   \   00000030   0x.... 0x....      BL       assert_failed
   1210            assert_param(IS_USART_CONFIG_IT(USART_IT));
   \                     ??USART_ITConfig_0: (+1)
   \   00000034   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000036   0x2D28             CMP      R5,#+40
   \   00000038   0xD025             BEQ.N    ??USART_ITConfig_1
   \   0000003A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000003C   0xF240 0x7027      MOVW     R0,#+1831
   \   00000040   0x4285             CMP      R5,R0
   \   00000042   0xD020             BEQ.N    ??USART_ITConfig_1
   \   00000044   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000046   0xF240 0x6026      MOVW     R0,#+1574
   \   0000004A   0x4285             CMP      R5,R0
   \   0000004C   0xD01B             BEQ.N    ??USART_ITConfig_1
   \   0000004E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000050   0xF240 0x5025      MOVW     R0,#+1317
   \   00000054   0x4285             CMP      R5,R0
   \   00000056   0xD016             BEQ.N    ??USART_ITConfig_1
   \   00000058   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000005A   0xF240 0x4024      MOVW     R0,#+1060
   \   0000005E   0x4285             CMP      R5,R0
   \   00000060   0xD011             BEQ.N    ??USART_ITConfig_1
   \   00000062   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000064   0xF640 0x0046      MOVW     R0,#+2118
   \   00000068   0x4285             CMP      R5,R0
   \   0000006A   0xD00C             BEQ.N    ??USART_ITConfig_1
   \   0000006C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000006E   0xF640 0x106A      MOVW     R0,#+2410
   \   00000072   0x4285             CMP      R5,R0
   \   00000074   0xD007             BEQ.N    ??USART_ITConfig_1
   \   00000076   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000078   0x2D60             CMP      R5,#+96
   \   0000007A   0xD004             BEQ.N    ??USART_ITConfig_1
   \   0000007C   0xF240 0x41BA      MOVW     R1,#+1210
   \   00000080   0x....             LDR.N    R0,??DataTable22_2
   \   00000082   0x.... 0x....      BL       assert_failed
   1211            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??USART_ITConfig_1: (+1)
   \   00000086   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000088   0x2E00             CMP      R6,#+0
   \   0000008A   0xD007             BEQ.N    ??USART_ITConfig_2
   \   0000008C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000008E   0x2E01             CMP      R6,#+1
   \   00000090   0xD004             BEQ.N    ??USART_ITConfig_2
   \   00000092   0xF240 0x41BB      MOVW     R1,#+1211
   \   00000096   0x....             LDR.N    R0,??DataTable22_2
   \   00000098   0x.... 0x....      BL       assert_failed
   1212            
   1213            usartxbase = (uint32_t)USARTx;
   \                     ??USART_ITConfig_2: (+1)
   \   0000009C   0x46A2             MOV      R10,R4
   1214          
   1215            /* Get the USART register index */
   1216            usartreg = (((uint8_t)USART_IT) >> 0x05);
   \   0000009E   0x0028             MOVS     R0,R5
   \   000000A0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A2   0x0940             LSRS     R0,R0,#+5
   \   000000A4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A6   0x0007             MOVS     R7,R0
   1217          
   1218            /* Get the interrupt position */
   1219            itpos = USART_IT & IT_MASK;
   \   000000A8   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000AA   0xF015 0x001F      ANDS     R0,R5,#0x1F
   \   000000AE   0x4680             MOV      R8,R0
   1220            itmask = (((uint32_t)0x01) << itpos);
   \   000000B0   0x2001             MOVS     R0,#+1
   \   000000B2   0xFA10 0xF008      LSLS     R0,R0,R8
   \   000000B6   0x4681             MOV      R9,R0
   1221              
   1222            if (usartreg == 0x01) /* The IT is in CR1 register */
   \   000000B8   0x2F01             CMP      R7,#+1
   \   000000BA   0xD102             BNE.N    ??USART_ITConfig_3
   1223            {
   1224              usartxbase += 0x0C;
   \   000000BC   0xF11A 0x0A0C      ADDS     R10,R10,#+12
   \   000000C0   0xE006             B.N      ??USART_ITConfig_4
   1225            }
   1226            else if (usartreg == 0x02) /* The IT is in CR2 register */
   \                     ??USART_ITConfig_3: (+1)
   \   000000C2   0x2F02             CMP      R7,#+2
   \   000000C4   0xD102             BNE.N    ??USART_ITConfig_5
   1227            {
   1228              usartxbase += 0x10;
   \   000000C6   0xF11A 0x0A10      ADDS     R10,R10,#+16
   \   000000CA   0xE001             B.N      ??USART_ITConfig_4
   1229            }
   1230            else /* The IT is in CR3 register */
   1231            {
   1232              usartxbase += 0x14; 
   \                     ??USART_ITConfig_5: (+1)
   \   000000CC   0xF11A 0x0A14      ADDS     R10,R10,#+20
   1233            }
   1234            if (NewState != DISABLE)
   \                     ??USART_ITConfig_4: (+1)
   \   000000D0   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000D2   0x2E00             CMP      R6,#+0
   \   000000D4   0xD006             BEQ.N    ??USART_ITConfig_6
   1235            {
   1236              *(__IO uint32_t*)usartxbase  |= itmask;
   \   000000D6   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   000000DA   0xEA59 0x0000      ORRS     R0,R9,R0
   \   000000DE   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \   000000E2   0xE005             B.N      ??USART_ITConfig_7
   1237            }
   1238            else
   1239            {
   1240              *(__IO uint32_t*)usartxbase &= ~itmask;
   \                     ??USART_ITConfig_6: (+1)
   \   000000E4   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   000000E8   0xEA30 0x0009      BICS     R0,R0,R9
   \   000000EC   0xF8CA 0x0000      STR      R0,[R10, #+0]
   1241            }
   1242          }
   \                     ??USART_ITConfig_7: (+1)
   \   000000F0   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   1243          
   1244          /**
   1245            * @brief  Checks whether the specified USART flag is set or not.
   1246            * @param  USARTx: Select the USART peripheral. 
   1247            *   This parameter can be one of the following values:
   1248            *   USART1, USART2 or USART3.
   1249            * @param  USART_FLAG: specifies the flag to check.
   1250            *   This parameter can be one of the following values:
   1251            *     @arg USART_FLAG_CTS:  CTS Change flag
   1252            *     @arg USART_FLAG_LBD:  LIN Break detection flag
   1253            *     @arg USART_FLAG_TXE:  Transmit data register empty flag
   1254            *     @arg USART_FLAG_TC:   Transmission Complete flag
   1255            *     @arg USART_FLAG_RXNE: Receive data register not empty flag
   1256            *     @arg USART_FLAG_IDLE: Idle Line detection flag
   1257            *     @arg USART_FLAG_ORE:  OverRun Error flag
   1258            *     @arg USART_FLAG_NE:   Noise Error flag
   1259            *     @arg USART_FLAG_FE:   Framing Error flag
   1260            *     @arg USART_FLAG_PE:   Parity Error flag
   1261            * @retval The new state of USART_FLAG (SET or RESET).
   1262            */

   \                                 In section .text, align 2, keep-with-next
   1263          FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
   1264          {
   \                     USART_GetFlagStatus: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1265            FlagStatus bitstatus = RESET;
   \   00000006   0x2600             MOVS     R6,#+0
   1266            /* Check the parameters */
   1267            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000008   0x....             LDR.N    R0,??DataTable26_1  ;; 0x40013800
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00A             BEQ.N    ??USART_GetFlagStatus_0
   \   0000000E   0x....             LDR.N    R0,??DataTable26_2  ;; 0x40004400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD007             BEQ.N    ??USART_GetFlagStatus_0
   \   00000014   0x....             LDR.N    R0,??DataTable24  ;; 0x40004800
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD004             BEQ.N    ??USART_GetFlagStatus_0
   \   0000001A   0xF240 0x41F3      MOVW     R1,#+1267
   \   0000001E   0x....             LDR.N    R0,??DataTable26_3
   \   00000020   0x.... 0x....      BL       assert_failed
   1268            assert_param(IS_USART_FLAG(USART_FLAG));
   \                     ??USART_GetFlagStatus_0: (+1)
   \   00000024   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000026   0x2D01             CMP      R5,#+1
   \   00000028   0xD021             BEQ.N    ??USART_GetFlagStatus_1
   \   0000002A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002C   0x2D80             CMP      R5,#+128
   \   0000002E   0xD01E             BEQ.N    ??USART_GetFlagStatus_1
   \   00000030   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000032   0x2D40             CMP      R5,#+64
   \   00000034   0xD01B             BEQ.N    ??USART_GetFlagStatus_1
   \   00000036   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000038   0x2D20             CMP      R5,#+32
   \   0000003A   0xD018             BEQ.N    ??USART_GetFlagStatus_1
   \   0000003C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000003E   0x2D10             CMP      R5,#+16
   \   00000040   0xD015             BEQ.N    ??USART_GetFlagStatus_1
   \   00000042   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000044   0xF5B5 0x7F80      CMP      R5,#+256
   \   00000048   0xD011             BEQ.N    ??USART_GetFlagStatus_1
   \   0000004A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004C   0xF5B5 0x7F00      CMP      R5,#+512
   \   00000050   0xD00D             BEQ.N    ??USART_GetFlagStatus_1
   \   00000052   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000054   0x2D08             CMP      R5,#+8
   \   00000056   0xD00A             BEQ.N    ??USART_GetFlagStatus_1
   \   00000058   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000005A   0x2D04             CMP      R5,#+4
   \   0000005C   0xD007             BEQ.N    ??USART_GetFlagStatus_1
   \   0000005E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000060   0x2D02             CMP      R5,#+2
   \   00000062   0xD004             BEQ.N    ??USART_GetFlagStatus_1
   \   00000064   0xF240 0x41F4      MOVW     R1,#+1268
   \   00000068   0x....             LDR.N    R0,??DataTable26_3
   \   0000006A   0x.... 0x....      BL       assert_failed
   1269            
   1270            if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
   \                     ??USART_GetFlagStatus_1: (+1)
   \   0000006E   0x8820             LDRH     R0,[R4, #+0]
   \   00000070   0x4228             TST      R0,R5
   \   00000072   0xD002             BEQ.N    ??USART_GetFlagStatus_2
   1271            {
   1272              bitstatus = SET;
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0x0006             MOVS     R6,R0
   \   00000078   0xE001             B.N      ??USART_GetFlagStatus_3
   1273            }
   1274            else
   1275            {
   1276              bitstatus = RESET;
   \                     ??USART_GetFlagStatus_2: (+1)
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x0006             MOVS     R6,R0
   1277            }
   1278            return bitstatus;
   \                     ??USART_GetFlagStatus_3: (+1)
   \   0000007E   0x0030             MOVS     R0,R6
   \   00000080   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000082   0xBD70             POP      {R4-R6,PC}       ;; return
   1279          }
   1280          
   1281          /**
   1282            * @brief  Clears the USARTx's pending flags.
   1283            * @param  USARTx: Select the USART peripheral. 
   1284            *   This parameter can be one of the following values:
   1285            *   USART1, USART2 or USART3.
   1286            * @param  USART_FLAG: specifies the flag to clear.
   1287            *   This parameter can be any combination of the following values:
   1288            *     @arg USART_FLAG_CTS:  CTS Change flag.
   1289            *     @arg USART_FLAG_LBD:  LIN Break detection flag.
   1290            *     @arg USART_FLAG_TC:   Transmission Complete flag.
   1291            *     @arg USART_FLAG_RXNE: Receive data register not empty flag.
   1292            *   
   1293            * @note
   1294            *   - PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun 
   1295            *     error) and IDLE (Idle line detected) flags are cleared by software 
   1296            *     sequence: a read operation to USART_SR register (USART_GetFlagStatus()) 
   1297            *     followed by a read operation to USART_DR register (USART_ReceiveData()).
   1298            *   - RXNE flag can be also cleared by a read to the USART_DR register 
   1299            *     (USART_ReceiveData()).
   1300            *   - TC flag can be also cleared by software sequence: a read operation to 
   1301            *     USART_SR register (USART_GetFlagStatus()) followed by a write operation
   1302            *     to USART_DR register (USART_SendData()).
   1303            *   - TXE flag is cleared only by a write to the USART_DR register 
   1304            *     (USART_SendData()).
   1305            * @retval None
   1306            */

   \                                 In section .text, align 2, keep-with-next
   1307          void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)
   1308          {
   \                     USART_ClearFlag: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1309            /* Check the parameters */
   1310            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x....             LDR.N    R0,??DataTable26_1  ;; 0x40013800
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00A             BEQ.N    ??USART_ClearFlag_0
   \   0000000C   0x....             LDR.N    R0,??DataTable26_2  ;; 0x40004400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD007             BEQ.N    ??USART_ClearFlag_0
   \   00000012   0x....             LDR.N    R0,??DataTable24  ;; 0x40004800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD004             BEQ.N    ??USART_ClearFlag_0
   \   00000018   0xF240 0x511E      MOVW     R1,#+1310
   \   0000001C   0x....             LDR.N    R0,??DataTable26_3
   \   0000001E   0x.... 0x....      BL       assert_failed
   1311            assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
   \                     ??USART_ClearFlag_0: (+1)
   \   00000022   0xF64F 0x409F      MOVW     R0,#+64671
   \   00000026   0x4205             TST      R5,R0
   \   00000028   0xD102             BNE.N    ??USART_ClearFlag_1
   \   0000002A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002C   0x2D00             CMP      R5,#+0
   \   0000002E   0xD104             BNE.N    ??USART_ClearFlag_2
   \                     ??USART_ClearFlag_1: (+1)
   \   00000030   0xF240 0x511F      MOVW     R1,#+1311
   \   00000034   0x....             LDR.N    R0,??DataTable26_3
   \   00000036   0x.... 0x....      BL       assert_failed
   1312               
   1313            USARTx->SR = (uint16_t)~USART_FLAG;
   \                     ??USART_ClearFlag_2: (+1)
   \   0000003A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000003C   0x43E8             MVNS     R0,R5
   \   0000003E   0x8020             STRH     R0,[R4, #+0]
   1314          }
   \   00000040   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1315          
   1316          /**
   1317            * @brief  Checks whether the specified USART interrupt has occurred or not.
   1318            * @param  USARTx: Select the USART peripheral. 
   1319            *   This parameter can be one of the following values:
   1320            *   USART1, USART2 or USART3.
   1321            * @param  USART_IT: specifies the USART interrupt source to check.
   1322            *   This parameter can be one of the following values:
   1323            *     @arg USART_IT_CTS:  CTS change interrupt
   1324            *     @arg USART_IT_LBD:  LIN Break detection interrupt
   1325            *     @arg USART_IT_TXE:  Tansmit Data Register empty interrupt
   1326            *     @arg USART_IT_TC:   Transmission complete interrupt
   1327            *     @arg USART_IT_RXNE: Receive Data register not empty interrupt
   1328            *     @arg USART_IT_IDLE: Idle line detection interrupt
   1329            *     @arg USART_IT_ORE:  OverRun Error interrupt
   1330            *     @arg USART_IT_NE:   Noise Error interrupt
   1331            *     @arg USART_IT_FE:   Framing Error interrupt
   1332            *     @arg USART_IT_PE:   Parity Error interrupt
   1333            * @retval The new state of USART_IT (SET or RESET).
   1334            */

   \                                 In section .text, align 2, keep-with-next
   1335          ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
   1336          {
   \                     USART_GetITStatus: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1337            uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
   \   00000008   0x2600             MOVS     R6,#+0
   \   0000000A   0x2700             MOVS     R7,#+0
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   1338            ITStatus bitstatus = RESET;
   \   00000010   0xF05F 0x0900      MOVS     R9,#+0
   1339            /* Check the parameters */
   1340            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000014   0x....             LDR.N    R0,??DataTable26_1  ;; 0x40013800
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD00A             BEQ.N    ??USART_GetITStatus_0
   \   0000001A   0x....             LDR.N    R0,??DataTable26_2  ;; 0x40004400
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD007             BEQ.N    ??USART_GetITStatus_0
   \   00000020   0x....             LDR.N    R0,??DataTable26  ;; 0x40004800
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD004             BEQ.N    ??USART_GetITStatus_0
   \   00000026   0xF240 0x513C      MOVW     R1,#+1340
   \   0000002A   0x....             LDR.N    R0,??DataTable26_3
   \   0000002C   0x.... 0x....      BL       assert_failed
   1341            assert_param(IS_USART_GET_IT(USART_IT)); 
   \                     ??USART_GetITStatus_0: (+1)
   \   00000030   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000032   0x2D28             CMP      R5,#+40
   \   00000034   0xD02E             BEQ.N    ??USART_GetITStatus_1
   \   00000036   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000038   0xF240 0x7027      MOVW     R0,#+1831
   \   0000003C   0x4285             CMP      R5,R0
   \   0000003E   0xD029             BEQ.N    ??USART_GetITStatus_1
   \   00000040   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000042   0xF240 0x6026      MOVW     R0,#+1574
   \   00000046   0x4285             CMP      R5,R0
   \   00000048   0xD024             BEQ.N    ??USART_GetITStatus_1
   \   0000004A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004C   0xF240 0x5025      MOVW     R0,#+1317
   \   00000050   0x4285             CMP      R5,R0
   \   00000052   0xD01F             BEQ.N    ??USART_GetITStatus_1
   \   00000054   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000056   0xF240 0x4024      MOVW     R0,#+1060
   \   0000005A   0x4285             CMP      R5,R0
   \   0000005C   0xD01A             BEQ.N    ??USART_GetITStatus_1
   \   0000005E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000060   0xF640 0x0046      MOVW     R0,#+2118
   \   00000064   0x4285             CMP      R5,R0
   \   00000066   0xD015             BEQ.N    ??USART_GetITStatus_1
   \   00000068   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000006A   0xF640 0x106A      MOVW     R0,#+2410
   \   0000006E   0x4285             CMP      R5,R0
   \   00000070   0xD010             BEQ.N    ??USART_GetITStatus_1
   \   00000072   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000074   0xF5B5 0x7F58      CMP      R5,#+864
   \   00000078   0xD00C             BEQ.N    ??USART_GetITStatus_1
   \   0000007A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000007C   0xF5B5 0x7F18      CMP      R5,#+608
   \   00000080   0xD008             BEQ.N    ??USART_GetITStatus_1
   \   00000082   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000084   0xF5B5 0x7FB0      CMP      R5,#+352
   \   00000088   0xD004             BEQ.N    ??USART_GetITStatus_1
   \   0000008A   0xF240 0x513D      MOVW     R1,#+1341
   \   0000008E   0x....             LDR.N    R0,??DataTable26_3
   \   00000090   0x.... 0x....      BL       assert_failed
   1342            
   1343            /* Get the USART register index */
   1344            usartreg = (((uint8_t)USART_IT) >> 0x05);
   \                     ??USART_GetITStatus_1: (+1)
   \   00000094   0x0028             MOVS     R0,R5
   \   00000096   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000098   0x0940             LSRS     R0,R0,#+5
   \   0000009A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009C   0x4680             MOV      R8,R0
   1345            /* Get the interrupt position */
   1346            itmask = USART_IT & IT_MASK;
   \   0000009E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000A0   0xF015 0x001F      ANDS     R0,R5,#0x1F
   \   000000A4   0x0007             MOVS     R7,R0
   1347            itmask = (uint32_t)0x01 << itmask;
   \   000000A6   0x2001             MOVS     R0,#+1
   \   000000A8   0xFA10 0xF707      LSLS     R7,R0,R7
   1348            
   1349            if (usartreg == 0x01) /* The IT  is in CR1 register */
   \   000000AC   0xF1B8 0x0F01      CMP      R8,#+1
   \   000000B0   0xD102             BNE.N    ??USART_GetITStatus_2
   1350            {
   1351              itmask &= USARTx->CR1;
   \   000000B2   0x89A0             LDRH     R0,[R4, #+12]
   \   000000B4   0x4007             ANDS     R7,R0,R7
   \   000000B6   0xE007             B.N      ??USART_GetITStatus_3
   1352            }
   1353            else if (usartreg == 0x02) /* The IT  is in CR2 register */
   \                     ??USART_GetITStatus_2: (+1)
   \   000000B8   0xF1B8 0x0F02      CMP      R8,#+2
   \   000000BC   0xD102             BNE.N    ??USART_GetITStatus_4
   1354            {
   1355              itmask &= USARTx->CR2;
   \   000000BE   0x8A20             LDRH     R0,[R4, #+16]
   \   000000C0   0x4007             ANDS     R7,R0,R7
   \   000000C2   0xE001             B.N      ??USART_GetITStatus_3
   1356            }
   1357            else /* The IT  is in CR3 register */
   1358            {
   1359              itmask &= USARTx->CR3;
   \                     ??USART_GetITStatus_4: (+1)
   \   000000C4   0x8AA0             LDRH     R0,[R4, #+20]
   \   000000C6   0x4007             ANDS     R7,R0,R7
   1360            }
   1361            
   1362            bitpos = USART_IT >> 0x08;
   \                     ??USART_GetITStatus_3: (+1)
   \   000000C8   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000CA   0x0A28             LSRS     R0,R5,#+8
   \   000000CC   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000CE   0x0006             MOVS     R6,R0
   1363            bitpos = (uint32_t)0x01 << bitpos;
   \   000000D0   0x2001             MOVS     R0,#+1
   \   000000D2   0xFA10 0xF606      LSLS     R6,R0,R6
   1364            bitpos &= USARTx->SR;
   \   000000D6   0x8820             LDRH     R0,[R4, #+0]
   \   000000D8   0x4006             ANDS     R6,R0,R6
   1365            if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
   \   000000DA   0x2F00             CMP      R7,#+0
   \   000000DC   0xD004             BEQ.N    ??USART_GetITStatus_5
   \   000000DE   0x2E00             CMP      R6,#+0
   \   000000E0   0xD002             BEQ.N    ??USART_GetITStatus_5
   1366            {
   1367              bitstatus = SET;
   \   000000E2   0x2001             MOVS     R0,#+1
   \   000000E4   0x4681             MOV      R9,R0
   \   000000E6   0xE001             B.N      ??USART_GetITStatus_6
   1368            }
   1369            else
   1370            {
   1371              bitstatus = RESET;
   \                     ??USART_GetITStatus_5: (+1)
   \   000000E8   0x2000             MOVS     R0,#+0
   \   000000EA   0x4681             MOV      R9,R0
   1372            }
   1373            
   1374            return bitstatus;  
   \                     ??USART_GetITStatus_6: (+1)
   \   000000EC   0x4648             MOV      R0,R9
   \   000000EE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000F0   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1375          }
   1376          
   1377          /**
   1378            * @brief  Clears the USARTx’s interrupt pending bits.
   1379            * @param  USARTx: Select the USART peripheral. 
   1380            *   This parameter can be one of the following values:
   1381            *   USART1, USART2 or USART3.
   1382            * @param  USART_IT: specifies the interrupt pending bit to clear.
   1383            *   This parameter can be one of the following values:
   1384            *     @arg USART_IT_CTS:  CTS change interrupt
   1385            *     @arg USART_IT_LBD:  LIN Break detection interrupt
   1386            *     @arg USART_IT_TC:   Transmission complete interrupt. 
   1387            *     @arg USART_IT_RXNE: Receive Data register not empty interrupt.
   1388            *   
   1389            * @note
   1390            *   - PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun 
   1391            *     error) and IDLE (Idle line detected) pending bits are cleared by 
   1392            *     software sequence: a read operation to USART_SR register 
   1393            *     (USART_GetITStatus()) followed by a read operation to USART_DR register 
   1394            *     (USART_ReceiveData()).
   1395            *   - RXNE pending bit can be also cleared by a read to the USART_DR register 
   1396            *     (USART_ReceiveData()).
   1397            *   - TC pending bit can be also cleared by software sequence: a read 
   1398            *     operation to USART_SR register (USART_GetITStatus()) followed by a write 
   1399            *     operation to USART_DR register (USART_SendData()).
   1400            *   - TXE pending bit is cleared only by a write to the USART_DR register 
   1401            *     (USART_SendData()).
   1402            * @retval None
   1403            */

   \                                 In section .text, align 2, keep-with-next
   1404          void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
   1405          {
   \                     USART_ClearITPendingBit: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1406            uint16_t bitpos = 0x00, itmask = 0x00;
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0x2700             MOVS     R7,#+0
   1407            /* Check the parameters */
   1408            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   0000000A   0x....             LDR.N    R0,??DataTable26_1  ;; 0x40013800
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD00A             BEQ.N    ??USART_ClearITPendingBit_0
   \   00000010   0x....             LDR.N    R0,??DataTable26_2  ;; 0x40004400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD007             BEQ.N    ??USART_ClearITPendingBit_0
   \   00000016   0x....             LDR.N    R0,??DataTable26  ;; 0x40004800
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD004             BEQ.N    ??USART_ClearITPendingBit_0
   \   0000001C   0xF44F 0x61B0      MOV      R1,#+1408
   \   00000020   0x....             LDR.N    R0,??DataTable26_3
   \   00000022   0x.... 0x....      BL       assert_failed
   1409            assert_param(IS_USART_CLEAR_IT(USART_IT)); 
   \                     ??USART_ClearITPendingBit_0: (+1)
   \   00000026   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000028   0xF240 0x6026      MOVW     R0,#+1574
   \   0000002C   0x4285             CMP      R5,R0
   \   0000002E   0xD013             BEQ.N    ??USART_ClearITPendingBit_1
   \   00000030   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000032   0xF240 0x5025      MOVW     R0,#+1317
   \   00000036   0x4285             CMP      R5,R0
   \   00000038   0xD00E             BEQ.N    ??USART_ClearITPendingBit_1
   \   0000003A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000003C   0xF640 0x0046      MOVW     R0,#+2118
   \   00000040   0x4285             CMP      R5,R0
   \   00000042   0xD009             BEQ.N    ??USART_ClearITPendingBit_1
   \   00000044   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000046   0xF640 0x106A      MOVW     R0,#+2410
   \   0000004A   0x4285             CMP      R5,R0
   \   0000004C   0xD004             BEQ.N    ??USART_ClearITPendingBit_1
   \   0000004E   0xF240 0x5181      MOVW     R1,#+1409
   \   00000052   0x....             LDR.N    R0,??DataTable26_3
   \   00000054   0x.... 0x....      BL       assert_failed
   1410            
   1411            bitpos = USART_IT >> 0x08;
   \                     ??USART_ClearITPendingBit_1: (+1)
   \   00000058   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000005A   0x0A28             LSRS     R0,R5,#+8
   \   0000005C   0x0006             MOVS     R6,R0
   1412            itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
   \   0000005E   0x2001             MOVS     R0,#+1
   \   00000060   0x40B0             LSLS     R0,R0,R6
   \   00000062   0x0007             MOVS     R7,R0
   1413            USARTx->SR = (uint16_t)~itmask;
   \   00000064   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000066   0x43F8             MVNS     R0,R7
   \   00000068   0x8020             STRH     R0,[R4, #+0]
   1414          }
   \   0000006A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   0x40013800         DC32     0x40013800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_1:
   \   00000000   0x40004400         DC32     0x40004400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_2:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   0x40004800         DC32     0x40004800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_1:
   \   00000000   0x003D0901         DC32     0x3d0901

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \   00000000   0xFFFFE9F3         DC32     0xffffe9f3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \   00000000   0x40004800         DC32     0x40004800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_1:
   \   00000000   0x40013800         DC32     0x40013800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_2:
   \   00000000   0x40004400         DC32     0x40004400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_3:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x45 0x3A          DC8 45H, 3AH, 5CH, 41H, 43H, 51H, 5CH, 50H
   \              0x5C 0x41    
   \              0x43 0x51    
   \              0x5C 0x50    
   \   00000008   0x72 0x6F          DC8 72H, 6FH, 6AH, 5FH, 76H, 65H, 72H, 30H
   \              0x6A 0x5F    
   \              0x76 0x65    
   \              0x72 0x30    
   \   00000010   0x39 0x61          DC8 39H, 61H, 5FH, 31H, 35H, 31H, 30H, 32H
   \              0x5F 0x31    
   \              0x35 0x31    
   \              0x30 0x32    
   \   00000018   0x30 0x31          DC8 30H, 31H, 35H, 5CH, 42H, 61H, 73H, 65H
   \              0x35 0x5C    
   \              0x42 0x61    
   \              0x73 0x65    
   \   00000020   0x5F 0x30          DC8 5FH, 30H, 32H, 5CH, 32H, 30H, 31H, 33H
   \              0x32 0x5C    
   \              0x32 0x30    
   \              0x31 0x33    
   \   00000028   0x5F 0x31          DC8 5FH, 31H, 31H, 5FH, 32H, 35H, 5FH, 53H
   \              0x31 0x5F    
   \              0x32 0x35    
   \              0x5F 0x53    
   \   00000030   0x70 0x69          DC8 70H, 69H, 72H, 69H, 74H, 31H, 5FH, 45H
   \              0x72 0x69    
   \              0x74 0x31    
   \              0x5F 0x45    
   \   00000038   0x6C 0x65          DC8 6CH, 65H, 6BH, 74H, 72H, 6FH, 6CH, 75H
   \              0x6B 0x74    
   \              0x72 0x6F    
   \              0x6C 0x75    
   \   00000040   0x78 0x5C          DC8 78H, 5CH, 53H, 54H, 4DH, 33H, 32H, 4CH
   \              0x53 0x54    
   \              0x4D 0x33    
   \              0x32 0x4C    
   \   00000048   0x5C 0x53          DC8 5CH, 53H, 54H, 4DH, 33H, 32H, 4CH, 31H
   \              0x54 0x4D    
   \              0x33 0x32    
   \              0x4C 0x31    
   \   00000050   0x78 0x78          DC8 78H, 78H, 5FH, 53H, 74H, 64H, 50H, 65H
   \              0x5F 0x53    
   \              0x74 0x64    
   \              0x50 0x65    
   \   00000058   0x72 0x69          DC8 72H, 69H, 70H, 68H, 5FH, 4CH, 69H, 62H
   \              0x70 0x68    
   \              0x5F 0x4C    
   \              0x69 0x62    
   \   00000060   0x5C 0x53          DC8 5CH, 53H, 6FH, 75H, 72H, 63H, 65H, 5CH
   \              0x6F 0x75    
   \              0x72 0x63    
   \              0x65 0x5C    
   \   00000068   0x53 0x54          DC8 53H, 54H, 4DH, 33H, 32H, 4CH, 31H, 78H
   \              0x4D 0x33    
   \              0x32 0x4C    
   \              0x31 0x78    
   \   00000070   0x78 0x5F          DC8 78H, 5FH, 53H, 74H, 64H, 50H, 65H, 72H
   \              0x53 0x74    
   \              0x64 0x50    
   \              0x65 0x72    
   \   00000078   0x69 0x70          DC8 69H, 70H, 68H, 5FH, 44H, 72H, 69H, 76H
   \              0x68 0x5F    
   \              0x44 0x72    
   \              0x69 0x76    
   \   00000080   0x65 0x72          DC8 65H, 72H, 5CH, 73H, 72H, 63H, 5CH, 73H
   \              0x5C 0x73    
   \              0x72 0x63    
   \              0x5C 0x73    
   \   00000088   0x74 0x6D          DC8 74H, 6DH, 33H, 32H, 6CH, 31H, 78H, 78H
   \              0x33 0x32    
   \              0x6C 0x31    
   \              0x78 0x78    
   \   00000090   0x5F 0x75          DC8 5FH, 75H, 73H, 61H, 72H, 74H, 2EH, 63H
   \              0x73 0x61    
   \              0x72 0x74    
   \              0x2E 0x63    
   \   00000098   0x00               DC8 0
   \   00000099   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   1415          
   1416          /**
   1417            * @}
   1418            */
   1419          
   1420          /**
   1421            * @}
   1422            */
   1423          
   1424          /**
   1425            * @}
   1426            */
   1427          
   1428          /**
   1429            * @}
   1430            */
   1431          
   1432          /******************* (C) COPYRIGHT 2010 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   USART_ClearFlag
        16   -> assert_failed
      24   USART_ClearITPendingBit
        24   -> assert_failed
      16   USART_ClockInit
        16   -> assert_failed
       0   USART_ClockStructInit
      16   USART_Cmd
        16   -> assert_failed
      16   USART_DMACmd
        16   -> assert_failed
       8   USART_DeInit
         8   -> RCC_APB1PeriphResetCmd
         8   -> RCC_APB2PeriphResetCmd
         8   -> assert_failed
      16   USART_GetFlagStatus
        16   -> assert_failed
      32   USART_GetITStatus
        32   -> assert_failed
      16   USART_HalfDuplexCmd
        16   -> assert_failed
      32   USART_ITConfig
        32   -> assert_failed
      48   USART_Init
        48   -> RCC_GetClocksFreq
        48   -> assert_failed
      16   USART_IrDACmd
        16   -> assert_failed
      16   USART_IrDAConfig
        16   -> assert_failed
      16   USART_LINBreakDetectLengthConfig
        16   -> assert_failed
      16   USART_LINCmd
        16   -> assert_failed
      16   USART_OneBitMethodCmd
        16   -> assert_failed
      16   USART_OverSampling8Cmd
        16   -> assert_failed
       8   USART_ReceiveData
         8   -> assert_failed
      16   USART_ReceiverWakeUpCmd
        16   -> assert_failed
       8   USART_SendBreak
         8   -> assert_failed
      16   USART_SendData
        16   -> assert_failed
      16   USART_SetAddress
        16   -> assert_failed
      16   USART_SetGuardTime
        16   -> assert_failed
      16   USART_SetPrescaler
        16   -> assert_failed
      16   USART_SmartCardCmd
        16   -> assert_failed
      16   USART_SmartCardNACKCmd
        16   -> assert_failed
       0   USART_StructInit
      16   USART_WakeUpConfig
        16   -> assert_failed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_2
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable25
       4  ??DataTable26
       4  ??DataTable26_1
       4  ??DataTable26_2
       4  ??DataTable26_3
     156  ?_0
      66  USART_ClearFlag
     108  USART_ClearITPendingBit
     176  USART_ClockInit
      18  USART_ClockStructInit
      94  USART_Cmd
     104  USART_DMACmd
     128  USART_DeInit
     132  USART_GetFlagStatus
     244  USART_GetITStatus
      90  USART_HalfDuplexCmd
     244  USART_ITConfig
     432  USART_Init
      84  USART_IrDACmd
      74  USART_IrDAConfig
      84  USART_LINBreakDetectLengthConfig
      94  USART_LINCmd
      94  USART_OneBitMethodCmd
      92  USART_OverSampling8Cmd
      48  USART_ReceiveData
      94  USART_ReceiverWakeUpCmd
      50  USART_SendBreak
      70  USART_SendData
      80  USART_SetAddress
      54  USART_SetGuardTime
      60  USART_SetPrescaler
      86  USART_SmartCardCmd
      84  USART_SmartCardNACKCmd
      28  USART_StructInit
      86  USART_WakeUpConfig

 
   156 bytes in section .rodata
 3 138 bytes in section .text
 
 3 138 bytes of CODE  memory
   156 bytes of CONST memory

Errors: none
Warnings: none
