###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        20/Nov/2015  05:05:36
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\SDK_Eval_Util\Source\src\SPIRIT_SDK_Application.c
#    Command line =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\SDK_Eval_Util\Source\src\SPIRIT_SDK_Application.c
#        -D USE_STDPERIPH_DRIVER -D VECT_TAB_FLASH -D STM32L1XX_MD -D
#        IAR_ARM_CM3 -D USE_FULL_ASSERT -D SPIRIT_USE_FULL_ASSERT -D
#        USE_SYSTICK_DELAY -D SDK -lC
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\List\
#        -o
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\.\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\examples\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\runtime\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\SDK_Eval_STM32L\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\SPIRIT1_Library\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\SDK_Eval_Util\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\SDK_Virtual_Com\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32_USB-FS-Device_Lib\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\ACQ\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\CMSIS\Include\"
#    List file    =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\List\SPIRIT_SDK_Application.lst
#    Object file  =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\Obj\SPIRIT_SDK_Application.o
#
###############################################################################

E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\SDK_Eval_Util\Source\src\SPIRIT_SDK_Application.c
      1          /**
      2          * @file    SPIRIT_SDK_Application.c
      3          * @author  DiZiC Ltd.
      4          * @version V3.0.1
      5          * @date    August 10, 2013
      6          * @brief   Identification functions for SPIRIT DK.
      7          * @details
      8          *
      9          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     10          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     11          * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     12          * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     13          * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     14          * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     15          *
     16          * THIS SOURCE CODE IS PROTECTED BY A LICENSE.
     17          * FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED
     18          * IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
     19          *
     20          * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     21          */  
     22          
     23          
     24          /* Includes ------------------------------------------------------------------*/
     25          #include "SPIRIT_SDK_Application.h"
     26          #include "stm32l1xx.h"
     27          
     28          
     29          /**
     30          * @addtogroup SPIRIT_DK                   SPIRIT DK
     31          * @{
     32          */
     33          
     34          
     35          /**
     36          * @defgroup SDK_SPIRIT_MANAGEMENT              SDK SPIRIT Management
     37          * @{
     38          */
     39          
     40          
     41          /**
     42          * @brief This flag is used to synchronize the TIM3 ISR with the XtalMeasurement routine.
     43          */

   \                                 In section .bss, align 1
     44          static volatile FlagStatus s_xTIMChCompareModeRaised = RESET;
   \                     s_xTIMChCompareModeRaised:
   \   00000000                      DS8 1
     45          
     46          /**
     47          * @brief This flag is used to synchronize the TIM3 ISR with the XtalMeasurement routine.
     48          */

   \                                 In section .bss, align 1
     49          static uint8_t s_RfModuleBand = 0;
   \                     s_RfModuleBand:
   \   00000000                      DS8 1
     50          
     51          
     52          #define ENABLE_TCXO()           GPIO_SetBits(GPIOC,GPIO_Pin_2);
     53          
     54          
     55          /**
     56          * @brief A map that contains the SPIRIT version
     57          */

   \                                 In section .rodata, align 4
     58          const SpiritVersionMap xSpiritVersionMap[] =
   \                     xSpiritVersionMap:
   \   00000000   0x0104             DC16 260
   \   00000002   0x01 0x00          DC8 1, 0
   \   00000004   0x0103             DC16 259
   \   00000006   0x01 0x00          DC8 1, 0
   \   00000008   0x0130             DC16 304
   \   0000000A   0x02 0x00          DC8 2, 0
     59          {
     60            /* The Control Board frame handler functions */
     61            {CUT_2_1v4, SPIRIT_VERSION_2_1},
     62            {CUT_2_1v3, SPIRIT_VERSION_2_1},
     63            {CUT_3_0, SPIRIT_VERSION_3_0},
     64          };
     65          
     66          
     67          /**
     68          * @defgroup SDK_SPIRIT_MANAGEMENT_FUNCTIONS    SDK SPIRIT Management Functions
     69          * @{
     70          */
     71          
     72          /**
     73          * @defgroup IDENTIFICATION_FUNCTIONS      SDK SPIRIT Management Identification Functions
     74          * @{
     75          */
     76          
     77          
     78          /**
     79          * @brief This function handles TIM3 global interrupt
     80          * @param None.
     81          * @retval None.
     82          */

   \                                 In section .text, align 2, keep-with-next
     83          void TIM3_IRQHandler(void)
     84          {
   \                     TIM3_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     85            if(TIM_GetITStatus(TIM3, TIM_IT_CC4))
   \   00000002   0x2110             MOVS     R1,#+16
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable6  ;; 0x40000400
   \   00000008   0x.... 0x....      BL       TIM_GetITStatus
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD009             BEQ.N    ??TIM3_IRQHandler_0
     86            {
     87              /* Set the TIM3 Compare IRQ flag */
     88              s_xTIMChCompareModeRaised = SET;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable6_1
   \   00000016   0x7008             STRB     R0,[R1, #+0]
     89              
     90              TIM_ClearITPendingBit(TIM3, TIM_IT_CC4);
   \   00000018   0x2110             MOVS     R1,#+16
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable6  ;; 0x40000400
   \   0000001E   0x.... 0x....      BL       TIM_ClearITPendingBit
   \   00000022   0xE00F             B.N      ??TIM3_IRQHandler_1
     91              
     92            }
     93            else if(TIM_GetITStatus(TIM3, TIM_IT_CC2))
   \                     ??TIM3_IRQHandler_0: (+1)
   \   00000024   0x2104             MOVS     R1,#+4
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable6  ;; 0x40000400
   \   0000002A   0x.... 0x....      BL       TIM_GetITStatus
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD008             BEQ.N    ??TIM3_IRQHandler_1
     94            {
     95              /* Set the TIM3 Compare IRQ flag */
     96              s_xTIMChCompareModeRaised = SET;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable6_1
   \   00000038   0x7008             STRB     R0,[R1, #+0]
     97              
     98              TIM_ClearITPendingBit(TIM3, TIM_IT_CC2);
   \   0000003A   0x2104             MOVS     R1,#+4
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable6  ;; 0x40000400
   \   00000040   0x.... 0x....      BL       TIM_ClearITPendingBit
     99              
    100            }
    101          }
   \                     ??TIM3_IRQHandler_1: (+1)
   \   00000044   0xBD01             POP      {R0,PC}          ;; return
    102          
    103          /**
    104          * @brief This function handles TIM4 global interrupt
    105          * @param None.
    106          * @retval None.
    107          */

   \                                 In section .text, align 2, keep-with-next
    108          void TIM4_IRQHandler(void)
    109          {
   \                     TIM4_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    110            if(TIM_GetITStatus(TIM4, TIM_IT_CC4))
   \   00000002   0x2110             MOVS     R1,#+16
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable6_2  ;; 0x40000800
   \   00000008   0x.... 0x....      BL       TIM_GetITStatus
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD009             BEQ.N    ??TIM4_IRQHandler_0
    111            {
    112              /* Set the TIM4 Compare IRQ flag */
    113              s_xTIMChCompareModeRaised = SET;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable6_1
   \   00000016   0x7008             STRB     R0,[R1, #+0]
    114              
    115              TIM_ClearITPendingBit(TIM4, TIM_IT_CC4);
   \   00000018   0x2110             MOVS     R1,#+16
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable6_2  ;; 0x40000800
   \   0000001E   0x.... 0x....      BL       TIM_ClearITPendingBit
   \   00000022   0xE00F             B.N      ??TIM4_IRQHandler_1
    116              
    117            }
    118            else if(TIM_GetITStatus(TIM4, TIM_IT_CC2))
   \                     ??TIM4_IRQHandler_0: (+1)
   \   00000024   0x2104             MOVS     R1,#+4
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable6_2  ;; 0x40000800
   \   0000002A   0x.... 0x....      BL       TIM_GetITStatus
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD008             BEQ.N    ??TIM4_IRQHandler_1
    119            {
    120              /* Set the TIM4 Compare IRQ flag */
    121              s_xTIMChCompareModeRaised = SET;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable6_1
   \   00000038   0x7008             STRB     R0,[R1, #+0]
    122              
    123              TIM_ClearITPendingBit(TIM4, TIM_IT_CC2);
   \   0000003A   0x2104             MOVS     R1,#+4
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable6_2  ;; 0x40000800
   \   00000040   0x.... 0x....      BL       TIM_ClearITPendingBit
    124              
    125            }
    126          }
   \                     ??TIM4_IRQHandler_1: (+1)
   \   00000044   0xBD01             POP      {R0,PC}          ;; return
    127          
    128          /**
    129          * @brief  This function can be used to automatically measure the XTAL frequency making use of the
    130          *         Spirit clock output to pin and an STM32L timer in compare mode.
    131          * @param  None.
    132          * @retval None.
    133          */
    134          #define N_SAMPLES 20
    135          #define SETTLING_PERIODS 4
    136          #define A 0.4

   \                                 In section .text, align 2, keep-with-next
    137          uint32_t SpiritManagementComputeXtalFrequency(void)
    138          {   
   \                     SpiritManagementComputeXtalFrequency: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB08F             SUB      SP,SP,#+60
    139            GPIO_TypeDef *pGpioPeriph;
    140            TIM_TypeDef *pTimerPeriph;
    141            
    142            //*** DiZiC Demo
    143            //*** SPIRIT1 GPIO_0 connected to PB.05, pin 41. AF: TIM3_CH2
    144            pTimerPeriph=TIM3;
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable6  ;; 0x40000400
   \   0000000A   0x4683             MOV      R11,R0
    145            pGpioPeriph=GPIOB;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable6_3  ;; 0x40020400
   \   00000010   0x9006             STR      R0,[SP, #+24]
    146            /* TIM3 clock enable */
    147            RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
    148            /* GPIOB clock enable */
    149            RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0x.... 0x....      BL       RCC_AHBPeriphClockCmd
    150           
    151            
    152            //#warning It is more safe disable all the other interrupt source.
    153            /* MCU GPIO, NVIC and timer configuration structures */
    154            GPIO_InitTypeDef GPIO_InitStructure;
    155            NVIC_InitTypeDef NVIC_InitStructure;
    156            TIM_ICInitTypeDef  TIM_ICInitStructure;
    157            
    158            uint32_t lMeasuredXtalFrequency;
    159          
    160            
    161            /* Instance the variables used to compute the XTAL frequency */
    162            uint8_t CaptureNumber=0;
   \   00000022   0xF05F 0x0800      MOVS     R8,#+0
    163            uint16_t IC3ReadValue1=0,IC3ReadValue2=0,Capture=0;
   \   00000026   0x2400             MOVS     R4,#+0
   \   00000028   0x2500             MOVS     R5,#+0
   \   0000002A   0xF05F 0x0900      MOVS     R9,#+0
    164            volatile uint16_t cWtchdg = 0;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    165            uint32_t TIMFreq=0,lXoFreq=0;
   \   00000034   0xF05F 0x0A00      MOVS     R10,#+0
   \   00000038   0x2600             MOVS     R6,#+0
    166            float fXoFreqRounded;
    167            
    168            /* Alternate Function (AF): TIM3 channel 2 pin (PB.05) configuration */
    169            GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
   \   0000003A   0x2002             MOVS     R0,#+2
   \   0000003C   0xF88D 0x0020      STRB     R0,[SP, #+32]
    170            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_40MHz;
   \   00000040   0x2003             MOVS     R0,#+3
   \   00000042   0xF88D 0x0021      STRB     R0,[SP, #+33]
    171            GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xF88D 0x0022      STRB     R0,[SP, #+34]
    172            GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0xF88D 0x0023      STRB     R0,[SP, #+35]
    173            GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_5;
   \   00000052   0x2020             MOVS     R0,#+32
   \   00000054   0x9007             STR      R0,[SP, #+28]
    174            GPIO_Init(pGpioPeriph, &GPIO_InitStructure);
   \   00000056   0xA907             ADD      R1,SP,#+28
   \   00000058   0x9806             LDR      R0,[SP, #+24]
   \   0000005A   0x.... 0x....      BL       GPIO_Init
    175            GPIO_PinAFConfig(pGpioPeriph, GPIO_PinSource5, GPIO_AF_TIM3);
   \   0000005E   0x2202             MOVS     R2,#+2
   \   00000060   0x2105             MOVS     R1,#+5
   \   00000062   0x9806             LDR      R0,[SP, #+24]
   \   00000064   0x.... 0x....      BL       GPIO_PinAFConfig
    176            
    177            /* Configure the timer compare channel 2 */
    178            TIM_ICInitStructure.TIM_Channel     = TIM_Channel_2;
   \   00000068   0x2004             MOVS     R0,#+4
   \   0000006A   0xF8AD 0x0024      STRH     R0,[SP, #+36]
    179            /* Configure the timer IRQ to be raised on the rising fronts */
    180            TIM_ICInitStructure.TIM_ICPolarity  = TIM_ICPolarity_Rising;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0xF8AD 0x0026      STRH     R0,[SP, #+38]
    181            /* Input capture selection setting */
    182            TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0xF8AD 0x0028      STRH     R0,[SP, #+40]
    183            /* Input capture prescaler setting. Setting it to TIM_ICPSC_DIV8 makes the IRQ are raised every 8 rising fronts detected by hardware.  */
    184            TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV8;
   \   0000007A   0x200C             MOVS     R0,#+12
   \   0000007C   0xF8AD 0x002A      STRH     R0,[SP, #+42]
    185            /* Disable every kind of capture filter */
    186            TIM_ICInitStructure.TIM_ICFilter = 0x0;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xF8AD 0x002C      STRH     R0,[SP, #+44]
    187            
    188            /* Timer initialization */
    189            TIM_ICInit(pTimerPeriph, &TIM_ICInitStructure);
   \   00000086   0xA909             ADD      R1,SP,#+36
   \   00000088   0x4658             MOV      R0,R11
   \   0000008A   0x.... 0x....      BL       TIM_ICInit
    190            
    191            /* TIM enable counter */
    192            TIM_Cmd(pTimerPeriph, ENABLE);
   \   0000008E   0x2101             MOVS     R1,#+1
   \   00000090   0x4658             MOV      R0,R11
   \   00000092   0x.... 0x....      BL       TIM_Cmd
    193            
    194            /* Enable the CC2 Interrupt Request */
    195            TIM_ITConfig(pTimerPeriph, TIM_IT_CC2, ENABLE);
   \   00000096   0x2201             MOVS     R2,#+1
   \   00000098   0x2104             MOVS     R1,#+4
   \   0000009A   0x4658             MOV      R0,R11
   \   0000009C   0x.... 0x....      BL       TIM_ITConfig
    196            
    197            /* Enable the TIM4 global Interrupt */
    198            NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;
   \   000000A0   0x201D             MOVS     R0,#+29
   \   000000A2   0xF88D 0x0010      STRB     R0,[SP, #+16]
    199            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x0F;
   \   000000A6   0x200F             MOVS     R0,#+15
   \   000000A8   0xF88D 0x0011      STRB     R0,[SP, #+17]
    200            NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x0F;
   \   000000AC   0x200F             MOVS     R0,#+15
   \   000000AE   0xF88D 0x0012      STRB     R0,[SP, #+18]
    201            NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   000000B2   0x2001             MOVS     R0,#+1
   \   000000B4   0xF88D 0x0013      STRB     R0,[SP, #+19]
    202            NVIC_Init(&NVIC_InitStructure);
   \   000000B8   0xA804             ADD      R0,SP,#+16
   \   000000BA   0x.... 0x....      BL       NVIC_Init
    203            
    204            if(SpiritGeneralGetSpiritVersion() != SPIRIT_VERSION_2_0) {
   \   000000BE   0x.... 0x....      BL       SpiritGeneralGetSpiritVersion
   \   000000C2   0x2800             CMP      R0,#+0
   \   000000C4   0xD008             BEQ.N    ??SpiritManagementComputeXtalFrequency_0
    205              /* Disable the clock divider to measure the max frequency of the clock. */
    206              uint8_t tmp= 0x29; SpiritSpiWriteRegisters(0xB4, 1, &tmp);
   \   000000C6   0x2029             MOVS     R0,#+41
   \   000000C8   0xF88D 0x000B      STRB     R0,[SP, #+11]
   \   000000CC   0xF10D 0x020B      ADD      R2,SP,#+11
   \   000000D0   0x2101             MOVS     R1,#+1
   \   000000D2   0x20B4             MOVS     R0,#+180
   \   000000D4   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
    207            }
    208            
    209            /* Spirit1 side clock configuration */
    210            SpiritGpioClockOutputInit(&(ClockOutputInit){XO_RATIO_1_192, RCO_RATIO_1, EXTRA_CLOCK_CYCLES_0});
   \                     ??SpiritManagementComputeXtalFrequency_0: (+1)
   \   000000D8   0x.... 0x....      LDR.W    R0,??DataTable6_4
   \   000000DC   0x6800             LDR      R0,[R0, #+0]
   \   000000DE   0x900D             STR      R0,[SP, #+52]
   \   000000E0   0xA80D             ADD      R0,SP,#+52
   \   000000E2   0x.... 0x....      BL       SpiritGpioClockOutputInit
    211            
    212            /* Instance the structure used to configure the Spirit clock frequency to be divided by a 192 factor. */
    213            SpiritGpioInit(&(SGpioInit){SPIRIT_GPIO_0, SPIRIT_GPIO_MODE_DIGITAL_OUTPUT_LP, SPIRIT_GPIO_DIG_OUT_MCU_CLOCK});
   \   000000E6   0x.... 0x....      LDR.W    R0,??DataTable6_5
   \   000000EA   0x6800             LDR      R0,[R0, #+0]
   \   000000EC   0x900C             STR      R0,[SP, #+48]
   \   000000EE   0xA80C             ADD      R0,SP,#+48
   \   000000F0   0x.... 0x....      BL       SpiritGpioInit
    214            
    215            SpiritGpioClockOutput(S_ENABLE);
   \   000000F4   0x2001             MOVS     R0,#+1
   \   000000F6   0x.... 0x....      BL       SpiritGpioClockOutput
    216            
    217            /* measure the frequency and average it on N_SAMPLES. Moreover cycle to wait for same SETTLING_PERIODS */
    218            for(uint32_t i=0;i<2*(N_SAMPLES+SETTLING_PERIODS);i++) {
   \   000000FA   0x2700             MOVS     R7,#+0
   \                     ??SpiritManagementComputeXtalFrequency_1: (+1)
   \   000000FC   0x2F30             CMP      R7,#+48
   \   000000FE   0xD26A             BCS.N    ??SpiritManagementComputeXtalFrequency_2
    219              /* block the routine until the TIM CCP2 IRQ is raised */
    220              while(!s_xTIMChCompareModeRaised && (cWtchdg!=0xFFFF)) {
   \                     ??SpiritManagementComputeXtalFrequency_3: (+1)
   \   00000100   0x.... 0x....      LDR.W    R0,??DataTable6_1
   \   00000104   0x7800             LDRB     R0,[R0, #+0]
   \   00000106   0x2800             CMP      R0,#+0
   \   00000108   0xD10B             BNE.N    ??SpiritManagementComputeXtalFrequency_4
   \   0000010A   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   0000010E   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000112   0x4288             CMP      R0,R1
   \   00000114   0xD005             BEQ.N    ??SpiritManagementComputeXtalFrequency_4
    221                cWtchdg++;    
   \   00000116   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   0000011A   0x1C40             ADDS     R0,R0,#+1
   \   0000011C   0xF8AD 0x0008      STRH     R0,[SP, #+8]
   \   00000120   0xE7EE             B.N      ??SpiritManagementComputeXtalFrequency_3
    222              }
    223              
    224              if(cWtchdg==0xFFFF) {
   \                     ??SpiritManagementComputeXtalFrequency_4: (+1)
   \   00000122   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   00000126   0xF64F 0x71FF      MOVW     R1,#+65535
   \   0000012A   0x4288             CMP      R0,R1
   \   0000012C   0xD053             BEQ.N    ??SpiritManagementComputeXtalFrequency_2
    225                break;
    226              }
    227              else {
    228                cWtchdg=0;
   \                     ??SpiritManagementComputeXtalFrequency_5: (+1)
   \   0000012E   0x2000             MOVS     R0,#+0
   \   00000130   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    229              }
    230              
    231              /* reset the IRQ raised flag */
    232              s_xTIMChCompareModeRaised = RESET;
   \   00000134   0x2000             MOVS     R0,#+0
   \   00000136   0x.... 0x....      LDR.W    R1,??DataTable6_1
   \   0000013A   0x7008             STRB     R0,[R1, #+0]
    233              
    234              /* if the SETTLING PERIODS expired */
    235              if(i>=SETTLING_PERIODS*2) {
   \   0000013C   0x2F08             CMP      R7,#+8
   \   0000013E   0xD348             BCC.N    ??SpiritManagementComputeXtalFrequency_6
    236                /* First TIMER capture */
    237                if(CaptureNumber == 0)
   \   00000140   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000144   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000148   0xD106             BNE.N    ??SpiritManagementComputeXtalFrequency_7
    238                {
    239                  /* Get the Input Capture value */
    240                  IC3ReadValue1 = TIM_GetCapture2(pTimerPeriph);
   \   0000014A   0x4658             MOV      R0,R11
   \   0000014C   0x.... 0x....      BL       TIM_GetCapture2
   \   00000150   0x0004             MOVS     R4,R0
    241                  CaptureNumber = 1;
   \   00000152   0x2001             MOVS     R0,#+1
   \   00000154   0x4680             MOV      R8,R0
   \   00000156   0xE03C             B.N      ??SpiritManagementComputeXtalFrequency_6
    242                }
    243                /* Second TIMER capture */
    244                else if(CaptureNumber == 1)
   \                     ??SpiritManagementComputeXtalFrequency_7: (+1)
   \   00000158   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000015C   0xF1B8 0x0F01      CMP      R8,#+1
   \   00000160   0xD137             BNE.N    ??SpiritManagementComputeXtalFrequency_6
    245                {
    246                  /* Get the Input Capture value */
    247                  IC3ReadValue2 = TIM_GetCapture2(pTimerPeriph);
   \   00000162   0x4658             MOV      R0,R11
   \   00000164   0x.... 0x....      BL       TIM_GetCapture2
   \   00000168   0x0005             MOVS     R5,R0
    248                  
    249                  /* Capture computation */
    250                  if (IC3ReadValue2 > IC3ReadValue1)
   \   0000016A   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000016C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000016E   0x42AC             CMP      R4,R5
   \   00000170   0xD203             BCS.N    ??SpiritManagementComputeXtalFrequency_8
    251                  {
    252                    /* If the TIMER didn't overflow between the first and the second capture. Compute it as the difference between the second and the first capture values. */
    253                    Capture = (IC3ReadValue2 - IC3ReadValue1) - 1;
   \   00000172   0x1B28             SUBS     R0,R5,R4
   \   00000174   0x1E40             SUBS     R0,R0,#+1
   \   00000176   0x4681             MOV      R9,R0
   \   00000178   0xE002             B.N      ??SpiritManagementComputeXtalFrequency_9
    254                  }
    255                  else
    256                  {
    257                    /* .. else, if overflowed 'roll' the first measure to be complementar of 0xFFFF */
    258                    Capture = ((0xFFFF - IC3ReadValue1) + IC3ReadValue2) - 1;
   \                     ??SpiritManagementComputeXtalFrequency_8: (+1)
   \   0000017A   0x1B28             SUBS     R0,R5,R4
   \   0000017C   0x1E80             SUBS     R0,R0,#+2
   \   0000017E   0x4681             MOV      R9,R0
    259                  }
    260                  
    261                  /* Punctual frequency computation */
    262                  TIMFreq = (uint32_t) SystemCoreClock / Capture;
   \                     ??SpiritManagementComputeXtalFrequency_9: (+1)
   \   00000180   0x.... 0x....      LDR.W    R0,??DataTable6_6
   \   00000184   0x6800             LDR      R0,[R0, #+0]
   \   00000186   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000018A   0xFBB0 0xF0F9      UDIV     R0,R0,R9
   \   0000018E   0x4682             MOV      R10,R0
    263                  
    264                  /* Averaged frequency computation */
    265                  lXoFreq =(uint32_t)(A*(float)lXoFreq+(1.0-A)*(float)TIMFreq);
   \   00000190   0x0030             MOVS     R0,R6
   \   00000192   0x.... 0x....      BL       __aeabi_ui2f
   \   00000196   0x.... 0x....      BL       __aeabi_f2d
   \   0000019A   0x.... 0x....      LDR.W    R2,??DataTable6_7  ;; 0x9999999a
   \   0000019E   0x.... 0x....      LDR.W    R3,??DataTable6_8  ;; 0x3fd99999
   \   000001A2   0x.... 0x....      BL       __aeabi_dmul
   \   000001A6   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \   000001AA   0x4650             MOV      R0,R10
   \   000001AC   0x.... 0x....      BL       __aeabi_ui2f
   \   000001B0   0x.... 0x....      BL       __aeabi_f2d
   \   000001B4   0xF05F 0x3233      MOVS     R2,#+858993459
   \   000001B8   0x.... 0x....      LDR.W    R3,??DataTable6_9  ;; 0x3fe33333
   \   000001BC   0x.... 0x....      BL       __aeabi_dmul
   \   000001C0   0xE9DD 0x2300      LDRD     R2,R3,[SP, #+0]
   \   000001C4   0x.... 0x....      BL       __aeabi_dadd
   \   000001C8   0x.... 0x....      BL       __aeabi_d2uiz
   \   000001CC   0x0006             MOVS     R6,R0
    266                  
    267                  CaptureNumber = 0;
   \   000001CE   0x2000             MOVS     R0,#+0
   \   000001D0   0x4680             MOV      R8,R0
    268                }
    269              }
    270            }
   \                     ??SpiritManagementComputeXtalFrequency_6: (+1)
   \   000001D2   0x1C7F             ADDS     R7,R7,#+1
   \   000001D4   0xE792             B.N      ??SpiritManagementComputeXtalFrequency_1
    271            
    272            /* Compute the real frequency in Hertz tanking in account the MCU and Spirit divisions */
    273            lXoFreq *=(192*8);
   \                     ??SpiritManagementComputeXtalFrequency_2: (+1)
   \   000001D6   0xF44F 0x60C0      MOV      R0,#+1536
   \   000001DA   0x4346             MULS     R6,R0,R6
    274            
    275            /* Disable the output clock */
    276            SpiritGpioClockOutput(S_DISABLE);
   \   000001DC   0x2000             MOVS     R0,#+0
   \   000001DE   0x.... 0x....      BL       SpiritGpioClockOutput
    277            
    278            /* TIM enable counter */
    279            TIM_Cmd(pTimerPeriph, DISABLE);
   \   000001E2   0x2100             MOVS     R1,#+0
   \   000001E4   0x4658             MOV      R0,R11
   \   000001E6   0x.... 0x....      BL       TIM_Cmd
    280            
    281            /* Enable the CC2 Interrupt Request */
    282            TIM_ITConfig(pTimerPeriph, TIM_IT_CC2, DISABLE);
   \   000001EA   0x2200             MOVS     R2,#+0
   \   000001EC   0x2104             MOVS     R1,#+4
   \   000001EE   0x4658             MOV      R0,R11
   \   000001F0   0x.... 0x....      BL       TIM_ITConfig
    283            
    284            /* SPIRIT GPIO 0 to the default configuration */
    285            SpiritGpioSetLevel(SPIRIT_GPIO_0, LOW);
   \   000001F4   0x2100             MOVS     R1,#+0
   \   000001F6   0x2005             MOVS     R0,#+5
   \   000001F8   0x.... 0x....      BL       SpiritGpioSetLevel
    286            
    287            if(SpiritGeneralGetSpiritVersion() != SPIRIT_VERSION_2_0)
   \   000001FC   0x.... 0x....      BL       SpiritGeneralGetSpiritVersion
   \   00000200   0x2800             CMP      R0,#+0
   \   00000202   0xD008             BEQ.N    ??SpiritManagementComputeXtalFrequency_10
    288            {
    289              uint8_t tmp= 0x21; SpiritSpiWriteRegisters(0xB4, 1, &tmp);
   \   00000204   0x2021             MOVS     R0,#+33
   \   00000206   0xF88D 0x000A      STRB     R0,[SP, #+10]
   \   0000020A   0xF10D 0x020A      ADD      R2,SP,#+10
   \   0000020E   0x2101             MOVS     R1,#+1
   \   00000210   0x20B4             MOVS     R0,#+180
   \   00000212   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
    290            }
    291            
    292            /* Round the measured frequency to be measured as an integer MHz value */
    293            fXoFreqRounded = (float)lXoFreq/1e6;
   \                     ??SpiritManagementComputeXtalFrequency_10: (+1)
   \   00000216   0x0030             MOVS     R0,R6
   \   00000218   0x.... 0x....      BL       __aeabi_ui2f
   \   0000021C   0x.... 0x....      BL       __aeabi_f2d
   \   00000220   0x2200             MOVS     R2,#+0
   \   00000222   0x....             LDR.N    R3,??DataTable6_10  ;; 0x412e8480
   \   00000224   0x.... 0x....      BL       __aeabi_ddiv
   \   00000228   0x.... 0x....      BL       __aeabi_d2f
   \   0000022C   0x9003             STR      R0,[SP, #+12]
    294            
    295            if( fXoFreqRounded-(float)((uint32_t)fXoFreqRounded)>0.5)
   \   0000022E   0x9803             LDR      R0,[SP, #+12]
   \   00000230   0x.... 0x....      BL       __aeabi_f2uiz
   \   00000234   0x.... 0x....      BL       __aeabi_ui2f
   \   00000238   0x0001             MOVS     R1,R0
   \   0000023A   0x9803             LDR      R0,[SP, #+12]
   \   0000023C   0x.... 0x....      BL       __aeabi_fsub
   \   00000240   0x....             LDR.N    R1,??DataTable6_11  ;; 0x3f000001
   \   00000242   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000246   0xD807             BHI.N    ??SpiritManagementComputeXtalFrequency_11
    296            {
    297              lMeasuredXtalFrequency = (((uint32_t)fXoFreqRounded+1)*1000000);
   \   00000248   0x9803             LDR      R0,[SP, #+12]
   \   0000024A   0x.... 0x....      BL       __aeabi_f2uiz
   \   0000024E   0x1C40             ADDS     R0,R0,#+1
   \   00000250   0x....             LDR.N    R1,??DataTable6_12  ;; 0xf4240
   \   00000252   0x4348             MULS     R0,R1,R0
   \   00000254   0x9005             STR      R0,[SP, #+20]
   \   00000256   0xE005             B.N      ??SpiritManagementComputeXtalFrequency_12
    298            }
    299            else
    300            {
    301              lMeasuredXtalFrequency = (((uint32_t)fXoFreqRounded)*1000000);
   \                     ??SpiritManagementComputeXtalFrequency_11: (+1)
   \   00000258   0x9803             LDR      R0,[SP, #+12]
   \   0000025A   0x.... 0x....      BL       __aeabi_f2uiz
   \   0000025E   0x....             LDR.N    R1,??DataTable6_12  ;; 0xf4240
   \   00000260   0x4348             MULS     R0,R1,R0
   \   00000262   0x9005             STR      R0,[SP, #+20]
    302            }
    303            
    304            SdkEvalM2SGpioInit(M2S_GPIO_0, M2S_MODE_GPIO_IN);
   \                     ??SpiritManagementComputeXtalFrequency_12: (+1)
   \   00000264   0x2100             MOVS     R1,#+0
   \   00000266   0x2000             MOVS     R0,#+0
   \   00000268   0x.... 0x....      BL       SdkEvalM2SGpioInit
    305            
    306            SpiritRadioSetXtalFrequency(lMeasuredXtalFrequency);
   \   0000026C   0x9805             LDR      R0,[SP, #+20]
   \   0000026E   0x.... 0x....      BL       SpiritRadioSetXtalFrequency
    307            
    308            return lMeasuredXtalFrequency;
   \   00000272   0x9805             LDR      R0,[SP, #+20]
   \   00000274   0xB00F             ADD      SP,SP,#+60
   \   00000276   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    309          }
    310          
    311          /* This function is used to detect the pa ext board, due to the unworking measurement algorithm */
    312          //*** DiZiC
    313          //*** uint32_t SpiritManagementComputeXtalFrequencyGpio2(void)

   \                                 In section .text, align 2, keep-with-next
    314           uint32_t SpiritManagementComputeXtalFrequencyGpio0(void)
    315          {
   \                     SpiritManagementComputeXtalFrequencyGpio0: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB08F             SUB      SP,SP,#+60
    316            
    317            GPIO_TypeDef *pGpioPeriph;
    318            TIM_TypeDef *pTimerPeriph;
    319            
    320           
    321              //*** DiZiC Demo. SPIRIT1 GPIO_0 connected to = PB.05, AF: TIM3_CH2, pin 41
    322              pTimerPeriph=TIM3;
   \   00000006   0x....             LDR.N    R0,??DataTable6  ;; 0x40000400
   \   00000008   0x4683             MOV      R11,R0
    323              pGpioPeriph=GPIOB;
   \   0000000A   0x....             LDR.N    R0,??DataTable6_3  ;; 0x40020400
   \   0000000C   0x9006             STR      R0,[SP, #+24]
    324              /* TIM2 clock enable */
    325              RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
    326              /* GPIOB clock enable */
    327              RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0x.... 0x....      BL       RCC_AHBPeriphClockCmd
    328           
    329              
    330            /* MCU GPIO, NVIC and timer configuration structures */
    331            GPIO_InitTypeDef GPIO_InitStructure;
    332            NVIC_InitTypeDef NVIC_InitStructure;
    333            TIM_ICInitTypeDef  TIM_ICInitStructure;
    334            
    335            uint32_t lMeasuredXtalFrequency;
    336            
    337            /* Instance the variables used to compute the XTAL frequency */
    338            uint8_t CaptureNumber=0;
   \   0000001E   0xF05F 0x0800      MOVS     R8,#+0
    339            uint16_t IC3ReadValue1=0,IC3ReadValue2=0,Capture=0;
   \   00000022   0x2400             MOVS     R4,#+0
   \   00000024   0x2500             MOVS     R5,#+0
   \   00000026   0xF05F 0x0900      MOVS     R9,#+0
    340            volatile uint16_t cWtchdg = 0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    341            uint32_t TIM3Freq=0,lXoFreq=0;
   \   00000030   0xF05F 0x0A00      MOVS     R10,#+0
   \   00000034   0x2600             MOVS     R6,#+0
    342            float fXoFreqRounded;
    343            
    344            
    345            /* TIM3 channel #2 pin (AF of PB.05) configuration */
    346            GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
   \   00000036   0x2002             MOVS     R0,#+2
   \   00000038   0xF88D 0x0020      STRB     R0,[SP, #+32]
    347            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_40MHz;
   \   0000003C   0x2003             MOVS     R0,#+3
   \   0000003E   0xF88D 0x0021      STRB     R0,[SP, #+33]
    348            GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xF88D 0x0022      STRB     R0,[SP, #+34]
    349            GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0xF88D 0x0023      STRB     R0,[SP, #+35]
    350            GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_5;
   \   0000004E   0x2020             MOVS     R0,#+32
   \   00000050   0x9007             STR      R0,[SP, #+28]
    351            GPIO_Init(pGpioPeriph, &GPIO_InitStructure);
   \   00000052   0xA907             ADD      R1,SP,#+28
   \   00000054   0x9806             LDR      R0,[SP, #+24]
   \   00000056   0x.... 0x....      BL       GPIO_Init
    352            GPIO_PinAFConfig(pGpioPeriph, GPIO_PinSource5, GPIO_AF_TIM3);
   \   0000005A   0x2202             MOVS     R2,#+2
   \   0000005C   0x2105             MOVS     R1,#+5
   \   0000005E   0x9806             LDR      R0,[SP, #+24]
   \   00000060   0x.... 0x....      BL       GPIO_PinAFConfig
    353            
    354            /* Configure the timer TIM3 compare channel 2 */
    355            TIM_ICInitStructure.TIM_Channel     = TIM_Channel_2;
   \   00000064   0x2004             MOVS     R0,#+4
   \   00000066   0xF8AD 0x0024      STRH     R0,[SP, #+36]
    356            /* Configure the timer IRQ to be raised on the rising fronts */
    357            TIM_ICInitStructure.TIM_ICPolarity  = TIM_ICPolarity_Rising;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xF8AD 0x0026      STRH     R0,[SP, #+38]
    358            /* Input capture selection setting */
    359            TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;
   \   00000070   0x2001             MOVS     R0,#+1
   \   00000072   0xF8AD 0x0028      STRH     R0,[SP, #+40]
    360            /* Input capture prescaler setting. Setting it to TIM_ICPSC_DIV8 makes the IRQ are raised every 8 rising fronts detected by hardware.  */
    361            TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV8;
   \   00000076   0x200C             MOVS     R0,#+12
   \   00000078   0xF8AD 0x002A      STRH     R0,[SP, #+42]
    362            /* Disable every kind of capture filter */
    363            TIM_ICInitStructure.TIM_ICFilter = 0x0;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0xF8AD 0x002C      STRH     R0,[SP, #+44]
    364            
    365            /* Timer initialization */
    366            TIM_ICInit(pTimerPeriph, &TIM_ICInitStructure);
   \   00000082   0xA909             ADD      R1,SP,#+36
   \   00000084   0x4658             MOV      R0,R11
   \   00000086   0x.... 0x....      BL       TIM_ICInit
    367            
    368            /* TIM enable counter */
    369            TIM_Cmd(pTimerPeriph, ENABLE);
   \   0000008A   0x2101             MOVS     R1,#+1
   \   0000008C   0x4658             MOV      R0,R11
   \   0000008E   0x.... 0x....      BL       TIM_Cmd
    370            
    371            /* Enable the CC4 Interrupt Request */
    372            //*** TIM_ITConfig(pTimerPeriph, TIM_IT_CC4, ENABLE);
    373              /* Enable the CC2 Interrupt Request */
    374            TIM_ITConfig(pTimerPeriph, TIM_IT_CC2, ENABLE); //***
   \   00000092   0x2201             MOVS     R2,#+1
   \   00000094   0x2104             MOVS     R1,#+4
   \   00000096   0x4658             MOV      R0,R11
   \   00000098   0x.... 0x....      BL       TIM_ITConfig
    375            
    376            /* Enable the TIM3 global Interrupt */
    377            NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;
   \   0000009C   0x201D             MOVS     R0,#+29
   \   0000009E   0xF88D 0x0010      STRB     R0,[SP, #+16]
    378            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x0F;
   \   000000A2   0x200F             MOVS     R0,#+15
   \   000000A4   0xF88D 0x0011      STRB     R0,[SP, #+17]
    379            NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x0F;
   \   000000A8   0x200F             MOVS     R0,#+15
   \   000000AA   0xF88D 0x0012      STRB     R0,[SP, #+18]
    380            NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   000000AE   0x2001             MOVS     R0,#+1
   \   000000B0   0xF88D 0x0013      STRB     R0,[SP, #+19]
    381            NVIC_Init(&NVIC_InitStructure);
   \   000000B4   0xA804             ADD      R0,SP,#+16
   \   000000B6   0x.... 0x....      BL       NVIC_Init
    382          
    383            /* Spirit1 side clock configuration */
    384            SpiritGpioClockOutputInit(&(ClockOutputInit){XO_RATIO_1_192, RCO_RATIO_1, EXTRA_CLOCK_CYCLES_0});
   \   000000BA   0x....             LDR.N    R0,??DataTable6_13
   \   000000BC   0x6800             LDR      R0,[R0, #+0]
   \   000000BE   0x900D             STR      R0,[SP, #+52]
   \   000000C0   0xA80D             ADD      R0,SP,#+52
   \   000000C2   0x.... 0x....      BL       SpiritGpioClockOutputInit
    385            
    386            /* Instance the structure used to configure the Spirit clock frequency to be divided by a 192 factor. */
    387            SpiritGpioInit(&(SGpioInit){SPIRIT_GPIO_0, SPIRIT_GPIO_MODE_DIGITAL_OUTPUT_LP, SPIRIT_GPIO_DIG_OUT_MCU_CLOCK});
   \   000000C6   0x....             LDR.N    R0,??DataTable6_14
   \   000000C8   0x6800             LDR      R0,[R0, #+0]
   \   000000CA   0x900C             STR      R0,[SP, #+48]
   \   000000CC   0xA80C             ADD      R0,SP,#+48
   \   000000CE   0x.... 0x....      BL       SpiritGpioInit
    388            SpiritGpioClockOutput(S_ENABLE);
   \   000000D2   0x2001             MOVS     R0,#+1
   \   000000D4   0x.... 0x....      BL       SpiritGpioClockOutput
    389            
    390            /* measure the frequency and average it on N_SAMPLES. Moreover cycle to wait for same SETTLING_PERIODS */
    391            for(uint32_t i=0;i<2*(N_SAMPLES+SETTLING_PERIODS);i++)
   \   000000D8   0x2700             MOVS     R7,#+0
   \                     ??SpiritManagementComputeXtalFrequencyGpio0_0: (+1)
   \   000000DA   0x2F30             CMP      R7,#+48
   \   000000DC   0xD264             BCS.N    ??SpiritManagementComputeXtalFrequencyGpio0_1
    392            {
    393              /* block the routine until the TIM3 CCP2 IRQ is raised */
    394              while(!s_xTIMChCompareModeRaised && (cWtchdg!=0xFFFF))
   \                     ??SpiritManagementComputeXtalFrequencyGpio0_2: (+1)
   \   000000DE   0x....             LDR.N    R0,??DataTable6_1
   \   000000E0   0x7800             LDRB     R0,[R0, #+0]
   \   000000E2   0x2800             CMP      R0,#+0
   \   000000E4   0xD10B             BNE.N    ??SpiritManagementComputeXtalFrequencyGpio0_3
   \   000000E6   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   000000EA   0xF64F 0x71FF      MOVW     R1,#+65535
   \   000000EE   0x4288             CMP      R0,R1
   \   000000F0   0xD005             BEQ.N    ??SpiritManagementComputeXtalFrequencyGpio0_3
    395                cWtchdg++;    
   \   000000F2   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   000000F6   0x1C40             ADDS     R0,R0,#+1
   \   000000F8   0xF8AD 0x0008      STRH     R0,[SP, #+8]
   \   000000FC   0xE7EF             B.N      ??SpiritManagementComputeXtalFrequencyGpio0_2
    396              
    397              if(cWtchdg==0xFFFF)
   \                     ??SpiritManagementComputeXtalFrequencyGpio0_3: (+1)
   \   000000FE   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   00000102   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000106   0x4288             CMP      R0,R1
   \   00000108   0xD04E             BEQ.N    ??SpiritManagementComputeXtalFrequencyGpio0_1
    398                break;
    399              else
    400                cWtchdg=0;
   \                     ??SpiritManagementComputeXtalFrequencyGpio0_4: (+1)
   \   0000010A   0x2000             MOVS     R0,#+0
   \   0000010C   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    401              
    402              /* reset the IRQ raised flag */
    403              s_xTIMChCompareModeRaised = RESET;
   \   00000110   0x2000             MOVS     R0,#+0
   \   00000112   0x....             LDR.N    R1,??DataTable6_1
   \   00000114   0x7008             STRB     R0,[R1, #+0]
    404              
    405              /* if the SETTLING PERIODS expired */
    406              if(i>=SETTLING_PERIODS*2)
   \   00000116   0x2F08             CMP      R7,#+8
   \   00000118   0xD344             BCC.N    ??SpiritManagementComputeXtalFrequencyGpio0_5
    407              {
    408                /* First TIMER3 capture */
    409                if(CaptureNumber == 0)
   \   0000011A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000011E   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000122   0xD106             BNE.N    ??SpiritManagementComputeXtalFrequencyGpio0_6
    410                {
    411                  /* Get the Input Capture value */
    412          //***        IC3ReadValue1 = TIM_GetCapture4(pTimerPeriph);
    413                  IC3ReadValue1 = TIM_GetCapture2(pTimerPeriph);
   \   00000124   0x4658             MOV      R0,R11
   \   00000126   0x.... 0x....      BL       TIM_GetCapture2
   \   0000012A   0x0004             MOVS     R4,R0
    414                  CaptureNumber = 1;
   \   0000012C   0x2001             MOVS     R0,#+1
   \   0000012E   0x4680             MOV      R8,R0
   \   00000130   0xE038             B.N      ??SpiritManagementComputeXtalFrequencyGpio0_5
    415                }
    416                /* Second TIMER3 capture */
    417                else if(CaptureNumber == 1)
   \                     ??SpiritManagementComputeXtalFrequencyGpio0_6: (+1)
   \   00000132   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000136   0xF1B8 0x0F01      CMP      R8,#+1
   \   0000013A   0xD133             BNE.N    ??SpiritManagementComputeXtalFrequencyGpio0_5
    418                {
    419                  /* Get the Input Capture value */
    420          //***        IC3ReadValue2 = TIM_GetCapture4(pTimerPeriph);
    421                  IC3ReadValue2 = TIM_GetCapture2(pTimerPeriph);
   \   0000013C   0x4658             MOV      R0,R11
   \   0000013E   0x.... 0x....      BL       TIM_GetCapture2
   \   00000142   0x0005             MOVS     R5,R0
    422                  
    423                  /* Capture computation */
    424                  if (IC3ReadValue2 > IC3ReadValue1)
   \   00000144   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000146   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000148   0x42AC             CMP      R4,R5
   \   0000014A   0xD203             BCS.N    ??SpiritManagementComputeXtalFrequencyGpio0_7
    425                  {
    426                    /* If the TIMER3 didn't overflow between the first and the second capture. Compute it as the difference between the second and the first capture values. */
    427                    Capture = (IC3ReadValue2 - IC3ReadValue1) - 1;
   \   0000014C   0x1B28             SUBS     R0,R5,R4
   \   0000014E   0x1E40             SUBS     R0,R0,#+1
   \   00000150   0x4681             MOV      R9,R0
   \   00000152   0xE002             B.N      ??SpiritManagementComputeXtalFrequencyGpio0_8
    428                  }
    429                  else
    430                  {
    431                    /* .. else, if overflowed 'roll' the first measure to be complementar of 0xFFFF */
    432                    Capture = ((0xFFFF - IC3ReadValue1) + IC3ReadValue2) - 1;
   \                     ??SpiritManagementComputeXtalFrequencyGpio0_7: (+1)
   \   00000154   0x1B28             SUBS     R0,R5,R4
   \   00000156   0x1E80             SUBS     R0,R0,#+2
   \   00000158   0x4681             MOV      R9,R0
    433                  }
    434                  
    435                  /* Punctual frequency computation */
    436                  TIM3Freq = (uint32_t) SystemCoreClock / Capture;
   \                     ??SpiritManagementComputeXtalFrequencyGpio0_8: (+1)
   \   0000015A   0x....             LDR.N    R0,??DataTable6_6
   \   0000015C   0x6800             LDR      R0,[R0, #+0]
   \   0000015E   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000162   0xFBB0 0xF0F9      UDIV     R0,R0,R9
   \   00000166   0x4682             MOV      R10,R0
    437                  
    438                  /* Averaged frequency computation */
    439                  lXoFreq =(uint32_t)(A*(float)lXoFreq+(1.0-A)*(float)TIM3Freq);
   \   00000168   0x0030             MOVS     R0,R6
   \   0000016A   0x.... 0x....      BL       __aeabi_ui2f
   \   0000016E   0x.... 0x....      BL       __aeabi_f2d
   \   00000172   0x....             LDR.N    R2,??DataTable6_7  ;; 0x9999999a
   \   00000174   0x....             LDR.N    R3,??DataTable6_8  ;; 0x3fd99999
   \   00000176   0x.... 0x....      BL       __aeabi_dmul
   \   0000017A   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \   0000017E   0x4650             MOV      R0,R10
   \   00000180   0x.... 0x....      BL       __aeabi_ui2f
   \   00000184   0x.... 0x....      BL       __aeabi_f2d
   \   00000188   0xF05F 0x3233      MOVS     R2,#+858993459
   \   0000018C   0x....             LDR.N    R3,??DataTable6_9  ;; 0x3fe33333
   \   0000018E   0x.... 0x....      BL       __aeabi_dmul
   \   00000192   0xE9DD 0x2300      LDRD     R2,R3,[SP, #+0]
   \   00000196   0x.... 0x....      BL       __aeabi_dadd
   \   0000019A   0x.... 0x....      BL       __aeabi_d2uiz
   \   0000019E   0x0006             MOVS     R6,R0
    440                  
    441                  CaptureNumber = 0;
   \   000001A0   0x2000             MOVS     R0,#+0
   \   000001A2   0x4680             MOV      R8,R0
    442                }
    443              }
    444            }
   \                     ??SpiritManagementComputeXtalFrequencyGpio0_5: (+1)
   \   000001A4   0x1C7F             ADDS     R7,R7,#+1
   \   000001A6   0xE798             B.N      ??SpiritManagementComputeXtalFrequencyGpio0_0
    445            
    446            /* Compute the real frequency in Hertz tanking in account the MCU and Spirit divisions */
    447            lXoFreq *=(192*8);
   \                     ??SpiritManagementComputeXtalFrequencyGpio0_1: (+1)
   \   000001A8   0xF44F 0x60C0      MOV      R0,#+1536
   \   000001AC   0x4346             MULS     R6,R0,R6
    448            
    449            /* Disable the output clock */
    450            SpiritGpioClockOutput(S_DISABLE);
   \   000001AE   0x2000             MOVS     R0,#+0
   \   000001B0   0x.... 0x....      BL       SpiritGpioClockOutput
    451            
    452            /* TIM enable counter */
    453            TIM_Cmd(pTimerPeriph, DISABLE);
   \   000001B4   0x2100             MOVS     R1,#+0
   \   000001B6   0x4658             MOV      R0,R11
   \   000001B8   0x.... 0x....      BL       TIM_Cmd
    454            
    455            /* Enable the CC4 Interrupt Request */
    456          //***  TIM_ITConfig(pTimerPeriph, TIM_IT_CC4, DISABLE);
    457            TIM_ITConfig(pTimerPeriph, TIM_IT_CC2, DISABLE);
   \   000001BC   0x2200             MOVS     R2,#+0
   \   000001BE   0x2104             MOVS     R1,#+4
   \   000001C0   0x4658             MOV      R0,R11
   \   000001C2   0x.... 0x....      BL       TIM_ITConfig
    458          
    459            
    460            /* Restore SPIRIT GPIO 0 to the default configuration */
    461            SpiritGpioSetLevel(SPIRIT_GPIO_0, LOW);
   \   000001C6   0x2100             MOVS     R1,#+0
   \   000001C8   0x2005             MOVS     R0,#+5
   \   000001CA   0x.... 0x....      BL       SpiritGpioSetLevel
    462            
    463            /* Round the measured frequency to be measured as an integer MHz value */
    464            fXoFreqRounded = (float)lXoFreq/1e6;
   \   000001CE   0x0030             MOVS     R0,R6
   \   000001D0   0x.... 0x....      BL       __aeabi_ui2f
   \   000001D4   0x.... 0x....      BL       __aeabi_f2d
   \   000001D8   0x2200             MOVS     R2,#+0
   \   000001DA   0x....             LDR.N    R3,??DataTable6_10  ;; 0x412e8480
   \   000001DC   0x.... 0x....      BL       __aeabi_ddiv
   \   000001E0   0x.... 0x....      BL       __aeabi_d2f
   \   000001E4   0x9003             STR      R0,[SP, #+12]
    465            
    466            if( fXoFreqRounded-(float)((uint32_t)fXoFreqRounded)>0.5)
   \   000001E6   0x9803             LDR      R0,[SP, #+12]
   \   000001E8   0x.... 0x....      BL       __aeabi_f2uiz
   \   000001EC   0x.... 0x....      BL       __aeabi_ui2f
   \   000001F0   0x0001             MOVS     R1,R0
   \   000001F2   0x9803             LDR      R0,[SP, #+12]
   \   000001F4   0x.... 0x....      BL       __aeabi_fsub
   \   000001F8   0x....             LDR.N    R1,??DataTable6_11  ;; 0x3f000001
   \   000001FA   0x.... 0x....      BL       __aeabi_cfrcmple
   \   000001FE   0xD807             BHI.N    ??SpiritManagementComputeXtalFrequencyGpio0_9
    467            {  
    468              lMeasuredXtalFrequency = (((uint32_t)fXoFreqRounded+1)*1000000);
   \   00000200   0x9803             LDR      R0,[SP, #+12]
   \   00000202   0x.... 0x....      BL       __aeabi_f2uiz
   \   00000206   0x1C40             ADDS     R0,R0,#+1
   \   00000208   0x....             LDR.N    R1,??DataTable6_12  ;; 0xf4240
   \   0000020A   0x4348             MULS     R0,R1,R0
   \   0000020C   0x9005             STR      R0,[SP, #+20]
   \   0000020E   0xE005             B.N      ??SpiritManagementComputeXtalFrequencyGpio0_10
    469            }
    470            else
    471            {
    472              lMeasuredXtalFrequency = (((uint32_t)fXoFreqRounded)*1000000);
   \                     ??SpiritManagementComputeXtalFrequencyGpio0_9: (+1)
   \   00000210   0x9803             LDR      R0,[SP, #+12]
   \   00000212   0x.... 0x....      BL       __aeabi_f2uiz
   \   00000216   0x....             LDR.N    R1,??DataTable6_12  ;; 0xf4240
   \   00000218   0x4348             MULS     R0,R1,R0
   \   0000021A   0x9005             STR      R0,[SP, #+20]
    473            }
    474            
    475            SdkEvalM2SGpioInit(M2S_GPIO_0, M2S_MODE_GPIO_IN);
   \                     ??SpiritManagementComputeXtalFrequencyGpio0_10: (+1)
   \   0000021C   0x2100             MOVS     R1,#+0
   \   0000021E   0x2000             MOVS     R0,#+0
   \   00000220   0x.... 0x....      BL       SdkEvalM2SGpioInit
    476            
    477            return lMeasuredXtalFrequency;
   \   00000224   0x9805             LDR      R0,[SP, #+20]
   \   00000226   0xB00F             ADD      SP,SP,#+60
   \   00000228   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    478          }
    479          
    480          
    481          /**
    482          * @brief  Compute the SPIRIT version.
    483          * @param  None.
    484          * @retval SpiritVersion The dentified version of the SPIRIT.
    485          */

   \                                 In section .text, align 2, keep-with-next
    486          void SpiritManagementComputeSpiritVersion(void)
    487          {
   \                     SpiritManagementComputeSpiritVersion: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    488            uint16_t nSpiritVersion = SpiritGeneralGetDevicePartNumber();
   \   00000004   0x.... 0x....      BL       SpiritGeneralGetDevicePartNumber
   \   00000008   0x0004             MOVS     R4,R0
    489            SpiritVersion xSpiritVersion;
    490            
    491            for(int i=0; i<CUT_MAX_NO; i++)
   \   0000000A   0x2000             MOVS     R0,#+0
   \                     ??SpiritManagementComputeSpiritVersion_0: (+1)
   \   0000000C   0x2803             CMP      R0,#+3
   \   0000000E   0xDA0D             BGE.N    ??SpiritManagementComputeSpiritVersion_1
    492            {
    493              if(nSpiritVersion == xSpiritVersionMap[i].nSpiritVersion)
   \   00000010   0x....             LDR.N    R1,??DataTable6_15
   \   00000012   0xF831 0x1020      LDRH     R1,[R1, R0, LSL #+2]
   \   00000016   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000018   0x428C             CMP      R4,R1
   \   0000001A   0xD105             BNE.N    ??SpiritManagementComputeSpiritVersion_2
    494              {
    495                xSpiritVersion = xSpiritVersionMap[i].xSpiritVersion;
   \   0000001C   0x....             LDR.N    R1,??DataTable6_15
   \   0000001E   0xEB11 0x0080      ADDS     R0,R1,R0, LSL #+2
   \   00000022   0x7880             LDRB     R0,[R0, #+2]
   \   00000024   0x0005             MOVS     R5,R0
    496                break;
   \   00000026   0xE001             B.N      ??SpiritManagementComputeSpiritVersion_1
    497              }
    498            }
   \                     ??SpiritManagementComputeSpiritVersion_2: (+1)
   \   00000028   0x1C40             ADDS     R0,R0,#+1
   \   0000002A   0xE7EF             B.N      ??SpiritManagementComputeSpiritVersion_0
    499            
    500            uint8_t cXtalFreq = SpiritManagementComputeXtalFrequencyGpio0()/1000000;
   \                     ??SpiritManagementComputeSpiritVersion_1: (+1)
   \   0000002C   0x.... 0x....      BL       SpiritManagementComputeXtalFrequencyGpio0
   \   00000030   0x....             LDR.N    R1,??DataTable6_12  ;; 0xf4240
   \   00000032   0xFBB0 0xF6F1      UDIV     R6,R0,R1
    501            
    502            /* Check if the digital divider works (cut 2.1) or not (cut 2.0) */
    503            if(xSpiritVersion == SPIRIT_VERSION_2_1)  
   \   00000036   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000038   0x2D01             CMP      R5,#+1
   \   0000003A   0xD12F             BNE.N    ??SpiritManagementComputeSpiritVersion_3
    504            {
    505              if(cXtalFreq>=24 && cXtalFreq<=26)
   \   0000003C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003E   0x2E18             CMP      R6,#+24
   \   00000040   0xDB24             BLT.N    ??SpiritManagementComputeSpiritVersion_4
   \   00000042   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000044   0x2E1B             CMP      R6,#+27
   \   00000046   0xDA21             BGE.N    ??SpiritManagementComputeSpiritVersion_4
    506              {
    507                /* Disable the clock divider to measure the max frequency of the clock. */
    508                uint8_t tmp= 0x29; SpiritSpiWriteRegisters(0xB4, 1, &tmp);
   \   00000048   0x2029             MOVS     R0,#+41
   \   0000004A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000004E   0xAA00             ADD      R2,SP,#+0
   \   00000050   0x2101             MOVS     R1,#+1
   \   00000052   0x20B4             MOVS     R0,#+180
   \   00000054   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
    509                
    510                cXtalFreq = SpiritManagementComputeXtalFrequencyGpio0()/1000000;
   \   00000058   0x.... 0x....      BL       SpiritManagementComputeXtalFrequencyGpio0
   \   0000005C   0x....             LDR.N    R1,??DataTable6_12  ;; 0xf4240
   \   0000005E   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000062   0x0006             MOVS     R6,R0
    511                
    512                if(cXtalFreq>=24 && cXtalFreq<=26)
   \   00000064   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000066   0x2E18             CMP      R6,#+24
   \   00000068   0xDB05             BLT.N    ??SpiritManagementComputeSpiritVersion_5
   \   0000006A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000006C   0x2E1B             CMP      R6,#+27
   \   0000006E   0xDA02             BGE.N    ??SpiritManagementComputeSpiritVersion_5
    513                {
    514                  xSpiritVersion = SPIRIT_VERSION_2_0;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x0005             MOVS     R5,R0
   \   00000074   0xE001             B.N      ??SpiritManagementComputeSpiritVersion_6
    515                }
    516                else
    517                {
    518                  xSpiritVersion = SPIRIT_VERSION_2_1;
   \                     ??SpiritManagementComputeSpiritVersion_5: (+1)
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0x0005             MOVS     R5,R0
    519                }
    520                
    521                tmp= 0x21; SpiritSpiWriteRegisters(0xB4, 1, &tmp);
   \                     ??SpiritManagementComputeSpiritVersion_6: (+1)
   \   0000007A   0x2021             MOVS     R0,#+33
   \   0000007C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000080   0xAA00             ADD      R2,SP,#+0
   \   00000082   0x2101             MOVS     R1,#+1
   \   00000084   0x20B4             MOVS     R0,#+180
   \   00000086   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   0000008A   0xE007             B.N      ??SpiritManagementComputeSpiritVersion_3
    522              }
    523              else
    524              {
    525                if(cXtalFreq>=12 && cXtalFreq<=13)
   \                     ??SpiritManagementComputeSpiritVersion_4: (+1)
   \   0000008C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000008E   0x2E0C             CMP      R6,#+12
   \   00000090   0xDB04             BLT.N    ??SpiritManagementComputeSpiritVersion_3
   \   00000092   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000094   0x2E0E             CMP      R6,#+14
   \   00000096   0xDA01             BGE.N    ??SpiritManagementComputeSpiritVersion_3
    526                {
    527                  xSpiritVersion = SPIRIT_VERSION_2_1;
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0x0005             MOVS     R5,R0
    528                }
    529              }  
    530            }
    531          
    532            if(SdkEvalGetVersion() == SDK_EVAL_VERSION_D1)
   \                     ??SpiritManagementComputeSpiritVersion_3: (+1)
   \   0000009C   0x.... 0x....      BL       SdkEvalGetVersion
   \   000000A0   0x2802             CMP      R0,#+2
   \   000000A2   0xD101             BNE.N    ??SpiritManagementComputeSpiritVersion_7
    533              xSpiritVersion = SPIRIT_VERSION_3_0_D1;
   \   000000A4   0x2003             MOVS     R0,#+3
   \   000000A6   0x0005             MOVS     R5,R0
    534            
    535            SpiritGeneralSetSpiritVersion(xSpiritVersion);
   \                     ??SpiritManagementComputeSpiritVersion_7: (+1)
   \   000000A8   0x0028             MOVS     R0,R5
   \   000000AA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AC   0x.... 0x....      BL       SpiritGeneralSetSpiritVersion
    536            
    537          }
   \   000000B0   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    538          
    539          /**
    540          * @brief  Read the status register.
    541          * @param  None
    542          * @retval Status
    543          */
    544          
    545          

   \                                 In section .text, align 2, keep-with-next
    546          void SpiritManagementIdentificationRFBoard(void)
    547          {
   \                     SpiritManagementIdentificationRFBoard: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    548            
    549            SpiritManagementComputeSpiritVersion();
   \   00000002   0x.... 0x....      BL       SpiritManagementComputeSpiritVersion
    550            SpiritManagementComputeXtalFrequency();
   \   00000006   0x.... 0x....      BL       SpiritManagementComputeXtalFrequency
    551            
    552          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    553          

   \                                 In section .text, align 2, keep-with-next
    554          void SpiritManagementSetBand(uint8_t value)
    555          {
    556            s_RfModuleBand = value;
   \                     SpiritManagementSetBand: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable6_16
   \   00000002   0x7008             STRB     R0,[R1, #+0]
    557          }
   \   00000004   0x4770             BX       LR               ;; return
    558          

   \                                 In section .text, align 2, keep-with-next
    559          uint8_t SpiritManagementGetBand(void)
    560          {
    561            return s_RfModuleBand;
   \                     SpiritManagementGetBand: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable6_16
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    562          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x40000400         DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x........         DC32     s_xTIMChCompareModeRaised

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x40000800         DC32     0x40000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x........         DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x9999999A         DC32     0x9999999a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   0x3FD99999         DC32     0x3fd99999

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_9:
   \   00000000   0x3FE33333         DC32     0x3fe33333

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_10:
   \   00000000   0x412E8480         DC32     0x412e8480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_11:
   \   00000000   0x3F000001         DC32     0x3f000001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_12:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_13:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_14:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_15:
   \   00000000   0x........         DC32     xSpiritVersionMap

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_16:
   \   00000000   0x........         DC32     s_RfModuleBand

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x1E 0x00          DC8 30, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x05 0x02          DC8 5, 2, 136, 0
   \              0x88 0x00    

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x1E 0x00          DC8 30, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x05 0x02          DC8 5, 2, 136, 0
   \              0x88 0x00    
    563          
    564          /**
    565          * @}
    566          */
    567          
    568          
    569          
    570          /**
    571          * @}
    572          */
    573          
    574          
    575          
    576          /**
    577          * @}
    578          */
    579          
    580          /**
    581          * @}
    582          */
    583          
    584          
    585          /******************* (C) COPYRIGHT 2012 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   SpiritManagementComputeSpiritVersion
        24   -> SdkEvalGetVersion
        24   -> SdkEvalSpiWriteRegisters
        24   -> SpiritGeneralGetDevicePartNumber
        24   -> SpiritGeneralSetSpiritVersion
        24   -> SpiritManagementComputeXtalFrequencyGpio0
      96   SpiritManagementComputeXtalFrequency
        96   -> GPIO_Init
        96   -> GPIO_PinAFConfig
        96   -> NVIC_Init
        96   -> RCC_AHBPeriphClockCmd
        96   -> RCC_APB1PeriphClockCmd
        96   -> SdkEvalM2SGpioInit
        96   -> SdkEvalSpiWriteRegisters
        96   -> SpiritGeneralGetSpiritVersion
        96   -> SpiritGpioClockOutput
        96   -> SpiritGpioClockOutputInit
        96   -> SpiritGpioInit
        96   -> SpiritGpioSetLevel
        96   -> SpiritRadioSetXtalFrequency
        96   -> TIM_Cmd
        96   -> TIM_GetCapture2
        96   -> TIM_ICInit
        96   -> TIM_ITConfig
        96   -> __aeabi_d2f
        96   -> __aeabi_d2uiz
        96   -> __aeabi_dadd
        96   -> __aeabi_ddiv
        96   -> __aeabi_dmul
        96   -> __aeabi_f2d
        96   -> __aeabi_f2uiz
        96   -> __aeabi_fsub
        96   -> __aeabi_ui2f
        96 __aeabi_cfrcmple
      96   SpiritManagementComputeXtalFrequencyGpio0
        96   -> GPIO_Init
        96   -> GPIO_PinAFConfig
        96   -> NVIC_Init
        96   -> RCC_AHBPeriphClockCmd
        96   -> RCC_APB1PeriphClockCmd
        96   -> SdkEvalM2SGpioInit
        96   -> SpiritGpioClockOutput
        96   -> SpiritGpioClockOutputInit
        96   -> SpiritGpioInit
        96   -> SpiritGpioSetLevel
        96   -> TIM_Cmd
        96   -> TIM_GetCapture2
        96   -> TIM_ICInit
        96   -> TIM_ITConfig
        96   -> __aeabi_d2f
        96   -> __aeabi_d2uiz
        96   -> __aeabi_dadd
        96   -> __aeabi_ddiv
        96   -> __aeabi_dmul
        96   -> __aeabi_f2d
        96   -> __aeabi_f2uiz
        96   -> __aeabi_fsub
        96   -> __aeabi_ui2f
        96 __aeabi_cfrcmple
       0   SpiritManagementGetBand
       8   SpiritManagementIdentificationRFBoard
         8   -> SpiritManagementComputeSpiritVersion
         8   -> SpiritManagementComputeXtalFrequency
       0   SpiritManagementSetBand
       8   TIM3_IRQHandler
         8   -> TIM_ClearITPendingBit
         8   -> TIM_GetITStatus
       8   TIM4_IRQHandler
         8   -> TIM_ClearITPendingBit
         8   -> TIM_GetITStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_11
       4  ??DataTable6_12
       4  ??DataTable6_13
       4  ??DataTable6_14
       4  ??DataTable6_15
       4  ??DataTable6_16
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
       4  ?_0
       4  ?_1
       4  ?_2
       4  ?_3
     178  SpiritManagementComputeSpiritVersion
     634  SpiritManagementComputeXtalFrequency
     556  SpiritManagementComputeXtalFrequencyGpio0
       6  SpiritManagementGetBand
      12  SpiritManagementIdentificationRFBoard
       6  SpiritManagementSetBand
      70  TIM3_IRQHandler
      70  TIM4_IRQHandler
       1  s_RfModuleBand
       1  s_xTIMChCompareModeRaised
      12  xSpiritVersionMap

 
     2 bytes in section .bss
    28 bytes in section .rodata
 1 600 bytes in section .text
 
 1 600 bytes of CODE  memory
    28 bytes of CONST memory
     2 bytes of DATA  memory

Errors: none
Warnings: none
