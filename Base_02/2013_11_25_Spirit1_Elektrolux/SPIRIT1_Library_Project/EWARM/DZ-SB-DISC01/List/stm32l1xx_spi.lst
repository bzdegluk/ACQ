###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        20/Nov/2015  05:05:50
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_spi.c
#    Command line =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_spi.c
#        -D USE_STDPERIPH_DRIVER -D VECT_TAB_FLASH -D STM32L1XX_MD -D
#        IAR_ARM_CM3 -D USE_FULL_ASSERT -D SPIRIT_USE_FULL_ASSERT -D
#        USE_SYSTICK_DELAY -D SDK -lC
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\List\
#        -o
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\.\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\examples\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\runtime\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\SDK_Eval_STM32L\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\SPIRIT1_Library\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\SDK_Eval_Util\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\SDK_Virtual_Com\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32_USB-FS-Device_Lib\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\ACQ\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\CMSIS\Include\"
#    List file    =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\List\stm32l1xx_spi.lst
#    Object file  =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\Obj\stm32l1xx_spi.o
#
###############################################################################

E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_spi.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_spi.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    31-December-2010
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Serial peripheral interface (SPI):           
      9            *           - Initialization and Configuration
     10            *           - Data transfers functions
     11            *           - Hardware CRC Calculation
     12            *           - DMA transfers management
     13            *           - Interrupts and flags management 
     14            *           
     15            *  @verbatim
     16            *          
     17            *          The I2S feature is not implemented in STM32L1xx Ultra Low Power
     18            *          Medium-density devices and will be supported in future products.
     19            *                    
     20            *          ===================================================================
     21            *                                 How to use this driver
     22            *          ===================================================================
     23            *          1. Enable peripheral clock using RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE)
     24            *             function for SPI1 or using RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE)
     25            *             function for SPI2.
     26            *
     27            *          2. Enable SCK, MOSI, MISO and NSS GPIO clocks using RCC_AHBPeriphClockCmd()
     28            *             function. 
     29            *
     30            *          3. Peripherals alternate function: 
     31            *                 - Connect the pin to the desired peripherals' Alternate 
     32            *                   Function (AF) using GPIO_PinAFConfig() function
     33            *                 - Configure the desired pin in alternate function by:
     34            *                   GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
     35            *                 - Select the type, pull-up/pull-down and output speed via 
     36            *                   GPIO_PuPd, GPIO_OType and GPIO_Speed members
     37            *                 - Call GPIO_Init() function
     38            *        
     39            *          4. Program the Polarity, Phase, First Data, Baud Rate Prescaler, Slave 
     40            *             Management, Peripheral Mode and CRC Polynomial values using the SPI_Init()
     41            *             function.
     42            *
     43            *          5. Enable the NVIC and the corresponding interrupt using the function 
     44            *             SPI_ITConfig() if you need to use interrupt mode. 
     45            *
     46            *          6. When using the DMA mode 
     47            *                   - Configure the DMA using DMA_Init() function
     48            *                   - Active the needed channel Request using SPI_I2S_DMACmd() function
     49            * 
     50            *          7. Enable the SPI using the SPI_Cmd() function.
     51            * 
     52            *          8. Enable the DMA using the DMA_Cmd() function when using DMA mode. 
     53            *
     54            *          9. Optionally you can enable/configure the following parameters without
     55            *             re-initialization (i.e there is no need to call again SPI_Init() function):
     56            *              - When bidirectional mode (SPI_Direction_1Line_Rx or SPI_Direction_1Line_Tx)
     57            *                is programmed as Data direction parameter using the SPI_Init() function
     58            *                it can be possible to switch between SPI_Direction_Tx or SPI_Direction_Rx
     59            *                using the SPI_BiDirectionalLineConfig() function.
     60            *              - When SPI_NSS_Soft is selected as Slave Select Management parameter 
     61            *                using the SPI_Init() function it can be possible to manage the 
     62            *                NSS internal signal using the SPI_NSSInternalSoftwareConfig() function.
     63            *              -  Reconfigure the data size using the SPI_DataSizeConfig() function  
     64            *              -  Enable or disable the SS output using the SPI_SSOutputCmd() function  
     65            *          
     66            *          10. To use the CRC Hardware calculation feature refer to the Peripheral 
     67            *              CRC hardware Calculation subsection.
     68            *
     69            *  @endverbatim  
     70            *                                  
     71            ******************************************************************************
     72            * @attention
     73            *
     74            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     75            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     76            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     77            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     78            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     79            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     80            *
     81            * <h2><center>&copy; COPYRIGHT 2010 STMicroelectronics</center></h2>
     82            ******************************************************************************  
     83            */ 
     84          
     85          /* Includes ------------------------------------------------------------------*/
     86          #include "stm32l1xx_spi.h"
     87          #include "stm32l1xx_rcc.h"
     88          
     89          /** @addtogroup STM32L1xx_StdPeriph_Driver
     90            * @{
     91            */
     92          
     93          /** @defgroup SPI 
     94            * @brief SPI driver modules
     95            * @{
     96            */ 
     97          
     98          /* Private typedef -----------------------------------------------------------*/
     99          /* Private define ------------------------------------------------------------*/
    100          /* SPI registers Masks */
    101          #define CR1_CLEAR_MASK       ((uint16_t)0x3040)
    102          
    103          /* Private macro -------------------------------------------------------------*/
    104          /* Private variables ---------------------------------------------------------*/
    105          /* Private function prototypes -----------------------------------------------*/
    106          /* Private functions ---------------------------------------------------------*/
    107          
    108          /** @defgroup SPI_Private_Functions
    109            * @{
    110            */
    111          
    112          /** @defgroup SPI_Group1 Initialization and Configuration functions
    113           *  @brief   Initialization and Configuration functions 
    114           *
    115          @verbatim   
    116           ===============================================================================
    117                            Initialization and Configuration functions
    118           ===============================================================================  
    119          
    120            This section provides a set of functions allowing to initialize the SPI Direction,
    121            SPI Mode, SPI Data Size, SPI Polarity, SPI Phase, SPI NSS Management, SPI Baud
    122            Rate Prescaler, SPI First Bit and SPI CRC Polynomial.
    123            
    124            The SPI_Init() function follows the SPI configuration procedures for Master mode
    125            and Slave mode (details for these procedures are available in reference manual
    126            (RM0038)).
    127            
    128          @endverbatim
    129            * @{
    130            */
    131          
    132          /**
    133            * @brief  Deinitializes the SPIx peripheral registers to their default
    134            *         reset values.
    135            * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
    136            * @retval None
    137            */

   \                                 In section .text, align 2, keep-with-next
    138          void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
    139          {
   \                     SPI_I2S_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    140            /* Check the parameters */
    141            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40013000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD008             BEQ.N    ??SPI_I2S_DeInit_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable18_1  ;; 0x40003800
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD004             BEQ.N    ??SPI_I2S_DeInit_0
   \   00000014   0x218D             MOVS     R1,#+141
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   0000001A   0x.... 0x....      BL       assert_failed
    142          
    143            if (SPIx == SPI1)
   \                     ??SPI_I2S_DeInit_0: (+1)
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40013000
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD10A             BNE.N    ??SPI_I2S_DeInit_1
    144            {
    145              /* Enable SPI1 reset state */
    146              RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
   \   00000026   0x2101             MOVS     R1,#+1
   \   00000028   0xF44F 0x5080      MOV      R0,#+4096
   \   0000002C   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    147              /* Release SPI1 from reset state */
    148              RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0xF44F 0x5080      MOV      R0,#+4096
   \   00000036   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
   \   0000003A   0xE00D             B.N      ??SPI_I2S_DeInit_2
    149            }
    150            else
    151            {
    152              if (SPIx == SPI2)
   \                     ??SPI_I2S_DeInit_1: (+1)
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable18_1  ;; 0x40003800
   \   00000040   0x4284             CMP      R4,R0
   \   00000042   0xD109             BNE.N    ??SPI_I2S_DeInit_2
    153              {
    154                /* Enable SPI2 reset state */
    155                RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
   \   00000044   0x2101             MOVS     R1,#+1
   \   00000046   0xF44F 0x4080      MOV      R0,#+16384
   \   0000004A   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    156                /* Release SPI2 from reset state */
    157                RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
   \   0000004E   0x2100             MOVS     R1,#+0
   \   00000050   0xF44F 0x4080      MOV      R0,#+16384
   \   00000054   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    158              }
    159            }
    160          }
   \                     ??SPI_I2S_DeInit_2: (+1)
   \   00000058   0xBD10             POP      {R4,PC}          ;; return
    161          
    162          /**
    163            * @brief  Initializes the SPIx peripheral according to the specified 
    164            *   parameters in the SPI_InitStruct.
    165            * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
    166            * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure that
    167            *   contains the configuration information for the specified SPI peripheral.
    168            * @retval None
    169            */

   \                                 In section .text, align 2, keep-with-next
    170          void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
    171          {
   \                     SPI_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    172            uint16_t tmpreg = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    173            
    174            /* check the parameters */
    175            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40013000
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD008             BEQ.N    ??SPI_Init_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable18_1  ;; 0x40003800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD004             BEQ.N    ??SPI_Init_0
   \   00000018   0x21AF             MOVS     R1,#+175
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   0000001E   0x.... 0x....      BL       assert_failed
    176            
    177            /* Check the SPI parameters */
    178            assert_param(IS_SPI_DIRECTION_MODE(SPI_InitStruct->SPI_Direction));
   \                     ??SPI_Init_0: (+1)
   \   00000022   0x8828             LDRH     R0,[R5, #+0]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD010             BEQ.N    ??SPI_Init_1
   \   00000028   0x8828             LDRH     R0,[R5, #+0]
   \   0000002A   0xF5B0 0x6F80      CMP      R0,#+1024
   \   0000002E   0xD00C             BEQ.N    ??SPI_Init_1
   \   00000030   0x8828             LDRH     R0,[R5, #+0]
   \   00000032   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000036   0xD008             BEQ.N    ??SPI_Init_1
   \   00000038   0x8828             LDRH     R0,[R5, #+0]
   \   0000003A   0xF5B0 0x4F40      CMP      R0,#+49152
   \   0000003E   0xD004             BEQ.N    ??SPI_Init_1
   \   00000040   0x21B2             MOVS     R1,#+178
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   00000046   0x.... 0x....      BL       assert_failed
    179            assert_param(IS_SPI_MODE(SPI_InitStruct->SPI_Mode));
   \                     ??SPI_Init_1: (+1)
   \   0000004A   0x8868             LDRH     R0,[R5, #+2]
   \   0000004C   0xF5B0 0x7F82      CMP      R0,#+260
   \   00000050   0xD007             BEQ.N    ??SPI_Init_2
   \   00000052   0x8868             LDRH     R0,[R5, #+2]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD004             BEQ.N    ??SPI_Init_2
   \   00000058   0x21B3             MOVS     R1,#+179
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   0000005E   0x.... 0x....      BL       assert_failed
    180            assert_param(IS_SPI_DATASIZE(SPI_InitStruct->SPI_DataSize));
   \                     ??SPI_Init_2: (+1)
   \   00000062   0x88A8             LDRH     R0,[R5, #+4]
   \   00000064   0xF5B0 0x6F00      CMP      R0,#+2048
   \   00000068   0xD007             BEQ.N    ??SPI_Init_3
   \   0000006A   0x88A8             LDRH     R0,[R5, #+4]
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD004             BEQ.N    ??SPI_Init_3
   \   00000070   0x21B4             MOVS     R1,#+180
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   00000076   0x.... 0x....      BL       assert_failed
    181            assert_param(IS_SPI_CPOL(SPI_InitStruct->SPI_CPOL));
   \                     ??SPI_Init_3: (+1)
   \   0000007A   0x88E8             LDRH     R0,[R5, #+6]
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD007             BEQ.N    ??SPI_Init_4
   \   00000080   0x88E8             LDRH     R0,[R5, #+6]
   \   00000082   0x2802             CMP      R0,#+2
   \   00000084   0xD004             BEQ.N    ??SPI_Init_4
   \   00000086   0x21B5             MOVS     R1,#+181
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   0000008C   0x.... 0x....      BL       assert_failed
    182            assert_param(IS_SPI_CPHA(SPI_InitStruct->SPI_CPHA));
   \                     ??SPI_Init_4: (+1)
   \   00000090   0x8928             LDRH     R0,[R5, #+8]
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD007             BEQ.N    ??SPI_Init_5
   \   00000096   0x8928             LDRH     R0,[R5, #+8]
   \   00000098   0x2801             CMP      R0,#+1
   \   0000009A   0xD004             BEQ.N    ??SPI_Init_5
   \   0000009C   0x21B6             MOVS     R1,#+182
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   000000A2   0x.... 0x....      BL       assert_failed
    183            assert_param(IS_SPI_NSS(SPI_InitStruct->SPI_NSS));
   \                     ??SPI_Init_5: (+1)
   \   000000A6   0x8968             LDRH     R0,[R5, #+10]
   \   000000A8   0xF5B0 0x7F00      CMP      R0,#+512
   \   000000AC   0xD007             BEQ.N    ??SPI_Init_6
   \   000000AE   0x8968             LDRH     R0,[R5, #+10]
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xD004             BEQ.N    ??SPI_Init_6
   \   000000B4   0x21B7             MOVS     R1,#+183
   \   000000B6   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   000000BA   0x.... 0x....      BL       assert_failed
    184            assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct->SPI_BaudRatePrescaler));
   \                     ??SPI_Init_6: (+1)
   \   000000BE   0x89A8             LDRH     R0,[R5, #+12]
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xD019             BEQ.N    ??SPI_Init_7
   \   000000C4   0x89A8             LDRH     R0,[R5, #+12]
   \   000000C6   0x2808             CMP      R0,#+8
   \   000000C8   0xD016             BEQ.N    ??SPI_Init_7
   \   000000CA   0x89A8             LDRH     R0,[R5, #+12]
   \   000000CC   0x2810             CMP      R0,#+16
   \   000000CE   0xD013             BEQ.N    ??SPI_Init_7
   \   000000D0   0x89A8             LDRH     R0,[R5, #+12]
   \   000000D2   0x2818             CMP      R0,#+24
   \   000000D4   0xD010             BEQ.N    ??SPI_Init_7
   \   000000D6   0x89A8             LDRH     R0,[R5, #+12]
   \   000000D8   0x2820             CMP      R0,#+32
   \   000000DA   0xD00D             BEQ.N    ??SPI_Init_7
   \   000000DC   0x89A8             LDRH     R0,[R5, #+12]
   \   000000DE   0x2828             CMP      R0,#+40
   \   000000E0   0xD00A             BEQ.N    ??SPI_Init_7
   \   000000E2   0x89A8             LDRH     R0,[R5, #+12]
   \   000000E4   0x2830             CMP      R0,#+48
   \   000000E6   0xD007             BEQ.N    ??SPI_Init_7
   \   000000E8   0x89A8             LDRH     R0,[R5, #+12]
   \   000000EA   0x2838             CMP      R0,#+56
   \   000000EC   0xD004             BEQ.N    ??SPI_Init_7
   \   000000EE   0x21B8             MOVS     R1,#+184
   \   000000F0   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   000000F4   0x.... 0x....      BL       assert_failed
    185            assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
   \                     ??SPI_Init_7: (+1)
   \   000000F8   0x89E8             LDRH     R0,[R5, #+14]
   \   000000FA   0x2800             CMP      R0,#+0
   \   000000FC   0xD007             BEQ.N    ??SPI_Init_8
   \   000000FE   0x89E8             LDRH     R0,[R5, #+14]
   \   00000100   0x2880             CMP      R0,#+128
   \   00000102   0xD004             BEQ.N    ??SPI_Init_8
   \   00000104   0x21B9             MOVS     R1,#+185
   \   00000106   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   0000010A   0x.... 0x....      BL       assert_failed
    186            assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));
   \                     ??SPI_Init_8: (+1)
   \   0000010E   0x8A28             LDRH     R0,[R5, #+16]
   \   00000110   0x2800             CMP      R0,#+0
   \   00000112   0xD104             BNE.N    ??SPI_Init_9
   \   00000114   0x21BA             MOVS     R1,#+186
   \   00000116   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   0000011A   0x.... 0x....      BL       assert_failed
    187          
    188          /*---------------------------- SPIx CR1 Configuration ------------------------*/
    189            /* Get the SPIx CR1 value */
    190            tmpreg = SPIx->CR1;
   \                     ??SPI_Init_9: (+1)
   \   0000011E   0x8820             LDRH     R0,[R4, #+0]
   \   00000120   0x0006             MOVS     R6,R0
    191            /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
    192            tmpreg &= CR1_CLEAR_MASK;
   \   00000122   0xF416 0x5641      ANDS     R6,R6,#0x3040
    193            /* Configure SPIx: direction, NSS management, first transmitted bit, BaudRate prescaler
    194               master/salve mode, CPOL and CPHA */
    195            /* Set BIDImode, BIDIOE and RxONLY bits according to SPI_Direction value */
    196            /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
    197            /* Set LSBFirst bit according to SPI_FirstBit value */
    198            /* Set BR bits according to SPI_BaudRatePrescaler value */
    199            /* Set CPOL bit according to SPI_CPOL value */
    200            /* Set CPHA bit according to SPI_CPHA value */
    201            tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
    202                            SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
    203                            SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
    204                            SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
   \   00000126   0x8828             LDRH     R0,[R5, #+0]
   \   00000128   0x8869             LDRH     R1,[R5, #+2]
   \   0000012A   0x4308             ORRS     R0,R1,R0
   \   0000012C   0x88A9             LDRH     R1,[R5, #+4]
   \   0000012E   0x4308             ORRS     R0,R1,R0
   \   00000130   0x88E9             LDRH     R1,[R5, #+6]
   \   00000132   0x4308             ORRS     R0,R1,R0
   \   00000134   0x8929             LDRH     R1,[R5, #+8]
   \   00000136   0x4308             ORRS     R0,R1,R0
   \   00000138   0x8969             LDRH     R1,[R5, #+10]
   \   0000013A   0x4308             ORRS     R0,R1,R0
   \   0000013C   0x89A9             LDRH     R1,[R5, #+12]
   \   0000013E   0x4308             ORRS     R0,R1,R0
   \   00000140   0x89E9             LDRH     R1,[R5, #+14]
   \   00000142   0x4308             ORRS     R0,R1,R0
   \   00000144   0x4306             ORRS     R6,R0,R6
    205            /* Write to SPIx CR1 */
    206            SPIx->CR1 = tmpreg;
   \   00000146   0x8026             STRH     R6,[R4, #+0]
    207            
    208          /*---------------------------- SPIx CRCPOLY Configuration --------------------*/
    209            /* Write to SPIx CRCPOLY */
    210            SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
   \   00000148   0x8A28             LDRH     R0,[R5, #+16]
   \   0000014A   0x8220             STRH     R0,[R4, #+16]
    211          }
   \   0000014C   0xBD70             POP      {R4-R6,PC}       ;; return
    212          
    213          /**
    214            * @brief  Fills each SPI_InitStruct member with its default value.
    215            * @param  SPI_InitStruct : pointer to a SPI_InitTypeDef structure which will be initialized.
    216            * @retval None
    217            */

   \                                 In section .text, align 2, keep-with-next
    218          void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
    219          {
    220          /*--------------- Reset SPI init structure parameters values -----------------*/
    221            /* Initialize the SPI_Direction member */
    222            SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
   \                     SPI_StructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x8001             STRH     R1,[R0, #+0]
    223            /* initialize the SPI_Mode member */
    224            SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x8041             STRH     R1,[R0, #+2]
    225            /* initialize the SPI_DataSize member */
    226            SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x8081             STRH     R1,[R0, #+4]
    227            /* Initialize the SPI_CPOL member */
    228            SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x80C1             STRH     R1,[R0, #+6]
    229            /* Initialize the SPI_CPHA member */
    230            SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x8101             STRH     R1,[R0, #+8]
    231            /* Initialize the SPI_NSS member */
    232            SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x8141             STRH     R1,[R0, #+10]
    233            /* Initialize the SPI_BaudRatePrescaler member */
    234            SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x8181             STRH     R1,[R0, #+12]
    235            /* Initialize the SPI_FirstBit member */
    236            SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x81C1             STRH     R1,[R0, #+14]
    237            /* Initialize the SPI_CRCPolynomial member */
    238            SPI_InitStruct->SPI_CRCPolynomial = 7;
   \   00000020   0x2107             MOVS     R1,#+7
   \   00000022   0x8201             STRH     R1,[R0, #+16]
    239          }
   \   00000024   0x4770             BX       LR               ;; return
    240          
    241          /**
    242            * @brief  Enables or disables the specified SPI peripheral.
    243            * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
    244            * @param  NewState: new state of the SPIx peripheral. 
    245            *   This parameter can be: ENABLE or DISABLE.
    246            * @retval None
    247            */

   \                                 In section .text, align 2, keep-with-next
    248          void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    249          {
   \                     SPI_Cmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    250            /* Check the parameters */
    251            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40013000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD008             BEQ.N    ??SPI_Cmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable18_1  ;; 0x40003800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD004             BEQ.N    ??SPI_Cmd_0
   \   00000016   0x21FB             MOVS     R1,#+251
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   0000001C   0x.... 0x....      BL       assert_failed
    252            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??SPI_Cmd_0: (+1)
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD007             BEQ.N    ??SPI_Cmd_1
   \   00000026   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000028   0x2D01             CMP      R5,#+1
   \   0000002A   0xD004             BEQ.N    ??SPI_Cmd_1
   \   0000002C   0x21FC             MOVS     R1,#+252
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   00000032   0x.... 0x....      BL       assert_failed
    253            if (NewState != DISABLE)
   \                     ??SPI_Cmd_1: (+1)
   \   00000036   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000038   0x2D00             CMP      R5,#+0
   \   0000003A   0xD004             BEQ.N    ??SPI_Cmd_2
    254            {
    255              /* Enable the selected SPI peripheral */
    256              SPIx->CR1 |= SPI_CR1_SPE;
   \   0000003C   0x8820             LDRH     R0,[R4, #+0]
   \   0000003E   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000042   0x8020             STRH     R0,[R4, #+0]
   \   00000044   0xE004             B.N      ??SPI_Cmd_3
    257            }
    258            else
    259            {
    260              /* Disable the selected SPI peripheral */
    261              SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_SPE);
   \                     ??SPI_Cmd_2: (+1)
   \   00000046   0x8820             LDRH     R0,[R4, #+0]
   \   00000048   0xF64F 0x71BF      MOVW     R1,#+65471
   \   0000004C   0x4008             ANDS     R0,R1,R0
   \   0000004E   0x8020             STRH     R0,[R4, #+0]
    262            }
    263          }
   \                     ??SPI_Cmd_3: (+1)
   \   00000050   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    264          
    265          /**
    266            * @brief  Configures the data size for the selected SPI.
    267            * @param  SPIx: where x can be 1 or 2  to select the SPI peripheral.
    268            * @param  SPI_DataSize: specifies the SPI data size.
    269            *   This parameter can be one of the following values:
    270            *     @arg SPI_DataSize_16b: Set data frame format to 16bit
    271            *     @arg SPI_DataSize_8b: Set data frame format to 8bit
    272            * @retval None
    273            */

   \                                 In section .text, align 2, keep-with-next
    274          void SPI_DataSizeConfig(SPI_TypeDef* SPIx, uint16_t SPI_DataSize)
    275          {
   \                     SPI_DataSizeConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    276            /* Check the parameters */
    277            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40013000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD009             BEQ.N    ??SPI_DataSizeConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable18_1  ;; 0x40003800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD005             BEQ.N    ??SPI_DataSizeConfig_0
   \   00000016   0xF240 0x1115      MOVW     R1,#+277
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   0000001E   0x.... 0x....      BL       assert_failed
    278            assert_param(IS_SPI_DATASIZE(SPI_DataSize));
   \                     ??SPI_DataSizeConfig_0: (+1)
   \   00000022   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000024   0xF5B5 0x6F00      CMP      R5,#+2048
   \   00000028   0xD008             BEQ.N    ??SPI_DataSizeConfig_1
   \   0000002A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002C   0x2D00             CMP      R5,#+0
   \   0000002E   0xD005             BEQ.N    ??SPI_DataSizeConfig_1
   \   00000030   0xF44F 0x718B      MOV      R1,#+278
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   00000038   0x.... 0x....      BL       assert_failed
    279            /* Clear DFF bit */
    280            SPIx->CR1 &= (uint16_t)~SPI_DataSize_16b;
   \                     ??SPI_DataSizeConfig_1: (+1)
   \   0000003C   0x8820             LDRH     R0,[R4, #+0]
   \   0000003E   0xF24F 0x71FF      MOVW     R1,#+63487
   \   00000042   0x4008             ANDS     R0,R1,R0
   \   00000044   0x8020             STRH     R0,[R4, #+0]
    281            /* Set new DFF bit value */
    282            SPIx->CR1 |= SPI_DataSize;
   \   00000046   0x8820             LDRH     R0,[R4, #+0]
   \   00000048   0x4328             ORRS     R0,R5,R0
   \   0000004A   0x8020             STRH     R0,[R4, #+0]
    283          }
   \   0000004C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    284          
    285          /**
    286            * @brief  Selects the data transfer direction in bidirectional mode for the specified SPI.
    287            * @param  SPIx: where x can be 1 or 2  to select the SPI peripheral.
    288            * @param  SPI_Direction: specifies the data transfer direction in bidirectional mode. 
    289            *   This parameter can be one of the following values:
    290            *     @arg SPI_Direction_Tx: Selects Tx transmission direction
    291            *     @arg SPI_Direction_Rx: Selects Rx receive direction
    292            * @retval None
    293            */

   \                                 In section .text, align 2, keep-with-next
    294          void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
    295          {
   \                     SPI_BiDirectionalLineConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    296            /* Check the parameters */
    297            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40013000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD009             BEQ.N    ??SPI_BiDirectionalLineConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable18_1  ;; 0x40003800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD005             BEQ.N    ??SPI_BiDirectionalLineConfig_0
   \   00000016   0xF240 0x1129      MOVW     R1,#+297
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   0000001E   0x.... 0x....      BL       assert_failed
    298            assert_param(IS_SPI_DIRECTION(SPI_Direction));
   \                     ??SPI_BiDirectionalLineConfig_0: (+1)
   \   00000022   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000024   0xF64B 0x70FF      MOVW     R0,#+49151
   \   00000028   0x4285             CMP      R5,R0
   \   0000002A   0xD009             BEQ.N    ??SPI_BiDirectionalLineConfig_1
   \   0000002C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002E   0xF5B5 0x4F80      CMP      R5,#+16384
   \   00000032   0xD005             BEQ.N    ??SPI_BiDirectionalLineConfig_1
   \   00000034   0xF44F 0x7195      MOV      R1,#+298
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   0000003C   0x.... 0x....      BL       assert_failed
    299            if (SPI_Direction == SPI_Direction_Tx)
   \                     ??SPI_BiDirectionalLineConfig_1: (+1)
   \   00000040   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000042   0xF5B5 0x4F80      CMP      R5,#+16384
   \   00000046   0xD104             BNE.N    ??SPI_BiDirectionalLineConfig_2
    300            {
    301              /* Set the Tx only mode */
    302              SPIx->CR1 |= SPI_Direction_Tx;
   \   00000048   0x8820             LDRH     R0,[R4, #+0]
   \   0000004A   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \   0000004E   0x8020             STRH     R0,[R4, #+0]
   \   00000050   0xE004             B.N      ??SPI_BiDirectionalLineConfig_3
    303            }
    304            else
    305            {
    306              /* Set the Rx only mode */
    307              SPIx->CR1 &= SPI_Direction_Rx;
   \                     ??SPI_BiDirectionalLineConfig_2: (+1)
   \   00000052   0x8820             LDRH     R0,[R4, #+0]
   \   00000054   0xF64B 0x71FF      MOVW     R1,#+49151
   \   00000058   0x4008             ANDS     R0,R1,R0
   \   0000005A   0x8020             STRH     R0,[R4, #+0]
    308            }
    309          }
   \                     ??SPI_BiDirectionalLineConfig_3: (+1)
   \   0000005C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    310          
    311          /**
    312            * @brief  Configures internally by software the NSS pin for the selected SPI.
    313            * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
    314            * @param  SPI_NSSInternalSoft: specifies the SPI NSS internal state.
    315            *   This parameter can be one of the following values:
    316            *     @arg SPI_NSSInternalSoft_Set: Set NSS pin internally
    317            *     @arg SPI_NSSInternalSoft_Reset: Reset NSS pin internally
    318            * @retval None
    319            */

   \                                 In section .text, align 2, keep-with-next
    320          void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft)
    321          {
   \                     SPI_NSSInternalSoftwareConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    322            /* Check the parameters */
    323            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40013000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD009             BEQ.N    ??SPI_NSSInternalSoftwareConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable18_1  ;; 0x40003800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD005             BEQ.N    ??SPI_NSSInternalSoftwareConfig_0
   \   00000016   0xF240 0x1143      MOVW     R1,#+323
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   0000001E   0x.... 0x....      BL       assert_failed
    324            assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
   \                     ??SPI_NSSInternalSoftwareConfig_0: (+1)
   \   00000022   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000024   0xF5B5 0x7F80      CMP      R5,#+256
   \   00000028   0xD00A             BEQ.N    ??SPI_NSSInternalSoftwareConfig_1
   \   0000002A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002C   0xF64F 0x60FF      MOVW     R0,#+65279
   \   00000030   0x4285             CMP      R5,R0
   \   00000032   0xD005             BEQ.N    ??SPI_NSSInternalSoftwareConfig_1
   \   00000034   0xF44F 0x71A2      MOV      R1,#+324
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   0000003C   0x.... 0x....      BL       assert_failed
    325            if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
   \                     ??SPI_NSSInternalSoftwareConfig_1: (+1)
   \   00000040   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000042   0xF64F 0x60FF      MOVW     R0,#+65279
   \   00000046   0x4285             CMP      R5,R0
   \   00000048   0xD004             BEQ.N    ??SPI_NSSInternalSoftwareConfig_2
    326            {
    327              /* Set NSS pin internally by software */
    328              SPIx->CR1 |= SPI_NSSInternalSoft_Set;
   \   0000004A   0x8820             LDRH     R0,[R4, #+0]
   \   0000004C   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000050   0x8020             STRH     R0,[R4, #+0]
   \   00000052   0xE004             B.N      ??SPI_NSSInternalSoftwareConfig_3
    329            }
    330            else
    331            {
    332              /* Reset NSS pin internally by software */
    333              SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
   \                     ??SPI_NSSInternalSoftwareConfig_2: (+1)
   \   00000054   0x8820             LDRH     R0,[R4, #+0]
   \   00000056   0xF64F 0x61FF      MOVW     R1,#+65279
   \   0000005A   0x4008             ANDS     R0,R1,R0
   \   0000005C   0x8020             STRH     R0,[R4, #+0]
    334            }
    335          }
   \                     ??SPI_NSSInternalSoftwareConfig_3: (+1)
   \   0000005E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    336          
    337          /**
    338            * @brief  Enables or disables the SS output for the selected SPI.
    339            * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
    340            * @param  NewState: new state of the SPIx SS output. 
    341            *   This parameter can be: ENABLE or DISABLE.
    342            * @retval None
    343            */

   \                                 In section .text, align 2, keep-with-next
    344          void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    345          {
   \                     SPI_SSOutputCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    346            /* Check the parameters */
    347            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40013000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD009             BEQ.N    ??SPI_SSOutputCmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable18_1  ;; 0x40003800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD005             BEQ.N    ??SPI_SSOutputCmd_0
   \   00000016   0xF240 0x115B      MOVW     R1,#+347
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   0000001E   0x.... 0x....      BL       assert_failed
    348            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??SPI_SSOutputCmd_0: (+1)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD008             BEQ.N    ??SPI_SSOutputCmd_1
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD005             BEQ.N    ??SPI_SSOutputCmd_1
   \   0000002E   0xF44F 0x71AE      MOV      R1,#+348
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   00000036   0x.... 0x....      BL       assert_failed
    349            if (NewState != DISABLE)
   \                     ??SPI_SSOutputCmd_1: (+1)
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x2D00             CMP      R5,#+0
   \   0000003E   0xD004             BEQ.N    ??SPI_SSOutputCmd_2
    350            {
    351              /* Enable the selected SPI SS output */
    352              SPIx->CR2 |= (uint16_t)SPI_CR2_SSOE;
   \   00000040   0x88A0             LDRH     R0,[R4, #+4]
   \   00000042   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000046   0x80A0             STRH     R0,[R4, #+4]
   \   00000048   0xE004             B.N      ??SPI_SSOutputCmd_3
    353            }
    354            else
    355            {
    356              /* Disable the selected SPI SS output */
    357              SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_SSOE);
   \                     ??SPI_SSOutputCmd_2: (+1)
   \   0000004A   0x88A0             LDRH     R0,[R4, #+4]
   \   0000004C   0xF64F 0x71FB      MOVW     R1,#+65531
   \   00000050   0x4008             ANDS     R0,R1,R0
   \   00000052   0x80A0             STRH     R0,[R4, #+4]
    358            }
    359          }
   \                     ??SPI_SSOutputCmd_3: (+1)
   \   00000054   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    360          
    361          /**
    362            * @}
    363            */
    364          
    365          /** @defgroup SPI_Group2 Data transfers functions
    366           *  @brief   Data transfers functions
    367           *
    368          @verbatim   
    369           ===============================================================================
    370                                   Data transfers functions
    371           ===============================================================================  
    372          
    373            This section provides a set of functions allowing to manage the SPI data transfers
    374            
    375            In reception, data are received and then stored into an internal Rx buffer while 
    376            In transmission, data are first stored into an internal Tx buffer before being 
    377            transmitted.
    378          
    379            The read access of the SPI_DR register can be done using the SPI_I2S_ReceiveData()
    380            function and returns the Rx buffered value. Whereas a write access to the SPI_DR 
    381            can be done using SPI_I2S_SendData() function and stores the written data into 
    382            Tx buffer.
    383          
    384          @endverbatim
    385            * @{
    386            */
    387          
    388          /**
    389            * @brief  Returns the most recent received data by the SPIx peripheral. 
    390            * @param  SPIx: where x can be 1 or 2 in SPI mode.
    391            * @retval The value of the received data.
    392            */

   \                                 In section .text, align 2, keep-with-next
    393          uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx)
    394          {
   \                     SPI_I2S_ReceiveData: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    395            /* Check the parameters */
    396            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40013000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD009             BEQ.N    ??SPI_I2S_ReceiveData_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable18_1  ;; 0x40003800
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD005             BEQ.N    ??SPI_I2S_ReceiveData_0
   \   00000014   0xF44F 0x71C6      MOV      R1,#+396
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   0000001C   0x.... 0x....      BL       assert_failed
    397            
    398            /* Return the data in the DR register */
    399            return SPIx->DR;
   \                     ??SPI_I2S_ReceiveData_0: (+1)
   \   00000020   0x89A0             LDRH     R0,[R4, #+12]
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    400          }
    401          
    402          /**
    403            * @brief  Transmits a Data through the SPIx peripheral.
    404            * @param  SPIx: where x can be 1 or 2 in SPI mode. 
    405            * @param  Data: Data to be transmitted.
    406            * @retval None
    407            */

   \                                 In section .text, align 2, keep-with-next
    408          void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data)
    409          {
   \                     SPI_I2S_SendData: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    410            /* Check the parameters */
    411            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40013000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD009             BEQ.N    ??SPI_I2S_SendData_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable18_1  ;; 0x40003800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD005             BEQ.N    ??SPI_I2S_SendData_0
   \   00000016   0xF240 0x119B      MOVW     R1,#+411
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   0000001E   0x.... 0x....      BL       assert_failed
    412            
    413            /* Write in the DR register the data to be sent */
    414            SPIx->DR = Data;
   \                     ??SPI_I2S_SendData_0: (+1)
   \   00000022   0x81A5             STRH     R5,[R4, #+12]
    415          }
   \   00000024   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    416          
    417          /**
    418            * @}
    419            */
    420          
    421          /** @defgroup SPI_Group3 Hardware CRC Calculation functions
    422           *  @brief   Hardware CRC Calculation functions
    423           *
    424          @verbatim   
    425           ===============================================================================
    426                                   Hardware CRC Calculation functions
    427           ===============================================================================  
    428          
    429            This section provides a set of functions allowing to manage the SPI CRC hardware 
    430            calculation
    431          
    432            SPI communication using CRC is possible through the following procedure:
    433               1. Program the Data direction, Polarity, Phase, First Data, Baud Rate Prescaler, 
    434                  Slave Management, Peripheral Mode and CRC Polynomial values using the SPI_Init()
    435                  function.
    436               2. Enable the CRC calculation using the SPI_CalculateCRC() function.
    437               3. Enable the SPI using the SPI_Cmd() function
    438               4. Before writing the last data to the TX buffer, set the CRCNext bit using the 
    439                SPI_TransmitCRC() function to indicate that after transmission of the last 
    440                data, the CRC should be transmitted.
    441               5. After transmitting the last data, the SPI transmits the CRC. The SPI_CR1_CRCNEXT
    442                  bit is reset. The CRC is also received and compared against the SPI_RXCRCR 
    443                  value. 
    444                  If the value does not match, the SPI_FLAG_CRCERR flag is set and an interrupt
    445                  can be generated when the SPI_I2S_IT_ERR interrupt is enabled.
    446          
    447          Note: 
    448          -----
    449              - It is advised to don't read the calculate CRC values during the communication.
    450          
    451              - When the SPI is in slave mode, be careful to enable CRC calculation only 
    452                when the clock is stable, that is, when the clock is in the steady state. 
    453                If not, a wrong CRC calculation may be done. In fact, the CRC is sensitive 
    454                to the SCK slave input clock as soon as CRCEN is set, and this, whatever 
    455                the value of the SPE bit.
    456          
    457              - With high bitrate frequencies, be careful when transmitting the CRC.
    458                As the number of used CPU cycles has to be as low as possible in the CRC 
    459                transfer phase, it is forbidden to call software functions in the CRC 
    460                transmission sequence to avoid errors in the last data and CRC reception. 
    461                In fact, CRCNEXT bit has to be written before the end of the transmission/reception 
    462                of the last data.
    463          
    464              - For high bit rate frequencies, it is advised to use the DMA mode to avoid the
    465                degradation of the SPI speed performance due to CPU accesses impacting the 
    466                SPI bandwidth.
    467          
    468              - When the STM32L15xxx are configured as slaves and the NSS hardware mode is 
    469                used, the NSS pin needs to be kept low between the data phase and the CRC 
    470                phase.
    471          
    472              - When the SPI is configured in slave mode with the CRC feature enabled, CRC
    473                calculation takes place even if a high level is applied on the NSS pin. 
    474                This may happen for example in case of a multislave environment where the 
    475                communication master addresses slaves alternately.
    476          
    477              - Between a slave deselection (high level on NSS) and a new slave selection 
    478                (low level on NSS), the CRC value should be cleared on both master and slave
    479                sides in order to resynchronize the master and slave for their respective 
    480                CRC calculation.
    481          
    482              To clear the CRC, follow the procedure below:
    483                1. Disable SPI using the SPI_Cmd() function
    484                2. Disable the CRC calculation using the SPI_CalculateCRC() function.
    485                3. Enable the CRC calculation using the SPI_CalculateCRC() function.
    486                4. Enable SPI using the SPI_Cmd() function.
    487          
    488          @endverbatim
    489            * @{
    490            */
    491          
    492          /**
    493            * @brief  Enables or disables the CRC value calculation of the transferred bytes.
    494            * @param  SPIx: where x can be 1 or 2  to select the SPI peripheral.
    495            * @param  NewState: new state of the SPIx CRC value calculation.
    496            *   This parameter can be: ENABLE or DISABLE.
    497            * @retval None
    498            */

   \                                 In section .text, align 2, keep-with-next
    499          void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)
    500          {
   \                     SPI_CalculateCRC: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    501            /* Check the parameters */
    502            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40013000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD008             BEQ.N    ??SPI_CalculateCRC_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable18_1  ;; 0x40003800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD004             BEQ.N    ??SPI_CalculateCRC_0
   \   00000016   0xF44F 0x71FB      MOV      R1,#+502
   \   0000001A   0x....             LDR.N    R0,??DataTable18_2
   \   0000001C   0x.... 0x....      BL       assert_failed
    503            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??SPI_CalculateCRC_0: (+1)
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD007             BEQ.N    ??SPI_CalculateCRC_1
   \   00000026   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000028   0x2D01             CMP      R5,#+1
   \   0000002A   0xD004             BEQ.N    ??SPI_CalculateCRC_1
   \   0000002C   0xF240 0x11F7      MOVW     R1,#+503
   \   00000030   0x....             LDR.N    R0,??DataTable18_2
   \   00000032   0x.... 0x....      BL       assert_failed
    504            if (NewState != DISABLE)
   \                     ??SPI_CalculateCRC_1: (+1)
   \   00000036   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000038   0x2D00             CMP      R5,#+0
   \   0000003A   0xD004             BEQ.N    ??SPI_CalculateCRC_2
    505            {
    506              /* Enable the selected SPI CRC calculation */
    507              SPIx->CR1 |= SPI_CR1_CRCEN;
   \   0000003C   0x8820             LDRH     R0,[R4, #+0]
   \   0000003E   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   00000042   0x8020             STRH     R0,[R4, #+0]
   \   00000044   0xE004             B.N      ??SPI_CalculateCRC_3
    508            }
    509            else
    510            {
    511              /* Disable the selected SPI CRC calculation */
    512              SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_CRCEN);
   \                     ??SPI_CalculateCRC_2: (+1)
   \   00000046   0x8820             LDRH     R0,[R4, #+0]
   \   00000048   0xF64D 0x71FF      MOVW     R1,#+57343
   \   0000004C   0x4008             ANDS     R0,R1,R0
   \   0000004E   0x8020             STRH     R0,[R4, #+0]
    513            }
    514          }
   \                     ??SPI_CalculateCRC_3: (+1)
   \   00000050   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    515          
    516          /**
    517            * @brief  Transmit the SPIx CRC value.
    518            * @param  SPIx: where x can be 1 or 2  to select the SPI peripheral.
    519            * @retval None
    520            */

   \                                 In section .text, align 2, keep-with-next
    521          void SPI_TransmitCRC(SPI_TypeDef* SPIx)
    522          {
   \                     SPI_TransmitCRC: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    523            /* Check the parameters */
    524            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000004   0x....             LDR.N    R0,??DataTable18  ;; 0x40013000
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD007             BEQ.N    ??SPI_TransmitCRC_0
   \   0000000A   0x....             LDR.N    R0,??DataTable18_1  ;; 0x40003800
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD004             BEQ.N    ??SPI_TransmitCRC_0
   \   00000010   0xF44F 0x7103      MOV      R1,#+524
   \   00000014   0x....             LDR.N    R0,??DataTable18_2
   \   00000016   0x.... 0x....      BL       assert_failed
    525            
    526            /* Enable the selected SPI CRC transmission */
    527            SPIx->CR1 |= SPI_CR1_CRCNEXT;
   \                     ??SPI_TransmitCRC_0: (+1)
   \   0000001A   0x8820             LDRH     R0,[R4, #+0]
   \   0000001C   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   00000020   0x8020             STRH     R0,[R4, #+0]
    528          }
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    529          
    530          /**
    531            * @brief  Returns the transmit or the receive CRC register value for the specified SPI.
    532            * @param  SPIx: where x can be 1 or 2  to select the SPI peripheral.
    533            * @param  SPI_CRC: specifies the CRC register to be read.
    534            *   This parameter can be one of the following values:
    535            *     @arg SPI_CRC_Tx: Selects Tx CRC register
    536            *     @arg SPI_CRC_Rx: Selects Rx CRC register
    537            * @retval The selected CRC register value..
    538            */

   \                                 In section .text, align 2, keep-with-next
    539          uint16_t SPI_GetCRC(SPI_TypeDef* SPIx, uint8_t SPI_CRC)
    540          {
   \                     SPI_GetCRC: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    541            uint16_t crcreg = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    542            /* Check the parameters */
    543            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000008   0x....             LDR.N    R0,??DataTable18  ;; 0x40013000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD007             BEQ.N    ??SPI_GetCRC_0
   \   0000000E   0x....             LDR.N    R0,??DataTable18_1  ;; 0x40003800
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD004             BEQ.N    ??SPI_GetCRC_0
   \   00000014   0xF240 0x211F      MOVW     R1,#+543
   \   00000018   0x....             LDR.N    R0,??DataTable18_2
   \   0000001A   0x.... 0x....      BL       assert_failed
    544            assert_param(IS_SPI_CRC(SPI_CRC));
   \                     ??SPI_GetCRC_0: (+1)
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD007             BEQ.N    ??SPI_GetCRC_1
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0x2D01             CMP      R5,#+1
   \   00000028   0xD004             BEQ.N    ??SPI_GetCRC_1
   \   0000002A   0xF44F 0x7108      MOV      R1,#+544
   \   0000002E   0x....             LDR.N    R0,??DataTable18_2
   \   00000030   0x.... 0x....      BL       assert_failed
    545            if (SPI_CRC != SPI_CRC_Rx)
   \                     ??SPI_GetCRC_1: (+1)
   \   00000034   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000036   0x2D01             CMP      R5,#+1
   \   00000038   0xD002             BEQ.N    ??SPI_GetCRC_2
    546            {
    547              /* Get the Tx CRC register */
    548              crcreg = SPIx->TXCRCR;
   \   0000003A   0x8B20             LDRH     R0,[R4, #+24]
   \   0000003C   0x0006             MOVS     R6,R0
   \   0000003E   0xE001             B.N      ??SPI_GetCRC_3
    549            }
    550            else
    551            {
    552              /* Get the Rx CRC register */
    553              crcreg = SPIx->RXCRCR;
   \                     ??SPI_GetCRC_2: (+1)
   \   00000040   0x8AA0             LDRH     R0,[R4, #+20]
   \   00000042   0x0006             MOVS     R6,R0
    554            }
    555            /* Return the selected CRC register */
    556            return crcreg;
   \                     ??SPI_GetCRC_3: (+1)
   \   00000044   0x0030             MOVS     R0,R6
   \   00000046   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000048   0xBD70             POP      {R4-R6,PC}       ;; return
    557          }
    558          
    559          /**
    560            * @brief  Returns the CRC Polynomial register value for the specified SPI.
    561            * @param  SPIx: where x can be 1 or 2  to select the SPI peripheral.
    562            * @retval The CRC Polynomial register value.
    563            */

   \                                 In section .text, align 2, keep-with-next
    564          uint16_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx)
    565          {
   \                     SPI_GetCRCPolynomial: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    566            /* Check the parameters */
    567            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000004   0x....             LDR.N    R0,??DataTable18  ;; 0x40013000
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD007             BEQ.N    ??SPI_GetCRCPolynomial_0
   \   0000000A   0x....             LDR.N    R0,??DataTable18_1  ;; 0x40003800
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD004             BEQ.N    ??SPI_GetCRCPolynomial_0
   \   00000010   0xF240 0x2137      MOVW     R1,#+567
   \   00000014   0x....             LDR.N    R0,??DataTable18_2
   \   00000016   0x.... 0x....      BL       assert_failed
    568            
    569            /* Return the CRC polynomial register */
    570            return SPIx->CRCPR;
   \                     ??SPI_GetCRCPolynomial_0: (+1)
   \   0000001A   0x8A20             LDRH     R0,[R4, #+16]
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    571          }
    572          
    573          /**
    574            * @}
    575            */
    576          
    577          /** @defgroup SPI_Group4 DMA transfers management functions
    578           *  @brief   DMA transfers management functions
    579            *
    580          @verbatim   
    581           ===============================================================================
    582                                   DMA transfers management functions
    583           ===============================================================================  
    584          
    585          @endverbatim
    586            * @{
    587            */
    588          
    589          /**
    590            * @brief  Enables or disables the SPIx DMA interface.
    591            * @param  SPIx: where x can be 1 or 2 in SPI mode 
    592            * @param  SPI_I2S_DMAReq: specifies the SPI DMA transfer request to be enabled or disabled. 
    593            *   This parameter can be any combination of the following values:
    594            *     @arg SPI_I2S_DMAReq_Tx: Tx buffer DMA transfer request
    595            *     @arg SPI_I2S_DMAReq_Rx: Rx buffer DMA transfer request
    596            * @param  NewState: new state of the selected SPI DMA transfer request.
    597            *   This parameter can be: ENABLE or DISABLE.
    598            * @retval None
    599            */

   \                                 In section .text, align 2, keep-with-next
    600          void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState)
    601          {
   \                     SPI_I2S_DMACmd: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    602            /* Check the parameters */
    603            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000008   0x....             LDR.N    R0,??DataTable18  ;; 0x40013000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD007             BEQ.N    ??SPI_I2S_DMACmd_0
   \   0000000E   0x....             LDR.N    R0,??DataTable18_1  ;; 0x40003800
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD004             BEQ.N    ??SPI_I2S_DMACmd_0
   \   00000014   0xF240 0x215B      MOVW     R1,#+603
   \   00000018   0x....             LDR.N    R0,??DataTable18_2
   \   0000001A   0x.... 0x....      BL       assert_failed
    604            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??SPI_I2S_DMACmd_0: (+1)
   \   0000001E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000020   0x2E00             CMP      R6,#+0
   \   00000022   0xD007             BEQ.N    ??SPI_I2S_DMACmd_1
   \   00000024   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000026   0x2E01             CMP      R6,#+1
   \   00000028   0xD004             BEQ.N    ??SPI_I2S_DMACmd_1
   \   0000002A   0xF44F 0x7117      MOV      R1,#+604
   \   0000002E   0x....             LDR.N    R0,??DataTable18_2
   \   00000030   0x.... 0x....      BL       assert_failed
    605            assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
   \                     ??SPI_I2S_DMACmd_1: (+1)
   \   00000034   0xF64F 0x70FC      MOVW     R0,#+65532
   \   00000038   0x4205             TST      R5,R0
   \   0000003A   0xD102             BNE.N    ??SPI_I2S_DMACmd_2
   \   0000003C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000003E   0x2D00             CMP      R5,#+0
   \   00000040   0xD104             BNE.N    ??SPI_I2S_DMACmd_3
   \                     ??SPI_I2S_DMACmd_2: (+1)
   \   00000042   0xF240 0x215D      MOVW     R1,#+605
   \   00000046   0x....             LDR.N    R0,??DataTable18_2
   \   00000048   0x.... 0x....      BL       assert_failed
    606          
    607            if (NewState != DISABLE)
   \                     ??SPI_I2S_DMACmd_3: (+1)
   \   0000004C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004E   0x2E00             CMP      R6,#+0
   \   00000050   0xD003             BEQ.N    ??SPI_I2S_DMACmd_4
    608            {
    609              /* Enable the selected SPI DMA requests */
    610              SPIx->CR2 |= SPI_I2S_DMAReq;
   \   00000052   0x88A0             LDRH     R0,[R4, #+4]
   \   00000054   0x4328             ORRS     R0,R5,R0
   \   00000056   0x80A0             STRH     R0,[R4, #+4]
   \   00000058   0xE002             B.N      ??SPI_I2S_DMACmd_5
    611            }
    612            else
    613            {
    614              /* Disable the selected SPI DMA requests */
    615              SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
   \                     ??SPI_I2S_DMACmd_4: (+1)
   \   0000005A   0x88A0             LDRH     R0,[R4, #+4]
   \   0000005C   0x43A8             BICS     R0,R0,R5
   \   0000005E   0x80A0             STRH     R0,[R4, #+4]
    616            }
    617          }
   \                     ??SPI_I2S_DMACmd_5: (+1)
   \   00000060   0xBD70             POP      {R4-R6,PC}       ;; return
    618          
    619          /**
    620            * @}
    621            */
    622          
    623          /** @defgroup SPI_Group5 Interrupts and flags management functions
    624           *  @brief   Interrupts and flags management functions
    625            *
    626          @verbatim   
    627           ===============================================================================
    628                                   Interrupts and flags management functions
    629           ===============================================================================  
    630          
    631            This section provides a set of functions allowing to configure the SPI Interrupts 
    632            sources and check or clear the flags or pending bits status.
    633            The user should identify which mode will be used in his application to manage 
    634            the communication: Polling mode, Interrupt mode or DMA mode. 
    635              
    636            Polling Mode
    637            =============
    638            In Polling Mode, the SPI communication can be managed by 6 flags:
    639               1. SPI_I2S_FLAG_TXE : to indicate the status of the transmit buffer register
    640               2. SPI_I2S_FLAG_RXNE : to indicate the status of the receive buffer register
    641               3. SPI_I2S_FLAG_BSY : to indicate the state of the communication layer of the SPI.
    642               4. SPI_FLAG_CRCERR : to indicate if a CRC Calculation error occur              
    643               5. SPI_FLAG_MODF : to indicate if a Mode Fault error occur
    644               6. SPI_I2S_FLAG_OVR : to indicate if an Overrun error occur
    645          
    646          Note: Do not use the BSY flag to handle each data transmission or reception.
    647          ----- It is better to use the TXE and RXNE flags instead.
    648          
    649            In this Mode it is advised to use the following functions:
    650               - FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
    651               - void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
    652          
    653            Interrupt Mode
    654            ===============
    655            In Interrupt Mode, the SPI communication can be managed by 3 interrupt sources
    656            and 5 pending bits: 
    657            Pending Bits:
    658            ------------- 
    659               1. SPI_I2S_IT_TXE : to indicate the status of the transmit buffer register
    660               2. SPI_I2S_IT_RXNE : to indicate the status of the receive buffer register
    661               3. SPI_IT_CRCERR : to indicate if a CRC Calculation error occur              
    662               4. SPI_IT_MODF : to indicate if a Mode Fault error occur
    663               5. SPI_I2S_IT_OVR : to indicate if an Overrun error occur
    664          
    665            Interrupt Source:
    666            -----------------
    667               1. SPI_I2S_IT_TXE: specifies the interrupt source for the Tx buffer empty 
    668                                  interrupt.  
    669               2. SPI_I2S_IT_RXNE : specifies the interrupt source for the Rx buffer not 
    670                                    empty interrupt.
    671               3. SPI_I2S_IT_ERR : specifies the interrupt source for the errors interrupt.
    672          
    673            In this Mode it is advised to use the following functions:
    674               - void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState);
    675               - ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);
    676               - void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);
    677          
    678            DMA Mode
    679            ========
    680            In DMA Mode, the SPI communication can be managed by 2 DMA Channel requests:
    681               1. SPI_I2S_DMAReq_Tx: specifies the Tx buffer DMA transfer request
    682               2. SPI_I2S_DMAReq_Rx: specifies the Rx buffer DMA transfer request
    683          
    684            In this Mode it is advised to use the following function:
    685              - void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState);
    686          
    687          @endverbatim
    688            * @{
    689            */
    690          
    691          /**
    692            * @brief  Enables or disables the specified SPI interrupts.
    693            * @param  SPIx: where x can be 1 or 2 in SPI mode 
    694            * @param  SPI_I2S_IT: specifies the SPI interrupt source to be enabled or disabled. 
    695            *   This parameter can be one of the following values:
    696            *     @arg SPI_I2S_IT_TXE: Tx buffer empty interrupt mask
    697            *     @arg SPI_I2S_IT_RXNE: Rx buffer not empty interrupt mask
    698            *     @arg SPI_I2S_IT_ERR: Error interrupt mask
    699            * @param  NewState: new state of the specified SPI interrupt.
    700            *   This parameter can be: ENABLE or DISABLE.
    701            * @retval None
    702            */

   \                                 In section .text, align 2, keep-with-next
    703          void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState)
    704          {
   \                     SPI_I2S_ITConfig: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    705            uint16_t itpos = 0, itmask = 0 ;
   \   0000000A   0x2700             MOVS     R7,#+0
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
    706            
    707            /* Check the parameters */
    708            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000010   0x....             LDR.N    R0,??DataTable18  ;; 0x40013000
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD007             BEQ.N    ??SPI_I2S_ITConfig_0
   \   00000016   0x....             LDR.N    R0,??DataTable18_1  ;; 0x40003800
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD004             BEQ.N    ??SPI_I2S_ITConfig_0
   \   0000001C   0xF44F 0x7131      MOV      R1,#+708
   \   00000020   0x....             LDR.N    R0,??DataTable18_2
   \   00000022   0x.... 0x....      BL       assert_failed
    709            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??SPI_I2S_ITConfig_0: (+1)
   \   00000026   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000028   0x2E00             CMP      R6,#+0
   \   0000002A   0xD007             BEQ.N    ??SPI_I2S_ITConfig_1
   \   0000002C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002E   0x2E01             CMP      R6,#+1
   \   00000030   0xD004             BEQ.N    ??SPI_I2S_ITConfig_1
   \   00000032   0xF240 0x21C5      MOVW     R1,#+709
   \   00000036   0x....             LDR.N    R0,??DataTable18_2
   \   00000038   0x.... 0x....      BL       assert_failed
    710            assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));
   \                     ??SPI_I2S_ITConfig_1: (+1)
   \   0000003C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003E   0x2D71             CMP      R5,#+113
   \   00000040   0xD00A             BEQ.N    ??SPI_I2S_ITConfig_2
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0x2D60             CMP      R5,#+96
   \   00000046   0xD007             BEQ.N    ??SPI_I2S_ITConfig_2
   \   00000048   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004A   0x2D50             CMP      R5,#+80
   \   0000004C   0xD004             BEQ.N    ??SPI_I2S_ITConfig_2
   \   0000004E   0xF240 0x21C6      MOVW     R1,#+710
   \   00000052   0x....             LDR.N    R0,??DataTable18_2
   \   00000054   0x.... 0x....      BL       assert_failed
    711          
    712            /* Get the SPI IT index */
    713            itpos = SPI_I2S_IT >> 4;
   \                     ??SPI_I2S_ITConfig_2: (+1)
   \   00000058   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005A   0x0928             LSRS     R0,R5,#+4
   \   0000005C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005E   0x0007             MOVS     R7,R0
    714          
    715            /* Set the IT mask */
    716            itmask = (uint16_t)1 << (uint16_t)itpos;
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0x40B8             LSLS     R0,R0,R7
   \   00000064   0x4680             MOV      R8,R0
    717          
    718            if (NewState != DISABLE)
   \   00000066   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000068   0x2E00             CMP      R6,#+0
   \   0000006A   0xD004             BEQ.N    ??SPI_I2S_ITConfig_3
    719            {
    720              /* Enable the selected SPI interrupt */
    721              SPIx->CR2 |= itmask;
   \   0000006C   0x88A0             LDRH     R0,[R4, #+4]
   \   0000006E   0xEA58 0x0000      ORRS     R0,R8,R0
   \   00000072   0x80A0             STRH     R0,[R4, #+4]
   \   00000074   0xE003             B.N      ??SPI_I2S_ITConfig_4
    722            }
    723            else
    724            {
    725              /* Disable the selected SPI interrupt */
    726              SPIx->CR2 &= (uint16_t)~itmask;
   \                     ??SPI_I2S_ITConfig_3: (+1)
   \   00000076   0x88A0             LDRH     R0,[R4, #+4]
   \   00000078   0xEA30 0x0008      BICS     R0,R0,R8
   \   0000007C   0x80A0             STRH     R0,[R4, #+4]
    727            }
    728          }
   \                     ??SPI_I2S_ITConfig_4: (+1)
   \   0000007E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    729          
    730          /**
    731            * @brief  Checks whether the specified SPI flag is set or not.
    732            * @param  SPIx: where x can be 1 or 2 in SPI mode 
    733            * @param  SPI_I2S_FLAG: specifies the SPI flag to check. 
    734            *   This parameter can be one of the following values:
    735            *     @arg SPI_I2S_FLAG_TXE: Transmit buffer empty flag.
    736            *     @arg SPI_I2S_FLAG_RXNE: Receive buffer not empty flag.
    737            *     @arg SPI_I2S_FLAG_BSY: Busy flag.
    738            *     @arg SPI_I2S_FLAG_OVR: Overrun flag.
    739            *     @arg SPI_I2S_FLAG_MODF: Mode Fault flag.
    740            *     @arg SPI_I2S_FLAG_CRCERR: CRC Error flag.
    741            * @retval The new state of SPI_I2S_FLAG (SET or RESET).
    742            */

   \                                 In section .text, align 2, keep-with-next
    743          FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
    744          {
   \                     SPI_I2S_GetFlagStatus: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    745            FlagStatus bitstatus = RESET;
   \   00000006   0x2600             MOVS     R6,#+0
    746            /* Check the parameters */
    747            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000008   0x....             LDR.N    R0,??DataTable18  ;; 0x40013000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD007             BEQ.N    ??SPI_I2S_GetFlagStatus_0
   \   0000000E   0x....             LDR.N    R0,??DataTable18_1  ;; 0x40003800
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD004             BEQ.N    ??SPI_I2S_GetFlagStatus_0
   \   00000014   0xF240 0x21EB      MOVW     R1,#+747
   \   00000018   0x....             LDR.N    R0,??DataTable18_2
   \   0000001A   0x.... 0x....      BL       assert_failed
    748            assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
   \                     ??SPI_I2S_GetFlagStatus_0: (+1)
   \   0000001E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000020   0x2D80             CMP      R5,#+128
   \   00000022   0xD013             BEQ.N    ??SPI_I2S_GetFlagStatus_1
   \   00000024   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000026   0x2D40             CMP      R5,#+64
   \   00000028   0xD010             BEQ.N    ??SPI_I2S_GetFlagStatus_1
   \   0000002A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002C   0x2D20             CMP      R5,#+32
   \   0000002E   0xD00D             BEQ.N    ??SPI_I2S_GetFlagStatus_1
   \   00000030   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000032   0x2D10             CMP      R5,#+16
   \   00000034   0xD00A             BEQ.N    ??SPI_I2S_GetFlagStatus_1
   \   00000036   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000038   0x2D02             CMP      R5,#+2
   \   0000003A   0xD007             BEQ.N    ??SPI_I2S_GetFlagStatus_1
   \   0000003C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000003E   0x2D01             CMP      R5,#+1
   \   00000040   0xD004             BEQ.N    ??SPI_I2S_GetFlagStatus_1
   \   00000042   0xF44F 0x713B      MOV      R1,#+748
   \   00000046   0x....             LDR.N    R0,??DataTable18_2
   \   00000048   0x.... 0x....      BL       assert_failed
    749            
    750            /* Check the status of the specified SPI flag */
    751            if ((SPIx->SR & SPI_I2S_FLAG) != (uint16_t)RESET)
   \                     ??SPI_I2S_GetFlagStatus_1: (+1)
   \   0000004C   0x8920             LDRH     R0,[R4, #+8]
   \   0000004E   0x4228             TST      R0,R5
   \   00000050   0xD002             BEQ.N    ??SPI_I2S_GetFlagStatus_2
    752            {
    753              /* SPI_I2S_FLAG is set */
    754              bitstatus = SET;
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0x0006             MOVS     R6,R0
   \   00000056   0xE001             B.N      ??SPI_I2S_GetFlagStatus_3
    755            }
    756            else
    757            {
    758              /* SPI_I2S_FLAG is reset */
    759              bitstatus = RESET;
   \                     ??SPI_I2S_GetFlagStatus_2: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x0006             MOVS     R6,R0
    760            }
    761            /* Return the SPI_I2S_FLAG status */
    762            return  bitstatus;
   \                     ??SPI_I2S_GetFlagStatus_3: (+1)
   \   0000005C   0x0030             MOVS     R0,R6
   \   0000005E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000060   0xBD70             POP      {R4-R6,PC}       ;; return
    763          }
    764          
    765          /**
    766            * @brief  Clears the SPIx CRC Error (CRCERR) flag.
    767            * @param  SPIx: where x can be 1 or 2 in SPI mode 
    768            * @param  SPI_I2S_FLAG: specifies the SPI flag to clear. 
    769            *   This function clears only CRCERR flag.
    770            * @note
    771            *   - OVR (OverRun error) flag is cleared by software sequence: a read 
    772            *     operation to SPI_DR register (SPI_I2S_ReceiveData()) followed by a read 
    773            *     operation to SPI_SR register (SPI_I2S_GetFlagStatus()).
    774            *   - MODF (Mode Fault) flag is cleared by software sequence: a read/write 
    775            *     operation to SPI_SR register (SPI_I2S_GetFlagStatus()) followed by a 
    776            *     write operation to SPI_CR1 register (SPI_Cmd() to enable the SPI).
    777            * @retval None
    778            */

   \                                 In section .text, align 2, keep-with-next
    779          void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
    780          {
   \                     SPI_I2S_ClearFlag: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    781            /* Check the parameters */
    782            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000006   0x....             LDR.N    R0,??DataTable18  ;; 0x40013000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD007             BEQ.N    ??SPI_I2S_ClearFlag_0
   \   0000000C   0x....             LDR.N    R0,??DataTable18_1  ;; 0x40003800
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD004             BEQ.N    ??SPI_I2S_ClearFlag_0
   \   00000012   0xF240 0x310E      MOVW     R1,#+782
   \   00000016   0x....             LDR.N    R0,??DataTable18_2
   \   00000018   0x.... 0x....      BL       assert_failed
    783            assert_param(IS_SPI_I2S_CLEAR_FLAG(SPI_I2S_FLAG));
   \                     ??SPI_I2S_ClearFlag_0: (+1)
   \   0000001C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000001E   0x2D10             CMP      R5,#+16
   \   00000020   0xD004             BEQ.N    ??SPI_I2S_ClearFlag_1
   \   00000022   0xF240 0x310F      MOVW     R1,#+783
   \   00000026   0x....             LDR.N    R0,??DataTable18_2
   \   00000028   0x.... 0x....      BL       assert_failed
    784              
    785            /* Clear the selected SPI CRC Error (CRCERR) flag */
    786            SPIx->SR = (uint16_t)~SPI_I2S_FLAG;
   \                     ??SPI_I2S_ClearFlag_1: (+1)
   \   0000002C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002E   0x43E8             MVNS     R0,R5
   \   00000030   0x8120             STRH     R0,[R4, #+8]
    787          }
   \   00000032   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    788          
    789          /**
    790            * @brief  Checks whether the specified SPI interrupt has occurred or not.
    791            * @param  SPIx: where x can be
    792            *   - 1 or 2 in SPI mode 
    793            * @param  SPI_I2S_IT: specifies the SPI interrupt source to check. 
    794            *   This parameter can be one of the following values:
    795            *     @arg SPI_I2S_IT_TXE: Transmit buffer empty interrupt.
    796            *     @arg SPI_I2S_IT_RXNE: Receive buffer not empty interrupt.
    797            *     @arg SPI_I2S_IT_OVR: Overrun interrupt.
    798            *     @arg SPI_I2S_IT_MODF: Mode Fault interrupt.
    799            *     @arg SPI_I2S_IT_CRCERR: CRC Error interrupt.
    800            * @retval The new state of SPI_I2S_IT (SET or RESET).
    801            */

   \                                 In section .text, align 2, keep-with-next
    802          ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
    803          {
   \                     SPI_I2S_GetITStatus: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    804            ITStatus bitstatus = RESET;
   \   00000008   0x2600             MOVS     R6,#+0
    805            uint16_t itpos = 0, itmask = 0, enablestatus = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   \   00000010   0xF05F 0x0900      MOVS     R9,#+0
    806          
    807            /* Check the parameters */
    808            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000014   0x....             LDR.N    R0,??DataTable18  ;; 0x40013000
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD007             BEQ.N    ??SPI_I2S_GetITStatus_0
   \   0000001A   0x....             LDR.N    R0,??DataTable18_1  ;; 0x40003800
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD004             BEQ.N    ??SPI_I2S_GetITStatus_0
   \   00000020   0xF44F 0x714A      MOV      R1,#+808
   \   00000024   0x....             LDR.N    R0,??DataTable18_2
   \   00000026   0x.... 0x....      BL       assert_failed
    809            assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));
   \                     ??SPI_I2S_GetITStatus_0: (+1)
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0x2D60             CMP      R5,#+96
   \   0000002E   0xD010             BEQ.N    ??SPI_I2S_GetITStatus_1
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D71             CMP      R5,#+113
   \   00000034   0xD00D             BEQ.N    ??SPI_I2S_GetITStatus_1
   \   00000036   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000038   0x2D54             CMP      R5,#+84
   \   0000003A   0xD00A             BEQ.N    ??SPI_I2S_GetITStatus_1
   \   0000003C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003E   0x2D55             CMP      R5,#+85
   \   00000040   0xD007             BEQ.N    ??SPI_I2S_GetITStatus_1
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0x2D56             CMP      R5,#+86
   \   00000046   0xD004             BEQ.N    ??SPI_I2S_GetITStatus_1
   \   00000048   0xF240 0x3129      MOVW     R1,#+809
   \   0000004C   0x....             LDR.N    R0,??DataTable18_2
   \   0000004E   0x.... 0x....      BL       assert_failed
    810          
    811            /* Get the SPI_I2S_IT index */
    812            itpos = 0x01 << (SPI_I2S_IT & 0x0F);
   \                     ??SPI_I2S_GetITStatus_1: (+1)
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0xF015 0x010F      ANDS     R1,R5,#0xF
   \   00000058   0x4088             LSLS     R0,R0,R1
   \   0000005A   0x0007             MOVS     R7,R0
    813          
    814            /* Get the SPI_I2S_IT IT mask */
    815            itmask = SPI_I2S_IT >> 4;
   \   0000005C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005E   0x0928             LSRS     R0,R5,#+4
   \   00000060   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000062   0x4680             MOV      R8,R0
    816          
    817            /* Set the IT mask */
    818            itmask = 0x01 << itmask;
   \   00000064   0x2001             MOVS     R0,#+1
   \   00000066   0xFA10 0xF808      LSLS     R8,R0,R8
    819          
    820            /* Get the SPI_I2S_IT enable bit status */
    821            enablestatus = (SPIx->CR2 & itmask) ;
   \   0000006A   0x88A0             LDRH     R0,[R4, #+4]
   \   0000006C   0xEA18 0x0000      ANDS     R0,R8,R0
   \   00000070   0x4681             MOV      R9,R0
    822          
    823            /* Check the status of the specified SPI interrupt */
    824            if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
   \   00000072   0x8920             LDRH     R0,[R4, #+8]
   \   00000074   0x4238             TST      R0,R7
   \   00000076   0xD007             BEQ.N    ??SPI_I2S_GetITStatus_2
   \   00000078   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000007C   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000080   0xD002             BEQ.N    ??SPI_I2S_GetITStatus_2
    825            {
    826              /* SPI_I2S_IT is set */
    827              bitstatus = SET;
   \   00000082   0x2001             MOVS     R0,#+1
   \   00000084   0x0006             MOVS     R6,R0
   \   00000086   0xE001             B.N      ??SPI_I2S_GetITStatus_3
    828            }
    829            else
    830            {
    831              /* SPI_I2S_IT is reset */
    832              bitstatus = RESET;
   \                     ??SPI_I2S_GetITStatus_2: (+1)
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x0006             MOVS     R6,R0
    833            }
    834            /* Return the SPI_I2S_IT status */
    835            return bitstatus;
   \                     ??SPI_I2S_GetITStatus_3: (+1)
   \   0000008C   0x0030             MOVS     R0,R6
   \   0000008E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000090   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    836          }
    837          
    838          /**
    839            * @brief  Clears the SPIx CRC Error (CRCERR) interrupt pending bit.
    840            * @param  SPIx: where x can be
    841            *   - 1 or 2 in SPI mode 
    842            * @param  SPI_I2S_IT: specifies the SPI interrupt pending bit to clear.
    843            *   This function clears only CRCERR interrupt pending bit.   
    844            * @note
    845            *   - OVR (OverRun Error) interrupt pending bit is cleared by software 
    846            *     sequence: a read operation to SPI_DR register (SPI_I2S_ReceiveData()) 
    847            *     followed by a read operation to SPI_SR register (SPI_I2S_GetITStatus()).
    848            *   - MODF (Mode Fault) interrupt pending bit is cleared by software sequence:
    849            *     a read/write operation to SPI_SR register (SPI_I2S_GetITStatus()) 
    850            *     followed by a write operation to SPI_CR1 register (SPI_Cmd() to enable 
    851            *     the SPI).
    852            * @retval None
    853            */

   \                                 In section .text, align 2, keep-with-next
    854          void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
    855          {
   \                     SPI_I2S_ClearITPendingBit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    856            uint16_t itpos = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    857            /* Check the parameters */
    858            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000008   0x....             LDR.N    R0,??DataTable18  ;; 0x40013000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD007             BEQ.N    ??SPI_I2S_ClearITPendingBit_0
   \   0000000E   0x....             LDR.N    R0,??DataTable18_1  ;; 0x40003800
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD004             BEQ.N    ??SPI_I2S_ClearITPendingBit_0
   \   00000014   0xF240 0x315A      MOVW     R1,#+858
   \   00000018   0x....             LDR.N    R0,??DataTable18_2
   \   0000001A   0x.... 0x....      BL       assert_failed
    859            assert_param(IS_SPI_I2S_CLEAR_IT(SPI_I2S_IT));
   \                     ??SPI_I2S_ClearITPendingBit_0: (+1)
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D54             CMP      R5,#+84
   \   00000022   0xD004             BEQ.N    ??SPI_I2S_ClearITPendingBit_1
   \   00000024   0xF240 0x315B      MOVW     R1,#+859
   \   00000028   0x....             LDR.N    R0,??DataTable18_2
   \   0000002A   0x.... 0x....      BL       assert_failed
    860          
    861            /* Get the SPI_I2S IT index */
    862            itpos = 0x01 << (SPI_I2S_IT & 0x0F);
   \                     ??SPI_I2S_ClearITPendingBit_1: (+1)
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF015 0x010F      ANDS     R1,R5,#0xF
   \   00000034   0x4088             LSLS     R0,R0,R1
   \   00000036   0x0006             MOVS     R6,R0
    863          
    864            /* Clear the selected SPI CRC Error (CRCERR) interrupt pending bit */
    865            SPIx->SR = (uint16_t)~itpos;
   \   00000038   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000003A   0x43F0             MVNS     R0,R6
   \   0000003C   0x8120             STRH     R0,[R4, #+8]
    866          }
   \   0000003E   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x40013000         DC32     0x40013000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0x40003800         DC32     0x40003800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x45 0x3A          DC8 45H, 3AH, 5CH, 41H, 43H, 51H, 5CH, 50H
   \              0x5C 0x41    
   \              0x43 0x51    
   \              0x5C 0x50    
   \   00000008   0x72 0x6F          DC8 72H, 6FH, 6AH, 5FH, 76H, 65H, 72H, 30H
   \              0x6A 0x5F    
   \              0x76 0x65    
   \              0x72 0x30    
   \   00000010   0x39 0x61          DC8 39H, 61H, 5FH, 31H, 35H, 31H, 30H, 32H
   \              0x5F 0x31    
   \              0x35 0x31    
   \              0x30 0x32    
   \   00000018   0x30 0x31          DC8 30H, 31H, 35H, 5CH, 42H, 61H, 73H, 65H
   \              0x35 0x5C    
   \              0x42 0x61    
   \              0x73 0x65    
   \   00000020   0x5F 0x30          DC8 5FH, 30H, 32H, 5CH, 32H, 30H, 31H, 33H
   \              0x32 0x5C    
   \              0x32 0x30    
   \              0x31 0x33    
   \   00000028   0x5F 0x31          DC8 5FH, 31H, 31H, 5FH, 32H, 35H, 5FH, 53H
   \              0x31 0x5F    
   \              0x32 0x35    
   \              0x5F 0x53    
   \   00000030   0x70 0x69          DC8 70H, 69H, 72H, 69H, 74H, 31H, 5FH, 45H
   \              0x72 0x69    
   \              0x74 0x31    
   \              0x5F 0x45    
   \   00000038   0x6C 0x65          DC8 6CH, 65H, 6BH, 74H, 72H, 6FH, 6CH, 75H
   \              0x6B 0x74    
   \              0x72 0x6F    
   \              0x6C 0x75    
   \   00000040   0x78 0x5C          DC8 78H, 5CH, 53H, 54H, 4DH, 33H, 32H, 4CH
   \              0x53 0x54    
   \              0x4D 0x33    
   \              0x32 0x4C    
   \   00000048   0x5C 0x53          DC8 5CH, 53H, 54H, 4DH, 33H, 32H, 4CH, 31H
   \              0x54 0x4D    
   \              0x33 0x32    
   \              0x4C 0x31    
   \   00000050   0x78 0x78          DC8 78H, 78H, 5FH, 53H, 74H, 64H, 50H, 65H
   \              0x5F 0x53    
   \              0x74 0x64    
   \              0x50 0x65    
   \   00000058   0x72 0x69          DC8 72H, 69H, 70H, 68H, 5FH, 4CH, 69H, 62H
   \              0x70 0x68    
   \              0x5F 0x4C    
   \              0x69 0x62    
   \   00000060   0x5C 0x53          DC8 5CH, 53H, 6FH, 75H, 72H, 63H, 65H, 5CH
   \              0x6F 0x75    
   \              0x72 0x63    
   \              0x65 0x5C    
   \   00000068   0x53 0x54          DC8 53H, 54H, 4DH, 33H, 32H, 4CH, 31H, 78H
   \              0x4D 0x33    
   \              0x32 0x4C    
   \              0x31 0x78    
   \   00000070   0x78 0x5F          DC8 78H, 5FH, 53H, 74H, 64H, 50H, 65H, 72H
   \              0x53 0x74    
   \              0x64 0x50    
   \              0x65 0x72    
   \   00000078   0x69 0x70          DC8 69H, 70H, 68H, 5FH, 44H, 72H, 69H, 76H
   \              0x68 0x5F    
   \              0x44 0x72    
   \              0x69 0x76    
   \   00000080   0x65 0x72          DC8 65H, 72H, 5CH, 73H, 72H, 63H, 5CH, 73H
   \              0x5C 0x73    
   \              0x72 0x63    
   \              0x5C 0x73    
   \   00000088   0x74 0x6D          DC8 74H, 6DH, 33H, 32H, 6CH, 31H, 78H, 78H
   \              0x33 0x32    
   \              0x6C 0x31    
   \              0x78 0x78    
   \   00000090   0x5F 0x73          DC8 5FH, 73H, 70H, 69H, 2EH, 63H, 0
   \              0x70 0x69    
   \              0x2E 0x63    
   \              0x00         
   \   00000097   0x00               DC8 0
    867          
    868          /**
    869            * @}
    870            */
    871          
    872          /**
    873            * @}
    874            */ 
    875          
    876          /**
    877            * @}
    878            */ 
    879          
    880          /**
    881            * @}
    882            */ 
    883          
    884          /******************* (C) COPYRIGHT 2010 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   SPI_BiDirectionalLineConfig
        16   -> assert_failed
      16   SPI_CalculateCRC
        16   -> assert_failed
      16   SPI_Cmd
        16   -> assert_failed
      16   SPI_DataSizeConfig
        16   -> assert_failed
      16   SPI_GetCRC
        16   -> assert_failed
       8   SPI_GetCRCPolynomial
         8   -> assert_failed
      16   SPI_I2S_ClearFlag
        16   -> assert_failed
      16   SPI_I2S_ClearITPendingBit
        16   -> assert_failed
      16   SPI_I2S_DMACmd
        16   -> assert_failed
       8   SPI_I2S_DeInit
         8   -> RCC_APB1PeriphResetCmd
         8   -> RCC_APB2PeriphResetCmd
         8   -> assert_failed
      16   SPI_I2S_GetFlagStatus
        16   -> assert_failed
      32   SPI_I2S_GetITStatus
        32   -> assert_failed
      24   SPI_I2S_ITConfig
        24   -> assert_failed
       8   SPI_I2S_ReceiveData
         8   -> assert_failed
      16   SPI_I2S_SendData
        16   -> assert_failed
      16   SPI_Init
        16   -> assert_failed
      16   SPI_NSSInternalSoftwareConfig
        16   -> assert_failed
      16   SPI_SSOutputCmd
        16   -> assert_failed
       0   SPI_StructInit
       8   SPI_TransmitCRC
         8   -> assert_failed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
     152  ?_0
      94  SPI_BiDirectionalLineConfig
      82  SPI_CalculateCRC
      82  SPI_Cmd
      78  SPI_DataSizeConfig
      74  SPI_GetCRC
      30  SPI_GetCRCPolynomial
      52  SPI_I2S_ClearFlag
      64  SPI_I2S_ClearITPendingBit
      98  SPI_I2S_DMACmd
      90  SPI_I2S_DeInit
      98  SPI_I2S_GetFlagStatus
     148  SPI_I2S_GetITStatus
     130  SPI_I2S_ITConfig
      36  SPI_I2S_ReceiveData
      38  SPI_I2S_SendData
     334  SPI_Init
      96  SPI_NSSInternalSoftwareConfig
      86  SPI_SSOutputCmd
      38  SPI_StructInit
      36  SPI_TransmitCRC

 
   152 bytes in section .rodata
 1 796 bytes in section .text
 
 1 796 bytes of CODE  memory
   152 bytes of CONST memory

Errors: none
Warnings: none
