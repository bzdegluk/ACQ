###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        20/Nov/2015  05:05:27
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\SPIRIT1_Library\Source\src\SPIRIT_Calibration.c
#    Command line =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\SPIRIT1_Library\Source\src\SPIRIT_Calibration.c
#        -D USE_STDPERIPH_DRIVER -D VECT_TAB_FLASH -D STM32L1XX_MD -D
#        IAR_ARM_CM3 -D USE_FULL_ASSERT -D SPIRIT_USE_FULL_ASSERT -D
#        USE_SYSTICK_DELAY -D SDK -lC
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\List\
#        -o
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\.\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\examples\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\runtime\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\SDK_Eval_STM32L\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\SPIRIT1_Library\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\SDK_Eval_Util\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\SDK_Virtual_Com\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32_USB-FS-Device_Lib\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\ACQ\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\CMSIS\Include\"
#    List file    =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\List\SPIRIT_Calibration.lst
#    Object file  =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\Obj\SPIRIT_Calibration.o
#
###############################################################################

E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\SPIRIT1_Library\Source\src\SPIRIT_Calibration.c
      1          /**
      2           * @file    SPIRIT_Calibration.c
      3           * @author  High End Analog & RF BU - AMS / ART Team IMS-Systems Lab
      4           * @version V3.0.1
      5           * @date    November 19, 2012
      6           * @brief   Configuration and management of SPIRIT VCO-RCO calibration.
      7           * @details
      8           *
      9           * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     10           * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     11           * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     12           * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     13           * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     14           * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     15           *
     16           * THIS SOURCE CODE IS PROTECTED BY A LICENSE.
     17           * FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED
     18           * IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
     19           *
     20           * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     21           */
     22          
     23          
     24          /* Includes ------------------------------------------------------------------*/
     25          #include "SPIRIT_Calibration.h"
     26          #include "MCU_Interface.h"
     27          
     28          
     29          
     30          
     31          /**
     32           * @addtogroup SPIRIT_Libraries
     33           * @{
     34           */
     35          
     36          
     37          /**
     38           * @addtogroup SPIRIT_Calibration
     39           * @{
     40           */
     41          
     42          
     43          /**
     44           * @defgroup Calibration_Private_TypesDefinitions       Calibration Private Types Definitions
     45           * @{
     46           */
     47          
     48          /**
     49           *@}
     50           */
     51          
     52          
     53          /**
     54           * @defgroup Calibration_Private_Defines                Calibration Private Defines
     55           * @{
     56           */
     57          
     58          
     59          /**
     60           *@}
     61           */
     62          
     63          
     64          /**
     65           * @defgroup Calibration_Private_Macros                 Calibration Private Macros
     66           * @{
     67           */
     68          
     69          /**
     70           *@}
     71           */
     72          
     73          
     74          /**
     75           * @defgroup Calibration_Private_Variables              Calibration Private Variables
     76           * @{
     77           */
     78          
     79          /**
     80           *@}
     81           */
     82          
     83          
     84          
     85          /**
     86           * @defgroup Calibration_Private_FunctionPrototypes     Calibration Private Function Prototypes
     87           * @{
     88           */
     89          
     90          /**
     91           *@}
     92           */
     93          
     94          
     95          /**
     96           * @defgroup Calibration_Private_Functions              Calibration Private Functions
     97           * @{
     98           */
     99          
    100          /**
    101           * @brief  Enables or Disables the RCO calibration.
    102           * @param  xNewState new state for RCO calibration.
    103                     This parameter can be S_ENABLE or S_DISABLE.
    104           * @retval None.
    105           */

   \                                 In section .text, align 2, keep-with-next
    106          void SpiritCalibrationRco(SpiritFunctionalState xNewState)
    107          {
   \                     SpiritCalibrationRco: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    108            uint8_t tempRegValue;
    109          
    110            /* Check the parameters */
    111            s_assert_param(IS_SPIRIT_FUNCTIONAL_STATE(xNewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??SpiritCalibrationRco_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD004             BEQ.N    ??SpiritCalibrationRco_0
   \   00000010   0x216F             MOVS     R1,#+111
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000016   0x.... 0x....      BL       s_assert_failed
    112          
    113            /* Reads the register value */
    114            g_xStatus = SpiritSpiReadRegisters(PROTOCOL2_BASE, 1, &tempRegValue);
   \                     ??SpiritCalibrationRco_0: (+1)
   \   0000001A   0xAA00             ADD      R2,SP,#+0
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x2050             MOVS     R0,#+80
   \   00000020   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   00000024   0x9001             STR      R0,[SP, #+4]
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable11_1
   \   0000002A   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   0000002E   0x8001             STRH     R1,[R0, #+0]
    115          
    116            /* Build new value for the register */
    117            if(xNewState==S_ENABLE)
   \   00000030   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000032   0x2C01             CMP      R4,#+1
   \   00000034   0xD106             BNE.N    ??SpiritCalibrationRco_1
    118            {
    119              tempRegValue |= PROTOCOL2_RCO_CALIBRATION_MASK;
   \   00000036   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000003A   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000003E   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000042   0xE005             B.N      ??SpiritCalibrationRco_2
    120            }
    121            else
    122            {
    123              tempRegValue &= ~PROTOCOL2_RCO_CALIBRATION_MASK;
   \                     ??SpiritCalibrationRco_1: (+1)
   \   00000044   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000048   0xF010 0x00FB      ANDS     R0,R0,#0xFB
   \   0000004C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    124            }
    125          
    126            /* Writes register to enable or disable the RCO calibration */
    127            g_xStatus = SpiritSpiWriteRegisters(PROTOCOL2_BASE, 1, &tempRegValue);
   \                     ??SpiritCalibrationRco_2: (+1)
   \   00000050   0xAA00             ADD      R2,SP,#+0
   \   00000052   0x2101             MOVS     R1,#+1
   \   00000054   0x2050             MOVS     R0,#+80
   \   00000056   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   0000005A   0x9001             STR      R0,[SP, #+4]
   \   0000005C   0x....             LDR.N    R0,??DataTable11_1
   \   0000005E   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000062   0x8001             STRH     R1,[R0, #+0]
    128          
    129          }
   \   00000064   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    130          
    131          
    132          /**
    133           * @brief  Enables or Disables the VCO calibration.
    134           * @param  xNewState new state for VCO calibration.
    135                     This parameter can be S_ENABLE or S_DISABLE.
    136           * @retval None.
    137           */

   \                                 In section .text, align 2, keep-with-next
    138          void SpiritCalibrationVco(SpiritFunctionalState xNewState)
    139          {
   \                     SpiritCalibrationVco: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    140            uint8_t tempRegValue;
    141          
    142            /* Check the parameters */
    143            s_assert_param(IS_SPIRIT_FUNCTIONAL_STATE(xNewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD006             BEQ.N    ??SpiritCalibrationVco_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD003             BEQ.N    ??SpiritCalibrationVco_0
   \   00000010   0x218F             MOVS     R1,#+143
   \   00000012   0x....             LDR.N    R0,??DataTable11
   \   00000014   0x.... 0x....      BL       s_assert_failed
    144          
    145            /* Reads the register value */
    146            g_xStatus = SpiritSpiReadRegisters(PROTOCOL2_BASE, 1, &tempRegValue);
   \                     ??SpiritCalibrationVco_0: (+1)
   \   00000018   0xAA00             ADD      R2,SP,#+0
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x2050             MOVS     R0,#+80
   \   0000001E   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   00000022   0x9001             STR      R0,[SP, #+4]
   \   00000024   0x....             LDR.N    R0,??DataTable11_1
   \   00000026   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   0000002A   0x8001             STRH     R1,[R0, #+0]
    147          
    148             /* Build new value for the register */
    149            if(xNewState==S_ENABLE)
   \   0000002C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002E   0x2C01             CMP      R4,#+1
   \   00000030   0xD106             BNE.N    ??SpiritCalibrationVco_1
    150              tempRegValue |= PROTOCOL2_VCO_CALIBRATION_MASK;
   \   00000032   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000036   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000003A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000003E   0xE005             B.N      ??SpiritCalibrationVco_2
    151            else
    152              tempRegValue &= ~PROTOCOL2_VCO_CALIBRATION_MASK;
   \                     ??SpiritCalibrationVco_1: (+1)
   \   00000040   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000044   0xF010 0x00FD      ANDS     R0,R0,#0xFD
   \   00000048   0xF88D 0x0000      STRB     R0,[SP, #+0]
    153          
    154            /* Writes register to enable or disable the VCO calibration */
    155            g_xStatus = SpiritSpiWriteRegisters(PROTOCOL2_BASE, 1, &tempRegValue);
   \                     ??SpiritCalibrationVco_2: (+1)
   \   0000004C   0xAA00             ADD      R2,SP,#+0
   \   0000004E   0x2101             MOVS     R1,#+1
   \   00000050   0x2050             MOVS     R0,#+80
   \   00000052   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000056   0x9001             STR      R0,[SP, #+4]
   \   00000058   0x....             LDR.N    R0,??DataTable11_1
   \   0000005A   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   0000005E   0x8001             STRH     R1,[R0, #+0]
    156          
    157          }
   \   00000060   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    158          
    159          
    160          /**
    161           * @brief  Sets the RCO calibration words.
    162           * @param  cRwt RWT word for RCO calibration.
    163           *         This parameter can be a value of uint8_t.
    164           * @param  cRfb RFB word for RCO calibration.
    165           *         This parameter can be a value of uint8_t.
    166           * @retval None.
    167           */

   \                                 In section .text, align 2, keep-with-next
    168          void SpiritCalibrationSetRcoCalWords(uint8_t cRwt, uint8_t cRfb)
    169          {
   \                     SpiritCalibrationSetRcoCalWords: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    170            uint8_t tempRegValue[2];
    171          
    172            /* Build the value of RWT and the MSbits of the RFB word */
    173            tempRegValue[0] = (cRwt << 4) | (cRfb >> 1);
   \   00000008   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000A   0x0868             LSRS     R0,R5,#+1
   \   0000000C   0xEA50 0x1004      ORRS     R0,R0,R4, LSL #+4
   \   00000010   0xF88D 0x0000      STRB     R0,[SP, #+0]
    174          
    175            /* Reads the register value to update the LSbit of RFB */
    176            g_xStatus = SpiritSpiReadRegisters(RCO_VCO_CALIBR_IN1_BASE, 1, &tempRegValue[1]);
   \   00000014   0xF10D 0x0201      ADD      R2,SP,#+1
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x206E             MOVS     R0,#+110
   \   0000001C   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   00000020   0x9001             STR      R0,[SP, #+4]
   \   00000022   0x....             LDR.N    R0,??DataTable11_1
   \   00000024   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000028   0x8001             STRH     R1,[R0, #+0]
    177          
    178            /* Build new value for the register */
    179            tempRegValue[1] = (tempRegValue[1] & 0x7F) | (cRfb<<7);
   \   0000002A   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000002E   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   00000032   0xEA50 0x10C5      ORRS     R0,R0,R5, LSL #+7
   \   00000036   0xF88D 0x0001      STRB     R0,[SP, #+1]
    180          
    181            /* Writes the new value for RCO calibration words */
    182            g_xStatus = SpiritSpiWriteRegisters(RCO_VCO_CALIBR_IN2_BASE, 2, tempRegValue);
   \   0000003A   0xAA00             ADD      R2,SP,#+0
   \   0000003C   0x2102             MOVS     R1,#+2
   \   0000003E   0x206D             MOVS     R0,#+109
   \   00000040   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000044   0x9001             STR      R0,[SP, #+4]
   \   00000046   0x....             LDR.N    R0,??DataTable11_1
   \   00000048   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   0000004C   0x8001             STRH     R1,[R0, #+0]
    183          
    184          }
   \   0000004E   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    185          
    186          
    187          /**
    188           * @brief  Returns the RCO calibration words.
    189           * @param  pcRwt pointer to the variable in which the RWT word has to be stored.
    190           *         This parameter is a variable of uint8_t*.
    191           * @param  pcRfb pointer to the variable in which the RFB word has to be stored.
    192           *         This parameter is a variable of uint8_t*.
    193           * @retval None.
    194           */

   \                                 In section .text, align 2, keep-with-next
    195          void SpiritCalibrationGetRcoCalWords(uint8_t* pcRwt, uint8_t* pcRfb)
    196          {
   \                     SpiritCalibrationGetRcoCalWords: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    197            uint8_t tempRegValue[2];
    198          
    199            /* Reads the registers values */
    200            g_xStatus = SpiritSpiReadRegisters(RCO_VCO_CALIBR_OUT1_BASE, 2, tempRegValue);
   \   00000008   0xAA00             ADD      R2,SP,#+0
   \   0000000A   0x2102             MOVS     R1,#+2
   \   0000000C   0x20E4             MOVS     R0,#+228
   \   0000000E   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   00000012   0x9001             STR      R0,[SP, #+4]
   \   00000014   0x....             LDR.N    R0,??DataTable11_1
   \   00000016   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   0000001A   0x8001             STRH     R1,[R0, #+0]
    201          
    202            /* Build the RWT value */
    203            (*pcRwt) = tempRegValue[0] >> 4;
   \   0000001C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x0900             LSRS     R0,R0,#+4
   \   00000024   0x7020             STRB     R0,[R4, #+0]
    204            /* Build the RFB value */
    205            (*pcRfb) = (tempRegValue[0] & 0x0F)<<1 | (tempRegValue[1]>>7);
   \   00000026   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000002A   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   0000002E   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \   00000032   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000034   0x09C9             LSRS     R1,R1,#+7
   \   00000036   0xEA51 0x0040      ORRS     R0,R1,R0, LSL #+1
   \   0000003A   0x7028             STRB     R0,[R5, #+0]
    206          
    207          }
   \   0000003C   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    208          
    209          
    210          /**
    211           * @brief  Returns the VCO calibration data from internal VCO calibrator.
    212           * @param  None.
    213           * @retval uint8_t VCO calibration data word.
    214           */

   \                                 In section .text, align 2, keep-with-next
    215          uint8_t SpiritCalibrationGetVcoCalData(void)
    216          {
   \                     SpiritCalibrationGetVcoCalData: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    217            uint8_t tempRegValue;
    218          
    219            /* Reads the register value */
    220            g_xStatus = SpiritSpiReadRegisters(RCO_VCO_CALIBR_OUT0_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x20E5             MOVS     R0,#+229
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x....             LDR.N    R0,??DataTable11_1
   \   00000012   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000016   0x8001             STRH     R1,[R0, #+0]
    221          
    222            /* Build and returns the VCO calibration data value */
    223            return (tempRegValue & 0x7F);
   \   00000018   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001C   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   00000020   0xBD0E             POP      {R1-R3,PC}       ;; return
    224          
    225          }
    226          
    227          
    228          /**
    229           * @brief  Sets the VCO calibration data to be used in TX mode.
    230           * @param  cVcoCalData calibration data word to be set.
    231           *         This parameter is a variable of uint8_t.
    232           * @retval None.
    233           */

   \                                 In section .text, align 2, keep-with-next
    234          void SpiritCalibrationSetVcoCalDataTx(uint8_t cVcoCalData)
    235          {
   \                     SpiritCalibrationSetVcoCalDataTx: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    236            uint8_t tempRegValue;
    237          
    238            /* Reads the register value */
    239            g_xStatus = SpiritSpiReadRegisters(RCO_VCO_CALIBR_IN1_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x206E             MOVS     R0,#+110
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x....             LDR.N    R0,??DataTable11_1
   \   00000012   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000016   0x8001             STRH     R1,[R0, #+0]
    240          
    241            /* Build the value to be written */
    242            tempRegValue &= 0x80;
   \   00000018   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001C   0xF010 0x0080      ANDS     R0,R0,#0x80
   \   00000020   0xF88D 0x0000      STRB     R0,[SP, #+0]
    243            tempRegValue |= cVcoCalData;
   \   00000024   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000028   0x4320             ORRS     R0,R4,R0
   \   0000002A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    244          
    245            /* Writes the new value of calibration data in TX */
    246            g_xStatus = SpiritSpiWriteRegisters(RCO_VCO_CALIBR_IN1_BASE, 1, &tempRegValue);
   \   0000002E   0xAA00             ADD      R2,SP,#+0
   \   00000030   0x2101             MOVS     R1,#+1
   \   00000032   0x206E             MOVS     R0,#+110
   \   00000034   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000038   0x9001             STR      R0,[SP, #+4]
   \   0000003A   0x....             LDR.N    R0,??DataTable11_1
   \   0000003C   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000040   0x8001             STRH     R1,[R0, #+0]
    247          
    248          }
   \   00000042   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    249          
    250          
    251          /**
    252           * @brief  Returns the actual VCO calibration data used in TX mode.
    253           * @param  None.
    254           * @retval uint8_t Calibration data word used in TX mode.
    255           */

   \                                 In section .text, align 2, keep-with-next
    256          uint8_t SpiritCalibrationGetVcoCalDataTx(void)
    257          {
   \                     SpiritCalibrationGetVcoCalDataTx: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    258            uint8_t tempRegValue;
    259          
    260            /* Reads the register containing the calibration data word used in TX mode */
    261            g_xStatus = SpiritSpiReadRegisters(RCO_VCO_CALIBR_IN1_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x206E             MOVS     R0,#+110
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x....             LDR.N    R0,??DataTable11_1
   \   00000012   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000016   0x8001             STRH     R1,[R0, #+0]
    262          
    263            /* Mask the VCO_CALIBR_TX field and returns the value */
    264            return (tempRegValue & 0x7F);
   \   00000018   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001C   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   00000020   0xBD0E             POP      {R1-R3,PC}       ;; return
    265          
    266          }
    267          
    268          
    269          /**
    270           * @brief  Sets the VCO calibration data to be used in RX mode.
    271           * @param  cVcoCalData calibration data word to be set.
    272           *         This parameter is a variable of uint8_t.
    273           * @retval None.
    274           */

   \                                 In section .text, align 2, keep-with-next
    275          void SpiritCalibrationSetVcoCalDataRx(uint8_t cVcoCalData)
    276          {
   \                     SpiritCalibrationSetVcoCalDataRx: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    277            uint8_t tempRegValue;
    278          
    279            /* Reads the register value */
    280            g_xStatus = SpiritSpiReadRegisters(RCO_VCO_CALIBR_IN0_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x206F             MOVS     R0,#+111
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x....             LDR.N    R0,??DataTable11_1
   \   00000012   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000016   0x8001             STRH     R1,[R0, #+0]
    281          
    282            /* Build the value to be written */
    283            tempRegValue &= 0x80;
   \   00000018   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001C   0xF010 0x0080      ANDS     R0,R0,#0x80
   \   00000020   0xF88D 0x0000      STRB     R0,[SP, #+0]
    284            tempRegValue |= cVcoCalData;
   \   00000024   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000028   0x4320             ORRS     R0,R4,R0
   \   0000002A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    285          
    286            /* Writes the new value of calibration data in RX */
    287            g_xStatus = SpiritSpiWriteRegisters(RCO_VCO_CALIBR_IN0_BASE, 1, &tempRegValue);
   \   0000002E   0xAA00             ADD      R2,SP,#+0
   \   00000030   0x2101             MOVS     R1,#+1
   \   00000032   0x206F             MOVS     R0,#+111
   \   00000034   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000038   0x9001             STR      R0,[SP, #+4]
   \   0000003A   0x....             LDR.N    R0,??DataTable11_1
   \   0000003C   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000040   0x8001             STRH     R1,[R0, #+0]
    288          
    289          }
   \   00000042   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    290          
    291          
    292          /**
    293           * @brief  Returns the actual VCO calibration data used in RX mode.
    294           * @param  None.
    295           * @retval uint8_t Calibration data word used in RX mode.
    296           */

   \                                 In section .text, align 2, keep-with-next
    297          uint8_t SpiritCalibrationGetVcoCalDataRx(void)
    298          {
   \                     SpiritCalibrationGetVcoCalDataRx: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    299            uint8_t tempRegValue;
    300          
    301            /* Reads the register containing the calibration data word used in TX mode */
    302            g_xStatus = SpiritSpiReadRegisters(RCO_VCO_CALIBR_IN0_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x206F             MOVS     R0,#+111
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x....             LDR.N    R0,??DataTable11_1
   \   00000012   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000016   0x8001             STRH     R1,[R0, #+0]
    303          
    304            /* Mask the VCO_CALIBR_RX field and returns the value */
    305            return (tempRegValue & 0x7F);
   \   00000018   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001C   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   00000020   0xBD0E             POP      {R1-R3,PC}       ;; return
    306          
    307          }
    308          
    309          
    310          /**
    311           * @brief  Sets the VCO calibration window.
    312           * @param  xRefWord value of REFWORD corresponding to the Ref_period according to the formula: CALIBRATION_WIN = 11*Ref_period/fxo.
    313                     This parameter can be a value of @ref VcoWin.
    314           * @retval None.
    315           */

   \                                 In section .text, align 2, keep-with-next
    316          void SpiritCalibrationSetVcoWindow(VcoWin xRefWord)
    317          {
   \                     SpiritCalibrationSetVcoWindow: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    318            uint8_t tempRegValue;
    319          
    320            /* Check the parameters */
    321            s_assert_param(IS_VCO_WIN(xRefWord));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD019             BEQ.N    ??SpiritCalibrationSetVcoWindow_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD016             BEQ.N    ??SpiritCalibrationSetVcoWindow_0
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C02             CMP      R4,#+2
   \   00000014   0xD013             BEQ.N    ??SpiritCalibrationSetVcoWindow_0
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0x2C03             CMP      R4,#+3
   \   0000001A   0xD010             BEQ.N    ??SpiritCalibrationSetVcoWindow_0
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD00D             BEQ.N    ??SpiritCalibrationSetVcoWindow_0
   \   00000022   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000024   0x2C01             CMP      R4,#+1
   \   00000026   0xD00A             BEQ.N    ??SpiritCalibrationSetVcoWindow_0
   \   00000028   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002A   0x2C02             CMP      R4,#+2
   \   0000002C   0xD007             BEQ.N    ??SpiritCalibrationSetVcoWindow_0
   \   0000002E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000030   0x2C03             CMP      R4,#+3
   \   00000032   0xD004             BEQ.N    ??SpiritCalibrationSetVcoWindow_0
   \   00000034   0xF240 0x1141      MOVW     R1,#+321
   \   00000038   0x....             LDR.N    R0,??DataTable11
   \   0000003A   0x.... 0x....      BL       s_assert_failed
    322          
    323            /* Reads the register value */
    324            g_xStatus = SpiritSpiReadRegisters(SYNTH_CONFIG1_BASE, 1, &tempRegValue);
   \                     ??SpiritCalibrationSetVcoWindow_0: (+1)
   \   0000003E   0xAA00             ADD      R2,SP,#+0
   \   00000040   0x2101             MOVS     R1,#+1
   \   00000042   0x209E             MOVS     R0,#+158
   \   00000044   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   00000048   0x9001             STR      R0,[SP, #+4]
   \   0000004A   0x....             LDR.N    R0,??DataTable11_1
   \   0000004C   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000050   0x8001             STRH     R1,[R0, #+0]
    325          
    326            /* Build the values to be written */
    327            tempRegValue &= 0xFC;
   \   00000052   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000056   0xF010 0x00FC      ANDS     R0,R0,#0xFC
   \   0000005A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    328            tempRegValue |= xRefWord;
   \   0000005E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000062   0x4320             ORRS     R0,R4,R0
   \   00000064   0xF88D 0x0000      STRB     R0,[SP, #+0]
    329          
    330            /* Writes the new value of VCO calibration window */
    331            g_xStatus = SpiritSpiWriteRegisters(SYNTH_CONFIG1_BASE, 1, &tempRegValue);
   \   00000068   0xAA00             ADD      R2,SP,#+0
   \   0000006A   0x2101             MOVS     R1,#+1
   \   0000006C   0x209E             MOVS     R0,#+158
   \   0000006E   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000072   0x9001             STR      R0,[SP, #+4]
   \   00000074   0x....             LDR.N    R0,??DataTable11_1
   \   00000076   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   0000007A   0x8001             STRH     R1,[R0, #+0]
    332          
    333          }
   \   0000007C   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    334          
    335          
    336          /**
    337           * @brief  Returns the VCO calibration window.
    338           * @param  None.
    339           * @retval VcoWin Value of REFWORD corresponding to the Ref_period according to the formula: CALIBRATION_WIN = 11*Ref_period/fxo.
    340           *         This parameter can be a value of @ref VcoWin.
    341           */

   \                                 In section .text, align 2, keep-with-next
    342          VcoWin SpiritCalibrationGetVcoWindow(void)
    343          {
   \                     SpiritCalibrationGetVcoWindow: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
    344            uint8_t tempRegValue1, tempRegValue2;
    345            VcoWin refWord;
    346          
    347            /* Reads the register containing the REFWORD value */
    348            g_xStatus = SpiritSpiReadRegisters(SYNTH_CONFIG1_BASE, 1, &tempRegValue1);
   \   00000002   0xAA00             ADD      R2,SP,#+0
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x209E             MOVS     R0,#+158
   \   00000008   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000C   0x9001             STR      R0,[SP, #+4]
   \   0000000E   0x....             LDR.N    R0,??DataTable11_1
   \   00000010   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000014   0x8001             STRH     R1,[R0, #+0]
    349          
    350            /* Reads the Xtal configuration */
    351            g_xStatus = SpiritSpiReadRegisters(ANA_FUNC_CONF0_BASE, 1, &tempRegValue2);
   \   00000016   0xF10D 0x0201      ADD      R2,SP,#+1
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   00000022   0x9001             STR      R0,[SP, #+4]
   \   00000024   0x....             LDR.N    R0,??DataTable11_1
   \   00000026   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   0000002A   0x8001             STRH     R1,[R0, #+0]
    352          
    353            /* Mask the REFWORD field */
    354            tempRegValue1 &= 0x03;
   \   0000002C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000030   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   00000034   0xF88D 0x0000      STRB     R0,[SP, #+0]
    355          
    356            /* Mask the 24_26_MHz_SELECT field */
    357            tempRegValue2 = ((tempRegValue2 & 0x40)>>6);
   \   00000038   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000003C   0xF3C0 0x1080      UBFX     R0,R0,#+6,#+1
   \   00000040   0xF88D 0x0001      STRB     R0,[SP, #+1]
    358          
    359            /* In case of 26 MHz crystal */
    360            if(tempRegValue2)
   \   00000044   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD015             BEQ.N    ??SpiritCalibrationGetVcoWindow_0
    361            {
    362              switch(tempRegValue1)
   \   0000004C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD005             BEQ.N    ??SpiritCalibrationGetVcoWindow_1
   \   00000054   0x2802             CMP      R0,#+2
   \   00000056   0xD009             BEQ.N    ??SpiritCalibrationGetVcoWindow_2
   \   00000058   0xD305             BCC.N    ??SpiritCalibrationGetVcoWindow_3
   \   0000005A   0x2803             CMP      R0,#+3
   \   0000005C   0xD009             BEQ.N    ??SpiritCalibrationGetVcoWindow_4
   \   0000005E   0xE020             B.N      ??SpiritCalibrationGetVcoWindow_5
    363              {
    364              case 0:
    365                refWord = CALIB_TIME_6_77_US_26MHZ;
   \                     ??SpiritCalibrationGetVcoWindow_1: (+1)
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x0004             MOVS     R4,R0
    366                break;
   \   00000064   0xE01D             B.N      ??SpiritCalibrationGetVcoWindow_5
    367              case 1:
    368                refWord = CALIB_TIME_13_54_US_26MHZ;
   \                     ??SpiritCalibrationGetVcoWindow_3: (+1)
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0x0004             MOVS     R4,R0
    369                break;
   \   0000006A   0xE01A             B.N      ??SpiritCalibrationGetVcoWindow_5
    370              case 2:
    371                refWord = CALIB_TIME_27_08_US_26MHZ;
   \                     ??SpiritCalibrationGetVcoWindow_2: (+1)
   \   0000006C   0x2002             MOVS     R0,#+2
   \   0000006E   0x0004             MOVS     R4,R0
    372                break;
   \   00000070   0xE017             B.N      ??SpiritCalibrationGetVcoWindow_5
    373              case 3:
    374                refWord = CALIB_TIME_54_15_US_26MHZ;
   \                     ??SpiritCalibrationGetVcoWindow_4: (+1)
   \   00000072   0x2003             MOVS     R0,#+3
   \   00000074   0x0004             MOVS     R4,R0
    375                break;
   \   00000076   0xE014             B.N      ??SpiritCalibrationGetVcoWindow_5
    376              }
    377            }
    378          
    379            /* In case of 24 MHz crystal */
    380            else
    381            {
    382              switch(tempRegValue1)
   \                     ??SpiritCalibrationGetVcoWindow_0: (+1)
   \   00000078   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD005             BEQ.N    ??SpiritCalibrationGetVcoWindow_6
   \   00000080   0x2802             CMP      R0,#+2
   \   00000082   0xD009             BEQ.N    ??SpiritCalibrationGetVcoWindow_7
   \   00000084   0xD305             BCC.N    ??SpiritCalibrationGetVcoWindow_8
   \   00000086   0x2803             CMP      R0,#+3
   \   00000088   0xD009             BEQ.N    ??SpiritCalibrationGetVcoWindow_9
   \   0000008A   0xE00A             B.N      ??SpiritCalibrationGetVcoWindow_5
    383              {
    384              case 0:
    385                refWord = CALIB_TIME_7_33_US_24MHZ;
   \                     ??SpiritCalibrationGetVcoWindow_6: (+1)
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0x0004             MOVS     R4,R0
    386                break;
   \   00000090   0xE007             B.N      ??SpiritCalibrationGetVcoWindow_5
    387              case 1:
    388                refWord = CALIB_TIME_14_67_US_24MHZ;
   \                     ??SpiritCalibrationGetVcoWindow_8: (+1)
   \   00000092   0x2001             MOVS     R0,#+1
   \   00000094   0x0004             MOVS     R4,R0
    389                break;
   \   00000096   0xE004             B.N      ??SpiritCalibrationGetVcoWindow_5
    390              case 2:
    391                refWord = CALIB_TIME_29_33_US_24MHZ;
   \                     ??SpiritCalibrationGetVcoWindow_7: (+1)
   \   00000098   0x2002             MOVS     R0,#+2
   \   0000009A   0x0004             MOVS     R4,R0
    392                break;
   \   0000009C   0xE001             B.N      ??SpiritCalibrationGetVcoWindow_5
    393              case 3:
    394                refWord = CALIB_TIME_58_67_US_24MHZ;
   \                     ??SpiritCalibrationGetVcoWindow_9: (+1)
   \   0000009E   0x2003             MOVS     R0,#+3
   \   000000A0   0x0004             MOVS     R4,R0
    395                break;
    396              }
    397            }
    398          
    399            return refWord;
   \                     ??SpiritCalibrationGetVcoWindow_5: (+1)
   \   000000A2   0x0020             MOVS     R0,R4
   \   000000A4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A6   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    400          
    401          }
    402          
    403          /**
    404           * @brief  Selects a VCO.
    405           * @param  xVco can be VCO_H or VCO_L according to which VCO select.
    406           *         This parameter can be a value of @ref VcoSel.
    407           * @retval None.
    408           */

   \                                 In section .text, align 2, keep-with-next
    409          void SpiritCalibrationSelectVco(VcoSel xVco)
    410          {
   \                     SpiritCalibrationSelectVco: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    411            uint8_t tempRegValue;
    412            
    413            /* Check the parameter */
    414            s_assert_param(IS_VCO_SEL(xVco));
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD007             BEQ.N    ??SpiritCalibrationSelectVco_0
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x2C01             CMP      R4,#+1
   \   00000010   0xD004             BEQ.N    ??SpiritCalibrationSelectVco_0
   \   00000012   0xF44F 0x71CF      MOV      R1,#+414
   \   00000016   0x....             LDR.N    R0,??DataTable11
   \   00000018   0x.... 0x....      BL       s_assert_failed
    415            
    416            SpiritSpiReadRegisters(SYNTH_CONFIG1_BASE, 1, &tempRegValue);
   \                     ??SpiritCalibrationSelectVco_0: (+1)
   \   0000001C   0xAA00             ADD      R2,SP,#+0
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0x209E             MOVS     R0,#+158
   \   00000022   0x.... 0x....      BL       SdkEvalSpiReadRegisters
    417            
    418            tempRegValue &= 0xF9;
   \   00000026   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000002A   0xF010 0x00F9      ANDS     R0,R0,#0xF9
   \   0000002E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    419            
    420            if(xVco == VCO_H)
   \   00000032   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000034   0x2C01             CMP      R4,#+1
   \   00000036   0xD106             BNE.N    ??SpiritCalibrationSelectVco_1
    421            {
    422              tempRegValue |= 0x02;
   \   00000038   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000003C   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000040   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000044   0xE005             B.N      ??SpiritCalibrationSelectVco_2
    423              
    424            }
    425            else
    426            {
    427              tempRegValue |= 0x04;
   \                     ??SpiritCalibrationSelectVco_1: (+1)
   \   00000046   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000004A   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000004E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    428            }
    429            SpiritSpiWriteRegisters(SYNTH_CONFIG1_BASE, 1, &tempRegValue);  
   \                     ??SpiritCalibrationSelectVco_2: (+1)
   \   00000052   0xAA00             ADD      R2,SP,#+0
   \   00000054   0x2101             MOVS     R1,#+1
   \   00000056   0x209E             MOVS     R0,#+158
   \   00000058   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
    430            
    431          }
   \   0000005C   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    432          
    433          
    434          
    435          /**
    436           * @brief  Returns the VCO selected.
    437           * @param  void.
    438           * @retval VCO_H or VCO_L according to which VCO selected.
    439           *         This parameter can be a value of @ref VcoSel.
    440           */

   \                                 In section .text, align 2, keep-with-next
    441          VcoSel SpiritCalibrationGetVcoSelecttion(void)
    442          {
   \                     SpiritCalibrationGetVcoSelecttion: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    443            uint8_t tempRegValue;
    444            
    445            SpiritSpiReadRegisters(SYNTH_CONFIG1_BASE, 1, &tempRegValue);
   \   00000002   0xAA00             ADD      R2,SP,#+0
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x209E             MOVS     R0,#+158
   \   00000008   0x.... 0x....      BL       SdkEvalSpiReadRegisters
    446            
    447            tempRegValue = (tempRegValue>>1)&0x3;
   \   0000000C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000010   0xF3C0 0x0041      UBFX     R0,R0,#+1,#+2
   \   00000014   0xF88D 0x0000      STRB     R0,[SP, #+0]
    448            
    449            if(tempRegValue == 0x01)
   \   00000018   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD101             BNE.N    ??SpiritCalibrationGetVcoSelecttion_0
    450            {
    451              return VCO_H;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xE000             B.N      ??SpiritCalibrationGetVcoSelecttion_1
    452              
    453            }
    454            else
    455            {
    456              return VCO_L;
   \                     ??SpiritCalibrationGetVcoSelecttion_0: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \                     ??SpiritCalibrationGetVcoSelecttion_1: (+1)
   \   00000026   0xBD02             POP      {R1,PC}          ;; return
    457            }
    458            
    459          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x........         DC32     g_xStatus

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x45 0x3A          DC8 45H, 3AH, 5CH, 41H, 43H, 51H, 5CH, 50H
   \              0x5C 0x41    
   \              0x43 0x51    
   \              0x5C 0x50    
   \   00000008   0x72 0x6F          DC8 72H, 6FH, 6AH, 5FH, 76H, 65H, 72H, 30H
   \              0x6A 0x5F    
   \              0x76 0x65    
   \              0x72 0x30    
   \   00000010   0x39 0x61          DC8 39H, 61H, 5FH, 31H, 35H, 31H, 30H, 32H
   \              0x5F 0x31    
   \              0x35 0x31    
   \              0x30 0x32    
   \   00000018   0x30 0x31          DC8 30H, 31H, 35H, 5CH, 42H, 61H, 73H, 65H
   \              0x35 0x5C    
   \              0x42 0x61    
   \              0x73 0x65    
   \   00000020   0x5F 0x30          DC8 5FH, 30H, 32H, 5CH, 32H, 30H, 31H, 33H
   \              0x32 0x5C    
   \              0x32 0x30    
   \              0x31 0x33    
   \   00000028   0x5F 0x31          DC8 5FH, 31H, 31H, 5FH, 32H, 35H, 5FH, 53H
   \              0x31 0x5F    
   \              0x32 0x35    
   \              0x5F 0x53    
   \   00000030   0x70 0x69          DC8 70H, 69H, 72H, 69H, 74H, 31H, 5FH, 45H
   \              0x72 0x69    
   \              0x74 0x31    
   \              0x5F 0x45    
   \   00000038   0x6C 0x65          DC8 6CH, 65H, 6BH, 74H, 72H, 6FH, 6CH, 75H
   \              0x6B 0x74    
   \              0x72 0x6F    
   \              0x6C 0x75    
   \   00000040   0x78 0x5C          DC8 78H, 5CH, 53H, 50H, 49H, 52H, 49H, 54H
   \              0x53 0x50    
   \              0x49 0x52    
   \              0x49 0x54    
   \   00000048   0x31 0x5F          DC8 31H, 5FH, 4CH, 69H, 62H, 72H, 61H, 72H
   \              0x4C 0x69    
   \              0x62 0x72    
   \              0x61 0x72    
   \   00000050   0x79 0x5F          DC8 79H, 5FH, 50H, 72H, 6FH, 6AH, 65H, 63H
   \              0x50 0x72    
   \              0x6F 0x6A    
   \              0x65 0x63    
   \   00000058   0x74 0x5C          DC8 74H, 5CH, 53H, 50H, 49H, 52H, 49H, 54H
   \              0x53 0x50    
   \              0x49 0x52    
   \              0x49 0x54    
   \   00000060   0x31 0x5F          DC8 31H, 5FH, 4CH, 69H, 62H, 72H, 61H, 72H
   \              0x4C 0x69    
   \              0x62 0x72    
   \              0x61 0x72    
   \   00000068   0x79 0x5C          DC8 79H, 5CH, 53H, 6FH, 75H, 72H, 63H, 65H
   \              0x53 0x6F    
   \              0x75 0x72    
   \              0x63 0x65    
   \   00000070   0x5C 0x73          DC8 5CH, 73H, 72H, 63H, 5CH, 53H, 50H, 49H
   \              0x72 0x63    
   \              0x5C 0x53    
   \              0x50 0x49    
   \   00000078   0x52 0x49          DC8 52H, 49H, 54H, 5FH, 43H, 61H, 6CH, 69H
   \              0x54 0x5F    
   \              0x43 0x61    
   \              0x6C 0x69    
   \   00000080   0x62 0x72          DC8 62H, 72H, 61H, 74H, 69H, 6FH, 6EH, 2EH
   \              0x61 0x74    
   \              0x69 0x6F    
   \              0x6E 0x2E    
   \   00000088   0x63 0x00          DC8 63H, 0
   \   0000008A   0x00 0x00          DC8 0, 0
    460          
    461          
    462          /**
    463           *@}
    464           */
    465          
    466          /**
    467           *@}
    468           */
    469          
    470          
    471          /**
    472           *@}
    473           */
    474          
    475          
    476          
    477          /******************* (C) COPYRIGHT 2012 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   SpiritCalibrationGetRcoCalWords
        24   -> SdkEvalSpiReadRegisters
      16   SpiritCalibrationGetVcoCalData
        16   -> SdkEvalSpiReadRegisters
      16   SpiritCalibrationGetVcoCalDataRx
        16   -> SdkEvalSpiReadRegisters
      16   SpiritCalibrationGetVcoCalDataTx
        16   -> SdkEvalSpiReadRegisters
       8   SpiritCalibrationGetVcoSelecttion
         8   -> SdkEvalSpiReadRegisters
      16   SpiritCalibrationGetVcoWindow
        16   -> SdkEvalSpiReadRegisters
      16   SpiritCalibrationRco
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      16   SpiritCalibrationSelectVco
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      24   SpiritCalibrationSetRcoCalWords
        24   -> SdkEvalSpiReadRegisters
        24   -> SdkEvalSpiWriteRegisters
      16   SpiritCalibrationSetVcoCalDataRx
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
      16   SpiritCalibrationSetVcoCalDataTx
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
      16   SpiritCalibrationSetVcoWindow
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      16   SpiritCalibrationVco
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
     140  ?_0
      62  SpiritCalibrationGetRcoCalWords
      34  SpiritCalibrationGetVcoCalData
      34  SpiritCalibrationGetVcoCalDataRx
      34  SpiritCalibrationGetVcoCalDataTx
      40  SpiritCalibrationGetVcoSelecttion
     168  SpiritCalibrationGetVcoWindow
     102  SpiritCalibrationRco
      94  SpiritCalibrationSelectVco
      80  SpiritCalibrationSetRcoCalWords
      68  SpiritCalibrationSetVcoCalDataRx
      68  SpiritCalibrationSetVcoCalDataTx
     126  SpiritCalibrationSetVcoWindow
      98  SpiritCalibrationVco

 
   140 bytes in section .rodata
 1 016 bytes in section .text
 
 1 016 bytes of CODE  memory
   140 bytes of CONST memory

Errors: none
Warnings: none
