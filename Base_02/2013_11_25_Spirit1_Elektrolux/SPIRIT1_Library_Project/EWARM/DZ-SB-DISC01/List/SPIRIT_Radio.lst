###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        20/Nov/2015  05:05:35
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\SPIRIT1_Library\Source\src\SPIRIT_Radio.c
#    Command line =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\SPIRIT1_Library\Source\src\SPIRIT_Radio.c
#        -D USE_STDPERIPH_DRIVER -D VECT_TAB_FLASH -D STM32L1XX_MD -D
#        IAR_ARM_CM3 -D USE_FULL_ASSERT -D SPIRIT_USE_FULL_ASSERT -D
#        USE_SYSTICK_DELAY -D SDK -lC
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\List\
#        -o
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\.\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\examples\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\runtime\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\SDK_Eval_STM32L\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\SPIRIT1_Library\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\SDK_Eval_Util\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\SDK_Virtual_Com\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32_USB-FS-Device_Lib\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\ACQ\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\CMSIS\Include\"
#    List file    =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\List\SPIRIT_Radio.lst
#    Object file  =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\Obj\SPIRIT_Radio.o
#
###############################################################################

E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\SPIRIT1_Library\Source\src\SPIRIT_Radio.c
      1          /**
      2          * @file    SPIRIT_Radio.c
      3          * @author  High End Analog & RF BU - AMS / ART Team IMS-Systems Lab
      4          * @version V3.0.1
      5          * @date    November 19, 2012
      6          * @brief   This file provides all the low level API to manage Analog and Digital
      7          *          radio part of SPIRIT.
      8          * @details
      9          *
     10          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     11          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     12          * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     13          * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     14          * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     15          * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     16          *
     17          * THIS SOURCE CODE IS PROTECTED BY A LICENSE.
     18          * FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED
     19          * IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
     20          *
     21          * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     22          *
     23          */
     24          
     25          /* Includes ------------------------------------------------------------------*/
     26          #include "SPIRIT_Radio.h"
     27          #include "MCU_Interface.h"
     28          #include <math.h>
     29          
     30          /** @addtogroup SPIRIT_Libraries
     31          * @{
     32          */
     33          
     34          
     35          /** @addtogroup SPIRIT_Radio
     36          * @{
     37          */
     38          
     39          
     40          /** @defgroup Radio_Private_TypesDefinitions            Radio Private Types Definitions
     41          * @{
     42          */
     43          
     44          
     45          /**
     46          * @}
     47          */
     48          
     49          
     50          /** @defgroup Radio_Private_Defines                     Radio Private Defines
     51          * @{
     52          */
     53          
     54          
     55          
     56          
     57          /**
     58          * @}
     59          */
     60          
     61          
     62          /** @defgroup Radio_Private_Macros                      Radio Private Macros
     63          * @{
     64          */
     65          #define XTAL_FLAG(xtalFrequency)               xtalFrequency>=25e6 ? XTAL_FLAG_26_MHz:XTAL_FLAG_24_MHz
     66          
     67          /**
     68          * @}
     69          */
     70          
     71          
     72          /** @defgroup Radio_Private_Variables                   Radio Private Variables
     73          * @{
     74          */
     75          /**
     76          * @brief  The Xtal frequency. To be set by the user (see SetXtalFreq() function)
     77          */

   \                                 In section .bss, align 4
     78          static uint32_t s_lXtalFrequency;
   \                     s_lXtalFrequency:
   \   00000000                      DS8 4
     79          
     80          /**
     81          * @brief  Factor is: B/2 used in the formula for SYNTH word calculation
     82          */

   \                                 In section .rodata, align 4
     83          static const uint8_t s_vectcBHalfFactor[4]={(HIGH_BAND_FACTOR/2), (MIDDLE_BAND_FACTOR/2), (LOW_BAND_FACTOR/2), (VERY_LOW_BAND_FACTOR/2)};
   \                     s_vectcBHalfFactor:
   \   00000000   0x03 0x06          DC8 3, 6, 8, 16
   \              0x08 0x10    
     84          
     85          /**
     86          * @brief  BS value to write in the SYNT0 register according to the selected band
     87          */

   \                                 In section .rodata, align 4
     88          static const uint8_t s_vectcBandRegValue[4]={SYNT0_BS_6, SYNT0_BS_12, SYNT0_BS_16, SYNT0_BS_32};
   \                     s_vectcBandRegValue:
   \   00000000   0x01 0x03          DC8 1, 3, 4, 5
   \              0x04 0x05    
     89          
     90          
     91          /**
     92          * @brief  It represents the available channel bandwidth times 10 for 26 Mhz xtal.
     93          * @note   The channel bandwidth for others xtal frequencies can be computed since this table
     94          *         multiplying the current table by a factor xtal_frequency/26e6.
     95          */

   \                                 In section .rodata, align 4
     96          static const uint16_t s_vectnBandwidth26M[90]=
   \                     s_vectnBandwidth26M:
   \   00000000   0x1F41 0x1F0F      DC16 8001, 7951, 7684, 7368, 7051, 6709, 6423, 5867, 5414, 4509, 4259
   \              0x1E04 0x1CC8
   \              0x1B8B 0x1A35
   \              0x1917 0x16EB
   \              0x1526 0x119D
   \              0x10A3       
   \   00000016   0x0FC0 0x0EE0      DC16 4032, 3808, 3621, 3417, 3254, 2945, 2703, 2247, 2124, 2011, 1900
   \              0x0E25 0x0D59
   \              0x0CB6 0x0B81
   \              0x0A8F 0x08C7
   \              0x084C 0x07DB
   \              0x076C       
   \   0000002C   0x070F 0x06AA      DC16 1807, 1706, 1624, 1471, 1350, 1123, 1062, 1005, 950, 903, 853, 812
   \              0x0658 0x05BF
   \              0x0546 0x0463
   \              0x0426 0x03ED
   \              0x03B6 0x0387
   \              0x0355 0x032C
   \   00000044   0x02DF 0x02A3      DC16 735, 675, 561, 530, 502, 474, 451, 426, 406, 367, 337, 280, 265
   \              0x0231 0x0212
   \              0x01F6 0x01DA
   \              0x01C3 0x01AA
   \              0x0196 0x016F
   \              0x0151 0x0118
   \              0x0109       
   \   0000005E   0x00FB 0x00ED      DC16 251, 237, 226, 213, 203, 184, 169, 140, 133, 126, 119, 113, 106
   \              0x00E2 0x00D5
   \              0x00CB 0x00B8
   \              0x00A9 0x008C
   \              0x0085 0x007E
   \              0x0077 0x0071
   \              0x006A       
   \   00000078   0x0065 0x005C      DC16 101, 92, 84, 70, 66, 63, 59, 56, 53, 51, 46, 42, 35, 33, 31, 30
   \              0x0054 0x0046
   \              0x0042 0x003F
   \              0x003B 0x0038
   \              0x0035 0x0033
   \              0x002E 0x002A
   \              0x0023 0x0021
   \              0x001F 0x001E
   \   00000098   0x001C 0x001B      DC16 28, 27, 25, 23, 21, 18, 17, 16, 15, 14, 13, 13, 12, 11
   \              0x0019 0x0017
   \              0x0015 0x0012
   \              0x0011 0x0010
   \              0x000F 0x000E
   \              0x000D 0x000D
   \              0x000C 0x000B
     97          {
     98            8001, 7951, 7684, 7368, 7051, 6709, 6423, 5867, 5414, \
     99              4509, 4259, 4032, 3808, 3621, 3417, 3254, 2945, 2703, \
    100                2247, 2124, 2011, 1900, 1807, 1706, 1624, 1471, 1350, \
    101                  1123, 1062, 1005,  950,  903,  853,  812,  735,  675, \
    102                    561,  530,  502,  474,  451,  426,  406,  367,  337, \
    103                      280,  265,  251,  237,  226,  213,  203,  184,  169, \
    104                        140,  133,  126,  119,  113,  106,  101,   92,   84, \
    105                          70,   66,   63,   59,   56,   53,   51,   46,   42, \
    106                            35,   33,   31,   30,   28,   27,   25,   23,   21, \
    107                              18,   17,   16,   15,   14,   13,   13,   12,   11
    108          };
    109          
    110          /**
    111          * @brief  It represents the available VCO frequencies
    112          */

   \                                 In section .rodata, align 4
    113          static const uint16_t s_vectnVCOFreq[16]=
   \                     s_vectnVCOFreq:
   \   00000000   0x1224 0x1264      DC16 4644, 4708, 4772, 4836, 4902, 4966, 5030, 5095, 5161, 5232, 5303
   \              0x12A4 0x12E4
   \              0x1326 0x1366
   \              0x13A6 0x13E7
   \              0x1429 0x1470
   \              0x14B7       
   \   00000016   0x14FF 0x1548      DC16 5375, 5448, 5519, 5592, 5663
   \              0x158F 0x15D8
   \              0x161F       
    114          {
    115            4644, 4708, 4772, 4836, 4902, 4966, 5030, 5095, \
    116              5161, 5232, 5303, 5375, 5448, 5519, 5592, 5663
    117          };
    118          
    119          
    120          /**
    121          * @}
    122          */
    123          
    124          
    125          /** @defgroup Radio_Private_FunctionPrototypes          Radio Private Function Prototypes
    126          * @{
    127          */
    128          
    129          
    130          /**
    131          * @}
    132          */
    133          
    134          
    135          /** @defgroup Radio_Private_Functions                    Radio Private Functions
    136          * @{
    137          */
    138          
    139          /**
    140          * @brief  Initializes the SPIRIT analog and digital radio part according to the specified
    141          *         parameters in the pxSRadioInitStruct.
    142          * @param  pxSRadioInitStruct pointer to a SRadioInit structure that
    143          *         contains the configuration information for the analog radio part of SPIRIT.
    144          * @retval None.
    145          */

   \                                 In section .text, align 2, keep-with-next
    146          void SpiritRadioInit(SRadioInit* pxSRadioInitStruct)
    147          {
   \                     SpiritRadioInit: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x0004             MOVS     R4,R0
    148            int32_t FOffsetTmp;
    149            uint8_t anaRadioRegArray[8], digRadioRegArray[4];
    150            int16_t xtalOffsetFactor;
    151            uint8_t drM, drE, FdevM, FdevE, bwM, bwE;
    152            
    153            /* Get the RF board version */
    154            SpiritVersion xSpiritVersion = SpiritGeneralGetSpiritVersion();
   \   00000006   0x.... 0x....      BL       SpiritGeneralGetSpiritVersion
   \   0000000A   0x0007             MOVS     R7,R0
    155            
    156            /* Workaround for Vtune */
    157            uint8_t value = 0xA0; SpiritSpiWriteRegisters(0x9F, 1, &value);
   \   0000000C   0x20A0             MOVS     R0,#+160
   \   0000000E   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \   00000012   0xF10D 0x0203      ADD      R2,SP,#+3
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0x209F             MOVS     R0,#+159
   \   0000001A   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
    158            
    159            /* Calculates the offset respect to RF frequency and according to xtal_ppm parameter: (xtal_ppm*FBase)/10^6 */
    160            FOffsetTmp = (int32_t)((pxSRadioInitStruct->nXtalOffsetPpm*pxSRadioInitStruct->lFrequencyBase)/PPM_FACTOR);
   \   0000001E   0xF9B4 0x0000      LDRSH    R0,[R4, #+0]
   \   00000022   0x6861             LDR      R1,[R4, #+4]
   \   00000024   0x4348             MULS     R0,R1,R0
   \   00000026   0x.... 0x....      BL       __aeabi_ui2d
   \   0000002A   0x2200             MOVS     R2,#+0
   \   0000002C   0x.... 0x....      LDR.W    R3,??DataTable12  ;; 0x412e8480
   \   00000030   0x.... 0x....      BL       __aeabi_ddiv
   \   00000034   0x.... 0x....      BL       __aeabi_d2iz
   \   00000038   0x0005             MOVS     R5,R0
    161            
    162            /* Check the parameters */
    163            s_assert_param(IS_FREQUENCY_BAND(pxSRadioInitStruct->lFrequencyBase));
   \   0000003A   0x6860             LDR      R0,[R4, #+4]
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable13  ;; 0x2e5f5680
   \   00000040   0x4288             CMP      R0,R1
   \   00000042   0xD304             BCC.N    ??SpiritRadioInit_0
   \   00000044   0x6860             LDR      R0,[R4, #+4]
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable13_1  ;; 0x390c2fe1
   \   0000004A   0x4288             CMP      R0,R1
   \   0000004C   0xD322             BCC.N    ??SpiritRadioInit_1
   \                     ??SpiritRadioInit_0: (+1)
   \   0000004E   0x6860             LDR      R0,[R4, #+4]
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable13_2  ;; 0x1701e480
   \   00000054   0x4288             CMP      R0,R1
   \   00000056   0xD304             BCC.N    ??SpiritRadioInit_2
   \   00000058   0x6860             LDR      R0,[R4, #+4]
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable13_3  ;; 0x1c146a61
   \   0000005E   0x4288             CMP      R0,R1
   \   00000060   0xD318             BCC.N    ??SpiritRadioInit_1
   \                     ??SpiritRadioInit_2: (+1)
   \   00000062   0x6860             LDR      R0,[R4, #+4]
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable13_4  ;; 0x11d260c0
   \   00000068   0x4288             CMP      R0,R1
   \   0000006A   0xD304             BCC.N    ??SpiritRadioInit_3
   \   0000006C   0x6860             LDR      R0,[R4, #+4]
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable14  ;; 0x14ced7e1
   \   00000072   0x4288             CMP      R0,R1
   \   00000074   0xD30E             BCC.N    ??SpiritRadioInit_1
   \                     ??SpiritRadioInit_3: (+1)
   \   00000076   0x6860             LDR      R0,[R4, #+4]
   \   00000078   0x.... 0x....      LDR.W    R1,??DataTable14_1  ;; 0x8e18f40
   \   0000007C   0x4288             CMP      R0,R1
   \   0000007E   0xD304             BCC.N    ??SpiritRadioInit_4
   \   00000080   0x6860             LDR      R0,[R4, #+4]
   \   00000082   0x.... 0x....      LDR.W    R1,??DataTable14_2  ;; 0xa6fd061
   \   00000086   0x4288             CMP      R0,R1
   \   00000088   0xD304             BCC.N    ??SpiritRadioInit_1
   \                     ??SpiritRadioInit_4: (+1)
   \   0000008A   0x21A3             MOVS     R1,#+163
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable13_5
   \   00000090   0x.... 0x....      BL       s_assert_failed
    164            s_assert_param(IS_MODULATION_SELECTED(pxSRadioInitStruct->xModulationSelect));
   \                     ??SpiritRadioInit_1: (+1)
   \   00000094   0x7B60             LDRB     R0,[R4, #+13]
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD010             BEQ.N    ??SpiritRadioInit_5
   \   0000009A   0x7B60             LDRB     R0,[R4, #+13]
   \   0000009C   0x2850             CMP      R0,#+80
   \   0000009E   0xD00D             BEQ.N    ??SpiritRadioInit_5
   \   000000A0   0x7B60             LDRB     R0,[R4, #+13]
   \   000000A2   0x2810             CMP      R0,#+16
   \   000000A4   0xD00A             BEQ.N    ??SpiritRadioInit_5
   \   000000A6   0x7B60             LDRB     R0,[R4, #+13]
   \   000000A8   0x2820             CMP      R0,#+32
   \   000000AA   0xD007             BEQ.N    ??SpiritRadioInit_5
   \   000000AC   0x7B60             LDRB     R0,[R4, #+13]
   \   000000AE   0x2830             CMP      R0,#+48
   \   000000B0   0xD004             BEQ.N    ??SpiritRadioInit_5
   \   000000B2   0x21A4             MOVS     R1,#+164
   \   000000B4   0x.... 0x....      LDR.W    R0,??DataTable13_5
   \   000000B8   0x.... 0x....      BL       s_assert_failed
    165            s_assert_param(IS_DATARATE(pxSRadioInitStruct->lDatarate));
   \                     ??SpiritRadioInit_5: (+1)
   \   000000BC   0x6920             LDR      R0,[R4, #+16]
   \   000000BE   0x2864             CMP      R0,#+100
   \   000000C0   0xD304             BCC.N    ??SpiritRadioInit_6
   \   000000C2   0x6920             LDR      R0,[R4, #+16]
   \   000000C4   0x.... 0x....      LDR.W    R1,??DataTable13_6  ;; 0x7c831
   \   000000C8   0x4288             CMP      R0,R1
   \   000000CA   0xD304             BCC.N    ??SpiritRadioInit_7
   \                     ??SpiritRadioInit_6: (+1)
   \   000000CC   0x21A5             MOVS     R1,#+165
   \   000000CE   0x.... 0x....      LDR.W    R0,??DataTable13_5
   \   000000D2   0x.... 0x....      BL       s_assert_failed
    166            s_assert_param(IS_FREQUENCY_OFFSET(FOffsetTmp,s_lXtalFrequency));
   \                     ??SpiritRadioInit_7: (+1)
   \   000000D6   0x.... 0x....      LDR.W    R0,??DataTable15
   \   000000DA   0x6800             LDR      R0,[R0, #+0]
   \   000000DC   0x4240             RSBS     R0,R0,#+0
   \   000000DE   0xF45F 0x2180      MOVS     R1,#+262144
   \   000000E2   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000000E6   0xF44F 0x6100      MOV      R1,#+2048
   \   000000EA   0x4348             MULS     R0,R1,R0
   \   000000EC   0x4285             CMP      R5,R0
   \   000000EE   0xDB08             BLT.N    ??SpiritRadioInit_8
   \   000000F0   0x.... 0x....      LDR.W    R0,??DataTable15
   \   000000F4   0x6800             LDR      R0,[R0, #+0]
   \   000000F6   0x0C80             LSRS     R0,R0,#+18
   \   000000F8   0xF240 0x71FF      MOVW     R1,#+2047
   \   000000FC   0x4348             MULS     R0,R1,R0
   \   000000FE   0x42A8             CMP      R0,R5
   \   00000100   0xDA04             BGE.N    ??SpiritRadioInit_9
   \                     ??SpiritRadioInit_8: (+1)
   \   00000102   0x21A6             MOVS     R1,#+166
   \   00000104   0x.... 0x....      LDR.W    R0,??DataTable13_5
   \   00000108   0x.... 0x....      BL       s_assert_failed
    167            s_assert_param(IS_CHANNEL_SPACE(pxSRadioInitStruct->nChannelSpace,s_lXtalFrequency));
   \                     ??SpiritRadioInit_9: (+1)
   \   0000010C   0x.... 0x....      LDR.W    R0,??DataTable15
   \   00000110   0x6800             LDR      R0,[R0, #+0]
   \   00000112   0x0BC0             LSRS     R0,R0,#+15
   \   00000114   0x21FF             MOVS     R1,#+255
   \   00000116   0x4348             MULS     R0,R1,R0
   \   00000118   0x68A1             LDR      R1,[R4, #+8]
   \   0000011A   0x4288             CMP      R0,R1
   \   0000011C   0xD204             BCS.N    ??SpiritRadioInit_10
   \   0000011E   0x21A7             MOVS     R1,#+167
   \   00000120   0x.... 0x....      LDR.W    R0,??DataTable13_5
   \   00000124   0x.... 0x....      BL       s_assert_failed
    168            s_assert_param(IS_F_DEV(pxSRadioInitStruct->lFreqDev,s_lXtalFrequency));
   \                     ??SpiritRadioInit_10: (+1)
   \   00000128   0x6960             LDR      R0,[R4, #+20]
   \   0000012A   0x.... 0x....      LDR.W    R1,??DataTable15
   \   0000012E   0x6809             LDR      R1,[R1, #+0]
   \   00000130   0xEBB0 0x4F11      CMP      R0,R1, LSR #+16
   \   00000134   0xD308             BCC.N    ??SpiritRadioInit_11
   \   00000136   0x.... 0x....      LDR.W    R0,??DataTable15
   \   0000013A   0x6800             LDR      R0,[R0, #+0]
   \   0000013C   0x210F             MOVS     R1,#+15
   \   0000013E   0x4348             MULS     R0,R1,R0
   \   00000140   0x0A80             LSRS     R0,R0,#+10
   \   00000142   0x6961             LDR      R1,[R4, #+20]
   \   00000144   0x4288             CMP      R0,R1
   \   00000146   0xD204             BCS.N    ??SpiritRadioInit_12
   \                     ??SpiritRadioInit_11: (+1)
   \   00000148   0x21A8             MOVS     R1,#+168
   \   0000014A   0x.... 0x....      LDR.W    R0,??DataTable13_5
   \   0000014E   0x.... 0x....      BL       s_assert_failed
    169            
    170            /* Disable the digital, ADC, SMPS reference clock divider if fXO>24MHz or fXO<26MHz */
    171            if(xSpiritVersion != SPIRIT_VERSION_2_0)
   \                     ??SpiritRadioInit_12: (+1)
   \   00000152   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000154   0x2F00             CMP      R7,#+0
   \   00000156   0xF000 0x808E      BEQ.W    ??SpiritRadioInit_13
    172            {
    173              /* Goes in STANDBY state */
    174              SpiritSpiCommandStrobes(COMMAND_STANDBY);    
   \   0000015A   0x2063             MOVS     R0,#+99
   \   0000015C   0x.... 0x....      BL       SdkEvalSpiCommandStrobes
    175              do{
    176                /* Delay for state transition */
    177                for(volatile uint8_t i=0; i!=0xFF; i++);
   \                     ??SpiritRadioInit_14: (+1)
   \   00000160   0x2000             MOVS     R0,#+0
   \   00000162   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \                     ??SpiritRadioInit_15: (+1)
   \   00000166   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000016A   0x28FF             CMP      R0,#+255
   \   0000016C   0xD005             BEQ.N    ??SpiritRadioInit_16
   \   0000016E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000172   0x1C40             ADDS     R0,R0,#+1
   \   00000174   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000178   0xE7F5             B.N      ??SpiritRadioInit_15
    178                
    179                /* Reads the MC_STATUS register */
    180                SpiritRefreshStatus();
   \                     ??SpiritRadioInit_16: (+1)
   \   0000017A   0x.... 0x....      BL       SpiritRefreshStatus
    181              }while(g_xStatus.MC_STATE!=MC_STATE_STANDBY);
   \   0000017E   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   00000182   0x7800             LDRB     R0,[R0, #+0]
   \   00000184   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000186   0x0840             LSRS     R0,R0,#+1
   \   00000188   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000018A   0x2840             CMP      R0,#+64
   \   0000018C   0xD1E8             BNE.N    ??SpiritRadioInit_14
    182              
    183              if(s_lXtalFrequency<48000000)
   \   0000018E   0x.... 0x....      LDR.W    R0,??DataTable15
   \   00000192   0x6800             LDR      R0,[R0, #+0]
   \   00000194   0x.... 0x....      LDR.W    R1,??DataTable15_2  ;; 0x2dc6c00
   \   00000198   0x4288             CMP      R0,R1
   \   0000019A   0xD228             BCS.N    ??SpiritRadioInit_17
    184              {
    185                SpiritRadioSetDigDiv(S_DISABLE);
   \   0000019C   0x2000             MOVS     R0,#+0
   \   0000019E   0x.... 0x....      BL       SpiritRadioSetDigDiv
    186                s_assert_param(IS_CH_BW(pxSRadioInitStruct->lBandwidth,s_lXtalFrequency));
   \   000001A2   0x.... 0x....      LDR.W    R0,??DataTable15
   \   000001A6   0x6800             LDR      R0,[R0, #+0]
   \   000001A8   0x.... 0x....      LDR.W    R1,??DataTable15_3  ;; 0xf4240
   \   000001AC   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000001B0   0xF240 0x414C      MOVW     R1,#+1100
   \   000001B4   0x4348             MULS     R0,R1,R0
   \   000001B6   0x211A             MOVS     R1,#+26
   \   000001B8   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000001BC   0x69A1             LDR      R1,[R4, #+24]
   \   000001BE   0x4281             CMP      R1,R0
   \   000001C0   0xD30F             BCC.N    ??SpiritRadioInit_18
   \   000001C2   0x.... 0x....      LDR.W    R0,??DataTable15
   \   000001C6   0x6800             LDR      R0,[R0, #+0]
   \   000001C8   0x.... 0x....      LDR.W    R1,??DataTable15_3  ;; 0xf4240
   \   000001CC   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000001D0   0x.... 0x....      LDR.W    R1,??DataTable15_4  ;; 0xc3564
   \   000001D4   0x4348             MULS     R0,R1,R0
   \   000001D6   0x211A             MOVS     R1,#+26
   \   000001D8   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000001DC   0x69A1             LDR      R1,[R4, #+24]
   \   000001DE   0x4288             CMP      R0,R1
   \   000001E0   0xD22F             BCS.N    ??SpiritRadioInit_19
   \                     ??SpiritRadioInit_18: (+1)
   \   000001E2   0x21BA             MOVS     R1,#+186
   \   000001E4   0x.... 0x....      LDR.W    R0,??DataTable13_5
   \   000001E8   0x.... 0x....      BL       s_assert_failed
   \   000001EC   0xE029             B.N      ??SpiritRadioInit_19
    187              }
    188              else
    189              {      
    190                SpiritRadioSetDigDiv(S_ENABLE);
   \                     ??SpiritRadioInit_17: (+1)
   \   000001EE   0x2001             MOVS     R0,#+1
   \   000001F0   0x.... 0x....      BL       SpiritRadioSetDigDiv
    191                s_assert_param(IS_CH_BW(pxSRadioInitStruct->lBandwidth,(s_lXtalFrequency>>1)));
   \   000001F4   0x.... 0x....      LDR.W    R0,??DataTable15
   \   000001F8   0x6800             LDR      R0,[R0, #+0]
   \   000001FA   0x0840             LSRS     R0,R0,#+1
   \   000001FC   0x.... 0x....      LDR.W    R1,??DataTable15_3  ;; 0xf4240
   \   00000200   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000204   0xF240 0x414C      MOVW     R1,#+1100
   \   00000208   0x4348             MULS     R0,R1,R0
   \   0000020A   0x211A             MOVS     R1,#+26
   \   0000020C   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000210   0x69A1             LDR      R1,[R4, #+24]
   \   00000212   0x4281             CMP      R1,R0
   \   00000214   0xD310             BCC.N    ??SpiritRadioInit_20
   \   00000216   0x.... 0x....      LDR.W    R0,??DataTable15
   \   0000021A   0x6800             LDR      R0,[R0, #+0]
   \   0000021C   0x0840             LSRS     R0,R0,#+1
   \   0000021E   0x.... 0x....      LDR.W    R1,??DataTable15_3  ;; 0xf4240
   \   00000222   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000226   0x.... 0x....      LDR.W    R1,??DataTable15_4  ;; 0xc3564
   \   0000022A   0x4348             MULS     R0,R1,R0
   \   0000022C   0x211A             MOVS     R1,#+26
   \   0000022E   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000232   0x69A1             LDR      R1,[R4, #+24]
   \   00000234   0x4288             CMP      R0,R1
   \   00000236   0xD204             BCS.N    ??SpiritRadioInit_19
   \                     ??SpiritRadioInit_20: (+1)
   \   00000238   0x21BF             MOVS     R1,#+191
   \   0000023A   0x.... 0x....      LDR.W    R0,??DataTable13_5
   \   0000023E   0x.... 0x....      BL       s_assert_failed
    192              }
    193          
    194              /* Goes in READY state */
    195              SpiritSpiCommandStrobes(COMMAND_READY);
   \                     ??SpiritRadioInit_19: (+1)
   \   00000242   0x2062             MOVS     R0,#+98
   \   00000244   0x.... 0x....      BL       SdkEvalSpiCommandStrobes
    196              do{
    197                /* Delay for state transition */
    198                for(volatile uint8_t i=0; i!=0xFF; i++);
   \                     ??SpiritRadioInit_21: (+1)
   \   00000248   0x2000             MOVS     R0,#+0
   \   0000024A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \                     ??SpiritRadioInit_22: (+1)
   \   0000024E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000252   0x28FF             CMP      R0,#+255
   \   00000254   0xD005             BEQ.N    ??SpiritRadioInit_23
   \   00000256   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000025A   0x1C40             ADDS     R0,R0,#+1
   \   0000025C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000260   0xE7F5             B.N      ??SpiritRadioInit_22
    199                
    200                /* Reads the MC_STATUS register */
    201               SpiritRefreshStatus();
   \                     ??SpiritRadioInit_23: (+1)
   \   00000262   0x.... 0x....      BL       SpiritRefreshStatus
    202              }while(g_xStatus.MC_STATE!=MC_STATE_READY);
   \   00000266   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   0000026A   0x7800             LDRB     R0,[R0, #+0]
   \   0000026C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000026E   0x0840             LSRS     R0,R0,#+1
   \   00000270   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000272   0x2803             CMP      R0,#+3
   \   00000274   0xD1E8             BNE.N    ??SpiritRadioInit_21
    203            }
    204            
    205            /* Calculates the FC_OFFSET parameter and cast as signed int: FOffsetTmp = (Fxtal/2^18)*FC_OFFSET */
    206            xtalOffsetFactor = (FOffsetTmp*FBASE_DIVIDER)/s_lXtalFrequency;
   \                     ??SpiritRadioInit_13: (+1)
   \   00000276   0xF45F 0x2080      MOVS     R0,#+262144
   \   0000027A   0xFB00 0xF005      MUL      R0,R0,R5
   \   0000027E   0x.... 0x....      LDR.W    R1,??DataTable15
   \   00000282   0x6809             LDR      R1,[R1, #+0]
   \   00000284   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000288   0x0006             MOVS     R6,R0
    207            anaRadioRegArray[2] = (uint8_t)((((uint16_t)xtalOffsetFactor)>>8)&0x0F);
   \   0000028A   0x0030             MOVS     R0,R6
   \   0000028C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000028E   0x1200             ASRS     R0,R0,#+8
   \   00000290   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000294   0xF88D 0x000A      STRB     R0,[SP, #+10]
    208            anaRadioRegArray[3] = (uint8_t)(xtalOffsetFactor);
   \   00000298   0x0030             MOVS     R0,R6
   \   0000029A   0xF88D 0x000B      STRB     R0,[SP, #+11]
    209            
    210            /* Calculates the channel space factor */
    211            anaRadioRegArray[0] =((uint32_t)pxSRadioInitStruct->nChannelSpace<<9)/(s_lXtalFrequency>>6)+1;
   \   0000029E   0x68A0             LDR      R0,[R4, #+8]
   \   000002A0   0x0240             LSLS     R0,R0,#+9
   \   000002A2   0x.... 0x....      LDR.W    R1,??DataTable15
   \   000002A6   0x6809             LDR      R1,[R1, #+0]
   \   000002A8   0x0989             LSRS     R1,R1,#+6
   \   000002AA   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000002AE   0x1C40             ADDS     R0,R0,#+1
   \   000002B0   0xF88D 0x0008      STRB     R0,[SP, #+8]
    212            
    213            SpiritManagementWaTRxFcMem(pxSRadioInitStruct->lFrequencyBase);
   \   000002B4   0x6860             LDR      R0,[R4, #+4]
   \   000002B6   0x.... 0x....      BL       SpiritManagementWaTRxFcMem
    214            
    215            /* 2nd order DEM algorithm enabling */
    216            uint8_t tmpreg; SpiritSpiReadRegisters(0xA3, 1, &tmpreg);
   \   000002BA   0xF10D 0x0202      ADD      R2,SP,#+2
   \   000002BE   0x2101             MOVS     R1,#+1
   \   000002C0   0x20A3             MOVS     R0,#+163
   \   000002C2   0x.... 0x....      BL       SdkEvalSpiReadRegisters
    217            tmpreg &= ~0x02; SpiritSpiWriteRegisters(0xA3, 1, &tmpreg);
   \   000002C6   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   000002CA   0xF010 0x00FD      ANDS     R0,R0,#0xFD
   \   000002CE   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   000002D2   0xF10D 0x0202      ADD      R2,SP,#+2
   \   000002D6   0x2101             MOVS     R1,#+1
   \   000002D8   0x20A3             MOVS     R0,#+163
   \   000002DA   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
    218            
    219            /* Check the channel center frequency is in one of the possible range */
    220            s_assert_param(IS_FREQUENCY_BAND((pxSRadioInitStruct->lFrequencyBase + ((xtalOffsetFactor*s_lXtalFrequency)/FBASE_DIVIDER) + pxSRadioInitStruct->nChannelSpace * pxSRadioInitStruct->cChannelNumber)));  
   \   000002DE   0x6860             LDR      R0,[R4, #+4]
   \   000002E0   0xB236             SXTH     R6,R6            ;; SignExt  R6,R6,#+16,#+16
   \   000002E2   0x.... 0x....      LDR.W    R1,??DataTable15
   \   000002E6   0x6809             LDR      R1,[R1, #+0]
   \   000002E8   0xFB01 0xF106      MUL      R1,R1,R6
   \   000002EC   0xEB10 0x4091      ADDS     R0,R0,R1, LSR #+18
   \   000002F0   0x68A1             LDR      R1,[R4, #+8]
   \   000002F2   0x7B22             LDRB     R2,[R4, #+12]
   \   000002F4   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   000002F8   0x.... 0x....      LDR.W    R1,??DataTable13  ;; 0x2e5f5680
   \   000002FC   0x4288             CMP      R0,R1
   \   000002FE   0xD310             BCC.N    ??SpiritRadioInit_24
   \   00000300   0x6860             LDR      R0,[R4, #+4]
   \   00000302   0xB236             SXTH     R6,R6            ;; SignExt  R6,R6,#+16,#+16
   \   00000304   0x.... 0x....      LDR.W    R1,??DataTable15
   \   00000308   0x6809             LDR      R1,[R1, #+0]
   \   0000030A   0xFB01 0xF106      MUL      R1,R1,R6
   \   0000030E   0xEB10 0x4091      ADDS     R0,R0,R1, LSR #+18
   \   00000312   0x68A1             LDR      R1,[R4, #+8]
   \   00000314   0x7B22             LDRB     R2,[R4, #+12]
   \   00000316   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000031A   0x.... 0x....      LDR.W    R1,??DataTable13_1  ;; 0x390c2fe1
   \   0000031E   0x4288             CMP      R0,R1
   \   00000320   0xD36A             BCC.N    ??SpiritRadioInit_25
   \                     ??SpiritRadioInit_24: (+1)
   \   00000322   0x6860             LDR      R0,[R4, #+4]
   \   00000324   0xB236             SXTH     R6,R6            ;; SignExt  R6,R6,#+16,#+16
   \   00000326   0x.... 0x....      LDR.W    R1,??DataTable15
   \   0000032A   0x6809             LDR      R1,[R1, #+0]
   \   0000032C   0xFB01 0xF106      MUL      R1,R1,R6
   \   00000330   0xEB10 0x4091      ADDS     R0,R0,R1, LSR #+18
   \   00000334   0x68A1             LDR      R1,[R4, #+8]
   \   00000336   0x7B22             LDRB     R2,[R4, #+12]
   \   00000338   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000033C   0x.... 0x....      LDR.W    R1,??DataTable13_2  ;; 0x1701e480
   \   00000340   0x4288             CMP      R0,R1
   \   00000342   0xD310             BCC.N    ??SpiritRadioInit_26
   \   00000344   0x6860             LDR      R0,[R4, #+4]
   \   00000346   0xB236             SXTH     R6,R6            ;; SignExt  R6,R6,#+16,#+16
   \   00000348   0x.... 0x....      LDR.W    R1,??DataTable15
   \   0000034C   0x6809             LDR      R1,[R1, #+0]
   \   0000034E   0xFB01 0xF106      MUL      R1,R1,R6
   \   00000352   0xEB10 0x4091      ADDS     R0,R0,R1, LSR #+18
   \   00000356   0x68A1             LDR      R1,[R4, #+8]
   \   00000358   0x7B22             LDRB     R2,[R4, #+12]
   \   0000035A   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000035E   0x.... 0x....      LDR.W    R1,??DataTable13_3  ;; 0x1c146a61
   \   00000362   0x4288             CMP      R0,R1
   \   00000364   0xD348             BCC.N    ??SpiritRadioInit_25
   \                     ??SpiritRadioInit_26: (+1)
   \   00000366   0x6860             LDR      R0,[R4, #+4]
   \   00000368   0xB236             SXTH     R6,R6            ;; SignExt  R6,R6,#+16,#+16
   \   0000036A   0x.... 0x....      LDR.W    R1,??DataTable15
   \   0000036E   0x6809             LDR      R1,[R1, #+0]
   \   00000370   0xFB01 0xF106      MUL      R1,R1,R6
   \   00000374   0xEB10 0x4091      ADDS     R0,R0,R1, LSR #+18
   \   00000378   0x68A1             LDR      R1,[R4, #+8]
   \   0000037A   0x7B22             LDRB     R2,[R4, #+12]
   \   0000037C   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000380   0x.... 0x....      LDR.W    R1,??DataTable13_4  ;; 0x11d260c0
   \   00000384   0x4288             CMP      R0,R1
   \   00000386   0xD310             BCC.N    ??SpiritRadioInit_27
   \   00000388   0x6860             LDR      R0,[R4, #+4]
   \   0000038A   0xB236             SXTH     R6,R6            ;; SignExt  R6,R6,#+16,#+16
   \   0000038C   0x.... 0x....      LDR.W    R1,??DataTable15
   \   00000390   0x6809             LDR      R1,[R1, #+0]
   \   00000392   0xFB01 0xF106      MUL      R1,R1,R6
   \   00000396   0xEB10 0x4091      ADDS     R0,R0,R1, LSR #+18
   \   0000039A   0x68A1             LDR      R1,[R4, #+8]
   \   0000039C   0x7B22             LDRB     R2,[R4, #+12]
   \   0000039E   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   000003A2   0x.... 0x....      LDR.W    R1,??DataTable14  ;; 0x14ced7e1
   \   000003A6   0x4288             CMP      R0,R1
   \   000003A8   0xD326             BCC.N    ??SpiritRadioInit_25
   \                     ??SpiritRadioInit_27: (+1)
   \   000003AA   0x6860             LDR      R0,[R4, #+4]
   \   000003AC   0xB236             SXTH     R6,R6            ;; SignExt  R6,R6,#+16,#+16
   \   000003AE   0x.... 0x....      LDR.W    R1,??DataTable15
   \   000003B2   0x6809             LDR      R1,[R1, #+0]
   \   000003B4   0xFB01 0xF106      MUL      R1,R1,R6
   \   000003B8   0xEB10 0x4091      ADDS     R0,R0,R1, LSR #+18
   \   000003BC   0x68A1             LDR      R1,[R4, #+8]
   \   000003BE   0x7B22             LDRB     R2,[R4, #+12]
   \   000003C0   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   000003C4   0x.... 0x....      LDR.W    R1,??DataTable14_1  ;; 0x8e18f40
   \   000003C8   0x4288             CMP      R0,R1
   \   000003CA   0xD310             BCC.N    ??SpiritRadioInit_28
   \   000003CC   0x6860             LDR      R0,[R4, #+4]
   \   000003CE   0xB236             SXTH     R6,R6            ;; SignExt  R6,R6,#+16,#+16
   \   000003D0   0x.... 0x....      LDR.W    R1,??DataTable15
   \   000003D4   0x6809             LDR      R1,[R1, #+0]
   \   000003D6   0xFB01 0xF106      MUL      R1,R1,R6
   \   000003DA   0xEB10 0x4091      ADDS     R0,R0,R1, LSR #+18
   \   000003DE   0x68A1             LDR      R1,[R4, #+8]
   \   000003E0   0x7B22             LDRB     R2,[R4, #+12]
   \   000003E2   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   000003E6   0x.... 0x....      LDR.W    R1,??DataTable14_2  ;; 0xa6fd061
   \   000003EA   0x4288             CMP      R0,R1
   \   000003EC   0xD304             BCC.N    ??SpiritRadioInit_25
   \                     ??SpiritRadioInit_28: (+1)
   \   000003EE   0x21DC             MOVS     R1,#+220
   \   000003F0   0x.... 0x....      LDR.W    R0,??DataTable13_5
   \   000003F4   0x.... 0x....      BL       s_assert_failed
    221            
    222            /* Calculates the datarate mantissa and exponent */
    223            SpiritRadioSearchDatarateME(pxSRadioInitStruct->lDatarate, &drM, &drE);
   \                     ??SpiritRadioInit_25: (+1)
   \   000003F8   0xAA04             ADD      R2,SP,#+16
   \   000003FA   0xF10D 0x0111      ADD      R1,SP,#+17
   \   000003FE   0x6920             LDR      R0,[R4, #+16]
   \   00000400   0x.... 0x....      BL       SpiritRadioSearchDatarateME
    224            digRadioRegArray[0] = (uint8_t)(drM);
   \   00000404   0xF89D 0x0011      LDRB     R0,[SP, #+17]
   \   00000408   0xF88D 0x0014      STRB     R0,[SP, #+20]
    225            digRadioRegArray[1] = (uint8_t)(0x00 | pxSRadioInitStruct->xModulationSelect |drE);
   \   0000040C   0x7B60             LDRB     R0,[R4, #+13]
   \   0000040E   0xF89D 0x1010      LDRB     R1,[SP, #+16]
   \   00000412   0x4308             ORRS     R0,R1,R0
   \   00000414   0xF88D 0x0015      STRB     R0,[SP, #+21]
    226            
    227            /* Calculates the frequency deviation mantissa and exponent */
    228            SpiritRadioSearchFreqDevME(pxSRadioInitStruct->lFreqDev, &FdevM, &FdevE);
   \   00000418   0xF10D 0x0206      ADD      R2,SP,#+6
   \   0000041C   0xF10D 0x0107      ADD      R1,SP,#+7
   \   00000420   0x6960             LDR      R0,[R4, #+20]
   \   00000422   0x.... 0x....      BL       SpiritRadioSearchFreqDevME
    229            digRadioRegArray[2] = (uint8_t)((FdevE<<4) | 0x00 | FdevM);
   \   00000426   0xF89D 0x0006      LDRB     R0,[SP, #+6]
   \   0000042A   0xF89D 0x1007      LDRB     R1,[SP, #+7]
   \   0000042E   0xEA51 0x1000      ORRS     R0,R1,R0, LSL #+4
   \   00000432   0xF88D 0x0016      STRB     R0,[SP, #+22]
    230            
    231            /* Calculates the channel filter mantissa and exponent */
    232            SpiritRadioSearchChannelBwME(pxSRadioInitStruct->lBandwidth, &bwM, &bwE);
   \   00000436   0xAA01             ADD      R2,SP,#+4
   \   00000438   0xF10D 0x0105      ADD      R1,SP,#+5
   \   0000043C   0x69A0             LDR      R0,[R4, #+24]
   \   0000043E   0x.... 0x....      BL       SpiritRadioSearchChannelBwME
    233            
    234            digRadioRegArray[3] = (uint8_t)((bwM<<4) | bwE);
   \   00000442   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \   00000446   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   0000044A   0xEA51 0x1000      ORRS     R0,R1,R0, LSL #+4
   \   0000044E   0xF88D 0x0017      STRB     R0,[SP, #+23]
    235            
    236            if(xSpiritVersion == SPIRIT_VERSION_3_0 || xSpiritVersion == SPIRIT_VERSION_3_0_D1)
   \   00000452   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000454   0x2F02             CMP      R7,#+2
   \   00000456   0xD002             BEQ.N    ??SpiritRadioInit_29
   \   00000458   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000045A   0x2F03             CMP      R7,#+3
   \   0000045C   0xD15A             BNE.N    ??SpiritRadioInit_30
    237            {
    238              uint8_t ifOffsetAna;
    239              if(s_lXtalFrequency==24000000) {
   \                     ??SpiritRadioInit_29: (+1)
   \   0000045E   0x.... 0x....      LDR.W    R0,??DataTable15
   \   00000462   0x6800             LDR      R0,[R0, #+0]
   \   00000464   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x16e3600
   \   00000468   0x4288             CMP      R0,R1
   \   0000046A   0xD105             BNE.N    ??SpiritRadioInit_31
    240                ifOffsetAna = 0xB6;
   \   0000046C   0x20B6             MOVS     R0,#+182
   \   0000046E   0xF88D 0x0001      STRB     R0,[SP, #+1]
    241                anaRadioRegArray[1] = 0xB6;
   \   00000472   0x20B6             MOVS     R0,#+182
   \   00000474   0xF88D 0x0009      STRB     R0,[SP, #+9]
    242              }
    243              if(s_lXtalFrequency==25000000) {
   \                     ??SpiritRadioInit_31: (+1)
   \   00000478   0x.... 0x....      LDR.W    R0,??DataTable15
   \   0000047C   0x6800             LDR      R0,[R0, #+0]
   \   0000047E   0x.... 0x....      LDR.W    R1,??DataTable17_1  ;; 0x17d7840
   \   00000482   0x4288             CMP      R0,R1
   \   00000484   0xD105             BNE.N    ??SpiritRadioInit_32
    244                ifOffsetAna = 0xAC;
   \   00000486   0x20AC             MOVS     R0,#+172
   \   00000488   0xF88D 0x0001      STRB     R0,[SP, #+1]
    245                anaRadioRegArray[1] = 0xAC;
   \   0000048C   0x20AC             MOVS     R0,#+172
   \   0000048E   0xF88D 0x0009      STRB     R0,[SP, #+9]
    246              }
    247              if(s_lXtalFrequency==26000000) {
   \                     ??SpiritRadioInit_32: (+1)
   \   00000492   0x.... 0x....      LDR.W    R0,??DataTable15
   \   00000496   0x6800             LDR      R0,[R0, #+0]
   \   00000498   0x.... 0x....      LDR.W    R1,??DataTable17_2  ;; 0x18cba80
   \   0000049C   0x4288             CMP      R0,R1
   \   0000049E   0xD105             BNE.N    ??SpiritRadioInit_33
    248                ifOffsetAna = 0xA3;
   \   000004A0   0x20A3             MOVS     R0,#+163
   \   000004A2   0xF88D 0x0001      STRB     R0,[SP, #+1]
    249                anaRadioRegArray[1] = 0xA3;
   \   000004A6   0x20A3             MOVS     R0,#+163
   \   000004A8   0xF88D 0x0009      STRB     R0,[SP, #+9]
    250              }
    251              if(s_lXtalFrequency==48000000) {
   \                     ??SpiritRadioInit_33: (+1)
   \   000004AC   0x.... 0x....      LDR.W    R0,??DataTable15
   \   000004B0   0x6800             LDR      R0,[R0, #+0]
   \   000004B2   0x.... 0x....      LDR.W    R1,??DataTable15_2  ;; 0x2dc6c00
   \   000004B6   0x4288             CMP      R0,R1
   \   000004B8   0xD105             BNE.N    ??SpiritRadioInit_34
    252                ifOffsetAna = 0x3B;
   \   000004BA   0x203B             MOVS     R0,#+59
   \   000004BC   0xF88D 0x0001      STRB     R0,[SP, #+1]
    253                anaRadioRegArray[1] = 0xB6;
   \   000004C0   0x20B6             MOVS     R0,#+182
   \   000004C2   0xF88D 0x0009      STRB     R0,[SP, #+9]
    254              }
    255              if(s_lXtalFrequency==50000000) {
   \                     ??SpiritRadioInit_34: (+1)
   \   000004C6   0x.... 0x....      LDR.W    R0,??DataTable15
   \   000004CA   0x6800             LDR      R0,[R0, #+0]
   \   000004CC   0x.... 0x....      LDR.W    R1,??DataTable17_3  ;; 0x2faf080
   \   000004D0   0x4288             CMP      R0,R1
   \   000004D2   0xD105             BNE.N    ??SpiritRadioInit_35
    256                ifOffsetAna = 0x36;
   \   000004D4   0x2036             MOVS     R0,#+54
   \   000004D6   0xF88D 0x0001      STRB     R0,[SP, #+1]
    257                anaRadioRegArray[1] = 0xAC;
   \   000004DA   0x20AC             MOVS     R0,#+172
   \   000004DC   0xF88D 0x0009      STRB     R0,[SP, #+9]
    258              }
    259              if(s_lXtalFrequency==52000000) {
   \                     ??SpiritRadioInit_35: (+1)
   \   000004E0   0x.... 0x....      LDR.W    R0,??DataTable15
   \   000004E4   0x6800             LDR      R0,[R0, #+0]
   \   000004E6   0x.... 0x....      LDR.W    R1,??DataTable17_4  ;; 0x3197500
   \   000004EA   0x4288             CMP      R0,R1
   \   000004EC   0xD105             BNE.N    ??SpiritRadioInit_36
    260                ifOffsetAna = 0x31;
   \   000004EE   0x2031             MOVS     R0,#+49
   \   000004F0   0xF88D 0x0001      STRB     R0,[SP, #+1]
    261                anaRadioRegArray[1] = 0xA3;
   \   000004F4   0x20A3             MOVS     R0,#+163
   \   000004F6   0xF88D 0x0009      STRB     R0,[SP, #+9]
    262              }
    263              
    264              g_xStatus = SpiritSpiWriteRegisters(IF_OFFSET_ANA_BASE, 1, &ifOffsetAna);
   \                     ??SpiritRadioInit_36: (+1)
   \   000004FA   0xF10D 0x0201      ADD      R2,SP,#+1
   \   000004FE   0x2101             MOVS     R1,#+1
   \   00000500   0x2007             MOVS     R0,#+7
   \   00000502   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000506   0x9006             STR      R0,[SP, #+24]
   \   00000508   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   0000050C   0xF8BD 0x1018      LDRH     R1,[SP, #+24]
   \   00000510   0x8001             STRH     R1,[R0, #+0]
   \   00000512   0xE032             B.N      ??SpiritRadioInit_37
    265            }
    266            else
    267            {
    268              if(s_lXtalFrequency==24000000 || s_lXtalFrequency==48000000) {
   \                     ??SpiritRadioInit_30: (+1)
   \   00000514   0x.... 0x....      LDR.W    R0,??DataTable15
   \   00000518   0x6800             LDR      R0,[R0, #+0]
   \   0000051A   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x16e3600
   \   0000051E   0x4288             CMP      R0,R1
   \   00000520   0xD006             BEQ.N    ??SpiritRadioInit_38
   \   00000522   0x.... 0x....      LDR.W    R0,??DataTable15
   \   00000526   0x6800             LDR      R0,[R0, #+0]
   \   00000528   0x.... 0x....      LDR.W    R1,??DataTable15_2  ;; 0x2dc6c00
   \   0000052C   0x4288             CMP      R0,R1
   \   0000052E   0xD102             BNE.N    ??SpiritRadioInit_39
    269                anaRadioRegArray[1] = 0xB6;
   \                     ??SpiritRadioInit_38: (+1)
   \   00000530   0x20B6             MOVS     R0,#+182
   \   00000532   0xF88D 0x0009      STRB     R0,[SP, #+9]
    270              }
    271              if(s_lXtalFrequency==25000000 || s_lXtalFrequency==50000000) {
   \                     ??SpiritRadioInit_39: (+1)
   \   00000536   0x.... 0x....      LDR.W    R0,??DataTable15
   \   0000053A   0x6800             LDR      R0,[R0, #+0]
   \   0000053C   0x.... 0x....      LDR.W    R1,??DataTable17_1  ;; 0x17d7840
   \   00000540   0x4288             CMP      R0,R1
   \   00000542   0xD006             BEQ.N    ??SpiritRadioInit_40
   \   00000544   0x.... 0x....      LDR.W    R0,??DataTable15
   \   00000548   0x6800             LDR      R0,[R0, #+0]
   \   0000054A   0x.... 0x....      LDR.W    R1,??DataTable17_3  ;; 0x2faf080
   \   0000054E   0x4288             CMP      R0,R1
   \   00000550   0xD102             BNE.N    ??SpiritRadioInit_41
    272                anaRadioRegArray[1] = 0xAC;
   \                     ??SpiritRadioInit_40: (+1)
   \   00000552   0x20AC             MOVS     R0,#+172
   \   00000554   0xF88D 0x0009      STRB     R0,[SP, #+9]
    273              }
    274              if(s_lXtalFrequency==26000000 || s_lXtalFrequency==52000000) {
   \                     ??SpiritRadioInit_41: (+1)
   \   00000558   0x.... 0x....      LDR.W    R0,??DataTable15
   \   0000055C   0x6800             LDR      R0,[R0, #+0]
   \   0000055E   0x.... 0x....      LDR.W    R1,??DataTable17_2  ;; 0x18cba80
   \   00000562   0x4288             CMP      R0,R1
   \   00000564   0xD006             BEQ.N    ??SpiritRadioInit_42
   \   00000566   0x.... 0x....      LDR.W    R0,??DataTable15
   \   0000056A   0x6800             LDR      R0,[R0, #+0]
   \   0000056C   0x.... 0x....      LDR.W    R1,??DataTable17_4  ;; 0x3197500
   \   00000570   0x4288             CMP      R0,R1
   \   00000572   0xD102             BNE.N    ??SpiritRadioInit_37
    275                anaRadioRegArray[1] = 0xA3;
   \                     ??SpiritRadioInit_42: (+1)
   \   00000574   0x20A3             MOVS     R0,#+163
   \   00000576   0xF88D 0x0009      STRB     R0,[SP, #+9]
    276              }
    277            }
    278            
    279            /* Sets Xtal configuration */
    280            if(s_lXtalFrequency>26000000) 
   \                     ??SpiritRadioInit_37: (+1)
   \   0000057A   0x.... 0x....      LDR.W    R0,??DataTable15
   \   0000057E   0x6800             LDR      R0,[R0, #+0]
   \   00000580   0x.... 0x....      LDR.W    R1,??DataTable17_5  ;; 0x18cba81
   \   00000584   0x4288             CMP      R0,R1
   \   00000586   0xD30E             BCC.N    ??SpiritRadioInit_43
    281            {
    282              SpiritRadioSetXtalFlag(XTAL_FLAG((s_lXtalFrequency/2)));
   \   00000588   0x.... 0x....      LDR.W    R0,??DataTable15
   \   0000058C   0x6800             LDR      R0,[R0, #+0]
   \   0000058E   0x0840             LSRS     R0,R0,#+1
   \   00000590   0x.... 0x....      LDR.W    R1,??DataTable17_1  ;; 0x17d7840
   \   00000594   0x4288             CMP      R0,R1
   \   00000596   0xD301             BCC.N    ??SpiritRadioInit_44
   \   00000598   0x2001             MOVS     R0,#+1
   \   0000059A   0xE000             B.N      ??SpiritRadioInit_45
   \                     ??SpiritRadioInit_44: (+1)
   \   0000059C   0x2000             MOVS     R0,#+0
   \                     ??SpiritRadioInit_45: (+1)
   \   0000059E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000005A0   0x.... 0x....      BL       SpiritRadioSetXtalFlag
   \   000005A4   0xE00C             B.N      ??SpiritRadioInit_46
    283            }
    284            else
    285            {
    286              SpiritRadioSetXtalFlag(XTAL_FLAG(s_lXtalFrequency));
   \                     ??SpiritRadioInit_43: (+1)
   \   000005A6   0x.... 0x....      LDR.W    R0,??DataTable15
   \   000005AA   0x6800             LDR      R0,[R0, #+0]
   \   000005AC   0x.... 0x....      LDR.W    R1,??DataTable17_1  ;; 0x17d7840
   \   000005B0   0x4288             CMP      R0,R1
   \   000005B2   0xD301             BCC.N    ??SpiritRadioInit_47
   \   000005B4   0x2001             MOVS     R0,#+1
   \   000005B6   0xE000             B.N      ??SpiritRadioInit_48
   \                     ??SpiritRadioInit_47: (+1)
   \   000005B8   0x2000             MOVS     R0,#+0
   \                     ??SpiritRadioInit_48: (+1)
   \   000005BA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000005BC   0x.... 0x....      BL       SpiritRadioSetXtalFlag
    287            }
    288            
    289            /* Sets the channel number in the corresponding register */
    290            SpiritSpiWriteRegisters(CHNUM_BASE, 1, &pxSRadioInitStruct->cChannelNumber);
   \                     ??SpiritRadioInit_46: (+1)
   \   000005C0   0xF114 0x020C      ADDS     R2,R4,#+12
   \   000005C4   0x2101             MOVS     R1,#+1
   \   000005C6   0x206C             MOVS     R0,#+108
   \   000005C8   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
    291            
    292            /* Configures the Analog Radio registers */
    293            SpiritSpiWriteRegisters(CHSPACE_BASE, 4, anaRadioRegArray);
   \   000005CC   0xAA02             ADD      R2,SP,#+8
   \   000005CE   0x2104             MOVS     R1,#+4
   \   000005D0   0x200C             MOVS     R0,#+12
   \   000005D2   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
    294            
    295            /* Configures the Digital Radio registers */
    296            g_xStatus = SpiritSpiWriteRegisters(MOD1_BASE, 4, digRadioRegArray);
   \   000005D6   0xAA05             ADD      R2,SP,#+20
   \   000005D8   0x2104             MOVS     R1,#+4
   \   000005DA   0x201A             MOVS     R0,#+26
   \   000005DC   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   000005E0   0x9006             STR      R0,[SP, #+24]
   \   000005E2   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   000005E6   0xF8BD 0x1018      LDRH     R1,[SP, #+24]
   \   000005EA   0x8001             STRH     R1,[R0, #+0]
    297            
    298            /* Enable the freeze option of the AFC on the SYNC word */
    299            SpiritRadioAFCFreezeOnSync(S_ENABLE);
   \   000005EC   0x2001             MOVS     R0,#+1
   \   000005EE   0x.... 0x....      BL       SpiritRadioAFCFreezeOnSync
    300            
    301            SpiritRadioSetFrequencyBase(pxSRadioInitStruct->lFrequencyBase);
   \   000005F2   0x6860             LDR      R0,[R4, #+4]
   \   000005F4   0x.... 0x....      BL       SpiritRadioSetFrequencyBase
    302            
    303          }
   \   000005F8   0xB007             ADD      SP,SP,#+28
   \   000005FA   0xBDF0             POP      {R4-R7,PC}       ;; return
    304          
    305          
    306          /**
    307          * @brief  Returns the SPIRIT analog and digital radio structure according to the registers value.
    308          * @param  pxSRadioInitStruct pointer to a SRadioInit structure that
    309          *         contains the configuration information for the analog radio part of SPIRIT.
    310          * @retval None.
    311          */

   \                                 In section .text, align 2, keep-with-next
    312          void SpiritRadioGetInfo(SRadioInit* pxSRadioInitStruct)
    313          {
   \                     SpiritRadioGetInfo: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x0004             MOVS     R4,R0
    314            uint8_t anaRadioRegArray[8], digRadioRegArray[4];
    315            BandSelect band;
    316            int16_t xtalOffsetFactor;
    317            
    318            /* Get the RF board version */
    319            SpiritVersion xSpiritVersion = SpiritGeneralGetSpiritVersion();
   \   00000008   0x.... 0x....      BL       SpiritGeneralGetSpiritVersion
   \   0000000C   0x4682             MOV      R10,R0
    320            
    321            /* Reads the Analog Radio registers */
    322            SpiritSpiReadRegisters(SYNT3_BASE, 8, anaRadioRegArray);
   \   0000000E   0xAA04             ADD      R2,SP,#+16
   \   00000010   0x2108             MOVS     R1,#+8
   \   00000012   0x2008             MOVS     R0,#+8
   \   00000014   0x.... 0x....      BL       SdkEvalSpiReadRegisters
    323            
    324            /* Reads the Digital Radio registers */
    325            g_xStatus = SpiritSpiReadRegisters(MOD1_BASE, 4, digRadioRegArray);
   \   00000018   0xAA03             ADD      R2,SP,#+12
   \   0000001A   0x2104             MOVS     R1,#+4
   \   0000001C   0x201A             MOVS     R0,#+26
   \   0000001E   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   00000022   0x9000             STR      R0,[SP, #+0]
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   00000028   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   0000002C   0x8001             STRH     R1,[R0, #+0]
    326            
    327            /* Reads the operating band masking the Band selected field */
    328            if((anaRadioRegArray[3] & 0x07) == SYNT0_BS_6)
   \   0000002E   0xF89D 0x0013      LDRB     R0,[SP, #+19]
   \   00000032   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000036   0x2801             CMP      R0,#+1
   \   00000038   0xD102             BNE.N    ??SpiritRadioGetInfo_0
    329            {
    330              band = HIGH_BAND;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x4683             MOV      R11,R0
   \   0000003E   0xE019             B.N      ??SpiritRadioGetInfo_1
    331            }
    332            else if ((anaRadioRegArray[3] & 0x07) == SYNT0_BS_12)
   \                     ??SpiritRadioGetInfo_0: (+1)
   \   00000040   0xF89D 0x0013      LDRB     R0,[SP, #+19]
   \   00000044   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000048   0x2803             CMP      R0,#+3
   \   0000004A   0xD102             BNE.N    ??SpiritRadioGetInfo_2
    333            {
    334              band = MIDDLE_BAND;
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0x4683             MOV      R11,R0
   \   00000050   0xE010             B.N      ??SpiritRadioGetInfo_1
    335            }
    336            else if ((anaRadioRegArray[3] & 0x07) == SYNT0_BS_16)
   \                     ??SpiritRadioGetInfo_2: (+1)
   \   00000052   0xF89D 0x0013      LDRB     R0,[SP, #+19]
   \   00000056   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   0000005A   0x2804             CMP      R0,#+4
   \   0000005C   0xD102             BNE.N    ??SpiritRadioGetInfo_3
    337            {
    338              band = LOW_BAND;
   \   0000005E   0x2002             MOVS     R0,#+2
   \   00000060   0x4683             MOV      R11,R0
   \   00000062   0xE007             B.N      ??SpiritRadioGetInfo_1
    339            }
    340            else if ((anaRadioRegArray[3] & 0x07) == SYNT0_BS_32)
   \                     ??SpiritRadioGetInfo_3: (+1)
   \   00000064   0xF89D 0x0013      LDRB     R0,[SP, #+19]
   \   00000068   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   0000006C   0x2805             CMP      R0,#+5
   \   0000006E   0xD101             BNE.N    ??SpiritRadioGetInfo_1
    341            {
    342              band = VERY_LOW_BAND;
   \   00000070   0x2003             MOVS     R0,#+3
   \   00000072   0x4683             MOV      R11,R0
    343            }
    344            
    345            /* Computes the synth word */
    346            uint32_t synthWord = (uint32_t)((((uint32_t)(anaRadioRegArray[0]&0x1F))<<21)+(((uint32_t)(anaRadioRegArray[1]))<<13)+\
    347              (((uint32_t)(anaRadioRegArray[2]))<<5)+(((uint32_t)(anaRadioRegArray[3]))>>3));
   \                     ??SpiritRadioGetInfo_1: (+1)
   \   00000074   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \   00000078   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   0000007C   0xF89D 0x1011      LDRB     R1,[SP, #+17]
   \   00000080   0x0349             LSLS     R1,R1,#+13
   \   00000082   0xEB11 0x5040      ADDS     R0,R1,R0, LSL #+21
   \   00000086   0xF89D 0x1012      LDRB     R1,[SP, #+18]
   \   0000008A   0xEB10 0x1041      ADDS     R0,R0,R1, LSL #+5
   \   0000008E   0xF89D 0x1013      LDRB     R1,[SP, #+19]
   \   00000092   0xEB10 0x09D1      ADDS     R9,R0,R1, LSR #+3
    348            
    349            /* Calculates the frequency base */
    350            uint8_t cRefDiv = (uint8_t)SpiritRadioGetRefDiv()+1;
   \   00000096   0x.... 0x....      BL       SpiritRadioGetRefDiv
   \   0000009A   0xF110 0x0801      ADDS     R8,R0,#+1
    351            pxSRadioInitStruct->lFrequencyBase = (uint32_t)round(synthWord*(((double)s_lXtalFrequency)/(FBASE_DIVIDER*cRefDiv*s_vectcBHalfFactor[band])));
   \   0000009E   0x4648             MOV      R0,R9
   \   000000A0   0x.... 0x....      BL       __aeabi_ui2d
   \   000000A4   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \   000000A8   0x.... 0x....      LDR.W    R0,??DataTable15
   \   000000AC   0x6800             LDR      R0,[R0, #+0]
   \   000000AE   0x.... 0x....      BL       __aeabi_ui2d
   \   000000B2   0x0006             MOVS     R6,R0
   \   000000B4   0x000F             MOVS     R7,R1
   \   000000B6   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable18
   \   000000BE   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000C2   0xF81B 0x0000      LDRB     R0,[R11, R0]
   \   000000C6   0xFB00 0xF008      MUL      R0,R0,R8
   \   000000CA   0xF45F 0x2180      MOVS     R1,#+262144
   \   000000CE   0x4348             MULS     R0,R1,R0
   \   000000D0   0x.... 0x....      BL       __aeabi_i2d
   \   000000D4   0x0002             MOVS     R2,R0
   \   000000D6   0x000B             MOVS     R3,R1
   \   000000D8   0x0030             MOVS     R0,R6
   \   000000DA   0x0039             MOVS     R1,R7
   \   000000DC   0x.... 0x....      BL       __aeabi_ddiv
   \   000000E0   0xE9DD 0x2300      LDRD     R2,R3,[SP, #+0]
   \   000000E4   0x.... 0x....      BL       __aeabi_dmul
   \   000000E8   0x.... 0x....      BL       round
   \   000000EC   0x.... 0x....      BL       __aeabi_d2uiz
   \   000000F0   0x6060             STR      R0,[R4, #+4]
    352            
    353            /* Calculates the Offset Factor */
    354            uint16_t xtalOffTemp = ((((uint16_t)anaRadioRegArray[6])<<8)+((uint16_t)anaRadioRegArray[7]));
   \   000000F2   0xF89D 0x0016      LDRB     R0,[SP, #+22]
   \   000000F6   0xF89D 0x1017      LDRB     R1,[SP, #+23]
   \   000000FA   0xEB11 0x2500      ADDS     R5,R1,R0, LSL #+8
    355            
    356            /* If a negative number then convert the 12 bit 2-complement in a 16 bit number */
    357            if(xtalOffTemp & 0x0800)
   \   000000FE   0x0528             LSLS     R0,R5,#+20
   \   00000100   0xD502             BPL.N    ??SpiritRadioGetInfo_4
    358            {
    359              xtalOffTemp = xtalOffTemp | 0xF000;
   \   00000102   0xF455 0x4570      ORRS     R5,R5,#0xF000
   \   00000106   0xE001             B.N      ??SpiritRadioGetInfo_5
    360            }
    361            else
    362            {
    363              xtalOffTemp = xtalOffTemp & 0x0FFF;
   \                     ??SpiritRadioGetInfo_4: (+1)
   \   00000108   0x052D             LSLS     R5,R5,#+20       ;; ZeroExtS R5,R5,#+20,#+20
   \   0000010A   0x0D2D             LSRS     R5,R5,#+20
    364            }
    365            
    366            xtalOffsetFactor = *((int16_t*)(&xtalOffTemp));
   \                     ??SpiritRadioGetInfo_5: (+1)
   \   0000010C   0xF8AD 0x5018      STRH     R5,[SP, #+24]
    367            
    368            /* Calculates the frequency offset in ppm */
    369            pxSRadioInitStruct->nXtalOffsetPpm =(int16_t)((uint32_t)xtalOffsetFactor*s_lXtalFrequency*PPM_FACTOR)/((uint32_t)FBASE_DIVIDER*pxSRadioInitStruct->lFrequencyBase);
   \   00000110   0xF9BD 0x0018      LDRSH    R0,[SP, #+24]
   \   00000114   0x.... 0x....      LDR.W    R1,??DataTable15
   \   00000118   0x6809             LDR      R1,[R1, #+0]
   \   0000011A   0x4348             MULS     R0,R1,R0
   \   0000011C   0x.... 0x....      BL       __aeabi_ui2d
   \   00000120   0x2200             MOVS     R2,#+0
   \   00000122   0x.... 0x....      LDR.W    R3,??DataTable12  ;; 0x412e8480
   \   00000126   0x.... 0x....      BL       __aeabi_dmul
   \   0000012A   0x.... 0x....      BL       __aeabi_d2iz
   \   0000012E   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000130   0x6861             LDR      R1,[R4, #+4]
   \   00000132   0xF45F 0x2280      MOVS     R2,#+262144
   \   00000136   0x4351             MULS     R1,R2,R1
   \   00000138   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000013C   0x8020             STRH     R0,[R4, #+0]
    370            
    371            /* Channel space */
    372            pxSRadioInitStruct->nChannelSpace = anaRadioRegArray[4]*(s_lXtalFrequency>>15);
   \   0000013E   0xF89D 0x0014      LDRB     R0,[SP, #+20]
   \   00000142   0x.... 0x....      LDR.W    R1,??DataTable15
   \   00000146   0x6809             LDR      R1,[R1, #+0]
   \   00000148   0x0BC9             LSRS     R1,R1,#+15
   \   0000014A   0x4348             MULS     R0,R1,R0
   \   0000014C   0x60A0             STR      R0,[R4, #+8]
    373            
    374            /* Channel number */
    375            pxSRadioInitStruct->cChannelNumber = SpiritRadioGetChannel();
   \   0000014E   0x.... 0x....      BL       SpiritRadioGetChannel
   \   00000152   0x7320             STRB     R0,[R4, #+12]
    376            
    377            /* Modulation select */
    378            pxSRadioInitStruct->xModulationSelect = (ModulationSelect)(digRadioRegArray[1] & 0x70);
   \   00000154   0xF89D 0x000D      LDRB     R0,[SP, #+13]
   \   00000158   0xF010 0x0070      ANDS     R0,R0,#0x70
   \   0000015C   0x7360             STRB     R0,[R4, #+13]
    379            
    380            /* Reads the frequency deviation for mantissa and exponent */
    381            uint8_t FDevM = digRadioRegArray[2]&0x07;
   \   0000015E   0xF89D 0x000E      LDRB     R0,[SP, #+14]
   \   00000162   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000166   0xF88D 0x000B      STRB     R0,[SP, #+11]
    382            uint8_t FDevE = (digRadioRegArray[2]&0xF0)>>4;
   \   0000016A   0xF89D 0x000E      LDRB     R0,[SP, #+14]
   \   0000016E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000170   0x0900             LSRS     R0,R0,#+4
   \   00000172   0xF88D 0x000A      STRB     R0,[SP, #+10]
    383            
    384            /* Reads the channel filter register for mantissa and exponent */
    385            uint8_t bwM = (digRadioRegArray[3]&0xF0)>>4;
   \   00000176   0xF89D 0x000F      LDRB     R0,[SP, #+15]
   \   0000017A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000017C   0x0900             LSRS     R0,R0,#+4
   \   0000017E   0xF88D 0x0009      STRB     R0,[SP, #+9]
    386            uint8_t bwE = digRadioRegArray[3]&0x0F;
   \   00000182   0xF89D 0x000F      LDRB     R0,[SP, #+15]
   \   00000186   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   0000018A   0xF88D 0x0008      STRB     R0,[SP, #+8]
    387            
    388            uint8_t cDivider = 0;
   \   0000018E   0x2600             MOVS     R6,#+0
    389            uint8_t cCorrection = 0;
   \   00000190   0x2700             MOVS     R7,#+0
    390            if(xSpiritVersion != SPIRIT_VERSION_2_0)
   \   00000192   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000196   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000019A   0xD004             BEQ.N    ??SpiritRadioGetInfo_6
    391            {  
    392              cDivider = SpiritRadioGetDigDiv();
   \   0000019C   0x.... 0x....      BL       SpiritRadioGetDigDiv
   \   000001A0   0x0006             MOVS     R6,R0
    393              cCorrection = 1;
   \   000001A2   0x2001             MOVS     R0,#+1
   \   000001A4   0x0007             MOVS     R7,R0
    394            }
    395            
    396            /* Calculates the datarate */
    397            pxSRadioInitStruct->lDatarate = ((s_lXtalFrequency>>(5+cDivider))*(256+digRadioRegArray[0]))>>(23-(digRadioRegArray[1]&0x0F));
   \                     ??SpiritRadioGetInfo_6: (+1)
   \   000001A6   0x.... 0x....      LDR.W    R0,??DataTable15
   \   000001AA   0x6800             LDR      R0,[R0, #+0]
   \   000001AC   0x1D71             ADDS     R1,R6,#+5
   \   000001AE   0x0002             MOVS     R2,R0
   \   000001B0   0x40CA             LSRS     R2,R2,R1
   \   000001B2   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   000001B6   0xF510 0x7080      ADDS     R0,R0,#+256
   \   000001BA   0xFB00 0xF002      MUL      R0,R0,R2
   \   000001BE   0xF89D 0x100D      LDRB     R1,[SP, #+13]
   \   000001C2   0xF011 0x010F      ANDS     R1,R1,#0xF
   \   000001C6   0xF1D1 0x0117      RSBS     R1,R1,#+23
   \   000001CA   0x0002             MOVS     R2,R0
   \   000001CC   0x40CA             LSRS     R2,R2,R1
   \   000001CE   0x6122             STR      R2,[R4, #+16]
    398            
    399            /* Calculates the frequency deviation */
    400            pxSRadioInitStruct->lFreqDev = (((s_lXtalFrequency>>6)*(8+FDevM))>>(12-FDevE+cCorrection));
   \   000001D0   0x.... 0x....      LDR.W    R0,??DataTable15
   \   000001D4   0x6800             LDR      R0,[R0, #+0]
   \   000001D6   0x0980             LSRS     R0,R0,#+6
   \   000001D8   0xF89D 0x100B      LDRB     R1,[SP, #+11]
   \   000001DC   0x3108             ADDS     R1,R1,#+8
   \   000001DE   0x4348             MULS     R0,R1,R0
   \   000001E0   0xF89D 0x100A      LDRB     R1,[SP, #+10]
   \   000001E4   0xF1D1 0x010C      RSBS     R1,R1,#+12
   \   000001E8   0x1879             ADDS     R1,R7,R1
   \   000001EA   0x0002             MOVS     R2,R0
   \   000001EC   0x40CA             LSRS     R2,R2,R1
   \   000001EE   0x6162             STR      R2,[R4, #+20]
    401            
    402            /* Reads the channel filter bandwidth from the look-up table and return it */
    403            pxSRadioInitStruct->lBandwidth = (uint32_t)(100.0*s_vectnBandwidth26M[bwM+(bwE*9)]*((s_lXtalFrequency>>cDivider)/26e6));
   \   000001F0   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   000001F4   0xF89D 0x1009      LDRB     R1,[SP, #+9]
   \   000001F8   0xF89D 0x2008      LDRB     R2,[SP, #+8]
   \   000001FC   0x2309             MOVS     R3,#+9
   \   000001FE   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   00000202   0xF830 0x0011      LDRH     R0,[R0, R1, LSL #+1]
   \   00000206   0x.... 0x....      BL       __aeabi_ui2d
   \   0000020A   0x2200             MOVS     R2,#+0
   \   0000020C   0x.... 0x....      LDR.W    R3,??DataTable18_2  ;; 0x40590000
   \   00000210   0x.... 0x....      BL       __aeabi_dmul
   \   00000214   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \   00000218   0x.... 0x....      LDR.W    R0,??DataTable15
   \   0000021C   0x6801             LDR      R1,[R0, #+0]
   \   0000021E   0x0008             MOVS     R0,R1
   \   00000220   0x40F0             LSRS     R0,R0,R6
   \   00000222   0x.... 0x....      BL       __aeabi_ui2d
   \   00000226   0x2200             MOVS     R2,#+0
   \   00000228   0x.... 0x....      LDR.W    R3,??DataTable19  ;; 0x4178cba8
   \   0000022C   0x.... 0x....      BL       __aeabi_ddiv
   \   00000230   0xE9DD 0x2300      LDRD     R2,R3,[SP, #+0]
   \   00000234   0x.... 0x....      BL       __aeabi_dmul
   \   00000238   0x.... 0x....      BL       __aeabi_d2uiz
   \   0000023C   0x61A0             STR      R0,[R4, #+24]
    404            
    405          }
   \   0000023E   0xB007             ADD      SP,SP,#+28
   \   00000240   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    406          
    407          
    408          /**
    409          * @brief  Sets the Xtal configuration in the ANA_FUNC_CONF0 register.
    410          * @param  xXtal one of the possible value of the enum type XtalFrequency.
    411          *         @arg XTAL_FLAG_24_MHz:  in case of 24 MHz crystal
    412          *         @arg XTAL_FLAG_26_MHz:  in case of 26 MHz crystal
    413          * @retval None.
    414          */

   \                                 In section .text, align 2, keep-with-next
    415          void SpiritRadioSetXtalFlag(XtalFlag xXtal)
    416          {
   \                     SpiritRadioSetXtalFlag: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    417            uint8_t tempRegValue = 0x00;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
    418            
    419            /* Check the parameters */
    420            s_assert_param(IS_XTAL_FLAG(xXtal));
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD008             BEQ.N    ??SpiritRadioSetXtalFlag_0
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C01             CMP      R4,#+1
   \   00000014   0xD005             BEQ.N    ??SpiritRadioSetXtalFlag_0
   \   00000016   0xF44F 0x71D2      MOV      R1,#+420
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable13_5
   \   0000001E   0x.... 0x....      BL       s_assert_failed
    421            
    422            /* Reads the ANA_FUNC_CONF_0 register */
    423            g_xStatus = SpiritSpiReadRegisters(ANA_FUNC_CONF0_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioSetXtalFlag_0: (+1)
   \   00000022   0xAA00             ADD      R2,SP,#+0
   \   00000024   0x2101             MOVS     R1,#+1
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000002C   0x9001             STR      R0,[SP, #+4]
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   00000032   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000036   0x8001             STRH     R1,[R0, #+0]
    424            if(xXtal == XTAL_FLAG_26_MHz)
   \   00000038   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003A   0x2C01             CMP      R4,#+1
   \   0000003C   0xD106             BNE.N    ??SpiritRadioSetXtalFlag_1
    425            {
    426              tempRegValue|=SELECT_24_26_MHZ_MASK;
   \   0000003E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000042   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000046   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000004A   0xE005             B.N      ??SpiritRadioSetXtalFlag_2
    427            }
    428            else
    429            {
    430              tempRegValue &= (~SELECT_24_26_MHZ_MASK);
   \                     ??SpiritRadioSetXtalFlag_1: (+1)
   \   0000004C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000050   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   00000054   0xF88D 0x0000      STRB     R0,[SP, #+0]
    431            }
    432            
    433            /* Sets the 24_26MHz_SELECT field in the ANA_FUNC_CONF_0 register */
    434            g_xStatus = SpiritSpiWriteRegisters(ANA_FUNC_CONF0_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioSetXtalFlag_2: (+1)
   \   00000058   0xAA00             ADD      R2,SP,#+0
   \   0000005A   0x2101             MOVS     R1,#+1
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000062   0x9001             STR      R0,[SP, #+4]
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   00000068   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   0000006C   0x8001             STRH     R1,[R0, #+0]
    435            
    436          }
   \   0000006E   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    437          
    438          
    439          /**
    440          * @brief  Returns the Xtal configuration in the ANA_FUNC_CONF0 register.
    441          * @param  None.
    442          * @retval XtalFrequency Settled Xtal configuration.
    443          */

   \                                 In section .text, align 2, keep-with-next
    444          XtalFlag SpiritRadioGetXtalFlag(void)
    445          {
   \                     SpiritRadioGetXtalFlag: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    446            uint8_t tempRegValue;
    447            
    448            /* Reads the Xtal configuration in the ANA_FUNC_CONF_0 register and return the value */
    449            g_xStatus = SpiritSpiReadRegisters(ANA_FUNC_CONF0_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   00000014   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000018   0x8001             STRH     R1,[R0, #+0]
    450            
    451            return (XtalFlag)((tempRegValue & 0x40)>>6);
   \   0000001A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001E   0xF3C0 0x1080      UBFX     R0,R0,#+6,#+1
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0xBD0E             POP      {R1-R3,PC}       ;; return
    452            
    453          }
    454          
    455          
    456          /**
    457          * @brief  Returns the charge pump word for a given VCO frequency.
    458          * @param  lFc channel center frequency expressed in Hz.
    459          *         This parameter can be a value in one of the following ranges:<ul>
    460          *         <li> High_Band: from 779 MHz to 915 MHz </li>
    461          *         <li> Middle Band: from 387 MHz to 470 MHz </li>
    462          *         <li> Low Band: from 300 MHz to 348 MHz </li>
    463          *         <li> Very low Band: from 150 MHz to 174 MHz </li> </ul>
    464          * @retval uint8_t Charge pump word.
    465          */

   \                                 In section .text, align 2, keep-with-next
    466          uint8_t SpiritRadioSearchWCP(uint32_t lFc)
    467          {
   \                     SpiritRadioSearchWCP: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
    468            volatile SpiritBool find = S_FALSE;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xF88D 0x0000      STRB     R0,[SP, #+0]
    469            volatile SpiritBool find_up = S_FALSE;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xF88D 0x0001      STRB     R0,[SP, #+1]
    470            int8_t i=8;
   \   00000012   0x2508             MOVS     R5,#+8
    471            int8_t start = 0;
   \   00000014   0x2600             MOVS     R6,#+0
    472            int8_t end = 15;
   \   00000016   0x270F             MOVS     R7,#+15
    473            uint32_t vcofreq;
    474            uint8_t BFactor;
    475            
    476            /* Check the channel center frequency is in one of the possible range */
    477            s_assert_param(IS_FREQUENCY_BAND(lFc));
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x2e5f5680
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD303             BCC.N    ??SpiritRadioSearchWCP_0
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable13_1  ;; 0x390c2fe1
   \   00000024   0x4284             CMP      R4,R0
   \   00000026   0xD31D             BCC.N    ??SpiritRadioSearchWCP_1
   \                     ??SpiritRadioSearchWCP_0: (+1)
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable13_2  ;; 0x1701e480
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD303             BCC.N    ??SpiritRadioSearchWCP_2
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable13_3  ;; 0x1c146a61
   \   00000034   0x4284             CMP      R4,R0
   \   00000036   0xD315             BCC.N    ??SpiritRadioSearchWCP_1
   \                     ??SpiritRadioSearchWCP_2: (+1)
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable13_4  ;; 0x11d260c0
   \   0000003C   0x4284             CMP      R4,R0
   \   0000003E   0xD303             BCC.N    ??SpiritRadioSearchWCP_3
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable14  ;; 0x14ced7e1
   \   00000044   0x4284             CMP      R4,R0
   \   00000046   0xD30D             BCC.N    ??SpiritRadioSearchWCP_1
   \                     ??SpiritRadioSearchWCP_3: (+1)
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x8e18f40
   \   0000004C   0x4284             CMP      R4,R0
   \   0000004E   0xD303             BCC.N    ??SpiritRadioSearchWCP_4
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable14_2  ;; 0xa6fd061
   \   00000054   0x4284             CMP      R4,R0
   \   00000056   0xD305             BCC.N    ??SpiritRadioSearchWCP_1
   \                     ??SpiritRadioSearchWCP_4: (+1)
   \   00000058   0xF240 0x11DD      MOVW     R1,#+477
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable13_5
   \   00000060   0x.... 0x....      BL       s_assert_failed
    478            
    479            /* Search the operating band */
    480            if(IS_FREQUENCY_BAND_HIGH(lFc))
   \                     ??SpiritRadioSearchWCP_1: (+1)
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x2e5f5680
   \   00000068   0x4284             CMP      R4,R0
   \   0000006A   0xD306             BCC.N    ??SpiritRadioSearchWCP_5
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable13_1  ;; 0x390c2fe1
   \   00000070   0x4284             CMP      R4,R0
   \   00000072   0xD202             BCS.N    ??SpiritRadioSearchWCP_5
    481            {
    482              BFactor = HIGH_BAND_FACTOR;
   \   00000074   0x2006             MOVS     R0,#+6
   \   00000076   0x4681             MOV      R9,R0
   \   00000078   0xE01F             B.N      ??SpiritRadioSearchWCP_6
    483            }
    484            else if(IS_FREQUENCY_BAND_MIDDLE(lFc))
   \                     ??SpiritRadioSearchWCP_5: (+1)
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable13_2  ;; 0x1701e480
   \   0000007E   0x4284             CMP      R4,R0
   \   00000080   0xD306             BCC.N    ??SpiritRadioSearchWCP_7
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable13_3  ;; 0x1c146a61
   \   00000086   0x4284             CMP      R4,R0
   \   00000088   0xD202             BCS.N    ??SpiritRadioSearchWCP_7
    485            {
    486              BFactor = MIDDLE_BAND_FACTOR;
   \   0000008A   0x200C             MOVS     R0,#+12
   \   0000008C   0x4681             MOV      R9,R0
   \   0000008E   0xE014             B.N      ??SpiritRadioSearchWCP_6
    487            }
    488            else if(IS_FREQUENCY_BAND_LOW(lFc))
   \                     ??SpiritRadioSearchWCP_7: (+1)
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable13_4  ;; 0x11d260c0
   \   00000094   0x4284             CMP      R4,R0
   \   00000096   0xD306             BCC.N    ??SpiritRadioSearchWCP_8
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable14  ;; 0x14ced7e1
   \   0000009C   0x4284             CMP      R4,R0
   \   0000009E   0xD202             BCS.N    ??SpiritRadioSearchWCP_8
    489            {
    490              BFactor = LOW_BAND_FACTOR;
   \   000000A0   0x2010             MOVS     R0,#+16
   \   000000A2   0x4681             MOV      R9,R0
   \   000000A4   0xE009             B.N      ??SpiritRadioSearchWCP_6
    491            }
    492            else if(IS_FREQUENCY_BAND_VERY_LOW(lFc))
   \                     ??SpiritRadioSearchWCP_8: (+1)
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x8e18f40
   \   000000AA   0x4284             CMP      R4,R0
   \   000000AC   0xD305             BCC.N    ??SpiritRadioSearchWCP_6
   \   000000AE   0x.... 0x....      LDR.W    R0,??DataTable14_2  ;; 0xa6fd061
   \   000000B2   0x4284             CMP      R4,R0
   \   000000B4   0xD201             BCS.N    ??SpiritRadioSearchWCP_6
    493            {
    494              BFactor = VERY_LOW_BAND_FACTOR;
   \   000000B6   0x2020             MOVS     R0,#+32
   \   000000B8   0x4681             MOV      R9,R0
    495            }
    496            
    497            /* Calculates the VCO frequency VCOFreq = lFc*B */
    498            vcofreq = (lFc/1000000)*BFactor;
   \                     ??SpiritRadioSearchWCP_6: (+1)
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable15_3  ;; 0xf4240
   \   000000BE   0xFBB4 0xF0F0      UDIV     R0,R4,R0
   \   000000C2   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000C6   0xFB09 0xF000      MUL      R0,R9,R0
   \   000000CA   0x4680             MOV      R8,R0
    499            
    500            /* Search in the vco frequency array the charge pump word */
    501            if(vcofreq>=s_vectnVCOFreq[15])
   \   000000CC   0x.... 0x....      LDR.W    R0,??DataTable23
   \   000000D0   0x8BC0             LDRH     R0,[R0, #+30]
   \   000000D2   0x4580             CMP      R8,R0
   \   000000D4   0xD304             BCC.N    ??SpiritRadioSearchWCP_9
    502            {
    503              i=15;
   \   000000D6   0x200F             MOVS     R0,#+15
   \   000000D8   0x0005             MOVS     R5,R0
    504              find =S_TRUE;
   \   000000DA   0x2001             MOVS     R0,#+1
   \   000000DC   0xF88D 0x0000      STRB     R0,[SP, #+0]
    505            }
    506            while(!find)
   \                     ??SpiritRadioSearchWCP_9: (+1)
   \   000000E0   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000E4   0x2800             CMP      R0,#+0
   \   000000E6   0xD13A             BNE.N    ??SpiritRadioSearchWCP_10
    507            {
    508              if(vcofreq>=s_vectnVCOFreq[i])
   \   000000E8   0x.... 0x....      LDR.W    R0,??DataTable23
   \   000000EC   0xB26D             SXTB     R5,R5            ;; SignExt  R5,R5,#+24,#+24
   \   000000EE   0xF830 0x0015      LDRH     R0,[R0, R5, LSL #+1]
   \   000000F2   0x4580             CMP      R8,R0
   \   000000F4   0xD317             BCC.N    ??SpiritRadioSearchWCP_11
    509              {
    510                if(vcofreq<=s_vectnVCOFreq[i+1])
   \   000000F6   0x.... 0x....      LDR.W    R0,??DataTable23
   \   000000FA   0xB26D             SXTB     R5,R5            ;; SignExt  R5,R5,#+24,#+24
   \   000000FC   0xEB10 0x0045      ADDS     R0,R0,R5, LSL #+1
   \   00000100   0x8840             LDRH     R0,[R0, #+2]
   \   00000102   0x4540             CMP      R0,R8
   \   00000104   0xD306             BCC.N    ??SpiritRadioSearchWCP_12
    511                {
    512                  find = S_TRUE;
   \   00000106   0x2001             MOVS     R0,#+1
   \   00000108   0xF88D 0x0000      STRB     R0,[SP, #+0]
    513                  find_up = S_TRUE;
   \   0000010C   0x2001             MOVS     R0,#+1
   \   0000010E   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   00000112   0xE7E5             B.N      ??SpiritRadioSearchWCP_9
    514                }
    515                else
    516                {
    517                  start = i;
   \                     ??SpiritRadioSearchWCP_12: (+1)
   \   00000114   0x002E             MOVS     R6,R5
    518                  i = i+ (end - start)/2;
   \   00000116   0xB27F             SXTB     R7,R7            ;; SignExt  R7,R7,#+24,#+24
   \   00000118   0xB276             SXTB     R6,R6            ;; SignExt  R6,R6,#+24,#+24
   \   0000011A   0x1BB8             SUBS     R0,R7,R6
   \   0000011C   0x2102             MOVS     R1,#+2
   \   0000011E   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000122   0x1945             ADDS     R5,R0,R5
   \   00000124   0xE7DC             B.N      ??SpiritRadioSearchWCP_9
    519                }
    520              }
    521              else
    522              {
    523                if(vcofreq>=s_vectnVCOFreq[i-1])
   \                     ??SpiritRadioSearchWCP_11: (+1)
   \   00000126   0x.... 0x....      LDR.W    R0,??DataTable23
   \   0000012A   0xB26D             SXTB     R5,R5            ;; SignExt  R5,R5,#+24,#+24
   \   0000012C   0xEB10 0x0045      ADDS     R0,R0,R5, LSL #+1
   \   00000130   0xF830 0x0C02      LDRH     R0,[R0, #-2]
   \   00000134   0x4580             CMP      R8,R0
   \   00000136   0xD303             BCC.N    ??SpiritRadioSearchWCP_13
    524                  find = S_TRUE;
   \   00000138   0x2001             MOVS     R0,#+1
   \   0000013A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000013E   0xE7CF             B.N      ??SpiritRadioSearchWCP_9
    525                else
    526                {
    527                  end = i;
   \                     ??SpiritRadioSearchWCP_13: (+1)
   \   00000140   0x002F             MOVS     R7,R5
    528                  i = i - (end-start)/2;
   \   00000142   0xB27F             SXTB     R7,R7            ;; SignExt  R7,R7,#+24,#+24
   \   00000144   0xB276             SXTB     R6,R6            ;; SignExt  R6,R6,#+24,#+24
   \   00000146   0x1BB8             SUBS     R0,R7,R6
   \   00000148   0x2102             MOVS     R1,#+2
   \   0000014A   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000014E   0x1A2D             SUBS     R5,R5,R0
    529                  if(end==i) {
   \   00000150   0xB27F             SXTB     R7,R7            ;; SignExt  R7,R7,#+24,#+24
   \   00000152   0xB26D             SXTB     R5,R5            ;; SignExt  R5,R5,#+24,#+24
   \   00000154   0x42AF             CMP      R7,R5
   \   00000156   0xD1C3             BNE.N    ??SpiritRadioSearchWCP_9
    530                    i=0;
   \   00000158   0x2000             MOVS     R0,#+0
   \   0000015A   0x0005             MOVS     R5,R0
   \   0000015C   0xE7C0             B.N      ??SpiritRadioSearchWCP_9
    531                  }        
    532                }
    533              }
    534            }
    535            if(find_up && i<15)
   \                     ??SpiritRadioSearchWCP_10: (+1)
   \   0000015E   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000162   0x2800             CMP      R0,#+0
   \   00000164   0xD015             BEQ.N    ??SpiritRadioSearchWCP_14
   \   00000166   0xB26D             SXTB     R5,R5            ;; SignExt  R5,R5,#+24,#+24
   \   00000168   0x2D0F             CMP      R5,#+15
   \   0000016A   0xDA12             BGE.N    ??SpiritRadioSearchWCP_14
    536            {
    537              if((vcofreq - s_vectnVCOFreq[i])>=(s_vectnVCOFreq[i+1] - vcofreq))
   \   0000016C   0x.... 0x....      LDR.W    R0,??DataTable23
   \   00000170   0xB26D             SXTB     R5,R5            ;; SignExt  R5,R5,#+24,#+24
   \   00000172   0xF830 0x0015      LDRH     R0,[R0, R5, LSL #+1]
   \   00000176   0xEBB8 0x0000      SUBS     R0,R8,R0
   \   0000017A   0x.... 0x....      LDR.W    R1,??DataTable23
   \   0000017E   0xB26D             SXTB     R5,R5            ;; SignExt  R5,R5,#+24,#+24
   \   00000180   0xEB11 0x0145      ADDS     R1,R1,R5, LSL #+1
   \   00000184   0x8849             LDRH     R1,[R1, #+2]
   \   00000186   0xEBB1 0x0108      SUBS     R1,R1,R8
   \   0000018A   0x4288             CMP      R0,R1
   \   0000018C   0xD31B             BCC.N    ??SpiritRadioSearchWCP_15
    538              {
    539                i = i+1;
   \   0000018E   0x1C6D             ADDS     R5,R5,#+1
   \   00000190   0xE019             B.N      ??SpiritRadioSearchWCP_15
    540              }
    541            }
    542            else if(!find_up && i<15)
   \                     ??SpiritRadioSearchWCP_14: (+1)
   \   00000192   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000196   0x2800             CMP      R0,#+0
   \   00000198   0xD115             BNE.N    ??SpiritRadioSearchWCP_15
   \   0000019A   0xB26D             SXTB     R5,R5            ;; SignExt  R5,R5,#+24,#+24
   \   0000019C   0x2D0F             CMP      R5,#+15
   \   0000019E   0xDA12             BGE.N    ??SpiritRadioSearchWCP_15
    543            {    
    544              if((s_vectnVCOFreq[i]-vcofreq)>=(vcofreq - s_vectnVCOFreq[i-1]))
   \   000001A0   0x.... 0x....      LDR.W    R0,??DataTable23
   \   000001A4   0xB26D             SXTB     R5,R5            ;; SignExt  R5,R5,#+24,#+24
   \   000001A6   0xF830 0x0015      LDRH     R0,[R0, R5, LSL #+1]
   \   000001AA   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   000001AE   0x.... 0x....      LDR.W    R1,??DataTable23
   \   000001B2   0xB26D             SXTB     R5,R5            ;; SignExt  R5,R5,#+24,#+24
   \   000001B4   0xEB11 0x0145      ADDS     R1,R1,R5, LSL #+1
   \   000001B8   0xF831 0x1C02      LDRH     R1,[R1, #-2]
   \   000001BC   0xEBB8 0x0101      SUBS     R1,R8,R1
   \   000001C0   0x4288             CMP      R0,R1
   \   000001C2   0xD300             BCC.N    ??SpiritRadioSearchWCP_15
    545              {
    546                i=i-1;
   \   000001C4   0x1E6D             SUBS     R5,R5,#+1
    547              }
    548            }  
    549            return  (uint8_t)(i%8);
   \                     ??SpiritRadioSearchWCP_15: (+1)
   \   000001C6   0xB26D             SXTB     R5,R5            ;; SignExt  R5,R5,#+24,#+24
   \   000001C8   0x2108             MOVS     R1,#+8
   \   000001CA   0xFB95 0xF0F1      SDIV     R0,R5,R1
   \   000001CE   0xFB00 0x5011      MLS      R0,R0,R1,R5
   \   000001D2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001D4   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    550            
    551          }
    552          
    553          /**
    554          * @brief  Returns the synth word.
    555          * @param  None.
    556          * @retval uint32_t Synth word.
    557          */

   \                                 In section .text, align 2, keep-with-next
    558          uint32_t SpiritRadioGetSynthWord(void)
    559          {
   \                     SpiritRadioGetSynthWord: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    560            uint8_t regArray[4];
    561            
    562            /* Reads the SYNTH registers, build the synth word and return it */
    563            g_xStatus = SpiritSpiReadRegisters(SYNT3_BASE, 4, regArray);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2104             MOVS     R1,#+4
   \   00000008   0x2008             MOVS     R0,#+8
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x....             LDR.N    R0,??DataTable15_1
   \   00000012   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000016   0x8001             STRH     R1,[R0, #+0]
    564            return ((((uint32_t)(regArray[0]&0x1F))<<21)+(((uint32_t)(regArray[1]))<<13)+\
    565              (((uint32_t)(regArray[2]))<<5)+(((uint32_t)(regArray[3]))>>3));
   \   00000018   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001C   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   00000020   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \   00000024   0x0349             LSLS     R1,R1,#+13
   \   00000026   0xEB11 0x5040      ADDS     R0,R1,R0, LSL #+21
   \   0000002A   0xF89D 0x1002      LDRB     R1,[SP, #+2]
   \   0000002E   0xEB10 0x1041      ADDS     R0,R0,R1, LSL #+5
   \   00000032   0xF89D 0x1003      LDRB     R1,[SP, #+3]
   \   00000036   0xEB10 0x00D1      ADDS     R0,R0,R1, LSR #+3
   \   0000003A   0xBD0E             POP      {R1-R3,PC}       ;; return
    566            
    567          }
    568          
    569          
    570          /**
    571          * @brief  Sets the SYNTH registers.
    572          * @param  lSynthWord the synth word to write in the SYNTH[3:0] registers.
    573          * @retval None.
    574          */

   \                                 In section .text, align 2, keep-with-next
    575          void SpiritRadioSetSynthWord(uint32_t lSynthWord)
    576          {
   \                     SpiritRadioSetSynthWord: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x0004             MOVS     R4,R0
    577            uint8_t tempArray[4];
    578            uint8_t tempRegValue;
    579            
    580            /* Reads the SYNT0 register */
    581            g_xStatus = SpiritSpiReadRegisters(SYNT0_BASE, 1, &tempRegValue);
   \   00000006   0xAA01             ADD      R2,SP,#+4
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0x200B             MOVS     R0,#+11
   \   0000000C   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   00000010   0x9002             STR      R0,[SP, #+8]
   \   00000012   0x....             LDR.N    R0,??DataTable15_1
   \   00000014   0xF8BD 0x1008      LDRH     R1,[SP, #+8]
   \   00000018   0x8001             STRH     R1,[R0, #+0]
    582            
    583            /* Mask the Band selected field */
    584            tempRegValue &= 0x07;
   \   0000001A   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000001E   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000022   0xF88D 0x0004      STRB     R0,[SP, #+4]
    585            
    586            /* Build the array for SYNTH registers */
    587            tempArray[0] = (uint8_t)((lSynthWord>>21)&(0x0000001F));
   \   00000026   0x0D60             LSRS     R0,R4,#+21
   \   00000028   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   0000002C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    588            tempArray[1] = (uint8_t)((lSynthWord>>13)&(0x000000FF));
   \   00000030   0x0B60             LSRS     R0,R4,#+13
   \   00000032   0xF88D 0x0001      STRB     R0,[SP, #+1]
    589            tempArray[2] = (uint8_t)((lSynthWord>>5)&(0x000000FF));
   \   00000036   0x0960             LSRS     R0,R4,#+5
   \   00000038   0xF88D 0x0002      STRB     R0,[SP, #+2]
    590            tempArray[3] = (uint8_t)(((lSynthWord&0x0000001F)<<3)| tempRegValue);
   \   0000003C   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000040   0xEA50 0x00C4      ORRS     R0,R0,R4, LSL #+3
   \   00000044   0xF88D 0x0003      STRB     R0,[SP, #+3]
    591            
    592            /* Writes the synth word in the SYNTH registers */
    593            g_xStatus = SpiritSpiWriteRegisters(SYNT3_BASE, 4, tempArray);
   \   00000048   0xAA00             ADD      R2,SP,#+0
   \   0000004A   0x2104             MOVS     R1,#+4
   \   0000004C   0x2008             MOVS     R0,#+8
   \   0000004E   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000052   0x9002             STR      R0,[SP, #+8]
   \   00000054   0x....             LDR.N    R0,??DataTable15_1
   \   00000056   0xF8BD 0x1008      LDRH     R1,[SP, #+8]
   \   0000005A   0x8001             STRH     R1,[R0, #+0]
    594            
    595          }
   \   0000005C   0xBD1F             POP      {R0-R4,PC}       ;; return
    596          
    597          
    598          /**
    599          * @brief  Sets the operating band.
    600          * @param  xBand the band to set.
    601          *         This parameter can be one of following parameters:
    602          *         @arg  HIGH_BAND   High_Band selected: from 779 MHz to 915 MHz
    603          *         @arg  MIDDLE_BAND: Middle Band selected: from 387 MHz to 470 MHz
    604          *         @arg  LOW_BAND:  Low Band selected: from 300 MHz to 348 MHz
    605          *         @arg  VERY_LOW_BAND:  Very low Band selected: from 150 MHz to 174 MHz
    606          * @retval None.
    607          */

   \                                 In section .text, align 2, keep-with-next
    608          void SpiritRadioSetBand(BandSelect xBand)
    609          {
   \                     SpiritRadioSetBand: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    610            uint8_t tempRegValue;
    611            
    612            /* Check the parameters */
    613            s_assert_param(IS_BAND_SELECTED(xBand));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD00D             BEQ.N    ??SpiritRadioSetBand_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD00A             BEQ.N    ??SpiritRadioSetBand_0
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C02             CMP      R4,#+2
   \   00000014   0xD007             BEQ.N    ??SpiritRadioSetBand_0
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0x2C03             CMP      R4,#+3
   \   0000001A   0xD004             BEQ.N    ??SpiritRadioSetBand_0
   \   0000001C   0xF240 0x2165      MOVW     R1,#+613
   \   00000020   0x....             LDR.N    R0,??DataTable13_5
   \   00000022   0x.... 0x....      BL       s_assert_failed
    614            
    615            /* Reads the SYNT0 register*/
    616            g_xStatus = SpiritSpiReadRegisters(SYNT0_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioSetBand_0: (+1)
   \   00000026   0xAA00             ADD      R2,SP,#+0
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0x200B             MOVS     R0,#+11
   \   0000002C   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   00000030   0x9001             STR      R0,[SP, #+4]
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable26
   \   00000036   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   0000003A   0x8001             STRH     R1,[R0, #+0]
    617            
    618            /* Mask the SYNTH[4;0] field and write the BS value */
    619            tempRegValue &= 0xF8;
   \   0000003C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000040   0xF010 0x00F8      ANDS     R0,R0,#0xF8
   \   00000044   0xF88D 0x0000      STRB     R0,[SP, #+0]
    620            tempRegValue |= s_vectcBandRegValue[xBand];
   \   00000048   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable24
   \   00000050   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000052   0x5C61             LDRB     R1,[R4, R1]
   \   00000054   0x4308             ORRS     R0,R1,R0
   \   00000056   0xF88D 0x0000      STRB     R0,[SP, #+0]
    621            
    622            /* Configures the SYNT0 register setting the operating band */
    623            g_xStatus = SpiritSpiWriteRegisters(SYNT0_BASE, 1, &tempRegValue);
   \   0000005A   0xAA00             ADD      R2,SP,#+0
   \   0000005C   0x2101             MOVS     R1,#+1
   \   0000005E   0x200B             MOVS     R0,#+11
   \   00000060   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000064   0x9001             STR      R0,[SP, #+4]
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable26
   \   0000006A   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   0000006E   0x8001             STRH     R1,[R0, #+0]
    624            
    625          }
   \   00000070   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    626          
    627          
    628          /**
    629          * @brief  Returns the operating band.
    630          * @param  None.
    631          * @retval BandSelect Settled band.
    632          *         This returned value can be one of the following parameters:
    633          *         @arg  HIGH_BAND   High_Band selected: from 779 MHz to 915 MHz
    634          *         @arg  MIDDLE_BAND: Middle Band selected: from 387 MHz to 470 MHz
    635          *         @arg  LOW_BAND:  Low Band selected: from 300 MHz to 348 MHz
    636          *         @arg  VERY_LOW_BAND:  Very low Band selected: from 150 MHz to 174 MHz
    637          */

   \                                 In section .text, align 2, keep-with-next
    638          BandSelect SpiritRadioGetBand(void)
    639          {
   \                     SpiritRadioGetBand: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    640            uint8_t tempRegValue;
    641            
    642            /* Reads the SYNT0 register */
    643            g_xStatus = SpiritSpiReadRegisters(SYNT0_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x200B             MOVS     R0,#+11
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable26
   \   00000014   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000018   0x8001             STRH     R1,[R0, #+0]
    644            
    645            /* Mask the Band selected field */
    646            if((tempRegValue & 0x07) == SYNT0_BS_6)
   \   0000001A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001E   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD101             BNE.N    ??SpiritRadioGetBand_0
    647            {
    648              return HIGH_BAND;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE010             B.N      ??SpiritRadioGetBand_1
    649            }
    650            else if ((tempRegValue & 0x07) == SYNT0_BS_12)
   \                     ??SpiritRadioGetBand_0: (+1)
   \   0000002A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000002E   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000032   0x2803             CMP      R0,#+3
   \   00000034   0xD101             BNE.N    ??SpiritRadioGetBand_2
    651            {
    652              return MIDDLE_BAND;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xE008             B.N      ??SpiritRadioGetBand_1
    653            }
    654            else if ((tempRegValue & 0x07) == SYNT0_BS_16)
   \                     ??SpiritRadioGetBand_2: (+1)
   \   0000003A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000003E   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000042   0x2804             CMP      R0,#+4
   \   00000044   0xD101             BNE.N    ??SpiritRadioGetBand_3
    655            {
    656              return LOW_BAND;
   \   00000046   0x2002             MOVS     R0,#+2
   \   00000048   0xE000             B.N      ??SpiritRadioGetBand_1
    657            }
    658            else
    659            {
    660              return VERY_LOW_BAND;
   \                     ??SpiritRadioGetBand_3: (+1)
   \   0000004A   0x2003             MOVS     R0,#+3
   \                     ??SpiritRadioGetBand_1: (+1)
   \   0000004C   0xBD0E             POP      {R1-R3,PC}       ;; return
    661            }
    662            
    663          }
    664          
    665          
    666          /**
    667          * @brief  Sets the channel number.
    668          * @param  cChannel the channel number.
    669          * @retval None.
    670          */

   \                                 In section .text, align 2, keep-with-next
    671          void SpiritRadioSetChannel(uint8_t cChannel)
    672          {
   \                     SpiritRadioSetChannel: (+1)
   \   00000000   0xB501             PUSH     {R0,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    673            /* Writes the CHNUM register */
    674            g_xStatus = SpiritSpiWriteRegisters(CHNUM_BASE, 1, &cChannel);
   \   00000004   0xAA02             ADD      R2,SP,#+8
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x206C             MOVS     R0,#+108
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   0000000E   0x9000             STR      R0,[SP, #+0]
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable26
   \   00000014   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   00000018   0x8001             STRH     R1,[R0, #+0]
    675            
    676          }
   \   0000001A   0xBD07             POP      {R0-R2,PC}       ;; return
    677          
    678          
    679          /**
    680          * @brief  Returns the actual channel number.
    681          * @param  None.
    682          * @retval uint8_t Actual channel number.
    683          */

   \                                 In section .text, align 2, keep-with-next
    684          uint8_t SpiritRadioGetChannel(void)
    685          {
   \                     SpiritRadioGetChannel: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    686            uint8_t tempRegValue;
    687            
    688            /* Reads the CHNUM register and return the value */
    689            g_xStatus = SpiritSpiReadRegisters(CHNUM_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x206C             MOVS     R0,#+108
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x....             LDR.N    R0,??DataTable15_1
   \   00000012   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000016   0x8001             STRH     R1,[R0, #+0]
    690            
    691            return tempRegValue;
   \   00000018   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001C   0xBD0E             POP      {R1-R3,PC}       ;; return
    692            
    693          }
    694          
    695          
    696          /**
    697          * @brief  Sets the channel space factor in channel space register.
    698          *         The channel spacing step is computed as F_Xo/32768.
    699          * @param  fChannelSpace the channel space expressed in Hz.
    700          * @retval None.
    701          */

   \                                 In section .text, align 2, keep-with-next
    702          void SpiritRadioSetChannelSpace(uint32_t fChannelSpace)
    703          {
   \                     SpiritRadioSetChannelSpace: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    704            uint8_t cChannelSpaceFactor;
    705            
    706            /* Round to the nearest integer */
    707            cChannelSpaceFactor = ((uint32_t)fChannelSpace*CHSPACE_DIVIDER)/s_lXtalFrequency;
   \   00000004   0xF44F 0x4000      MOV      R0,#+32768
   \   00000008   0xFB00 0xF004      MUL      R0,R0,R4
   \   0000000C   0x....             LDR.N    R1,??DataTable15
   \   0000000E   0x6809             LDR      R1,[R1, #+0]
   \   00000010   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000014   0xF88D 0x0000      STRB     R0,[SP, #+0]
    708            
    709            /* Write value into the register */
    710            g_xStatus = SpiritSpiWriteRegisters(CHSPACE_BASE, 1, &cChannelSpaceFactor);
   \   00000018   0xAA00             ADD      R2,SP,#+0
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x200C             MOVS     R0,#+12
   \   0000001E   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000022   0x9001             STR      R0,[SP, #+4]
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable26
   \   00000028   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   0000002C   0x8001             STRH     R1,[R0, #+0]
    711            
    712          }
   \   0000002E   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    713          
    714          
    715          /**
    716          * @brief  Returns the channel space register.
    717          * @param  None.
    718          * @retval uint32_t Channel space. The channel space is: CS = channel_space_factor x XtalFrequency/2^15
    719          *         where channel_space_factor is the CHSPACE register value.
    720          */

   \                                 In section .text, align 2, keep-with-next
    721          uint32_t SpiritRadioGetChannelSpace(void)
    722          {
   \                     SpiritRadioGetChannelSpace: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    723            uint8_t channelSpaceFactor;
    724            
    725            /* Reads the CHSPACE register, calculate the channel space and return it */
    726            g_xStatus = SpiritSpiReadRegisters(CHSPACE_BASE, 1, &channelSpaceFactor);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x200C             MOVS     R0,#+12
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x....             LDR.N    R0,??DataTable15_1
   \   00000012   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000016   0x8001             STRH     R1,[R0, #+0]
    727            
    728            /* Compute the Hertz value and return it */
    729            return ((channelSpaceFactor*s_lXtalFrequency)/CHSPACE_DIVIDER);
   \   00000018   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001C   0x....             LDR.N    R1,??DataTable15
   \   0000001E   0x6809             LDR      R1,[R1, #+0]
   \   00000020   0x4348             MULS     R0,R1,R0
   \   00000022   0x0BC0             LSRS     R0,R0,#+15
   \   00000024   0xBD0E             POP      {R1-R3,PC}       ;; return
    730            
    731          }
    732          
    733          
    734          /**
    735          * @brief  Sets the FC OFFSET register starting from xtal ppm value.
    736          * @param  nXtalPpm the xtal offset expressed in ppm.
    737          * @retval None.
    738          */

   \                                 In section .text, align 2, keep-with-next
    739          void SpiritRadioSetFrequencyOffsetPpm(int16_t nXtalPpm)
    740          {
   \                     SpiritRadioSetFrequencyOffsetPpm: (+1)
   \   00000000   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
    741            uint8_t tempArray[2];
    742            int16_t xtalOffsetFactor;
    743            uint32_t synthWord, fBase;
    744            int32_t FOffsetTmp;
    745            BandSelect band;
    746            
    747            /* Reads the synth word */
    748            synthWord = SpiritRadioGetSynthWord();
   \   00000006   0x.... 0x....      BL       SpiritRadioGetSynthWord
   \   0000000A   0x4682             MOV      R10,R0
    749            
    750            /* Reads the operating band */
    751            band = SpiritRadioGetBand();
   \   0000000C   0x.... 0x....      BL       SpiritRadioGetBand
   \   00000010   0x4680             MOV      R8,R0
    752            
    753            /* Calculates the frequency base */
    754            uint8_t cRefDiv = (uint8_t)SpiritRadioGetRefDiv()+1;
   \   00000012   0x.... 0x....      BL       SpiritRadioGetRefDiv
   \   00000016   0x1C47             ADDS     R7,R0,#+1
    755            fBase = synthWord*(s_lXtalFrequency/(s_vectcBHalfFactor[band]*cRefDiv)/FBASE_DIVIDER);
   \   00000018   0x....             LDR.N    R0,??DataTable15
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable18
   \   00000020   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000024   0xF818 0x1001      LDRB     R1,[R8, R1]
   \   00000028   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000002A   0x4379             MULS     R1,R7,R1
   \   0000002C   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000030   0x0C80             LSRS     R0,R0,#+18
   \   00000032   0xFB00 0xF00A      MUL      R0,R0,R10
   \   00000036   0x4681             MOV      R9,R0
    756            
    757            /* Calculates the offset respect to RF frequency and according to xtal_ppm parameter */
    758            FOffsetTmp = (int32_t)((nXtalPpm*fBase)/PPM_FACTOR);
   \   00000038   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   0000003A   0xFB09 0xF004      MUL      R0,R9,R4
   \   0000003E   0x.... 0x....      BL       __aeabi_ui2d
   \   00000042   0x2200             MOVS     R2,#+0
   \   00000044   0x.... 0x....      LDR.W    R3,??DataTable27  ;; 0x412e8480
   \   00000048   0x.... 0x....      BL       __aeabi_ddiv
   \   0000004C   0x.... 0x....      BL       __aeabi_d2iz
   \   00000050   0x0006             MOVS     R6,R0
    759            
    760            /* Check the Offset is in the correct range */
    761            s_assert_param(IS_FREQUENCY_OFFSET(FOffsetTmp,s_lXtalFrequency));
   \   00000052   0x....             LDR.N    R0,??DataTable15
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0x4240             RSBS     R0,R0,#+0
   \   00000058   0xF45F 0x2180      MOVS     R1,#+262144
   \   0000005C   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000060   0xF44F 0x6100      MOV      R1,#+2048
   \   00000064   0x4348             MULS     R0,R1,R0
   \   00000066   0x4286             CMP      R6,R0
   \   00000068   0xDB07             BLT.N    ??SpiritRadioSetFrequencyOffsetPpm_0
   \   0000006A   0x....             LDR.N    R0,??DataTable15
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0x0C80             LSRS     R0,R0,#+18
   \   00000070   0xF240 0x71FF      MOVW     R1,#+2047
   \   00000074   0x4348             MULS     R0,R1,R0
   \   00000076   0x42B0             CMP      R0,R6
   \   00000078   0xDA04             BGE.N    ??SpiritRadioSetFrequencyOffsetPpm_1
   \                     ??SpiritRadioSetFrequencyOffsetPpm_0: (+1)
   \   0000007A   0xF240 0x21F9      MOVW     R1,#+761
   \   0000007E   0x....             LDR.N    R0,??DataTable13_5
   \   00000080   0x.... 0x....      BL       s_assert_failed
    762            
    763            /* Calculates the FC_OFFSET value to write in the corresponding register */  
    764            xtalOffsetFactor = (FOffsetTmp*FBASE_DIVIDER)/s_lXtalFrequency;
   \                     ??SpiritRadioSetFrequencyOffsetPpm_1: (+1)
   \   00000084   0xF45F 0x2080      MOVS     R0,#+262144
   \   00000088   0xFB00 0xF006      MUL      R0,R0,R6
   \   0000008C   0x....             LDR.N    R1,??DataTable15
   \   0000008E   0x6809             LDR      R1,[R1, #+0]
   \   00000090   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000094   0x0005             MOVS     R5,R0
    765            
    766            /* Build the array related to the FC_OFFSET_1 and FC_OFFSET_0 register */
    767            tempArray[0]=(uint8_t)((((uint16_t)xtalOffsetFactor)>>8)&0x0F);
   \   00000096   0x0028             MOVS     R0,R5
   \   00000098   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000009A   0x1200             ASRS     R0,R0,#+8
   \   0000009C   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   000000A0   0xF88D 0x0000      STRB     R0,[SP, #+0]
    768            tempArray[1]=(uint8_t)(xtalOffsetFactor);
   \   000000A4   0x0028             MOVS     R0,R5
   \   000000A6   0xF88D 0x0001      STRB     R0,[SP, #+1]
    769            
    770            /* Writes the FC_OFFSET registers */
    771            g_xStatus = SpiritSpiWriteRegisters(FC_OFFSET1_BASE, 2, tempArray);
   \   000000AA   0xAA00             ADD      R2,SP,#+0
   \   000000AC   0x2102             MOVS     R1,#+2
   \   000000AE   0x200E             MOVS     R0,#+14
   \   000000B0   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   000000B4   0x9001             STR      R0,[SP, #+4]
   \   000000B6   0x.... 0x....      LDR.W    R0,??DataTable26
   \   000000BA   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   000000BE   0x8001             STRH     R1,[R0, #+0]
    772            
    773          }
   \   000000C0   0xE8BD 0x87F3      POP      {R0,R1,R4-R10,PC}  ;; return
    774          
    775          
    776          /**
    777          * @brief  Sets the FC OFFSET register starting from frequency offset expressed in Hz.
    778          * @param  lFOffset frequency offset expressed in Hz as signed word.
    779          * @retval None.
    780          */

   \                                 In section .text, align 2, keep-with-next
    781          void SpiritRadioSetFrequencyOffset(int32_t lFOffset)
    782          {
   \                     SpiritRadioSetFrequencyOffset: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
    783            uint8_t tempArray[2];
    784            int16_t offset;
    785            
    786            /* Check that the Offset is in the correct range */
    787            s_assert_param(IS_FREQUENCY_OFFSET(lFOffset,s_lXtalFrequency));
   \   00000006   0x....             LDR.N    R0,??DataTable15
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x4240             RSBS     R0,R0,#+0
   \   0000000C   0xF45F 0x2180      MOVS     R1,#+262144
   \   00000010   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000014   0xF44F 0x6100      MOV      R1,#+2048
   \   00000018   0x4348             MULS     R0,R1,R0
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xDB07             BLT.N    ??SpiritRadioSetFrequencyOffset_0
   \   0000001E   0x....             LDR.N    R0,??DataTable15
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x0C80             LSRS     R0,R0,#+18
   \   00000024   0xF240 0x71FF      MOVW     R1,#+2047
   \   00000028   0x4348             MULS     R0,R1,R0
   \   0000002A   0x42A0             CMP      R0,R4
   \   0000002C   0xDA05             BGE.N    ??SpiritRadioSetFrequencyOffset_1
   \                     ??SpiritRadioSetFrequencyOffset_0: (+1)
   \   0000002E   0xF240 0x3113      MOVW     R1,#+787
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable30
   \   00000036   0x.... 0x....      BL       s_assert_failed
    788            
    789            /* Calculates the offset value to write in the FC_OFFSET register */
    790            offset = (lFOffset*FBASE_DIVIDER)/s_lXtalFrequency;
   \                     ??SpiritRadioSetFrequencyOffset_1: (+1)
   \   0000003A   0xF45F 0x2080      MOVS     R0,#+262144
   \   0000003E   0xFB00 0xF004      MUL      R0,R0,R4
   \   00000042   0x....             LDR.N    R1,??DataTable15
   \   00000044   0x6809             LDR      R1,[R1, #+0]
   \   00000046   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000004A   0x0005             MOVS     R5,R0
    791            
    792            /* Build the array related to the FC_OFFSET_1 and FC_OFFSET_0 register */
    793            tempArray[0]=(uint8_t)((((uint16_t)offset)>>8)&0x0F);
   \   0000004C   0x0028             MOVS     R0,R5
   \   0000004E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000050   0x1200             ASRS     R0,R0,#+8
   \   00000052   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000056   0xF88D 0x0000      STRB     R0,[SP, #+0]
    794            tempArray[1]=(uint8_t)(offset);
   \   0000005A   0x0028             MOVS     R0,R5
   \   0000005C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    795            
    796            /* Writes the FC_OFFSET registers */
    797            g_xStatus = SpiritSpiWriteRegisters(FC_OFFSET1_BASE, 2, tempArray);
   \   00000060   0xAA00             ADD      R2,SP,#+0
   \   00000062   0x2102             MOVS     R1,#+2
   \   00000064   0x200E             MOVS     R0,#+14
   \   00000066   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   0000006A   0x9001             STR      R0,[SP, #+4]
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable26
   \   00000070   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000074   0x8001             STRH     R1,[R0, #+0]
    798            
    799          }
   \   00000076   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    800          
    801          
    802          /**
    803          * @brief  Returns the actual frequency offset.
    804          * @param  None.
    805          * @retval int32_t Frequency offset expressed in Hz as signed word.
    806          */

   \                                 In section .text, align 2, keep-with-next
    807          int32_t SpiritRadioGetFrequencyOffset(void)
    808          {
   \                     SpiritRadioGetFrequencyOffset: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
    809            uint8_t tempArray[2];
    810            int16_t xtalOffsetFactor;
    811            
    812            /* Reads the FC_OFFSET registers */
    813            g_xStatus = SpiritSpiReadRegisters(FC_OFFSET1_BASE, 2, tempArray);
   \   00000002   0xAA00             ADD      R2,SP,#+0
   \   00000004   0x2102             MOVS     R1,#+2
   \   00000006   0x200E             MOVS     R0,#+14
   \   00000008   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000C   0x9001             STR      R0,[SP, #+4]
   \   0000000E   0x....             LDR.N    R0,??DataTable15_1
   \   00000010   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000014   0x8001             STRH     R1,[R0, #+0]
    814            
    815            /* Calculates the Offset Factor */
    816            uint16_t xtalOffTemp = ((((uint16_t)tempArray[0])<<8)+((uint16_t)tempArray[1]));
   \   00000016   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001A   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \   0000001E   0xEB11 0x2100      ADDS     R1,R1,R0, LSL #+8
    817            
    818            if(xtalOffTemp & 0x0800)
   \   00000022   0x0508             LSLS     R0,R1,#+20
   \   00000024   0xD502             BPL.N    ??SpiritRadioGetFrequencyOffset_0
    819            {
    820              xtalOffTemp = xtalOffTemp | 0xF000;
   \   00000026   0xF451 0x4170      ORRS     R1,R1,#0xF000
   \   0000002A   0xE001             B.N      ??SpiritRadioGetFrequencyOffset_1
    821            }
    822            else
    823            {
    824              xtalOffTemp = xtalOffTemp & 0x0FFF;
   \                     ??SpiritRadioGetFrequencyOffset_0: (+1)
   \   0000002C   0x0509             LSLS     R1,R1,#+20       ;; ZeroExtS R1,R1,#+20,#+20
   \   0000002E   0x0D09             LSRS     R1,R1,#+20
    825            }
    826            
    827            xtalOffsetFactor = *((int16_t*)(&xtalOffTemp));
   \                     ??SpiritRadioGetFrequencyOffset_1: (+1)
   \   00000030   0x000C             MOVS     R4,R1
    828            
    829            /* Calculates the frequency offset and return it */
    830            return ((int32_t)(xtalOffsetFactor*s_lXtalFrequency)/FBASE_DIVIDER);
   \   00000032   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable18_3
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0xFB00 0xF004      MUL      R0,R0,R4
   \   0000003E   0xF45F 0x2280      MOVS     R2,#+262144
   \   00000042   0xFB90 0xF0F2      SDIV     R0,R0,R2
   \   00000046   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    831            
    832          }
    833          
    834          
    835          
    836          /**
    837          * @brief  Sets the Synth word and the Band Select register according to desired base carrier frequency.
    838          *         In this API the Xtal configuration is read out from
    839          *         the corresponding register. The user shall fix it before call this API.
    840          * @param  lFBase the base carrier frequency expressed in Hz as unsigned word.
    841          * @retval None.
    842          */

   \                                 In section .text, align 2, keep-with-next
    843          void SpiritRadioSetFrequencyBase(uint32_t lFBase)
    844          {
   \                     SpiritRadioSetFrequencyBase: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x0004             MOVS     R4,R0
    845            uint32_t synthWord, Fc;
    846            uint8_t band, anaRadioRegArray[4], wcp;
    847            
    848            /* Check the parameter */
    849            s_assert_param(IS_FREQUENCY_BAND(lFBase));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable31  ;; 0x2e5f5680
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD303             BCC.N    ??SpiritRadioSetFrequencyBase_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable31_1  ;; 0x390c2fe1
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD31D             BCC.N    ??SpiritRadioSetFrequencyBase_1
   \                     ??SpiritRadioSetFrequencyBase_0: (+1)
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable31_2  ;; 0x1701e480
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD303             BCC.N    ??SpiritRadioSetFrequencyBase_2
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable31_3  ;; 0x1c146a61
   \   00000024   0x4284             CMP      R4,R0
   \   00000026   0xD315             BCC.N    ??SpiritRadioSetFrequencyBase_1
   \                     ??SpiritRadioSetFrequencyBase_2: (+1)
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable31_4  ;; 0x11d260c0
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD303             BCC.N    ??SpiritRadioSetFrequencyBase_3
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable31_5  ;; 0x14ced7e1
   \   00000034   0x4284             CMP      R4,R0
   \   00000036   0xD30D             BCC.N    ??SpiritRadioSetFrequencyBase_1
   \                     ??SpiritRadioSetFrequencyBase_3: (+1)
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable31_6  ;; 0x8e18f40
   \   0000003C   0x4284             CMP      R4,R0
   \   0000003E   0xD303             BCC.N    ??SpiritRadioSetFrequencyBase_4
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable31_7  ;; 0xa6fd061
   \   00000044   0x4284             CMP      R4,R0
   \   00000046   0xD305             BCC.N    ??SpiritRadioSetFrequencyBase_1
   \                     ??SpiritRadioSetFrequencyBase_4: (+1)
   \   00000048   0xF240 0x3151      MOVW     R1,#+849
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable30
   \   00000050   0x.... 0x....      BL       s_assert_failed
    850            
    851            /* Search the operating band */
    852            if(IS_FREQUENCY_BAND_HIGH(lFBase))
   \                     ??SpiritRadioSetFrequencyBase_1: (+1)
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable31  ;; 0x2e5f5680
   \   00000058   0x4284             CMP      R4,R0
   \   0000005A   0xD306             BCC.N    ??SpiritRadioSetFrequencyBase_5
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable31_1  ;; 0x390c2fe1
   \   00000060   0x4284             CMP      R4,R0
   \   00000062   0xD202             BCS.N    ??SpiritRadioSetFrequencyBase_5
    853            {
    854              band = HIGH_BAND;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x4681             MOV      R9,R0
   \   00000068   0xE01F             B.N      ??SpiritRadioSetFrequencyBase_6
    855            }
    856            else if(IS_FREQUENCY_BAND_MIDDLE(lFBase))
   \                     ??SpiritRadioSetFrequencyBase_5: (+1)
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable31_2  ;; 0x1701e480
   \   0000006E   0x4284             CMP      R4,R0
   \   00000070   0xD306             BCC.N    ??SpiritRadioSetFrequencyBase_7
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable31_3  ;; 0x1c146a61
   \   00000076   0x4284             CMP      R4,R0
   \   00000078   0xD202             BCS.N    ??SpiritRadioSetFrequencyBase_7
    857            {
    858              band = MIDDLE_BAND;
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0x4681             MOV      R9,R0
   \   0000007E   0xE014             B.N      ??SpiritRadioSetFrequencyBase_6
    859            }
    860            else if(IS_FREQUENCY_BAND_LOW(lFBase))
   \                     ??SpiritRadioSetFrequencyBase_7: (+1)
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable31_4  ;; 0x11d260c0
   \   00000084   0x4284             CMP      R4,R0
   \   00000086   0xD306             BCC.N    ??SpiritRadioSetFrequencyBase_8
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable31_5  ;; 0x14ced7e1
   \   0000008C   0x4284             CMP      R4,R0
   \   0000008E   0xD202             BCS.N    ??SpiritRadioSetFrequencyBase_8
    861            {
    862              band = LOW_BAND;
   \   00000090   0x2002             MOVS     R0,#+2
   \   00000092   0x4681             MOV      R9,R0
   \   00000094   0xE009             B.N      ??SpiritRadioSetFrequencyBase_6
    863            }
    864            else if(IS_FREQUENCY_BAND_VERY_LOW(lFBase))
   \                     ??SpiritRadioSetFrequencyBase_8: (+1)
   \   00000096   0x.... 0x....      LDR.W    R0,??DataTable31_6  ;; 0x8e18f40
   \   0000009A   0x4284             CMP      R4,R0
   \   0000009C   0xD305             BCC.N    ??SpiritRadioSetFrequencyBase_6
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable31_7  ;; 0xa6fd061
   \   000000A2   0x4284             CMP      R4,R0
   \   000000A4   0xD201             BCS.N    ??SpiritRadioSetFrequencyBase_6
    865            {
    866              band = VERY_LOW_BAND;
   \   000000A6   0x2003             MOVS     R0,#+3
   \   000000A8   0x4681             MOV      R9,R0
    867            }
    868            
    869            int32_t FOffset  = SpiritRadioGetFrequencyOffset();
   \                     ??SpiritRadioSetFrequencyBase_6: (+1)
   \   000000AA   0x.... 0x....      BL       SpiritRadioGetFrequencyOffset
   \   000000AE   0x4680             MOV      R8,R0
    870            uint32_t lChannelSpace  = SpiritRadioGetChannelSpace();
   \   000000B0   0x.... 0x....      BL       SpiritRadioGetChannelSpace
   \   000000B4   0x0005             MOVS     R5,R0
    871            uint8_t cChannelNum = SpiritRadioGetChannel();
   \   000000B6   0x.... 0x....      BL       SpiritRadioGetChannel
   \   000000BA   0x0006             MOVS     R6,R0
    872            
    873            /* Calculates the channel center frequency */
    874            Fc = lFBase + FOffset + lChannelSpace*cChannelNum;
   \   000000BC   0xEB18 0x0004      ADDS     R0,R8,R4
   \   000000C0   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000C2   0xFB06 0x0005      MLA      R0,R6,R5,R0
   \   000000C6   0x4682             MOV      R10,R0
    875            
    876            /* Reads the reference divider */
    877            uint8_t cRefDiv = (uint8_t)SpiritRadioGetRefDiv()+1;
   \   000000C8   0x.... 0x....      BL       SpiritRadioGetRefDiv
   \   000000CC   0x1C47             ADDS     R7,R0,#+1
    878            
    879            if(SpiritGeneralGetSpiritVersion() != SPIRIT_VERSION_2_0) 
   \   000000CE   0x.... 0x....      BL       SpiritGeneralGetSpiritVersion
   \   000000D2   0x2800             CMP      R0,#+0
   \   000000D4   0xD03A             BEQ.N    ??SpiritRadioSetFrequencyBase_9
    880            {
    881              /* Selects the VCO */
    882              switch(band)
   \   000000D6   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000DA   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000DE   0xD02A             BEQ.N    ??SpiritRadioSetFrequencyBase_10
   \   000000E0   0xF1B9 0x0F02      CMP      R9,#+2
   \   000000E4   0xD00F             BEQ.N    ??SpiritRadioSetFrequencyBase_11
   \   000000E6   0xD31A             BCC.N    ??SpiritRadioSetFrequencyBase_12
   \   000000E8   0xF1B9 0x0F03      CMP      R9,#+3
   \   000000EC   0xD12E             BNE.N    ??SpiritRadioSetFrequencyBase_9
    883              {
    884              case VERY_LOW_BAND:
    885                if(Fc<161281250)
   \                     ??SpiritRadioSetFrequencyBase_13: (+1)
   \   000000EE   0x.... 0x....      LDR.W    R0,??DataTable31_8  ;; 0x99cf4e2
   \   000000F2   0x4582             CMP      R10,R0
   \   000000F4   0xD203             BCS.N    ??SpiritRadioSetFrequencyBase_14
    886                {
    887                  SpiritCalibrationSelectVco(VCO_L);
   \   000000F6   0x2000             MOVS     R0,#+0
   \   000000F8   0x.... 0x....      BL       SpiritCalibrationSelectVco
   \   000000FC   0xE002             B.N      ??SpiritRadioSetFrequencyBase_15
    888                }
    889                else
    890                {
    891                  SpiritCalibrationSelectVco(VCO_H);
   \                     ??SpiritRadioSetFrequencyBase_14: (+1)
   \   000000FE   0x2001             MOVS     R0,#+1
   \   00000100   0x.... 0x....      BL       SpiritCalibrationSelectVco
    892                }
    893                break;
   \                     ??SpiritRadioSetFrequencyBase_15: (+1)
   \   00000104   0xE022             B.N      ??SpiritRadioSetFrequencyBase_9
    894                
    895              case LOW_BAND:
    896                if(Fc<322562500)
   \                     ??SpiritRadioSetFrequencyBase_11: (+1)
   \   00000106   0x.... 0x....      LDR.W    R0,??DataTable31_9  ;; 0x1339e9c4
   \   0000010A   0x4582             CMP      R10,R0
   \   0000010C   0xD203             BCS.N    ??SpiritRadioSetFrequencyBase_16
    897                {
    898                  SpiritCalibrationSelectVco(VCO_L);
   \   0000010E   0x2000             MOVS     R0,#+0
   \   00000110   0x.... 0x....      BL       SpiritCalibrationSelectVco
   \   00000114   0xE002             B.N      ??SpiritRadioSetFrequencyBase_17
    899                }
    900                else
    901                {
    902                  SpiritCalibrationSelectVco(VCO_H);
   \                     ??SpiritRadioSetFrequencyBase_16: (+1)
   \   00000116   0x2001             MOVS     R0,#+1
   \   00000118   0x.... 0x....      BL       SpiritCalibrationSelectVco
    903                }
    904                break;
   \                     ??SpiritRadioSetFrequencyBase_17: (+1)
   \   0000011C   0xE016             B.N      ??SpiritRadioSetFrequencyBase_9
    905                
    906              case MIDDLE_BAND:
    907                if(Fc<430083334)
   \                     ??SpiritRadioSetFrequencyBase_12: (+1)
   \   0000011E   0x.... 0x....      LDR.W    R0,??DataTable31_10  ;; 0x19a28d06
   \   00000122   0x4582             CMP      R10,R0
   \   00000124   0xD203             BCS.N    ??SpiritRadioSetFrequencyBase_18
    908                {
    909                  SpiritCalibrationSelectVco(VCO_L);
   \   00000126   0x2000             MOVS     R0,#+0
   \   00000128   0x.... 0x....      BL       SpiritCalibrationSelectVco
   \   0000012C   0xE002             B.N      ??SpiritRadioSetFrequencyBase_19
    910                }
    911                else
    912                {
    913                  SpiritCalibrationSelectVco(VCO_H);
   \                     ??SpiritRadioSetFrequencyBase_18: (+1)
   \   0000012E   0x2001             MOVS     R0,#+1
   \   00000130   0x.... 0x....      BL       SpiritCalibrationSelectVco
    914                }
    915                break;
   \                     ??SpiritRadioSetFrequencyBase_19: (+1)
   \   00000134   0xE00A             B.N      ??SpiritRadioSetFrequencyBase_9
    916                
    917              case HIGH_BAND:
    918                if(Fc<860166667)
   \                     ??SpiritRadioSetFrequencyBase_10: (+1)
   \   00000136   0x.... 0x....      LDR.W    R0,??DataTable31_11  ;; 0x33451a0b
   \   0000013A   0x4582             CMP      R10,R0
   \   0000013C   0xD203             BCS.N    ??SpiritRadioSetFrequencyBase_20
    919                {
    920                  SpiritCalibrationSelectVco(VCO_L);
   \   0000013E   0x2000             MOVS     R0,#+0
   \   00000140   0x.... 0x....      BL       SpiritCalibrationSelectVco
   \   00000144   0xE002             B.N      ??SpiritRadioSetFrequencyBase_21
    921                }
    922                else
    923                {
    924                  SpiritCalibrationSelectVco(VCO_H);
   \                     ??SpiritRadioSetFrequencyBase_20: (+1)
   \   00000146   0x2001             MOVS     R0,#+1
   \   00000148   0x.... 0x....      BL       SpiritCalibrationSelectVco
    925                }
    926              }
    927            }
    928            
    929            /* Search the VCO charge pump word and set the corresponding register */
    930            wcp = SpiritRadioSearchWCP(Fc);
   \                     ??SpiritRadioSetFrequencyBase_21: (+1)
   \                     ??SpiritRadioSetFrequencyBase_9: (+1)
   \   0000014C   0x4650             MOV      R0,R10
   \   0000014E   0x.... 0x....      BL       SpiritRadioSearchWCP
   \   00000152   0xF88D 0x0010      STRB     R0,[SP, #+16]
    931            
    932            synthWord = (uint32_t)(lFBase*s_vectcBHalfFactor[band]*(((double)(FBASE_DIVIDER*cRefDiv))/s_lXtalFrequency));
   \   00000156   0x....             LDR.N    R0,??DataTable18
   \   00000158   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000015C   0xF819 0x0000      LDRB     R0,[R9, R0]
   \   00000160   0xFB00 0xF004      MUL      R0,R0,R4
   \   00000164   0x.... 0x....      BL       __aeabi_ui2d
   \   00000168   0xE9CD 0x0102      STRD     R0,R1,[SP, #+8]
   \   0000016C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000016E   0xF45F 0x2080      MOVS     R0,#+262144
   \   00000172   0xFB00 0xF007      MUL      R0,R0,R7
   \   00000176   0x.... 0x....      BL       __aeabi_i2d
   \   0000017A   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \   0000017E   0x....             LDR.N    R0,??DataTable18_3
   \   00000180   0x6800             LDR      R0,[R0, #+0]
   \   00000182   0x.... 0x....      BL       __aeabi_ui2d
   \   00000186   0x0002             MOVS     R2,R0
   \   00000188   0x000B             MOVS     R3,R1
   \   0000018A   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \   0000018E   0x.... 0x....      BL       __aeabi_ddiv
   \   00000192   0xE9DD 0x2302      LDRD     R2,R3,[SP, #+8]
   \   00000196   0x.... 0x....      BL       __aeabi_dmul
   \   0000019A   0x.... 0x....      BL       __aeabi_d2uiz
   \   0000019E   0x4683             MOV      R11,R0
    933            
    934            /* Build the array of registers values for the analog part */
    935            anaRadioRegArray[0] = (uint8_t)(((synthWord>>21)&(0x0000001F))|(wcp<<5));
   \   000001A0   0xEA5F 0x505B      LSRS     R0,R11,#+21
   \   000001A4   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   000001A8   0xF89D 0x1010      LDRB     R1,[SP, #+16]
   \   000001AC   0x0149             LSLS     R1,R1,#+5
   \   000001AE   0x4308             ORRS     R0,R1,R0
   \   000001B0   0xF88D 0x0014      STRB     R0,[SP, #+20]
    936            anaRadioRegArray[1] = (uint8_t)((synthWord>>13)&(0x000000FF));
   \   000001B4   0xEA5F 0x305B      LSRS     R0,R11,#+13
   \   000001B8   0xF88D 0x0015      STRB     R0,[SP, #+21]
    937            anaRadioRegArray[2] = (uint8_t)((synthWord>>5)&(0x000000FF));
   \   000001BC   0xEA5F 0x105B      LSRS     R0,R11,#+5
   \   000001C0   0xF88D 0x0016      STRB     R0,[SP, #+22]
    938            anaRadioRegArray[3] = (uint8_t)(((synthWord&0x0000001F)<<3)| s_vectcBandRegValue[band]);
   \   000001C4   0x.... 0x....      LDR.W    R0,??DataTable24
   \   000001C8   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000001CC   0xF819 0x0000      LDRB     R0,[R9, R0]
   \   000001D0   0xEA50 0x00CB      ORRS     R0,R0,R11, LSL #+3
   \   000001D4   0xF88D 0x0017      STRB     R0,[SP, #+23]
    939            
    940            /* Configures the needed Analog Radio registers */
    941            g_xStatus = SpiritSpiWriteRegisters(SYNT3_BASE, 4, anaRadioRegArray);
   \   000001D8   0xAA05             ADD      R2,SP,#+20
   \   000001DA   0x2104             MOVS     R1,#+4
   \   000001DC   0x2008             MOVS     R0,#+8
   \   000001DE   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   000001E2   0x9000             STR      R0,[SP, #+0]
   \   000001E4   0x.... 0x....      LDR.W    R0,??DataTable26
   \   000001E8   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   000001EC   0x8001             STRH     R1,[R0, #+0]
    942            
    943            SpiritManagementWaVcoCalibration();
   \   000001EE   0x.... 0x....      BL       SpiritManagementWaVcoCalibration
    944          }
   \   000001F2   0xB007             ADD      SP,SP,#+28
   \   000001F4   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    945          
    946          
    947          /**
    948          * @brief  Returns the base carrier frequency.
    949          * @param  None.
    950          * @retval uint32_t Base carrier frequency expressed in Hz as unsigned word.
    951          */

   \                                 In section .text, align 2, keep-with-next
    952          uint32_t SpiritRadioGetFrequencyBase(void)
    953          {
   \                     SpiritRadioGetFrequencyBase: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
    954            uint32_t synthWord;
    955            BandSelect band;
    956            
    957            /* Reads the synth word */
    958            synthWord = SpiritRadioGetSynthWord();
   \   00000004   0x.... 0x....      BL       SpiritRadioGetSynthWord
   \   00000008   0x4682             MOV      R10,R0
    959            
    960            /* Reads the operating band */
    961            band = SpiritRadioGetBand();
   \   0000000A   0x.... 0x....      BL       SpiritRadioGetBand
   \   0000000E   0x0007             MOVS     R7,R0
    962            
    963            uint8_t cRefDiv = (uint8_t)SpiritRadioGetRefDiv() + 1;
   \   00000010   0x.... 0x....      BL       SpiritRadioGetRefDiv
   \   00000014   0x1C46             ADDS     R6,R0,#+1
    964            
    965            /* Calculates the frequency base and return it */
    966            return (uint32_t)round(synthWord*(((double)s_lXtalFrequency)/(FBASE_DIVIDER*cRefDiv*s_vectcBHalfFactor[band])));
   \   00000016   0x4650             MOV      R0,R10
   \   00000018   0x.... 0x....      BL       __aeabi_ui2d
   \   0000001C   0x4680             MOV      R8,R0
   \   0000001E   0x4689             MOV      R9,R1
   \   00000020   0x....             LDR.N    R0,??DataTable18_3
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x.... 0x....      BL       __aeabi_ui2d
   \   00000028   0x0004             MOVS     R4,R0
   \   0000002A   0x000D             MOVS     R5,R1
   \   0000002C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002E   0x....             LDR.N    R0,??DataTable18
   \   00000030   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000032   0x5C38             LDRB     R0,[R7, R0]
   \   00000034   0xFB00 0xF006      MUL      R0,R0,R6
   \   00000038   0xF45F 0x2180      MOVS     R1,#+262144
   \   0000003C   0x4348             MULS     R0,R1,R0
   \   0000003E   0x.... 0x....      BL       __aeabi_i2d
   \   00000042   0x0002             MOVS     R2,R0
   \   00000044   0x000B             MOVS     R3,R1
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0x0029             MOVS     R1,R5
   \   0000004A   0x.... 0x....      BL       __aeabi_ddiv
   \   0000004E   0x4642             MOV      R2,R8
   \   00000050   0x464B             MOV      R3,R9
   \   00000052   0x.... 0x....      BL       __aeabi_dmul
   \   00000056   0x.... 0x....      BL       round
   \   0000005A   0x.... 0x....      BL       __aeabi_d2uiz
   \   0000005E   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    967          }
    968          
    969          
    970          /**
    971          * @brief  Returns the actual channel center frequency.
    972          * @param  None.
    973          * @retval uint32_t Actual channel center frequency expressed in Hz.
    974          */

   \                                 In section .text, align 2, keep-with-next
    975          uint32_t SpiritRadioGetCenterFrequency(void)
    976          {
   \                     SpiritRadioGetCenterFrequency: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    977            int32_t offset;
    978            uint8_t channel;
    979            uint32_t fBase;
    980            uint32_t channelSpace;
    981            
    982            /* Reads the frequency base */
    983            fBase = SpiritRadioGetFrequencyBase();
   \   00000002   0x.... 0x....      BL       SpiritRadioGetFrequencyBase
   \   00000006   0x0006             MOVS     R6,R0
    984            
    985            /* Reads the frequency offset */
    986            offset = SpiritRadioGetFrequencyOffset();
   \   00000008   0x.... 0x....      BL       SpiritRadioGetFrequencyOffset
   \   0000000C   0x0004             MOVS     R4,R0
    987            
    988            /* Reads the channel space */
    989            channelSpace = SpiritRadioGetChannelSpace();
   \   0000000E   0x.... 0x....      BL       SpiritRadioGetChannelSpace
   \   00000012   0x0007             MOVS     R7,R0
    990            
    991            /* Reads the channel number */
    992            channel = SpiritRadioGetChannel();
   \   00000014   0x.... 0x....      BL       SpiritRadioGetChannel
   \   00000018   0x0005             MOVS     R5,R0
    993            
    994            /* Calculates the channel center frequency and return it */
    995            return (uint32_t)(fBase +  offset + (uint32_t)(channelSpace*channel));
   \   0000001A   0x19A0             ADDS     R0,R4,R6
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0xFB05 0x0007      MLA      R0,R5,R7,R0
   \   00000022   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    996            
    997          }
    998          
    999          
   1000          /**
   1001          * @brief  Returns the mantissa and exponent, whose value used in the datarate formula
   1002          *         will give the datarate value closer to the given datarate.
   1003          * @param  fDatarate datarate expressed in bps. This parameter ranging between 100 and 500000.
   1004          * @param  pcM pointer to the returned mantissa value.
   1005          * @param  pcE pointer to the returned exponent value.
   1006          * @retval None.
   1007          */

   \                                 In section .text, align 2, keep-with-next
   1008          void SpiritRadioSearchDatarateME(uint32_t lDatarate, uint8_t* pcM, uint8_t* pcE)
   1009          {
   \                     SpiritRadioSearchDatarateME: (+1)
   \   00000000   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0017             MOVS     R7,R2
   1010            volatile SpiritBool find = S_FALSE;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1011            int8_t i=15;
   \   00000010   0x240F             MOVS     R4,#+15
   1012            uint8_t cMantissaTmp;
   1013            uint8_t cDivider = 0;
   \   00000012   0xF05F 0x0900      MOVS     R9,#+0
   1014            
   1015            /* Check the parameters */
   1016            s_assert_param(IS_DATARATE(lDatarate));
   \   00000016   0x2D64             CMP      R5,#+100
   \   00000018   0xD303             BCC.N    ??SpiritRadioSearchDatarateME_0
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable32  ;; 0x7c831
   \   0000001E   0x4285             CMP      R5,R0
   \   00000020   0xD305             BCC.N    ??SpiritRadioSearchDatarateME_1
   \                     ??SpiritRadioSearchDatarateME_0: (+1)
   \   00000022   0xF44F 0x717E      MOV      R1,#+1016
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable30
   \   0000002A   0x.... 0x....      BL       s_assert_failed
   1017            
   1018            if(SpiritGeneralGetSpiritVersion() != SPIRIT_VERSION_2_0) 
   \                     ??SpiritRadioSearchDatarateME_1: (+1)
   \   0000002E   0x.... 0x....      BL       SpiritGeneralGetSpiritVersion
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD002             BEQ.N    ??SpiritRadioSearchDatarateME_2
   1019            {
   1020              cDivider = (uint8_t)SpiritRadioGetDigDiv();
   \   00000036   0x.... 0x....      BL       SpiritRadioGetDigDiv
   \   0000003A   0x4681             MOV      R9,R0
   1021            }
   1022            
   1023            /* Search in the datarate array the exponent value */
   1024            while(!find && i>=0)
   \                     ??SpiritRadioSearchDatarateME_2: (+1)
   \   0000003C   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD113             BNE.N    ??SpiritRadioSearchDatarateME_3
   \   00000044   0xB264             SXTB     R4,R4            ;; SignExt  R4,R4,#+24,#+24
   \   00000046   0x2C00             CMP      R4,#+0
   \   00000048   0xD410             BMI.N    ??SpiritRadioSearchDatarateME_3
   1025            {
   1026              if(lDatarate>=(s_lXtalFrequency>>(20-i+cDivider)))
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable33
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0xF1D4 0x0114      RSBS     R1,R4,#+20
   \   00000054   0xEB19 0x0101      ADDS     R1,R9,R1
   \   00000058   0x0002             MOVS     R2,R0
   \   0000005A   0x40CA             LSRS     R2,R2,R1
   \   0000005C   0x4295             CMP      R5,R2
   \   0000005E   0xD303             BCC.N    ??SpiritRadioSearchDatarateME_4
   1027              {
   1028                find = S_TRUE;
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0xF88D 0x0008      STRB     R0,[SP, #+8]
   \   00000066   0xE7E9             B.N      ??SpiritRadioSearchDatarateME_2
   1029              }
   1030              else
   1031              {
   1032                i--;
   \                     ??SpiritRadioSearchDatarateME_4: (+1)
   \   00000068   0x1E64             SUBS     R4,R4,#+1
   \   0000006A   0xE7E7             B.N      ??SpiritRadioSearchDatarateME_2
   1033              }
   1034            }
   1035            i<0 ? i=0 : i;
   \                     ??SpiritRadioSearchDatarateME_3: (+1)
   \   0000006C   0xB264             SXTB     R4,R4            ;; SignExt  R4,R4,#+24,#+24
   \   0000006E   0x2C00             CMP      R4,#+0
   \   00000070   0xD502             BPL.N    ??SpiritRadioSearchDatarateME_5
   \   00000072   0x2400             MOVS     R4,#+0
   \   00000074   0xB264             SXTB     R4,R4            ;; SignExt  R4,R4,#+24,#+24
   \   00000076   0xE000             B.N      ??SpiritRadioSearchDatarateME_6
   \                     ??SpiritRadioSearchDatarateME_5: (+1)
   \   00000078   0xB264             SXTB     R4,R4            ;; SignExt  R4,R4,#+24,#+24
   1036            *pcE = i;
   \                     ??SpiritRadioSearchDatarateME_6: (+1)
   \   0000007A   0x703C             STRB     R4,[R7, #+0]
   1037            
   1038            /* Calculates the mantissa value according to the datarate formula */
   1039            cMantissaTmp = (lDatarate*(1<<(23-i)))/(s_lXtalFrequency>>(5+cDivider))-256;
   \   0000007C   0x2001             MOVS     R0,#+1
   \   0000007E   0xF1D4 0x0117      RSBS     R1,R4,#+23
   \   00000082   0x4088             LSLS     R0,R0,R1
   \   00000084   0xFB00 0xF005      MUL      R0,R0,R5
   \   00000088   0x.... 0x....      LDR.W    R1,??DataTable33
   \   0000008C   0x6809             LDR      R1,[R1, #+0]
   \   0000008E   0xF119 0x0205      ADDS     R2,R9,#+5
   \   00000092   0x000B             MOVS     R3,R1
   \   00000094   0x40D3             LSRS     R3,R3,R2
   \   00000096   0xFBB0 0xF0F3      UDIV     R0,R0,R3
   \   0000009A   0x4680             MOV      R8,R0
   1040            
   1041            /* Finds the mantissa value with less approximation */
   1042            int16_t mantissaCalculation[3];
   1043            for(uint8_t j=0;j<3;j++)
   \   0000009C   0x2000             MOVS     R0,#+0
   \                     ??SpiritRadioSearchDatarateME_7: (+1)
   \   0000009E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A0   0x2803             CMP      R0,#+3
   \   000000A2   0xDA29             BGE.N    ??SpiritRadioSearchDatarateME_8
   1044            {
   1045              if((cMantissaTmp+j-1))
   \   000000A4   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000A8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AA   0xEB10 0x0108      ADDS     R1,R0,R8
   \   000000AE   0x1E49             SUBS     R1,R1,#+1
   \   000000B0   0x2900             CMP      R1,#+0
   \   000000B2   0xD019             BEQ.N    ??SpiritRadioSearchDatarateME_9
   1046              {
   1047                mantissaCalculation[j]=lDatarate-(((256+cMantissaTmp+j-1)*(s_lXtalFrequency>>(5+cDivider)))>>(23-i));
   \   000000B4   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000B8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000BA   0xEB10 0x0108      ADDS     R1,R0,R8
   \   000000BE   0x31FF             ADDS     R1,R1,#+255
   \   000000C0   0x.... 0x....      LDR.W    R2,??DataTable33
   \   000000C4   0x6812             LDR      R2,[R2, #+0]
   \   000000C6   0xF119 0x0305      ADDS     R3,R9,#+5
   \   000000CA   0x4694             MOV      R12,R2
   \   000000CC   0xFA3C 0xFC03      LSRS     R12,R12,R3
   \   000000D0   0xFB0C 0xF101      MUL      R1,R12,R1
   \   000000D4   0xF1D4 0x0217      RSBS     R2,R4,#+23
   \   000000D8   0x000B             MOVS     R3,R1
   \   000000DA   0x40D3             LSRS     R3,R3,R2
   \   000000DC   0x1AE9             SUBS     R1,R5,R3
   \   000000DE   0xAA00             ADD      R2,SP,#+0
   \   000000E0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E2   0xF822 0x1010      STRH     R1,[R2, R0, LSL #+1]
   \   000000E6   0xE005             B.N      ??SpiritRadioSearchDatarateME_10
   1048              }
   1049              else
   1050              {
   1051                mantissaCalculation[j]=0x7FFF;
   \                     ??SpiritRadioSearchDatarateME_9: (+1)
   \   000000E8   0xF647 0x71FF      MOVW     R1,#+32767
   \   000000EC   0xAA00             ADD      R2,SP,#+0
   \   000000EE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000F0   0xF822 0x1010      STRH     R1,[R2, R0, LSL #+1]
   1052              }
   1053            }
   \                     ??SpiritRadioSearchDatarateME_10: (+1)
   \   000000F4   0x1C40             ADDS     R0,R0,#+1
   \   000000F6   0xE7D2             B.N      ??SpiritRadioSearchDatarateME_7
   1054            uint16_t mantissaCalculationDelta = 0xFFFF; // TODO qui si puo' ottimizzare un attimo il codice
   \                     ??SpiritRadioSearchDatarateME_8: (+1)
   \   000000F8   0xF64F 0x70FF      MOVW     R0,#+65535
   1055            for(uint8_t j=0;j<3;j++)
   \   000000FC   0x2100             MOVS     R1,#+0
   \                     ??SpiritRadioSearchDatarateME_11: (+1)
   \   000000FE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000100   0x2903             CMP      R1,#+3
   \   00000102   0xDA28             BGE.N    ??SpiritRadioSearchDatarateME_12
   1056            {
   1057              if(S_ABS(mantissaCalculation[j])<mantissaCalculationDelta)
   \   00000104   0xAA00             ADD      R2,SP,#+0
   \   00000106   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000108   0xF932 0x2011      LDRSH    R2,[R2, R1, LSL #+1]
   \   0000010C   0x2A01             CMP      R2,#+1
   \   0000010E   0xDB04             BLT.N    ??SpiritRadioSearchDatarateME_13
   \   00000110   0xAA00             ADD      R2,SP,#+0
   \   00000112   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000114   0xF932 0x2011      LDRSH    R2,[R2, R1, LSL #+1]
   \   00000118   0xE004             B.N      ??SpiritRadioSearchDatarateME_14
   \                     ??SpiritRadioSearchDatarateME_13: (+1)
   \   0000011A   0xAA00             ADD      R2,SP,#+0
   \   0000011C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000011E   0xF932 0x2011      LDRSH    R2,[R2, R1, LSL #+1]
   \   00000122   0x4252             RSBS     R2,R2,#+0
   \                     ??SpiritRadioSearchDatarateME_14: (+1)
   \   00000124   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000126   0x4282             CMP      R2,R0
   \   00000128   0xDA13             BGE.N    ??SpiritRadioSearchDatarateME_15
   1058              {
   1059                mantissaCalculationDelta = S_ABS(mantissaCalculation[j]);
   \   0000012A   0xAA00             ADD      R2,SP,#+0
   \   0000012C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000012E   0xF932 0x2011      LDRSH    R2,[R2, R1, LSL #+1]
   \   00000132   0x2A01             CMP      R2,#+1
   \   00000134   0xDB04             BLT.N    ??SpiritRadioSearchDatarateME_16
   \   00000136   0xA800             ADD      R0,SP,#+0
   \   00000138   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000013A   0xF830 0x0011      LDRH     R0,[R0, R1, LSL #+1]
   \   0000013E   0xE004             B.N      ??SpiritRadioSearchDatarateME_17
   \                     ??SpiritRadioSearchDatarateME_16: (+1)
   \   00000140   0xA800             ADD      R0,SP,#+0
   \   00000142   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000144   0xF930 0x0011      LDRSH    R0,[R0, R1, LSL #+1]
   \   00000148   0x4240             RSBS     R0,R0,#+0
   1060                *pcM = cMantissaTmp+j-1;
   \                     ??SpiritRadioSearchDatarateME_17: (+1)
   \   0000014A   0xEB11 0x0208      ADDS     R2,R1,R8
   \   0000014E   0x1E52             SUBS     R2,R2,#+1
   \   00000150   0x7032             STRB     R2,[R6, #+0]
   1061              }
   1062            }
   \                     ??SpiritRadioSearchDatarateME_15: (+1)
   \   00000152   0x1C49             ADDS     R1,R1,#+1
   \   00000154   0xE7D3             B.N      ??SpiritRadioSearchDatarateME_11
   1063            
   1064          }
   \                     ??SpiritRadioSearchDatarateME_12: (+1)
   \   00000156   0xE8BD 0x83F7      POP      {R0-R2,R4-R9,PC}  ;; return
   1065          
   1066          
   1067          /**
   1068          * @brief  Returns the mantissa and exponent for a given bandwidth.
   1069          *         Even if it is possible to pass as parameter any value in the below mentioned range,
   1070          *         the API will search the closer value according to a fixed table of channel
   1071          *         bandwidth values (@ref s_vectnBandwidth), as defined in the datasheet, returning the corresponding mantissa
   1072          *         and exponent value.
   1073          * @param  lBandwidth bandwidth expressed in Hz. This parameter ranging between 1100 and 800100.
   1074          * @param  pcM pointer to the returned mantissa value.
   1075          * @param  pcE pointer to the returned exponent value.
   1076          * @retval None.
   1077          */

   \                                 In section .text, align 2, keep-with-next
   1078          void SpiritRadioSearchChannelBwME(uint32_t lBandwidth, uint8_t* pcM, uint8_t* pcE)
   1079          {
   \                     SpiritRadioSearchChannelBwME: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1080            volatile SpiritBool find = S_FALSE;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1081            volatile SpiritBool findUp = S_FALSE;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xF88D 0x0001      STRB     R0,[SP, #+1]
   1082            int8_t i=44, i_tmp;
   \   00000016   0xF05F 0x0B2C      MOVS     R11,#+44
   1083            int8_t start = 0;
   \   0000001A   0xF05F 0x0800      MOVS     R8,#+0
   1084            int8_t end = 89;
   \   0000001E   0xF05F 0x0959      MOVS     R9,#+89
   1085            uint8_t cDivider = 1;
   \   00000022   0xF05F 0x0A01      MOVS     R10,#+1
   1086            
   1087            if(SpiritGeneralGetSpiritVersion() != SPIRIT_VERSION_2_0) 
   \   00000026   0x.... 0x....      BL       SpiritGeneralGetSpiritVersion
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD008             BEQ.N    ??SpiritRadioSearchChannelBwME_0
   1088            {
   1089              /* Search in the channel filter bandwidth table the exponent value */
   1090              if(SpiritRadioGetDigDiv())
   \   0000002E   0x.... 0x....      BL       SpiritRadioGetDigDiv
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD002             BEQ.N    ??SpiritRadioSearchChannelBwME_1
   1091              {
   1092                cDivider = 2;
   \   00000036   0x2002             MOVS     R0,#+2
   \   00000038   0x4682             MOV      R10,R0
   \   0000003A   0xE001             B.N      ??SpiritRadioSearchChannelBwME_0
   1093              }
   1094              else
   1095              {
   1096                cDivider = 1;
   \                     ??SpiritRadioSearchChannelBwME_1: (+1)
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x4682             MOV      R10,R0
   1097              }
   1098            }
   1099            
   1100            s_assert_param(IS_CH_BW(lBandwidth,s_lXtalFrequency/cDivider));
   \                     ??SpiritRadioSearchChannelBwME_0: (+1)
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable33
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000004A   0xFBB0 0xF0FA      UDIV     R0,R0,R10
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable33_1  ;; 0xf4240
   \   00000052   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000056   0xF240 0x414C      MOVW     R1,#+1100
   \   0000005A   0x4348             MULS     R0,R1,R0
   \   0000005C   0x211A             MOVS     R1,#+26
   \   0000005E   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000062   0x4284             CMP      R4,R0
   \   00000064   0xD312             BCC.N    ??SpiritRadioSearchChannelBwME_2
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable33
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000070   0xFBB0 0xF0FA      UDIV     R0,R0,R10
   \   00000074   0x.... 0x....      LDR.W    R1,??DataTable33_1  ;; 0xf4240
   \   00000078   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable33_2  ;; 0xc3564
   \   00000080   0x4348             MULS     R0,R1,R0
   \   00000082   0x211A             MOVS     R1,#+26
   \   00000084   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000088   0x42A0             CMP      R0,R4
   \   0000008A   0xD205             BCS.N    ??SpiritRadioSearchChannelBwME_3
   \                     ??SpiritRadioSearchChannelBwME_2: (+1)
   \   0000008C   0xF240 0x414C      MOVW     R1,#+1100
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable30
   \   00000094   0x.... 0x....      BL       s_assert_failed
   1101            
   1102            uint32_t lChfltFactor = (s_lXtalFrequency/cDivider)/100;
   \                     ??SpiritRadioSearchChannelBwME_3: (+1)
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable33
   \   0000009C   0x6800             LDR      R0,[R0, #+0]
   \   0000009E   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000A2   0xFBB0 0xF0FA      UDIV     R0,R0,R10
   \   000000A6   0x2164             MOVS     R1,#+100
   \   000000A8   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   1103            
   1104            while(!find)
   \                     ??SpiritRadioSearchChannelBwME_4: (+1)
   \   000000AC   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   000000B0   0x2900             CMP      R1,#+0
   \   000000B2   0xD14E             BNE.N    ??SpiritRadioSearchChannelBwME_5
   1105            {
   1106              if(lBandwidth>(uint32_t)((s_vectnBandwidth26M[i]*lChfltFactor)/2600))
   \   000000B4   0x.... 0x....      LDR.W    R1,??DataTable35
   \   000000B8   0xFA4F 0xFB8B      SXTB     R11,R11          ;; SignExt  R11,R11,#+24,#+24
   \   000000BC   0xF831 0x101B      LDRH     R1,[R1, R11, LSL #+1]
   \   000000C0   0x4341             MULS     R1,R0,R1
   \   000000C2   0xF640 0x2228      MOVW     R2,#+2600
   \   000000C6   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   000000CA   0x42A1             CMP      R1,R4
   \   000000CC   0xD222             BCS.N    ??SpiritRadioSearchChannelBwME_6
   1107              {
   1108                if(lBandwidth<=(uint32_t)((s_vectnBandwidth26M[i-1]*lChfltFactor)/2600))
   \   000000CE   0x.... 0x....      LDR.W    R1,??DataTable35
   \   000000D2   0xFA4F 0xFB8B      SXTB     R11,R11          ;; SignExt  R11,R11,#+24,#+24
   \   000000D6   0xEB11 0x014B      ADDS     R1,R1,R11, LSL #+1
   \   000000DA   0xF831 0x1C02      LDRH     R1,[R1, #-2]
   \   000000DE   0x4341             MULS     R1,R0,R1
   \   000000E0   0xF640 0x2228      MOVW     R2,#+2600
   \   000000E4   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   000000E8   0x42A1             CMP      R1,R4
   \   000000EA   0xD306             BCC.N    ??SpiritRadioSearchChannelBwME_7
   1109                {
   1110                  find = S_TRUE;
   \   000000EC   0x2101             MOVS     R1,#+1
   \   000000EE   0xF88D 0x1000      STRB     R1,[SP, #+0]
   1111                  findUp = S_TRUE;
   \   000000F2   0x2101             MOVS     R1,#+1
   \   000000F4   0xF88D 0x1001      STRB     R1,[SP, #+1]
   \   000000F8   0xE7D8             B.N      ??SpiritRadioSearchChannelBwME_4
   1112                }
   1113                else
   1114                {
   1115                  end = i;
   \                     ??SpiritRadioSearchChannelBwME_7: (+1)
   \   000000FA   0x46D9             MOV      R9,R11
   1116                  i = i - (end-start)/2;        
   \   000000FC   0xFA4F 0xF989      SXTB     R9,R9            ;; SignExt  R9,R9,#+24,#+24
   \   00000100   0xFA4F 0xF888      SXTB     R8,R8            ;; SignExt  R8,R8,#+24,#+24
   \   00000104   0xEBB9 0x0108      SUBS     R1,R9,R8
   \   00000108   0x2202             MOVS     R2,#+2
   \   0000010A   0xFB91 0xF1F2      SDIV     R1,R1,R2
   \   0000010E   0xEBBB 0x0B01      SUBS     R11,R11,R1
   \   00000112   0xE7CB             B.N      ??SpiritRadioSearchChannelBwME_4
   1117                }
   1118              }
   1119              else
   1120              {
   1121                if(lBandwidth>=(uint32_t)((s_vectnBandwidth26M[i+1]*lChfltFactor)/2600))
   \                     ??SpiritRadioSearchChannelBwME_6: (+1)
   \   00000114   0x.... 0x....      LDR.W    R1,??DataTable35
   \   00000118   0xFA4F 0xFB8B      SXTB     R11,R11          ;; SignExt  R11,R11,#+24,#+24
   \   0000011C   0xEB11 0x014B      ADDS     R1,R1,R11, LSL #+1
   \   00000120   0x8849             LDRH     R1,[R1, #+2]
   \   00000122   0x4341             MULS     R1,R0,R1
   \   00000124   0xF640 0x2228      MOVW     R2,#+2600
   \   00000128   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   0000012C   0x428C             CMP      R4,R1
   \   0000012E   0xD303             BCC.N    ??SpiritRadioSearchChannelBwME_8
   1122                {
   1123                  find = S_TRUE;
   \   00000130   0x2101             MOVS     R1,#+1
   \   00000132   0xF88D 0x1000      STRB     R1,[SP, #+0]
   \   00000136   0xE7B9             B.N      ??SpiritRadioSearchChannelBwME_4
   1124                }
   1125                else
   1126                {
   1127                  start = i;
   \                     ??SpiritRadioSearchChannelBwME_8: (+1)
   \   00000138   0x46D8             MOV      R8,R11
   1128                  i = i+ (end - start)/2;
   \   0000013A   0xFA4F 0xF989      SXTB     R9,R9            ;; SignExt  R9,R9,#+24,#+24
   \   0000013E   0xFA4F 0xF888      SXTB     R8,R8            ;; SignExt  R8,R8,#+24,#+24
   \   00000142   0xEBB9 0x0108      SUBS     R1,R9,R8
   \   00000146   0x2202             MOVS     R2,#+2
   \   00000148   0xFB91 0xF1F2      SDIV     R1,R1,R2
   \   0000014C   0xEB11 0x0B0B      ADDS     R11,R1,R11
   \   00000150   0xE7AC             B.N      ??SpiritRadioSearchChannelBwME_4
   1129                }
   1130              }
   1131            }
   1132            
   1133            /* Finds the mantissa value with less approximation */
   1134            i_tmp=i;
   \                     ??SpiritRadioSearchChannelBwME_5: (+1)
   \   00000152   0x465F             MOV      R7,R11
   1135            int16_t chfltCalculation[3];
   1136            for(uint8_t j=0;j<3;j++) 
   \   00000154   0x2100             MOVS     R1,#+0
   \                     ??SpiritRadioSearchChannelBwME_9: (+1)
   \   00000156   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000158   0x2903             CMP      R1,#+3
   \   0000015A   0xDA27             BGE.N    ??SpiritRadioSearchChannelBwME_10
   1137            {
   1138              if(((i_tmp+j-1)>=0) || ((i_tmp+j-1)<=89))
   \   0000015C   0xB27F             SXTB     R7,R7            ;; SignExt  R7,R7,#+24,#+24
   \   0000015E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000160   0x19CA             ADDS     R2,R1,R7
   \   00000162   0x1E52             SUBS     R2,R2,#+1
   \   00000164   0x2A00             CMP      R2,#+0
   \   00000166   0xD505             BPL.N    ??SpiritRadioSearchChannelBwME_11
   \   00000168   0xB27F             SXTB     R7,R7            ;; SignExt  R7,R7,#+24,#+24
   \   0000016A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000016C   0x19CA             ADDS     R2,R1,R7
   \   0000016E   0x1E52             SUBS     R2,R2,#+1
   \   00000170   0x2A5A             CMP      R2,#+90
   \   00000172   0xDA13             BGE.N    ??SpiritRadioSearchChannelBwME_12
   1139              {
   1140                chfltCalculation[j] = lBandwidth - (uint32_t)((s_vectnBandwidth26M[i_tmp+j-1]*lChfltFactor)/2600);
   \                     ??SpiritRadioSearchChannelBwME_11: (+1)
   \   00000174   0x.... 0x....      LDR.W    R2,??DataTable35
   \   00000178   0xB27F             SXTB     R7,R7            ;; SignExt  R7,R7,#+24,#+24
   \   0000017A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000017C   0x19CB             ADDS     R3,R1,R7
   \   0000017E   0xEB12 0x0243      ADDS     R2,R2,R3, LSL #+1
   \   00000182   0xF832 0x2C02      LDRH     R2,[R2, #-2]
   \   00000186   0x4342             MULS     R2,R0,R2
   \   00000188   0xF640 0x2328      MOVW     R3,#+2600
   \   0000018C   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   00000190   0x1AA2             SUBS     R2,R4,R2
   \   00000192   0xAB01             ADD      R3,SP,#+4
   \   00000194   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000196   0xF823 0x2011      STRH     R2,[R3, R1, LSL #+1]
   \   0000019A   0xE005             B.N      ??SpiritRadioSearchChannelBwME_13
   1141              }
   1142              else
   1143              {
   1144                chfltCalculation[j] = 0x7FFF;
   \                     ??SpiritRadioSearchChannelBwME_12: (+1)
   \   0000019C   0xF647 0x72FF      MOVW     R2,#+32767
   \   000001A0   0xAB01             ADD      R3,SP,#+4
   \   000001A2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001A4   0xF823 0x2011      STRH     R2,[R3, R1, LSL #+1]
   1145              }
   1146            }
   \                     ??SpiritRadioSearchChannelBwME_13: (+1)
   \   000001A8   0x1C49             ADDS     R1,R1,#+1
   \   000001AA   0xE7D4             B.N      ??SpiritRadioSearchChannelBwME_9
   1147            uint16_t chfltDelta = 0xFFFF;
   \                     ??SpiritRadioSearchChannelBwME_10: (+1)
   \   000001AC   0xF64F 0x71FF      MOVW     R1,#+65535
   1148            
   1149            for(uint8_t j=0;j<3;j++)
   \   000001B0   0x2200             MOVS     R2,#+0
   \                     ??SpiritRadioSearchChannelBwME_14: (+1)
   \   000001B2   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000001B4   0x2A03             CMP      R2,#+3
   \   000001B6   0xDA27             BGE.N    ??SpiritRadioSearchChannelBwME_15
   1150            {
   1151              if(S_ABS(chfltCalculation[j])<chfltDelta)
   \   000001B8   0xAB01             ADD      R3,SP,#+4
   \   000001BA   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000001BC   0xF933 0x3012      LDRSH    R3,[R3, R2, LSL #+1]
   \   000001C0   0x2B01             CMP      R3,#+1
   \   000001C2   0xDB04             BLT.N    ??SpiritRadioSearchChannelBwME_16
   \   000001C4   0xAB01             ADD      R3,SP,#+4
   \   000001C6   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000001C8   0xF933 0x3012      LDRSH    R3,[R3, R2, LSL #+1]
   \   000001CC   0xE004             B.N      ??SpiritRadioSearchChannelBwME_17
   \                     ??SpiritRadioSearchChannelBwME_16: (+1)
   \   000001CE   0xAB01             ADD      R3,SP,#+4
   \   000001D0   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000001D2   0xF933 0x3012      LDRSH    R3,[R3, R2, LSL #+1]
   \   000001D6   0x425B             RSBS     R3,R3,#+0
   \                     ??SpiritRadioSearchChannelBwME_17: (+1)
   \   000001D8   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000001DA   0x428B             CMP      R3,R1
   \   000001DC   0xDA12             BGE.N    ??SpiritRadioSearchChannelBwME_18
   1152              {
   1153                chfltDelta = S_ABS(chfltCalculation[j]);
   \   000001DE   0xAB01             ADD      R3,SP,#+4
   \   000001E0   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000001E2   0xF933 0x3012      LDRSH    R3,[R3, R2, LSL #+1]
   \   000001E6   0x2B01             CMP      R3,#+1
   \   000001E8   0xDB04             BLT.N    ??SpiritRadioSearchChannelBwME_19
   \   000001EA   0xA901             ADD      R1,SP,#+4
   \   000001EC   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000001EE   0xF831 0x1012      LDRH     R1,[R1, R2, LSL #+1]
   \   000001F2   0xE004             B.N      ??SpiritRadioSearchChannelBwME_20
   \                     ??SpiritRadioSearchChannelBwME_19: (+1)
   \   000001F4   0xA901             ADD      R1,SP,#+4
   \   000001F6   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000001F8   0xF931 0x1012      LDRSH    R1,[R1, R2, LSL #+1]
   \   000001FC   0x4249             RSBS     R1,R1,#+0
   1154                i=i_tmp+j-1;
   \                     ??SpiritRadioSearchChannelBwME_20: (+1)
   \   000001FE   0x19D3             ADDS     R3,R2,R7
   \   00000200   0x1E5B             SUBS     R3,R3,#+1
   \   00000202   0x469B             MOV      R11,R3
   1155              }    
   1156            }
   \                     ??SpiritRadioSearchChannelBwME_18: (+1)
   \   00000204   0x1C52             ADDS     R2,R2,#+1
   \   00000206   0xE7D4             B.N      ??SpiritRadioSearchChannelBwME_14
   1157            
   1158            *pcE = (uint8_t)(i/9);
   \                     ??SpiritRadioSearchChannelBwME_15: (+1)
   \   00000208   0xFA4F 0xFB8B      SXTB     R11,R11          ;; SignExt  R11,R11,#+24,#+24
   \   0000020C   0x2209             MOVS     R2,#+9
   \   0000020E   0xFB9B 0xF2F2      SDIV     R2,R11,R2
   \   00000212   0x7032             STRB     R2,[R6, #+0]
   1159            *pcM = (uint8_t)(i%9);
   \   00000214   0xFA4F 0xFB8B      SXTB     R11,R11          ;; SignExt  R11,R11,#+24,#+24
   \   00000218   0x2209             MOVS     R2,#+9
   \   0000021A   0xFB9B 0xF3F2      SDIV     R3,R11,R2
   \   0000021E   0xFB02 0xB213      MLS      R2,R2,R3,R11
   \   00000222   0x702A             STRB     R2,[R5, #+0]
   1160            
   1161          }
   \   00000224   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return
   1162          
   1163          
   1164          /**
   1165          * @brief  Returns the mantissa and exponent, whose value used in the frequency deviation formula
   1166          *         will give a frequency deviation value most closer to the given frequency deviation.
   1167          * @param  fFDev frequency deviation expressed in Hz. This parameter can be a value in the range [F_Xo*8/2^18, F_Xo*7680/2^18].
   1168          * @param  pcM pointer to the returned mantissa value.
   1169          * @param  pcE pointer to the returned exponent value.
   1170          * @retval None.
   1171          */

   \                                 In section .text, align 2, keep-with-next
   1172          void SpiritRadioSearchFreqDevME(uint32_t lFDev, uint8_t* pcM, uint8_t* pcE)
   1173          {
   \                     SpiritRadioSearchFreqDevME: (+1)
   \   00000000   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0017             MOVS     R7,R2
   1174            volatile SpiritBool find = S_FALSE;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1175            int8_t i=9;
   \   00000010   0x2409             MOVS     R4,#+9
   1176            uint8_t cMantissaTmp;
   1177            uint8_t cAdder = 0;
   \   00000012   0xF05F 0x0800      MOVS     R8,#+0
   1178            
   1179            /* Check the parameters */
   1180            s_assert_param(IS_F_DEV(lFDev,s_lXtalFrequency));
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable33
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xEBB5 0x4F10      CMP      R5,R0, LSR #+16
   \   00000020   0xD307             BCC.N    ??SpiritRadioSearchFreqDevME_0
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable33
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x210F             MOVS     R1,#+15
   \   0000002A   0x4348             MULS     R0,R1,R0
   \   0000002C   0x0A80             LSRS     R0,R0,#+10
   \   0000002E   0x42A8             CMP      R0,R5
   \   00000030   0xD205             BCS.N    ??SpiritRadioSearchFreqDevME_1
   \                     ??SpiritRadioSearchFreqDevME_0: (+1)
   \   00000032   0xF240 0x419C      MOVW     R1,#+1180
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable30
   \   0000003A   0x.... 0x....      BL       s_assert_failed
   1181            
   1182            if(SpiritGeneralGetSpiritVersion() != SPIRIT_VERSION_2_0) 
   \                     ??SpiritRadioSearchFreqDevME_1: (+1)
   \   0000003E   0x.... 0x....      BL       SpiritGeneralGetSpiritVersion
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD001             BEQ.N    ??SpiritRadioSearchFreqDevME_2
   1183            {
   1184              cAdder++;
   \   00000046   0xF118 0x0801      ADDS     R8,R8,#+1
   1185            }
   1186            
   1187            /* Search in the frequency deviation array the exponent value */
   1188            while(!find && i>=0)
   \                     ??SpiritRadioSearchFreqDevME_2: (+1)
   \   0000004A   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD112             BNE.N    ??SpiritRadioSearchFreqDevME_3
   \   00000052   0xB264             SXTB     R4,R4            ;; SignExt  R4,R4,#+24,#+24
   \   00000054   0x2C00             CMP      R4,#+0
   \   00000056   0xD40F             BMI.N    ??SpiritRadioSearchFreqDevME_3
   1189            {
   1190              if((uint32_t)lFDev>=(s_lXtalFrequency>>(cAdder+15-i)))
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable33
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0xF118 0x010F      ADDS     R1,R8,#+15
   \   00000062   0x1B09             SUBS     R1,R1,R4
   \   00000064   0x0002             MOVS     R2,R0
   \   00000066   0x40CA             LSRS     R2,R2,R1
   \   00000068   0x4295             CMP      R5,R2
   \   0000006A   0xD303             BCC.N    ??SpiritRadioSearchFreqDevME_4
   1191              {
   1192                find = S_TRUE;
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0xF88D 0x0008      STRB     R0,[SP, #+8]
   \   00000072   0xE7EA             B.N      ??SpiritRadioSearchFreqDevME_2
   1193              }
   1194              else
   1195              {
   1196                i--;
   \                     ??SpiritRadioSearchFreqDevME_4: (+1)
   \   00000074   0x1E64             SUBS     R4,R4,#+1
   \   00000076   0xE7E8             B.N      ??SpiritRadioSearchFreqDevME_2
   1197              }
   1198            }
   1199            i<0 ? i=0 : i;
   \                     ??SpiritRadioSearchFreqDevME_3: (+1)
   \   00000078   0xB264             SXTB     R4,R4            ;; SignExt  R4,R4,#+24,#+24
   \   0000007A   0x2C00             CMP      R4,#+0
   \   0000007C   0xD502             BPL.N    ??SpiritRadioSearchFreqDevME_5
   \   0000007E   0x2400             MOVS     R4,#+0
   \   00000080   0xB264             SXTB     R4,R4            ;; SignExt  R4,R4,#+24,#+24
   \   00000082   0xE000             B.N      ??SpiritRadioSearchFreqDevME_6
   \                     ??SpiritRadioSearchFreqDevME_5: (+1)
   \   00000084   0xB264             SXTB     R4,R4            ;; SignExt  R4,R4,#+24,#+24
   1200            *pcE = i;
   \                     ??SpiritRadioSearchFreqDevME_6: (+1)
   \   00000086   0x703C             STRB     R4,[R7, #+0]
   1201            
   1202            cMantissaTmp = ((lFDev<<(12-i+cAdder))/(s_lXtalFrequency>>6)); 
   \   00000088   0xF1D4 0x000C      RSBS     R0,R4,#+12
   \   0000008C   0xEB18 0x0000      ADDS     R0,R8,R0
   \   00000090   0xFA15 0xF000      LSLS     R0,R5,R0
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable33
   \   00000098   0x6809             LDR      R1,[R1, #+0]
   \   0000009A   0x0989             LSRS     R1,R1,#+6
   \   0000009C   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000A0   0x4681             MOV      R9,R0
   1203            if(cMantissaTmp>7) {
   \   000000A2   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000A6   0xF1B9 0x0F08      CMP      R9,#+8
   \   000000AA   0xDB01             BLT.N    ??SpiritRadioSearchFreqDevME_7
   1204              cMantissaTmp -= 8;
   \   000000AC   0xF1B9 0x0908      SUBS     R9,R9,#+8
   1205            }
   1206            
   1207            /* Finds the mantissa value with less approximation */
   1208            int16_t mantissaCalculation[3];
   1209            for(uint8_t j=0;j<3;j++) 
   \                     ??SpiritRadioSearchFreqDevME_7: (+1)
   \   000000B0   0x2000             MOVS     R0,#+0
   \                     ??SpiritRadioSearchFreqDevME_8: (+1)
   \   000000B2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B4   0x2803             CMP      R0,#+3
   \   000000B6   0xDA26             BGE.N    ??SpiritRadioSearchFreqDevME_9
   1210            {
   1211              if((cMantissaTmp+j-1)<8)
   \   000000B8   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000BC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000BE   0xEB10 0x0109      ADDS     R1,R0,R9
   \   000000C2   0x1E49             SUBS     R1,R1,#+1
   \   000000C4   0x2908             CMP      R1,#+8
   \   000000C6   0xDA16             BGE.N    ??SpiritRadioSearchFreqDevME_10
   1212              {
   1213                mantissaCalculation[j] = lFDev - (((s_lXtalFrequency>>6)*(8+cMantissaTmp+j-1))>>(12-i+cAdder));
   \   000000C8   0x.... 0x....      LDR.W    R1,??DataTable33
   \   000000CC   0x6809             LDR      R1,[R1, #+0]
   \   000000CE   0x0989             LSRS     R1,R1,#+6
   \   000000D0   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000D4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D6   0xEB10 0x0209      ADDS     R2,R0,R9
   \   000000DA   0x1DD2             ADDS     R2,R2,#+7
   \   000000DC   0x4351             MULS     R1,R2,R1
   \   000000DE   0xF1D4 0x020C      RSBS     R2,R4,#+12
   \   000000E2   0xEB18 0x0202      ADDS     R2,R8,R2
   \   000000E6   0x000B             MOVS     R3,R1
   \   000000E8   0x40D3             LSRS     R3,R3,R2
   \   000000EA   0x1AE9             SUBS     R1,R5,R3
   \   000000EC   0xAA00             ADD      R2,SP,#+0
   \   000000EE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000F0   0xF822 0x1010      STRH     R1,[R2, R0, LSL #+1]
   \   000000F4   0xE005             B.N      ??SpiritRadioSearchFreqDevME_11
   1214              }
   1215              else
   1216              {
   1217                mantissaCalculation[j] = 0x7FFF;
   \                     ??SpiritRadioSearchFreqDevME_10: (+1)
   \   000000F6   0xF647 0x71FF      MOVW     R1,#+32767
   \   000000FA   0xAA00             ADD      R2,SP,#+0
   \   000000FC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000FE   0xF822 0x1010      STRH     R1,[R2, R0, LSL #+1]
   1218              }
   1219            }
   \                     ??SpiritRadioSearchFreqDevME_11: (+1)
   \   00000102   0x1C40             ADDS     R0,R0,#+1
   \   00000104   0xE7D5             B.N      ??SpiritRadioSearchFreqDevME_8
   1220            uint16_t mantissaDelta = 0xFFFF;
   \                     ??SpiritRadioSearchFreqDevME_9: (+1)
   \   00000106   0xF64F 0x70FF      MOVW     R0,#+65535
   1221            
   1222            for(uint8_t j=0;j<3;j++)
   \   0000010A   0x2100             MOVS     R1,#+0
   \                     ??SpiritRadioSearchFreqDevME_12: (+1)
   \   0000010C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000010E   0x2903             CMP      R1,#+3
   \   00000110   0xDA28             BGE.N    ??SpiritRadioSearchFreqDevME_13
   1223            {
   1224              if(S_ABS(mantissaCalculation[j])<mantissaDelta)
   \   00000112   0xAA00             ADD      R2,SP,#+0
   \   00000114   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000116   0xF932 0x2011      LDRSH    R2,[R2, R1, LSL #+1]
   \   0000011A   0x2A01             CMP      R2,#+1
   \   0000011C   0xDB04             BLT.N    ??SpiritRadioSearchFreqDevME_14
   \   0000011E   0xAA00             ADD      R2,SP,#+0
   \   00000120   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000122   0xF932 0x2011      LDRSH    R2,[R2, R1, LSL #+1]
   \   00000126   0xE004             B.N      ??SpiritRadioSearchFreqDevME_15
   \                     ??SpiritRadioSearchFreqDevME_14: (+1)
   \   00000128   0xAA00             ADD      R2,SP,#+0
   \   0000012A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000012C   0xF932 0x2011      LDRSH    R2,[R2, R1, LSL #+1]
   \   00000130   0x4252             RSBS     R2,R2,#+0
   \                     ??SpiritRadioSearchFreqDevME_15: (+1)
   \   00000132   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000134   0x4282             CMP      R2,R0
   \   00000136   0xDA13             BGE.N    ??SpiritRadioSearchFreqDevME_16
   1225              {
   1226                mantissaDelta = S_ABS(mantissaCalculation[j]);
   \   00000138   0xAA00             ADD      R2,SP,#+0
   \   0000013A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000013C   0xF932 0x2011      LDRSH    R2,[R2, R1, LSL #+1]
   \   00000140   0x2A01             CMP      R2,#+1
   \   00000142   0xDB04             BLT.N    ??SpiritRadioSearchFreqDevME_17
   \   00000144   0xA800             ADD      R0,SP,#+0
   \   00000146   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000148   0xF830 0x0011      LDRH     R0,[R0, R1, LSL #+1]
   \   0000014C   0xE004             B.N      ??SpiritRadioSearchFreqDevME_18
   \                     ??SpiritRadioSearchFreqDevME_17: (+1)
   \   0000014E   0xA800             ADD      R0,SP,#+0
   \   00000150   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000152   0xF930 0x0011      LDRSH    R0,[R0, R1, LSL #+1]
   \   00000156   0x4240             RSBS     R0,R0,#+0
   1227                *pcM=cMantissaTmp+j-1;
   \                     ??SpiritRadioSearchFreqDevME_18: (+1)
   \   00000158   0xEB11 0x0209      ADDS     R2,R1,R9
   \   0000015C   0x1E52             SUBS     R2,R2,#+1
   \   0000015E   0x7032             STRB     R2,[R6, #+0]
   1228              }    
   1229            }
   \                     ??SpiritRadioSearchFreqDevME_16: (+1)
   \   00000160   0x1C49             ADDS     R1,R1,#+1
   \   00000162   0xE7D3             B.N      ??SpiritRadioSearchFreqDevME_12
   1230          }
   \                     ??SpiritRadioSearchFreqDevME_13: (+1)
   \   00000164   0xE8BD 0x83F7      POP      {R0-R2,R4-R9,PC}  ;; return
   1231          
   1232          
   1233          /**
   1234          * @brief  Sets the datarate.
   1235          * @param  fDatarate datarate expressed in bps. This value shall be in the range
   1236          *         [100 500000].
   1237          * @retval None.
   1238          */

   \                                 In section .text, align 2, keep-with-next
   1239          void SpiritRadioSetDatarate(uint32_t lDatarate)
   1240          {
   \                     SpiritRadioSetDatarate: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1241            uint8_t drE, tempRegValue[2];
   1242            
   1243            /* Check the parameters */
   1244            s_assert_param(IS_DATARATE(lDatarate));
   \   00000004   0x2C64             CMP      R4,#+100
   \   00000006   0xD303             BCC.N    ??SpiritRadioSetDatarate_0
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable32  ;; 0x7c831
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD305             BCC.N    ??SpiritRadioSetDatarate_1
   \                     ??SpiritRadioSetDatarate_0: (+1)
   \   00000010   0xF240 0x41DC      MOVW     R1,#+1244
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable30
   \   00000018   0x.... 0x....      BL       s_assert_failed
   1245            
   1246            /* Calculates the datarate mantissa and exponent */
   1247            SpiritRadioSearchDatarateME(lDatarate, &tempRegValue[0], &drE);
   \                     ??SpiritRadioSetDatarate_1: (+1)
   \   0000001C   0xF10D 0x0202      ADD      R2,SP,#+2
   \   00000020   0xA900             ADD      R1,SP,#+0
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       SpiritRadioSearchDatarateME
   1248            
   1249            /* Reads the MOD_O register*/
   1250            SpiritSpiReadRegisters(MOD0_BASE, 1, &tempRegValue[1]);
   \   00000028   0xF10D 0x0201      ADD      R2,SP,#+1
   \   0000002C   0x2101             MOVS     R1,#+1
   \   0000002E   0x201B             MOVS     R0,#+27
   \   00000030   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   1251            
   1252            /* Mask the other fields and set the datarate exponent */
   1253            tempRegValue[1] &= 0xF0;
   \   00000034   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000038   0xF010 0x00F0      ANDS     R0,R0,#0xF0
   \   0000003C   0xF88D 0x0001      STRB     R0,[SP, #+1]
   1254            tempRegValue[1] |= drE;
   \   00000040   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000044   0xF89D 0x1002      LDRB     R1,[SP, #+2]
   \   00000048   0x4308             ORRS     R0,R1,R0
   \   0000004A   0xF88D 0x0001      STRB     R0,[SP, #+1]
   1255            
   1256            /* Writes the Datarate registers */
   1257            g_xStatus = SpiritSpiWriteRegisters(MOD1_BASE, 2, tempRegValue);
   \   0000004E   0xAA00             ADD      R2,SP,#+0
   \   00000050   0x2102             MOVS     R1,#+2
   \   00000052   0x201A             MOVS     R0,#+26
   \   00000054   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000058   0x9001             STR      R0,[SP, #+4]
   \   0000005A   0x....             LDR.N    R0,??DataTable26
   \   0000005C   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000060   0x8001             STRH     R1,[R0, #+0]
   1258            
   1259          }
   \   00000062   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   1260          
   1261          
   1262          /**
   1263          * @brief  Returns the datarate.
   1264          * @param  None.
   1265          * @retval uint32_t Settled datarate expressed in bps.
   1266          */

   \                                 In section .text, align 2, keep-with-next
   1267          uint32_t SpiritRadioGetDatarate(void)
   1268          {
   \                     SpiritRadioGetDatarate: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   1269            uint8_t tempRegValue[2];
   1270            uint8_t cDivider=0;
   \   00000002   0x2400             MOVS     R4,#+0
   1271            
   1272            /* Reads the datarate registers for mantissa and exponent */
   1273            g_xStatus = SpiritSpiReadRegisters(MOD1_BASE, 2, tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2102             MOVS     R1,#+2
   \   00000008   0x201A             MOVS     R0,#+26
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x....             LDR.N    R0,??DataTable26
   \   00000012   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000016   0x8001             STRH     R1,[R0, #+0]
   1274            
   1275            if(SpiritGeneralGetSpiritVersion() != SPIRIT_VERSION_2_0) 
   \   00000018   0x.... 0x....      BL       SpiritGeneralGetSpiritVersion
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD004             BEQ.N    ??SpiritRadioGetDatarate_0
   1276            {
   1277              /* Calculates the datarate */
   1278              cDivider = 1-SpiritRadioGetDigDiv(); 
   \   00000020   0x.... 0x....      BL       SpiritRadioGetDigDiv
   \   00000024   0xF1D0 0x0001      RSBS     R0,R0,#+1
   \   00000028   0x0004             MOVS     R4,R0
   1279            }  
   1280            return (((s_lXtalFrequency>>(5+cDivider))*(256+tempRegValue[0]))>>(23-(tempRegValue[1]&0x0F)));
   \                     ??SpiritRadioGetDatarate_0: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable33
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x1D61             ADDS     R1,R4,#+5
   \   00000032   0x0002             MOVS     R2,R0
   \   00000034   0x40CA             LSRS     R2,R2,R1
   \   00000036   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000003A   0xF510 0x7080      ADDS     R0,R0,#+256
   \   0000003E   0xFB00 0xF102      MUL      R1,R0,R2
   \   00000042   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000046   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   0000004A   0xF1D0 0x0217      RSBS     R2,R0,#+23
   \   0000004E   0x0008             MOVS     R0,R1
   \   00000050   0x40D0             LSRS     R0,R0,R2
   \   00000052   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   1281            
   1282          }
   1283          
   1284          
   1285          /**
   1286          * @brief  Sets the frequency deviation.
   1287          * @param  fFDev frequency deviation expressed in Hz. Be sure that this value
   1288          *         is in the correct range [F_Xo*8/2^18, F_Xo*7680/2^18] Hz.
   1289          * @retval None.
   1290          */

   \                                 In section .text, align 2, keep-with-next
   1291          void SpiritRadioSetFrequencyDev(uint32_t lFDev)
   1292          {
   \                     SpiritRadioSetFrequencyDev: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1293            uint8_t FDevM, FDevE, tempRegValue;
   1294            
   1295            /* Check the parameters */
   1296            s_assert_param(IS_F_DEV(lFDev, s_lXtalFrequency));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable33
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0xEBB4 0x4F10      CMP      R4,R0, LSR #+16
   \   0000000E   0xD307             BCC.N    ??SpiritRadioSetFrequencyDev_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable33
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x210F             MOVS     R1,#+15
   \   00000018   0x4348             MULS     R0,R1,R0
   \   0000001A   0x0A80             LSRS     R0,R0,#+10
   \   0000001C   0x42A0             CMP      R0,R4
   \   0000001E   0xD204             BCS.N    ??SpiritRadioSetFrequencyDev_1
   \                     ??SpiritRadioSetFrequencyDev_0: (+1)
   \   00000020   0xF44F 0x61A2      MOV      R1,#+1296
   \   00000024   0x....             LDR.N    R0,??DataTable30
   \   00000026   0x.... 0x....      BL       s_assert_failed
   1297            
   1298            /* Calculates the frequency deviation mantissa and exponent */
   1299            SpiritRadioSearchFreqDevME(lFDev, &FDevM, &FDevE);
   \                     ??SpiritRadioSetFrequencyDev_1: (+1)
   \   0000002A   0xF10D 0x0201      ADD      R2,SP,#+1
   \   0000002E   0xF10D 0x0102      ADD      R1,SP,#+2
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       SpiritRadioSearchFreqDevME
   1300            
   1301            /* Reads the FDEV0 register */
   1302            SpiritSpiReadRegisters(FDEV0_BASE, 1, &tempRegValue);
   \   00000038   0xAA00             ADD      R2,SP,#+0
   \   0000003A   0x2101             MOVS     R1,#+1
   \   0000003C   0x201C             MOVS     R0,#+28
   \   0000003E   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   1303            
   1304            /* Mask the other fields and set the frequency deviation mantissa and exponent */
   1305            tempRegValue &= 0x08;
   \   00000042   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000046   0xF010 0x0008      ANDS     R0,R0,#0x8
   \   0000004A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1306            tempRegValue |= ((FDevE<<4)|(FDevM));
   \   0000004E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000052   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \   00000056   0xF89D 0x2002      LDRB     R2,[SP, #+2]
   \   0000005A   0xEA52 0x1101      ORRS     R1,R2,R1, LSL #+4
   \   0000005E   0x4308             ORRS     R0,R1,R0
   \   00000060   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1307            
   1308            /* Writes the Frequency deviation register */
   1309            g_xStatus = SpiritSpiWriteRegisters(FDEV0_BASE, 1, &tempRegValue);
   \   00000064   0xAA00             ADD      R2,SP,#+0
   \   00000066   0x2101             MOVS     R1,#+1
   \   00000068   0x201C             MOVS     R0,#+28
   \   0000006A   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   0000006E   0x9001             STR      R0,[SP, #+4]
   \   00000070   0x....             LDR.N    R0,??DataTable26
   \   00000072   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000076   0x8001             STRH     R1,[R0, #+0]
   1310            
   1311          }
   \   00000078   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   1312          
   1313          
   1314          /**
   1315          * @brief  Returns the frequency deviation.
   1316          * @param  None.
   1317          * @retval uint32_t Frequency deviation value expressed in Hz.
   1318          *         This value will be in the range [F_Xo*8/2^18, F_Xo*7680/2^18] Hz.
   1319          */

   \                                 In section .text, align 2, keep-with-next
   1320          uint32_t SpiritRadioGetFrequencyDev(void)
   1321          {
   \                     SpiritRadioGetFrequencyDev: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   1322            uint8_t tempRegValue, FDevM, FDevE;  
   1323            uint8_t cAdder = 0;
   \   00000002   0x2600             MOVS     R6,#+0
   1324            
   1325            /* Reads the frequency deviation register for mantissa and exponent */
   1326            g_xStatus = SpiritSpiReadRegisters(FDEV0_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x201C             MOVS     R0,#+28
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x....             LDR.N    R0,??DataTable26
   \   00000012   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000016   0x8001             STRH     R1,[R0, #+0]
   1327            FDevM = tempRegValue&0x07;
   \   00000018   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001C   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000020   0x0004             MOVS     R4,R0
   1328            FDevE = (tempRegValue&0xF0)>>4;
   \   00000022   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x0900             LSRS     R0,R0,#+4
   \   0000002A   0x0005             MOVS     R5,R0
   1329            
   1330            if(SpiritGeneralGetSpiritVersion() != SPIRIT_VERSION_2_0) 
   \   0000002C   0x.... 0x....      BL       SpiritGeneralGetSpiritVersion
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD000             BEQ.N    ??SpiritRadioGetFrequencyDev_0
   1331            {
   1332              cAdder++;
   \   00000034   0x1C76             ADDS     R6,R6,#+1
   1333            }
   1334            
   1335            /* Calculates the frequency deviation and return it */
   1336            return (((s_lXtalFrequency>>6)*(8+FDevM))>>(12-FDevE+cAdder));
   \                     ??SpiritRadioGetFrequencyDev_0: (+1)
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable33
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x0980             LSRS     R0,R0,#+6
   \   0000003E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000040   0xF114 0x0108      ADDS     R1,R4,#+8
   \   00000044   0xFB01 0xF100      MUL      R1,R1,R0
   \   00000048   0xF1D5 0x000C      RSBS     R0,R5,#+12
   \   0000004C   0x1832             ADDS     R2,R6,R0
   \   0000004E   0x0008             MOVS     R0,R1
   \   00000050   0x40D0             LSRS     R0,R0,R2
   \   00000052   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   1337            
   1338          }
   1339          
   1340          
   1341          /**
   1342          * @brief  Sets the channel filter bandwidth.
   1343          * @param  lBandwidth channel filter bandwidth expressed in Hz. This parameter shall be in the range [1100 800100]
   1344          *         Even if it is possible to pass as parameter any value in the above mentioned range,
   1345          *         the API will search the most closer value according to a fixed table of channel
   1346          *         bandwidth values (@ref s_vectnBandwidth), as defined in the datasheet. To verify the settled channel bandwidth
   1347          *         it is possible to use the SpiritRadioGetChannelBW() API.
   1348          * @retval None.
   1349          */

   \                                 In section .text, align 2, keep-with-next
   1350          void SpiritRadioSetChannelBW(uint32_t lBandwidth)
   1351          {
   \                     SpiritRadioSetChannelBW: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1352            uint8_t bwM, bwE, tempRegValue;
   1353          
   1354            if(SpiritGeneralGetSpiritVersion() != SPIRIT_VERSION_2_0) 
   \   00000004   0x.... 0x....      BL       SpiritGeneralGetSpiritVersion
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD04C             BEQ.N    ??SpiritRadioSetChannelBW_0
   1355            {
   1356              /* Search in the channel filter bandwidth table the exponent value */
   1357              if(SpiritRadioGetDigDiv())
   \   0000000C   0x.... 0x....      BL       SpiritRadioGetDigDiv
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD025             BEQ.N    ??SpiritRadioSetChannelBW_1
   1358              {
   1359                s_assert_param(IS_CH_BW(lBandwidth,(s_lXtalFrequency/2)));
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable33
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x0840             LSRS     R0,R0,#+1
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable33_1  ;; 0xf4240
   \   00000020   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000024   0xF240 0x414C      MOVW     R1,#+1100
   \   00000028   0x4348             MULS     R0,R1,R0
   \   0000002A   0x211A             MOVS     R1,#+26
   \   0000002C   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD30F             BCC.N    ??SpiritRadioSetChannelBW_2
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable33
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x0840             LSRS     R0,R0,#+1
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable33_1  ;; 0xf4240
   \   00000040   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable33_2  ;; 0xc3564
   \   00000048   0x4348             MULS     R0,R1,R0
   \   0000004A   0x211A             MOVS     R1,#+26
   \   0000004C   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000050   0x42A0             CMP      R0,R4
   \   00000052   0xD228             BCS.N    ??SpiritRadioSetChannelBW_0
   \                     ??SpiritRadioSetChannelBW_2: (+1)
   \   00000054   0xF240 0x514F      MOVW     R1,#+1359
   \   00000058   0x....             LDR.N    R0,??DataTable30
   \   0000005A   0x.... 0x....      BL       s_assert_failed
   \   0000005E   0xE022             B.N      ??SpiritRadioSetChannelBW_0
   1360              }
   1361              else
   1362              {
   1363                s_assert_param(IS_CH_BW(lBandwidth,(s_lXtalFrequency)));
   \                     ??SpiritRadioSetChannelBW_1: (+1)
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable33
   \   00000064   0x6800             LDR      R0,[R0, #+0]
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable33_1  ;; 0xf4240
   \   0000006A   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000006E   0xF240 0x414C      MOVW     R1,#+1100
   \   00000072   0x4348             MULS     R0,R1,R0
   \   00000074   0x211A             MOVS     R1,#+26
   \   00000076   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000007A   0x4284             CMP      R4,R0
   \   0000007C   0xD30E             BCC.N    ??SpiritRadioSetChannelBW_3
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable33
   \   00000082   0x6800             LDR      R0,[R0, #+0]
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable33_1  ;; 0xf4240
   \   00000088   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000008C   0x.... 0x....      LDR.W    R1,??DataTable33_2  ;; 0xc3564
   \   00000090   0x4348             MULS     R0,R1,R0
   \   00000092   0x211A             MOVS     R1,#+26
   \   00000094   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000098   0x42A0             CMP      R0,R4
   \   0000009A   0xD204             BCS.N    ??SpiritRadioSetChannelBW_0
   \                     ??SpiritRadioSetChannelBW_3: (+1)
   \   0000009C   0xF240 0x5153      MOVW     R1,#+1363
   \   000000A0   0x....             LDR.N    R0,??DataTable30
   \   000000A2   0x.... 0x....      BL       s_assert_failed
   1364              } 
   1365            }
   1366          
   1367            /* Calculates the channel bandwidth mantissa and exponent */
   1368            SpiritRadioSearchChannelBwME(lBandwidth, &bwM, &bwE);
   \                     ??SpiritRadioSetChannelBW_0: (+1)
   \   000000A6   0xF10D 0x0201      ADD      R2,SP,#+1
   \   000000AA   0xF10D 0x0102      ADD      R1,SP,#+2
   \   000000AE   0x0020             MOVS     R0,R4
   \   000000B0   0x.... 0x....      BL       SpiritRadioSearchChannelBwME
   1369            tempRegValue = (bwM<<4)|(bwE);
   \   000000B4   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   000000B8   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \   000000BC   0xEA51 0x1000      ORRS     R0,R1,R0, LSL #+4
   \   000000C0   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1370            
   1371            /* Writes the Channel filter register */
   1372            g_xStatus = SpiritSpiWriteRegisters(CHFLT_BASE, 1, &tempRegValue);
   \   000000C4   0xAA00             ADD      R2,SP,#+0
   \   000000C6   0x2101             MOVS     R1,#+1
   \   000000C8   0x201D             MOVS     R0,#+29
   \   000000CA   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   000000CE   0x9001             STR      R0,[SP, #+4]
   \   000000D0   0x....             LDR.N    R0,??DataTable26
   \   000000D2   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   000000D6   0x8001             STRH     R1,[R0, #+0]
   1373            
   1374          }
   \   000000D8   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   1375          
   1376          /**
   1377          * @brief  Returns the channel filter bandwidth.
   1378          * @param  None.
   1379          * @retval uint32_t Channel filter bandwidth expressed in Hz.
   1380          */

   \                                 In section .text, align 2, keep-with-next
   1381          uint32_t SpiritRadioGetChannelBW(void)
   1382          {
   \                     SpiritRadioGetChannelBW: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   1383            uint8_t tempRegValue, bwM, bwE;
   1384            
   1385            /* Reads the channel filter register for mantissa and exponent */
   1386            g_xStatus = SpiritSpiReadRegisters(CHFLT_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x201D             MOVS     R0,#+29
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x....             LDR.N    R0,??DataTable26
   \   00000012   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000016   0x8001             STRH     R1,[R0, #+0]
   1387            bwM = (tempRegValue&0xF0)>>4;
   \   00000018   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0x0900             LSRS     R0,R0,#+4
   \   00000020   0x0004             MOVS     R4,R0
   1388            bwE = tempRegValue&0x0F;
   \   00000022   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000026   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   0000002A   0x0005             MOVS     R5,R0
   1389            
   1390            /* Reads the channel filter bandwidth from the look-up table and return it */
   1391            return (uint32_t)(100.0*s_vectnBandwidth26M[bwM+(bwE*9)]*s_lXtalFrequency/26e6);
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable35
   \   00000030   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2109             MOVS     R1,#+9
   \   00000036   0xFB01 0x4105      MLA      R1,R1,R5,R4
   \   0000003A   0xF830 0x0011      LDRH     R0,[R0, R1, LSL #+1]
   \   0000003E   0x.... 0x....      BL       __aeabi_ui2d
   \   00000042   0x2200             MOVS     R2,#+0
   \   00000044   0x.... 0x....      LDR.W    R3,??DataTable46  ;; 0x40590000
   \   00000048   0x.... 0x....      BL       __aeabi_dmul
   \   0000004C   0x0004             MOVS     R4,R0
   \   0000004E   0x000D             MOVS     R5,R1
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable33
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0x.... 0x....      BL       __aeabi_ui2d
   \   0000005A   0x0022             MOVS     R2,R4
   \   0000005C   0x002B             MOVS     R3,R5
   \   0000005E   0x.... 0x....      BL       __aeabi_dmul
   \   00000062   0x2200             MOVS     R2,#+0
   \   00000064   0x.... 0x....      LDR.W    R3,??DataTable55  ;; 0x4178cba8
   \   00000068   0x.... 0x....      BL       __aeabi_ddiv
   \   0000006C   0x.... 0x....      BL       __aeabi_d2uiz
   \   00000070   0xBD3E             POP      {R1-R5,PC}       ;; return
   1392            
   1393          }
   1394          
   1395          
   1396          /**
   1397          * @brief  Sets the modulation type.
   1398          * @param  xModulation modulation to set.
   1399          *         This parameter shall be of type @ref ModulationSelect .
   1400          * @retval None.
   1401          */

   \                                 In section .text, align 2, keep-with-next
   1402          void SpiritRadioSetModulation(ModulationSelect xModulation)
   1403          {
   \                     SpiritRadioSetModulation: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1404            uint8_t tempRegValue;
   1405            
   1406            /* Check the parameters */
   1407            s_assert_param(IS_MODULATION_SELECTED(xModulation));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD010             BEQ.N    ??SpiritRadioSetModulation_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C50             CMP      R4,#+80
   \   0000000E   0xD00D             BEQ.N    ??SpiritRadioSetModulation_0
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C10             CMP      R4,#+16
   \   00000014   0xD00A             BEQ.N    ??SpiritRadioSetModulation_0
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0x2C20             CMP      R4,#+32
   \   0000001A   0xD007             BEQ.N    ??SpiritRadioSetModulation_0
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x2C30             CMP      R4,#+48
   \   00000020   0xD004             BEQ.N    ??SpiritRadioSetModulation_0
   \   00000022   0xF240 0x517F      MOVW     R1,#+1407
   \   00000026   0x....             LDR.N    R0,??DataTable30
   \   00000028   0x.... 0x....      BL       s_assert_failed
   1408            
   1409            /* Reads the modulation register */
   1410            SpiritSpiReadRegisters(MOD0_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioSetModulation_0: (+1)
   \   0000002C   0xAA00             ADD      R2,SP,#+0
   \   0000002E   0x2101             MOVS     R1,#+1
   \   00000030   0x201B             MOVS     R0,#+27
   \   00000032   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   1411            
   1412            /* Mask the other fields and set the modulation type */
   1413            tempRegValue &=0x8F;
   \   00000036   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000003A   0xF010 0x008F      ANDS     R0,R0,#0x8F
   \   0000003E   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1414            tempRegValue |= xModulation;
   \   00000042   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000046   0x4320             ORRS     R0,R4,R0
   \   00000048   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1415            
   1416            /* Writes the modulation register */
   1417            g_xStatus = SpiritSpiWriteRegisters(MOD0_BASE, 1, &tempRegValue);
   \   0000004C   0xAA00             ADD      R2,SP,#+0
   \   0000004E   0x2101             MOVS     R1,#+1
   \   00000050   0x201B             MOVS     R0,#+27
   \   00000052   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000056   0x9001             STR      R0,[SP, #+4]
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable57
   \   0000005C   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000060   0x8001             STRH     R1,[R0, #+0]
   1418            
   1419          }
   \   00000062   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   1420          
   1421          
   1422          /**
   1423          * @brief  Returns the modulation type used.
   1424          * @param  None.
   1425          * @retval ModulationSelect Settled modulation type.
   1426          */

   \                                 In section .text, align 2, keep-with-next
   1427          ModulationSelect SpiritRadioGetModulation(void)
   1428          {
   \                     SpiritRadioGetModulation: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   1429            uint8_t tempRegValue;
   1430            
   1431            /* Reads the modulation register MOD0*/
   1432            g_xStatus = SpiritSpiReadRegisters(MOD0_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x201B             MOVS     R0,#+27
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable57
   \   00000014   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000018   0x8001             STRH     R1,[R0, #+0]
   1433            
   1434            /* Return the modulation type */
   1435            return (ModulationSelect)(tempRegValue&0x70);
   \   0000001A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001E   0xF010 0x0070      ANDS     R0,R0,#0x70
   \   00000022   0xBD0E             POP      {R1-R3,PC}       ;; return
   1436            
   1437          }
   1438          
   1439          
   1440          /**
   1441          * @brief  Enables or Disables the Continuous Wave transmit mode.
   1442          * @param  xNewState new state for power ramping.
   1443          *         This parameter can be: S_ENABLE or S_DISABLE .
   1444          * @retval None.
   1445          */

   \                                 In section .text, align 2, keep-with-next
   1446          void SpiritRadioCWTransmitMode(SpiritFunctionalState xNewState)
   1447          {
   \                     SpiritRadioCWTransmitMode: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1448            uint8_t tempRegValue;
   1449            
   1450            /* Check the parameters */
   1451            s_assert_param(IS_SPIRIT_FUNCTIONAL_STATE(xNewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??SpiritRadioCWTransmitMode_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD004             BEQ.N    ??SpiritRadioCWTransmitMode_0
   \   00000010   0xF240 0x51AB      MOVW     R1,#+1451
   \   00000014   0x....             LDR.N    R0,??DataTable30
   \   00000016   0x.... 0x....      BL       s_assert_failed
   1452            
   1453            /* Reads the modulation register MOD0 and mask the CW field */
   1454            SpiritSpiReadRegisters(MOD0_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioCWTransmitMode_0: (+1)
   \   0000001A   0xAA00             ADD      R2,SP,#+0
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x201B             MOVS     R0,#+27
   \   00000020   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   1455            if(xNewState == S_ENABLE)
   \   00000024   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000026   0x2C01             CMP      R4,#+1
   \   00000028   0xD106             BNE.N    ??SpiritRadioCWTransmitMode_1
   1456            {
   1457              tempRegValue |=MOD0_CW;
   \   0000002A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000002E   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000032   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000036   0xE005             B.N      ??SpiritRadioCWTransmitMode_2
   1458            }
   1459            else
   1460            {
   1461              tempRegValue &= (~MOD0_CW);
   \                     ??SpiritRadioCWTransmitMode_1: (+1)
   \   00000038   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000003C   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   00000040   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1462            }
   1463            
   1464            /* Writes the new value in the MOD0 register */
   1465            g_xStatus = SpiritSpiWriteRegisters(MOD0_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioCWTransmitMode_2: (+1)
   \   00000044   0xAA00             ADD      R2,SP,#+0
   \   00000046   0x2101             MOVS     R1,#+1
   \   00000048   0x201B             MOVS     R0,#+27
   \   0000004A   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   0000004E   0x9001             STR      R0,[SP, #+4]
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable57
   \   00000054   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000058   0x8001             STRH     R1,[R0, #+0]
   1466            
   1467          }
   \   0000005A   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   1468          
   1469          
   1470          /**
   1471          * @brief  Sets the OOK Peak Decay.
   1472          * @param  xOokDecay Peak decay control for OOK.
   1473          *         This parameter shall be of type @ref OokPeakDecay .
   1474          * @retval None.
   1475          */

   \                                 In section .text, align 2, keep-with-next
   1476          void SpiritRadioSetOokPeakDecay(OokPeakDecay xOokDecay)
   1477          {
   \                     SpiritRadioSetOokPeakDecay: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1478            uint8_t tempRegValue;
   1479            
   1480            /* Check the parameters */
   1481            s_assert_param(IS_OOK_PEAK_DECAY(xOokDecay));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD00D             BEQ.N    ??SpiritRadioSetOokPeakDecay_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD00A             BEQ.N    ??SpiritRadioSetOokPeakDecay_0
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C02             CMP      R4,#+2
   \   00000014   0xD007             BEQ.N    ??SpiritRadioSetOokPeakDecay_0
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0x2C03             CMP      R4,#+3
   \   0000001A   0xD004             BEQ.N    ??SpiritRadioSetOokPeakDecay_0
   \   0000001C   0xF240 0x51C9      MOVW     R1,#+1481
   \   00000020   0x....             LDR.N    R0,??DataTable30
   \   00000022   0x.... 0x....      BL       s_assert_failed
   1482            
   1483            /* Reads the RSSI_FLT register */
   1484            SpiritSpiReadRegisters(RSSI_FLT_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioSetOokPeakDecay_0: (+1)
   \   00000026   0xAA00             ADD      R2,SP,#+0
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0x2021             MOVS     R0,#+33
   \   0000002C   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   1485            
   1486            /* Mask the other fields and set OOK Peak Decay */
   1487            tempRegValue &= 0xFC;
   \   00000030   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000034   0xF010 0x00FC      ANDS     R0,R0,#0xFC
   \   00000038   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1488            tempRegValue |= xOokDecay;
   \   0000003C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000040   0x4320             ORRS     R0,R4,R0
   \   00000042   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1489            
   1490            /* Writes the RSSI_FLT register to set the new OOK peak dacay value */
   1491            g_xStatus = SpiritSpiWriteRegisters(RSSI_FLT_BASE, 1, &tempRegValue);
   \   00000046   0xAA00             ADD      R2,SP,#+0
   \   00000048   0x2101             MOVS     R1,#+1
   \   0000004A   0x2021             MOVS     R0,#+33
   \   0000004C   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000050   0x9001             STR      R0,[SP, #+4]
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable57
   \   00000056   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   0000005A   0x8001             STRH     R1,[R0, #+0]
   1492            
   1493          }
   \   0000005C   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   1494          
   1495          
   1496          /**
   1497          * @brief  Returns the OOK Peak Decay.
   1498          * @param  None
   1499          * @retval OokPeakDecay Ook peak decay value.
   1500          */

   \                                 In section .text, align 2, keep-with-next
   1501          OokPeakDecay SpiritRadioGetOokPeakDecay(void)
   1502          {
   \                     SpiritRadioGetOokPeakDecay: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   1503            uint8_t tempRegValue;
   1504            
   1505            /* Reads the OOK peak decay register RSSI_FLT_BASE*/
   1506            g_xStatus = SpiritSpiReadRegisters(RSSI_FLT_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2021             MOVS     R0,#+33
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable57
   \   00000014   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000018   0x8001             STRH     R1,[R0, #+0]
   1507            
   1508            /* Returns the OOK peak decay */
   1509            return (OokPeakDecay) (tempRegValue & 0x03);
   \   0000001A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001E   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   00000022   0xBD0E             POP      {R1-R3,PC}       ;; return
   1510            
   1511          }
   1512          
   1513          
   1514          /**
   1515          * @brief  Configures the Power Amplifier Table and registers with value expressed in dBm.
   1516          * @param  cPALevelMaxIndex number of levels to set. This parameter shall be in the range [0:7].
   1517          * @param  cWidth step width expressed in terms of bit period units Tb/8.
   1518          *         This parameter shall be in the range [1:4].
   1519          * @param  xCLoad one of the possible value of the enum type PALoadCapacitor.
   1520          *         @arg LOAD_0_PF    No additional PA load capacitor
   1521          *         @arg LOAD_1_2_PF  1.2pF additional PA load capacitor
   1522          *         @arg LOAD_2_4_PF  2.4pF additional PA load capacitor
   1523          *         @arg LOAD_3_6_PF  3.6pF additional PA load capacitor
   1524          * @param  pfPAtabledBm pointer to an array of PA values in dbm between [-PA_LOWER_LIMIT: PA_UPPER_LIMIT] dbm.
   1525          *         The first element shall be the lower level (PA_LEVEL[0]) value and the last element
   1526          *         the higher level one (PA_LEVEL[paLevelMaxIndex]).
   1527          * @retval None.
   1528          */

   \                                 In section .text, align 2, keep-with-next
   1529          void SpiritRadioSetPATabledBm(uint8_t cPALevelMaxIndex, uint8_t cWidth, PALoadCapacitor xCLoad, float* pfPAtabledBm)
   1530          {
   \                     SpiritRadioSetPATabledBm: (+1)
   \   00000000   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
   \   00000006   0x001C             MOVS     R4,R3
   1531            uint8_t palevel[9], address, paLevelValue;
   1532            float z;
   1533            
   1534            /* Check the parameters */
   1535            s_assert_param(IS_PA_MAX_INDEX(cPALevelMaxIndex));
   \   00000008   0xF89D 0x0018      LDRB     R0,[SP, #+24]
   \   0000000C   0x2808             CMP      R0,#+8
   \   0000000E   0xDB05             BLT.N    ??SpiritRadioSetPATabledBm_0
   \   00000010   0xF240 0x51FF      MOVW     R1,#+1535
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable54
   \   00000018   0x.... 0x....      BL       s_assert_failed
   1536            s_assert_param(IS_PA_STEP_WIDTH(cWidth));
   \                     ??SpiritRadioSetPATabledBm_0: (+1)
   \   0000001C   0xF89D 0x001C      LDRB     R0,[SP, #+28]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD003             BEQ.N    ??SpiritRadioSetPATabledBm_1
   \   00000024   0xF89D 0x001C      LDRB     R0,[SP, #+28]
   \   00000028   0x2805             CMP      R0,#+5
   \   0000002A   0xDB05             BLT.N    ??SpiritRadioSetPATabledBm_2
   \                     ??SpiritRadioSetPATabledBm_1: (+1)
   \   0000002C   0xF44F 0x61C0      MOV      R1,#+1536
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable54
   \   00000034   0x.... 0x....      BL       s_assert_failed
   1537            s_assert_param(IS_PA_LOAD_CAP(xCLoad));
   \                     ??SpiritRadioSetPATabledBm_2: (+1)
   \   00000038   0xF89D 0x0020      LDRB     R0,[SP, #+32]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD011             BEQ.N    ??SpiritRadioSetPATabledBm_3
   \   00000040   0xF89D 0x0020      LDRB     R0,[SP, #+32]
   \   00000044   0x2840             CMP      R0,#+64
   \   00000046   0xD00D             BEQ.N    ??SpiritRadioSetPATabledBm_3
   \   00000048   0xF89D 0x0020      LDRB     R0,[SP, #+32]
   \   0000004C   0x2880             CMP      R0,#+128
   \   0000004E   0xD009             BEQ.N    ??SpiritRadioSetPATabledBm_3
   \   00000050   0xF89D 0x0020      LDRB     R0,[SP, #+32]
   \   00000054   0x28C0             CMP      R0,#+192
   \   00000056   0xD005             BEQ.N    ??SpiritRadioSetPATabledBm_3
   \   00000058   0xF240 0x6101      MOVW     R1,#+1537
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable54
   \   00000060   0x.... 0x....      BL       s_assert_failed
   1538            
   1539            /* Check the PA level in dBm is in the range and calculate the PA_LEVEL value
   1540            to write in the corresponding register using the linearization formula */
   1541            for(int i=0; i<=cPALevelMaxIndex; i++)
   \                     ??SpiritRadioSetPATabledBm_3: (+1)
   \   00000064   0x2700             MOVS     R7,#+0
   \                     ??SpiritRadioSetPATabledBm_4: (+1)
   \   00000066   0xF89D 0x0018      LDRB     R0,[SP, #+24]
   \   0000006A   0x42B8             CMP      R0,R7
   \   0000006C   0xF2C0 0x80AE      BLT.W    ??SpiritRadioSetPATabledBm_5
   1542            {
   1543              s_assert_param(IS_PAPOWER_DBM(*pfPAtabledBm));
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable55_1  ;; 0xc1f80000
   \   00000076   0x.... 0x....      BL       __aeabi_cfrcmple
   \   0000007A   0xD805             BHI.N    ??SpiritRadioSetPATabledBm_6
   \   0000007C   0x6820             LDR      R0,[R4, #+0]
   \   0000007E   0x.... 0x....      LDR.W    R1,??DataTable55_2  ;; 0x41400001
   \   00000082   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000086   0xD305             BCC.N    ??SpiritRadioSetPATabledBm_7
   \                     ??SpiritRadioSetPATabledBm_6: (+1)
   \   00000088   0xF240 0x6107      MOVW     R1,#+1543
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable54
   \   00000090   0x.... 0x....      BL       s_assert_failed
   1544              z=(*pfPAtabledBm+9.4089)/12.08;
   \                     ??SpiritRadioSetPATabledBm_7: (+1)
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0x.... 0x....      BL       __aeabi_f2d
   \   0000009A   0x.... 0x....      LDR.W    R2,??DataTable56  ;; 0x573eab36
   \   0000009E   0x.... 0x....      LDR.W    R3,??DataTable56_1  ;; 0x4022d15b
   \   000000A2   0x.... 0x....      BL       __aeabi_dadd
   \   000000A6   0x.... 0x....      LDR.W    R2,??DataTable56_2  ;; 0xc28f5c29
   \   000000AA   0x.... 0x....      LDR.W    R3,??DataTable57_1  ;; 0x402828f5
   \   000000AE   0x.... 0x....      BL       __aeabi_ddiv
   \   000000B2   0x.... 0x....      BL       __aeabi_d2f
   \   000000B6   0x0006             MOVS     R6,R0
   1545              paLevelValue=(uint8_t)round(0.082812*z*z*z*z+1.0653*z*z*z-0.82942*z*z-28.146*z+46.242);
   \   000000B8   0x0030             MOVS     R0,R6
   \   000000BA   0x.... 0x....      BL       __aeabi_f2d
   \   000000BE   0x.... 0x....      LDR.W    R2,??DataTable57_2  ;; 0xcfb762d8
   \   000000C2   0x.... 0x....      LDR.W    R3,??DataTable57_3  ;; 0x3fb5332a
   \   000000C6   0x.... 0x....      BL       __aeabi_dmul
   \   000000CA   0x4680             MOV      R8,R0
   \   000000CC   0x4689             MOV      R9,R1
   \   000000CE   0x0030             MOVS     R0,R6
   \   000000D0   0x.... 0x....      BL       __aeabi_f2d
   \   000000D4   0x4642             MOV      R2,R8
   \   000000D6   0x464B             MOV      R3,R9
   \   000000D8   0x.... 0x....      BL       __aeabi_dmul
   \   000000DC   0x4680             MOV      R8,R0
   \   000000DE   0x4689             MOV      R9,R1
   \   000000E0   0x0030             MOVS     R0,R6
   \   000000E2   0x.... 0x....      BL       __aeabi_f2d
   \   000000E6   0x4642             MOV      R2,R8
   \   000000E8   0x464B             MOV      R3,R9
   \   000000EA   0x.... 0x....      BL       __aeabi_dmul
   \   000000EE   0x4680             MOV      R8,R0
   \   000000F0   0x4689             MOV      R9,R1
   \   000000F2   0x0030             MOVS     R0,R6
   \   000000F4   0x.... 0x....      BL       __aeabi_f2d
   \   000000F8   0x4642             MOV      R2,R8
   \   000000FA   0x464B             MOV      R3,R9
   \   000000FC   0x.... 0x....      BL       __aeabi_dmul
   \   00000100   0x4682             MOV      R10,R0
   \   00000102   0x468B             MOV      R11,R1
   \   00000104   0x0030             MOVS     R0,R6
   \   00000106   0x.... 0x....      BL       __aeabi_f2d
   \   0000010A   0x.... 0x....      LDR.W    R2,??DataTable58  ;; 0x346dc5d
   \   0000010E   0x.... 0x....      LDR.W    R3,??DataTable58_1  ;; 0x3ff10b78
   \   00000112   0x.... 0x....      BL       __aeabi_dmul
   \   00000116   0x4680             MOV      R8,R0
   \   00000118   0x4689             MOV      R9,R1
   \   0000011A   0x0030             MOVS     R0,R6
   \   0000011C   0x.... 0x....      BL       __aeabi_f2d
   \   00000120   0x4642             MOV      R2,R8
   \   00000122   0x464B             MOV      R3,R9
   \   00000124   0x.... 0x....      BL       __aeabi_dmul
   \   00000128   0x4680             MOV      R8,R0
   \   0000012A   0x4689             MOV      R9,R1
   \   0000012C   0x0030             MOVS     R0,R6
   \   0000012E   0x.... 0x....      BL       __aeabi_f2d
   \   00000132   0x4642             MOV      R2,R8
   \   00000134   0x464B             MOV      R3,R9
   \   00000136   0x.... 0x....      BL       __aeabi_dmul
   \   0000013A   0x4652             MOV      R2,R10
   \   0000013C   0x465B             MOV      R3,R11
   \   0000013E   0x.... 0x....      BL       __aeabi_dadd
   \   00000142   0x4682             MOV      R10,R0
   \   00000144   0x468B             MOV      R11,R1
   \   00000146   0x0030             MOVS     R0,R6
   \   00000148   0x.... 0x....      BL       __aeabi_f2d
   \   0000014C   0x.... 0x....      LDR.W    R2,??DataTable60  ;; 0xcfd4bf0a
   \   00000150   0x.... 0x....      LDR.W    R3,??DataTable60_1  ;; 0x3fea8a9b
   \   00000154   0x.... 0x....      BL       __aeabi_dmul
   \   00000158   0x4680             MOV      R8,R0
   \   0000015A   0x4689             MOV      R9,R1
   \   0000015C   0x0030             MOVS     R0,R6
   \   0000015E   0x.... 0x....      BL       __aeabi_f2d
   \   00000162   0x4642             MOV      R2,R8
   \   00000164   0x464B             MOV      R3,R9
   \   00000166   0x.... 0x....      BL       __aeabi_dmul
   \   0000016A   0x0002             MOVS     R2,R0
   \   0000016C   0x000B             MOVS     R3,R1
   \   0000016E   0x4650             MOV      R0,R10
   \   00000170   0x4659             MOV      R1,R11
   \   00000172   0x.... 0x....      BL       __aeabi_dsub
   \   00000176   0x4680             MOV      R8,R0
   \   00000178   0x4689             MOV      R9,R1
   \   0000017A   0x0030             MOVS     R0,R6
   \   0000017C   0x.... 0x....      BL       __aeabi_f2d
   \   00000180   0x.... 0x....      LDR.W    R2,??DataTable60_2  ;; 0x4189374c
   \   00000184   0x.... 0x....      LDR.W    R3,??DataTable60_3  ;; 0x403c2560
   \   00000188   0x.... 0x....      BL       __aeabi_dmul
   \   0000018C   0x0002             MOVS     R2,R0
   \   0000018E   0x000B             MOVS     R3,R1
   \   00000190   0x4640             MOV      R0,R8
   \   00000192   0x4649             MOV      R1,R9
   \   00000194   0x.... 0x....      BL       __aeabi_dsub
   \   00000198   0x.... 0x....      LDR.W    R2,??DataTable60_4  ;; 0xdb22d0e5
   \   0000019C   0x.... 0x....      LDR.W    R3,??DataTable60_5  ;; 0x40471ef9
   \   000001A0   0x.... 0x....      BL       __aeabi_dadd
   \   000001A4   0x.... 0x....      BL       round
   \   000001A8   0x.... 0x....      BL       __aeabi_d2iz
   \   000001AC   0x0005             MOVS     R5,R0
   1546              paLevelValue>90 ? paLevelValue=90 : paLevelValue;
   \   000001AE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001B0   0x2D5B             CMP      R5,#+91
   \   000001B2   0xDB02             BLT.N    ??SpiritRadioSetPATabledBm_8
   \   000001B4   0x255A             MOVS     R5,#+90
   \   000001B6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001B8   0xE000             B.N      ??SpiritRadioSetPATabledBm_9
   \                     ??SpiritRadioSetPATabledBm_8: (+1)
   \   000001BA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   1547              palevel[cPALevelMaxIndex-i]=paLevelValue;
   \                     ??SpiritRadioSetPATabledBm_9: (+1)
   \   000001BC   0xA802             ADD      R0,SP,#+8
   \   000001BE   0xF89D 0x1018      LDRB     R1,[SP, #+24]
   \   000001C2   0x1BC9             SUBS     R1,R1,R7
   \   000001C4   0x540D             STRB     R5,[R1, R0]
   1548              pfPAtabledBm++;
   \   000001C6   0x1D24             ADDS     R4,R4,#+4
   1549            }
   \   000001C8   0x1C7F             ADDS     R7,R7,#+1
   \   000001CA   0xE74C             B.N      ??SpiritRadioSetPATabledBm_4
   1550            
   1551            /* Sets the PA_POWER[0] register */
   1552            palevel[cPALevelMaxIndex+1]=xCLoad|(cWidth-1)<<3|cPALevelMaxIndex;
   \                     ??SpiritRadioSetPATabledBm_5: (+1)
   \   000001CC   0xF89D 0x0020      LDRB     R0,[SP, #+32]
   \   000001D0   0xF89D 0x101C      LDRB     R1,[SP, #+28]
   \   000001D4   0x1E49             SUBS     R1,R1,#+1
   \   000001D6   0xEA50 0x00C1      ORRS     R0,R0,R1, LSL #+3
   \   000001DA   0xF89D 0x1018      LDRB     R1,[SP, #+24]
   \   000001DE   0x4308             ORRS     R0,R1,R0
   \   000001E0   0xA902             ADD      R1,SP,#+8
   \   000001E2   0xF89D 0x2018      LDRB     R2,[SP, #+24]
   \   000001E6   0x1851             ADDS     R1,R2,R1
   \   000001E8   0x7048             STRB     R0,[R1, #+1]
   1553            
   1554            /* Sets the base address */
   1555            address=PA_POWER8_BASE+7-cPALevelMaxIndex;
   \   000001EA   0xF89D 0x0018      LDRB     R0,[SP, #+24]
   \   000001EE   0xF1D0 0x0017      RSBS     R0,R0,#+23
   \   000001F2   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1556            
   1557            /* Configures the PA_POWER registers */
   1558            g_xStatus = SpiritSpiWriteRegisters(address, cPALevelMaxIndex+2, palevel);
   \   000001F6   0xAA02             ADD      R2,SP,#+8
   \   000001F8   0xF89D 0x0018      LDRB     R0,[SP, #+24]
   \   000001FC   0x1C81             ADDS     R1,R0,#+2
   \   000001FE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000200   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000204   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000208   0x9001             STR      R0,[SP, #+4]
   \   0000020A   0x.... 0x....      LDR.W    R0,??DataTable62
   \   0000020E   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000212   0x8001             STRH     R1,[R0, #+0]
   1559            
   1560          }
   \   00000214   0xB009             ADD      SP,SP,#+36
   \   00000216   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1561          
   1562          
   1563          /**
   1564          * @brief  Returns the Power Amplifier Table and registers, returning values in dBm.
   1565          * @param  pcPALevelMaxIndex pointer to the number of levels settled.
   1566          *         This parameter will be in the range [0:7].
   1567          * @param  pfPAtabledBm pointer to an array of 8 elements containing the PA value in dbm.
   1568          *         The first element will be the PA_LEVEL_0 and the last element
   1569          *         will be PA_LEVEL_7. Any value higher than PA_UPPER_LIMIT implies no output
   1570          *         power (output stage is in high impedance).
   1571          * @retval None.
   1572          */

   \                                 In section .text, align 2, keep-with-next
   1573          void SpiritRadioGetPATabledBm(uint8_t* pcPALevelMaxIndex, float* pfPAtabledBm)
   1574          {
   \                     SpiritRadioGetPATabledBm: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x4681             MOV      R9,R0
   \   00000008   0x000E             MOVS     R6,R1
   1575            uint8_t palevelvect[9];
   1576            float z;
   1577            
   1578            /* Reads the PA_LEVEL_x registers and the PA_POWER_0 register */
   1579            g_xStatus = SpiritSpiReadRegisters(PA_POWER8_BASE, 9, palevelvect);
   \   0000000A   0xAA01             ADD      R2,SP,#+4
   \   0000000C   0x2109             MOVS     R1,#+9
   \   0000000E   0x2010             MOVS     R0,#+16
   \   00000010   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   00000014   0x9000             STR      R0,[SP, #+0]
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable57
   \   0000001A   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   0000001E   0x8001             STRH     R1,[R0, #+0]
   1580            
   1581            /* Fill the PAtable */
   1582            for(int i=7; i>=0; i--)
   \   00000020   0xF05F 0x0807      MOVS     R8,#+7
   \                     ??SpiritRadioGetPATabledBm_0: (+1)
   \   00000024   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000028   0xF100 0x8093      BMI.W    ??SpiritRadioGetPATabledBm_1
   1583            {
   1584              z= (palevelvect[i]-45.456)/26.037;
   \   0000002C   0xA801             ADD      R0,SP,#+4
   \   0000002E   0xF818 0x0000      LDRB     R0,[R8, R0]
   \   00000032   0x.... 0x....      BL       __aeabi_ui2d
   \   00000036   0x.... 0x....      LDR.W    R2,??DataTable62_1  ;; 0x353f7cee
   \   0000003A   0x.... 0x....      LDR.W    R3,??DataTable62_2  ;; 0xc046ba5e
   \   0000003E   0x.... 0x....      BL       __aeabi_dadd
   \   00000042   0x.... 0x....      LDR.W    R2,??DataTable62_3  ;; 0xd4fdf3b6
   \   00000046   0x.... 0x....      LDR.W    R3,??DataTable62_4  ;; 0x403a0978
   \   0000004A   0x.... 0x....      BL       __aeabi_ddiv
   \   0000004E   0x.... 0x....      BL       __aeabi_d2f
   \   00000052   0x0007             MOVS     R7,R0
   1585              *pfPAtabledBm = 0.17524*z*z*z*z -0.63836*z*z*z -1.0048*z*z -10.236*z -8.7448;
   \   00000054   0x0038             MOVS     R0,R7
   \   00000056   0x.... 0x....      BL       __aeabi_f2d
   \   0000005A   0x.... 0x....      LDR.W    R2,??DataTable62_5  ;; 0xaa79bbae
   \   0000005E   0x.... 0x....      LDR.W    R3,??DataTable63  ;; 0x3fc66e43
   \   00000062   0x.... 0x....      BL       __aeabi_dmul
   \   00000066   0x0004             MOVS     R4,R0
   \   00000068   0x000D             MOVS     R5,R1
   \   0000006A   0x0038             MOVS     R0,R7
   \   0000006C   0x.... 0x....      BL       __aeabi_f2d
   \   00000070   0x0022             MOVS     R2,R4
   \   00000072   0x002B             MOVS     R3,R5
   \   00000074   0x.... 0x....      BL       __aeabi_dmul
   \   00000078   0x0004             MOVS     R4,R0
   \   0000007A   0x000D             MOVS     R5,R1
   \   0000007C   0x0038             MOVS     R0,R7
   \   0000007E   0x.... 0x....      BL       __aeabi_f2d
   \   00000082   0x0022             MOVS     R2,R4
   \   00000084   0x002B             MOVS     R3,R5
   \   00000086   0x.... 0x....      BL       __aeabi_dmul
   \   0000008A   0x0004             MOVS     R4,R0
   \   0000008C   0x000D             MOVS     R5,R1
   \   0000008E   0x0038             MOVS     R0,R7
   \   00000090   0x.... 0x....      BL       __aeabi_f2d
   \   00000094   0x0022             MOVS     R2,R4
   \   00000096   0x002B             MOVS     R3,R5
   \   00000098   0x.... 0x....      BL       __aeabi_dmul
   \   0000009C   0x4682             MOV      R10,R0
   \   0000009E   0x468B             MOV      R11,R1
   \   000000A0   0x0038             MOVS     R0,R7
   \   000000A2   0x.... 0x....      BL       __aeabi_f2d
   \   000000A6   0x.... 0x....      LDR.W    R2,??DataTable64  ;; 0xf36262cc
   \   000000AA   0x.... 0x....      LDR.W    R3,??DataTable64_1  ;; 0x3fe46d71
   \   000000AE   0x.... 0x....      BL       __aeabi_dmul
   \   000000B2   0x0004             MOVS     R4,R0
   \   000000B4   0x000D             MOVS     R5,R1
   \   000000B6   0x0038             MOVS     R0,R7
   \   000000B8   0x.... 0x....      BL       __aeabi_f2d
   \   000000BC   0x0022             MOVS     R2,R4
   \   000000BE   0x002B             MOVS     R3,R5
   \   000000C0   0x.... 0x....      BL       __aeabi_dmul
   \   000000C4   0x0004             MOVS     R4,R0
   \   000000C6   0x000D             MOVS     R5,R1
   \   000000C8   0x0038             MOVS     R0,R7
   \   000000CA   0x.... 0x....      BL       __aeabi_f2d
   \   000000CE   0x0022             MOVS     R2,R4
   \   000000D0   0x002B             MOVS     R3,R5
   \   000000D2   0x.... 0x....      BL       __aeabi_dmul
   \   000000D6   0x0002             MOVS     R2,R0
   \   000000D8   0x000B             MOVS     R3,R1
   \   000000DA   0x4650             MOV      R0,R10
   \   000000DC   0x4659             MOV      R1,R11
   \   000000DE   0x.... 0x....      BL       __aeabi_dsub
   \   000000E2   0x4682             MOV      R10,R0
   \   000000E4   0x468B             MOV      R11,R1
   \   000000E6   0x0038             MOVS     R0,R7
   \   000000E8   0x.... 0x....      BL       __aeabi_f2d
   \   000000EC   0x.... 0x....      LDR.W    R2,??DataTable65  ;; 0x2a305532
   \   000000F0   0x.... 0x....      LDR.W    R3,??DataTable65_1  ;; 0x3ff013a9
   \   000000F4   0x.... 0x....      BL       __aeabi_dmul
   \   000000F8   0x0004             MOVS     R4,R0
   \   000000FA   0x000D             MOVS     R5,R1
   \   000000FC   0x0038             MOVS     R0,R7
   \   000000FE   0x.... 0x....      BL       __aeabi_f2d
   \   00000102   0x0022             MOVS     R2,R4
   \   00000104   0x002B             MOVS     R3,R5
   \   00000106   0x.... 0x....      BL       __aeabi_dmul
   \   0000010A   0x0002             MOVS     R2,R0
   \   0000010C   0x000B             MOVS     R3,R1
   \   0000010E   0x4650             MOV      R0,R10
   \   00000110   0x4659             MOV      R1,R11
   \   00000112   0x.... 0x....      BL       __aeabi_dsub
   \   00000116   0x0004             MOVS     R4,R0
   \   00000118   0x000D             MOVS     R5,R1
   \   0000011A   0x0038             MOVS     R0,R7
   \   0000011C   0x.... 0x....      BL       __aeabi_f2d
   \   00000120   0x.... 0x....      LDR.W    R2,??DataTable65_2  ;; 0xfdf3b646
   \   00000124   0x.... 0x....      LDR.W    R3,??DataTable65_3  ;; 0x402478d4
   \   00000128   0x.... 0x....      BL       __aeabi_dmul
   \   0000012C   0x0002             MOVS     R2,R0
   \   0000012E   0x000B             MOVS     R3,R1
   \   00000130   0x0020             MOVS     R0,R4
   \   00000132   0x0029             MOVS     R1,R5
   \   00000134   0x.... 0x....      BL       __aeabi_dsub
   \   00000138   0x.... 0x....      LDR.W    R2,??DataTable65_4  ;; 0x6cf41f21
   \   0000013C   0x.... 0x....      LDR.W    R3,??DataTable68  ;; 0xc0217d56
   \   00000140   0x.... 0x....      BL       __aeabi_dadd
   \   00000144   0x.... 0x....      BL       __aeabi_d2f
   \   00000148   0x6030             STR      R0,[R6, #+0]
   1586              pfPAtabledBm++;
   \   0000014A   0x1D36             ADDS     R6,R6,#+4
   1587            }
   \   0000014C   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \   00000150   0xE768             B.N      ??SpiritRadioGetPATabledBm_0
   1588            
   1589            /* Return the settled index */
   1590            *pcPALevelMaxIndex = palevelvect[8]&0x07;
   \                     ??SpiritRadioGetPATabledBm_1: (+1)
   \   00000152   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   00000156   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   0000015A   0xF889 0x0000      STRB     R0,[R9, #+0]
   1591            
   1592          }
   \   0000015E   0xB005             ADD      SP,SP,#+20
   \   00000160   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1593          
   1594          
   1595          /**
   1596          * @brief  Sets a specific PA_LEVEL register, with a value given in dBm.
   1597          * @param  cIndex PA_LEVEL to set. This parameter shall be in the range [0:7].
   1598          * @param  fPowerdBm PA value to write expressed in dBm . Be sure that this values is in the
   1599          *         correct range [-PA_LOWER_LIMIT: PA_UPPER_LIMIT] dBm.
   1600          * @retval None.
   1601          */

   \                                 In section .text, align 2, keep-with-next
   1602          void SpiritRadioSetPALeveldBm(uint8_t cIndex, float fPowerdBm)
   1603          {
   \                     SpiritRadioSetPALeveldBm: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   1604            uint8_t address, paLevelValue;
   1605            
   1606            /* Check the parameters */
   1607            s_assert_param(IS_PA_MAX_INDEX(cIndex));
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C08             CMP      R4,#+8
   \   0000000E   0xDB05             BLT.N    ??SpiritRadioSetPALeveldBm_0
   \   00000010   0xF240 0x6147      MOVW     R1,#+1607
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable54
   \   00000018   0x.... 0x....      BL       s_assert_failed
   1608            s_assert_param(IS_PAPOWER_DBM(fPowerdBm));
   \                     ??SpiritRadioSetPALeveldBm_0: (+1)
   \   0000001C   0x0028             MOVS     R0,R5
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable55_1  ;; 0xc1f80000
   \   00000022   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000026   0xD805             BHI.N    ??SpiritRadioSetPALeveldBm_1
   \   00000028   0x0028             MOVS     R0,R5
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable55_2  ;; 0x41400001
   \   0000002E   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000032   0xD305             BCC.N    ??SpiritRadioSetPALeveldBm_2
   \                     ??SpiritRadioSetPALeveldBm_1: (+1)
   \   00000034   0xF44F 0x61C9      MOV      R1,#+1608
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable54
   \   0000003C   0x.... 0x....      BL       s_assert_failed
   1609            
   1610            /* Calculates the PA level value to write in the corresponding register using
   1611            an interpolation formula */
   1612            float z=(fPowerdBm+9.4089)/12.08;
   \                     ??SpiritRadioSetPALeveldBm_2: (+1)
   \   00000040   0x0028             MOVS     R0,R5
   \   00000042   0x.... 0x....      BL       __aeabi_f2d
   \   00000046   0x.... 0x....      LDR.W    R2,??DataTable56  ;; 0x573eab36
   \   0000004A   0x.... 0x....      LDR.W    R3,??DataTable56_1  ;; 0x4022d15b
   \   0000004E   0x.... 0x....      BL       __aeabi_dadd
   \   00000052   0x.... 0x....      LDR.W    R2,??DataTable56_2  ;; 0xc28f5c29
   \   00000056   0x.... 0x....      LDR.W    R3,??DataTable57_1  ;; 0x402828f5
   \   0000005A   0x.... 0x....      BL       __aeabi_ddiv
   \   0000005E   0x.... 0x....      BL       __aeabi_d2f
   \   00000062   0x0006             MOVS     R6,R0
   1613            paLevelValue=(uint8_t)round(0.082812*z*z*z*z+1.0653*z*z*z-0.82942*z*z-28.146*z+46.242);
   \   00000064   0x0030             MOVS     R0,R6
   \   00000066   0x.... 0x....      BL       __aeabi_f2d
   \   0000006A   0x.... 0x....      LDR.W    R2,??DataTable57_2  ;; 0xcfb762d8
   \   0000006E   0x.... 0x....      LDR.W    R3,??DataTable57_3  ;; 0x3fb5332a
   \   00000072   0x.... 0x....      BL       __aeabi_dmul
   \   00000076   0x4680             MOV      R8,R0
   \   00000078   0x4689             MOV      R9,R1
   \   0000007A   0x0030             MOVS     R0,R6
   \   0000007C   0x.... 0x....      BL       __aeabi_f2d
   \   00000080   0x4642             MOV      R2,R8
   \   00000082   0x464B             MOV      R3,R9
   \   00000084   0x.... 0x....      BL       __aeabi_dmul
   \   00000088   0x4680             MOV      R8,R0
   \   0000008A   0x4689             MOV      R9,R1
   \   0000008C   0x0030             MOVS     R0,R6
   \   0000008E   0x.... 0x....      BL       __aeabi_f2d
   \   00000092   0x4642             MOV      R2,R8
   \   00000094   0x464B             MOV      R3,R9
   \   00000096   0x.... 0x....      BL       __aeabi_dmul
   \   0000009A   0x4680             MOV      R8,R0
   \   0000009C   0x4689             MOV      R9,R1
   \   0000009E   0x0030             MOVS     R0,R6
   \   000000A0   0x.... 0x....      BL       __aeabi_f2d
   \   000000A4   0x4642             MOV      R2,R8
   \   000000A6   0x464B             MOV      R3,R9
   \   000000A8   0x.... 0x....      BL       __aeabi_dmul
   \   000000AC   0x4682             MOV      R10,R0
   \   000000AE   0x468B             MOV      R11,R1
   \   000000B0   0x0030             MOVS     R0,R6
   \   000000B2   0x.... 0x....      BL       __aeabi_f2d
   \   000000B6   0x.... 0x....      LDR.W    R2,??DataTable58  ;; 0x346dc5d
   \   000000BA   0x.... 0x....      LDR.W    R3,??DataTable58_1  ;; 0x3ff10b78
   \   000000BE   0x.... 0x....      BL       __aeabi_dmul
   \   000000C2   0x4680             MOV      R8,R0
   \   000000C4   0x4689             MOV      R9,R1
   \   000000C6   0x0030             MOVS     R0,R6
   \   000000C8   0x.... 0x....      BL       __aeabi_f2d
   \   000000CC   0x4642             MOV      R2,R8
   \   000000CE   0x464B             MOV      R3,R9
   \   000000D0   0x.... 0x....      BL       __aeabi_dmul
   \   000000D4   0x4680             MOV      R8,R0
   \   000000D6   0x4689             MOV      R9,R1
   \   000000D8   0x0030             MOVS     R0,R6
   \   000000DA   0x.... 0x....      BL       __aeabi_f2d
   \   000000DE   0x4642             MOV      R2,R8
   \   000000E0   0x464B             MOV      R3,R9
   \   000000E2   0x.... 0x....      BL       __aeabi_dmul
   \   000000E6   0x4652             MOV      R2,R10
   \   000000E8   0x465B             MOV      R3,R11
   \   000000EA   0x.... 0x....      BL       __aeabi_dadd
   \   000000EE   0x4682             MOV      R10,R0
   \   000000F0   0x468B             MOV      R11,R1
   \   000000F2   0x0030             MOVS     R0,R6
   \   000000F4   0x.... 0x....      BL       __aeabi_f2d
   \   000000F8   0x.... 0x....      LDR.W    R2,??DataTable60  ;; 0xcfd4bf0a
   \   000000FC   0x.... 0x....      LDR.W    R3,??DataTable60_1  ;; 0x3fea8a9b
   \   00000100   0x.... 0x....      BL       __aeabi_dmul
   \   00000104   0x4680             MOV      R8,R0
   \   00000106   0x4689             MOV      R9,R1
   \   00000108   0x0030             MOVS     R0,R6
   \   0000010A   0x.... 0x....      BL       __aeabi_f2d
   \   0000010E   0x4642             MOV      R2,R8
   \   00000110   0x464B             MOV      R3,R9
   \   00000112   0x.... 0x....      BL       __aeabi_dmul
   \   00000116   0x0002             MOVS     R2,R0
   \   00000118   0x000B             MOVS     R3,R1
   \   0000011A   0x4650             MOV      R0,R10
   \   0000011C   0x4659             MOV      R1,R11
   \   0000011E   0x.... 0x....      BL       __aeabi_dsub
   \   00000122   0x4680             MOV      R8,R0
   \   00000124   0x4689             MOV      R9,R1
   \   00000126   0x0030             MOVS     R0,R6
   \   00000128   0x.... 0x....      BL       __aeabi_f2d
   \   0000012C   0x.... 0x....      LDR.W    R2,??DataTable60_2  ;; 0x4189374c
   \   00000130   0x.... 0x....      LDR.W    R3,??DataTable60_3  ;; 0x403c2560
   \   00000134   0x.... 0x....      BL       __aeabi_dmul
   \   00000138   0x0002             MOVS     R2,R0
   \   0000013A   0x000B             MOVS     R3,R1
   \   0000013C   0x4640             MOV      R0,R8
   \   0000013E   0x4649             MOV      R1,R9
   \   00000140   0x.... 0x....      BL       __aeabi_dsub
   \   00000144   0x.... 0x....      LDR.W    R2,??DataTable60_4  ;; 0xdb22d0e5
   \   00000148   0x.... 0x....      LDR.W    R3,??DataTable60_5  ;; 0x40471ef9
   \   0000014C   0x.... 0x....      BL       __aeabi_dadd
   \   00000150   0x.... 0x....      BL       round
   \   00000154   0x.... 0x....      BL       __aeabi_d2iz
   \   00000158   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1614            
   1615            paLevelValue>90 ? paLevelValue=90 : paLevelValue;
   \   0000015C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000160   0x285B             CMP      R0,#+91
   \   00000162   0xDB05             BLT.N    ??SpiritRadioSetPALeveldBm_3
   \   00000164   0x205A             MOVS     R0,#+90
   \   00000166   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000016A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000016E   0xE001             B.N      ??SpiritRadioSetPALeveldBm_4
   \                     ??SpiritRadioSetPALeveldBm_3: (+1)
   \   00000170   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   1616            
   1617            /* Sets the base address */
   1618            address=PA_POWER8_BASE+7-cIndex;
   \                     ??SpiritRadioSetPALeveldBm_4: (+1)
   \   00000174   0xF1D4 0x0017      RSBS     R0,R4,#+23
   \   00000178   0x0007             MOVS     R7,R0
   1619            
   1620            /* Configures the PA_LEVEL register */
   1621            g_xStatus = SpiritSpiWriteRegisters(address, 1, &paLevelValue);
   \   0000017A   0xAA00             ADD      R2,SP,#+0
   \   0000017C   0x2101             MOVS     R1,#+1
   \   0000017E   0x0038             MOVS     R0,R7
   \   00000180   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000182   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000186   0x9001             STR      R0,[SP, #+4]
   \   00000188   0x.... 0x....      LDR.W    R0,??DataTable62
   \   0000018C   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000190   0x8001             STRH     R1,[R0, #+0]
   1622            
   1623          }
   \   00000192   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return
   1624          
   1625          
   1626          /**
   1627          * @brief  Returns a specific PA_LEVEL register, returning a value in dBm.
   1628          * @param  cIndex PA_LEVEL to read. This parameter shall be in the range [0:7]
   1629          * @retval float Settled power level expressed in dBm. A value
   1630          *         higher than PA_UPPER_LIMIT dBm implies no output power
   1631          *         (output stage is in high impedance).
   1632          */

   \                                 In section .text, align 2, keep-with-next
   1633          float SpiritRadioGetPALeveldBm(uint8_t cIndex)
   1634          {
   \                     SpiritRadioGetPALeveldBm: (+1)
   \   00000000   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \   00000004   0x0006             MOVS     R6,R0
   1635            uint8_t address, paLevelValue;
   1636            
   1637            /* Check the parameters */
   1638            s_assert_param(IS_PA_MAX_INDEX(cIndex));
   \   00000006   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000008   0x2E08             CMP      R6,#+8
   \   0000000A   0xDB05             BLT.N    ??SpiritRadioGetPALeveldBm_0
   \   0000000C   0xF240 0x6166      MOVW     R1,#+1638
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable54
   \   00000014   0x.... 0x....      BL       s_assert_failed
   1639            
   1640            /* Sets the base address */
   1641            address=PA_POWER8_BASE+7-cIndex;
   \                     ??SpiritRadioGetPALeveldBm_0: (+1)
   \   00000018   0xF1D6 0x0017      RSBS     R0,R6,#+23
   \   0000001C   0x4682             MOV      R10,R0
   1642            
   1643            /* Reads the PA_LEVEL[cIndex] register */
   1644            g_xStatus = SpiritSpiReadRegisters(address, 1, &paLevelValue);
   \   0000001E   0xAA00             ADD      R2,SP,#+0
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0x4650             MOV      R0,R10
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000002A   0x9001             STR      R0,[SP, #+4]
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable57
   \   00000030   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000034   0x8001             STRH     R1,[R0, #+0]
   1645            
   1646            //  float z= (paLevelValue-45.456)/26.037;
   1647            float z=(paLevelValue-45.5)/26.125;
   \   00000036   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000003A   0x.... 0x....      BL       __aeabi_ui2d
   \   0000003E   0x2200             MOVS     R2,#+0
   \   00000040   0x.... 0x....      LDR.W    R3,??DataTable71  ;; 0xc046c000
   \   00000044   0x.... 0x....      BL       __aeabi_dadd
   \   00000048   0x2200             MOVS     R2,#+0
   \   0000004A   0x.... 0x....      LDR.W    R3,??DataTable71_1  ;; 0x403a2000
   \   0000004E   0x.... 0x....      BL       __aeabi_ddiv
   \   00000052   0x.... 0x....      BL       __aeabi_d2f
   \   00000056   0x0007             MOVS     R7,R0
   1648            
   1649            /* Calculates the power level in dBm using the linearization formula and return the value */
   1650            return -0.0045522*z*z*z*z-0.60856*z*z*z-0.3432*z*z-10.976*z-9.0615;
   \   00000058   0x0038             MOVS     R0,R7
   \   0000005A   0x.... 0x....      BL       __aeabi_f2d
   \   0000005E   0x.... 0x....      LDR.W    R2,??DataTable71_2  ;; 0xe1ff63f9
   \   00000062   0x.... 0x....      LDR.W    R3,??DataTable71_3  ;; 0xbf72a553
   \   00000066   0x.... 0x....      BL       __aeabi_dmul
   \   0000006A   0x0004             MOVS     R4,R0
   \   0000006C   0x000D             MOVS     R5,R1
   \   0000006E   0x0038             MOVS     R0,R7
   \   00000070   0x.... 0x....      BL       __aeabi_f2d
   \   00000074   0x0022             MOVS     R2,R4
   \   00000076   0x002B             MOVS     R3,R5
   \   00000078   0x.... 0x....      BL       __aeabi_dmul
   \   0000007C   0x0004             MOVS     R4,R0
   \   0000007E   0x000D             MOVS     R5,R1
   \   00000080   0x0038             MOVS     R0,R7
   \   00000082   0x.... 0x....      BL       __aeabi_f2d
   \   00000086   0x0022             MOVS     R2,R4
   \   00000088   0x002B             MOVS     R3,R5
   \   0000008A   0x.... 0x....      BL       __aeabi_dmul
   \   0000008E   0x0004             MOVS     R4,R0
   \   00000090   0x000D             MOVS     R5,R1
   \   00000092   0x0038             MOVS     R0,R7
   \   00000094   0x.... 0x....      BL       __aeabi_f2d
   \   00000098   0x0022             MOVS     R2,R4
   \   0000009A   0x002B             MOVS     R3,R5
   \   0000009C   0x.... 0x....      BL       __aeabi_dmul
   \   000000A0   0x4680             MOV      R8,R0
   \   000000A2   0x4689             MOV      R9,R1
   \   000000A4   0x0038             MOVS     R0,R7
   \   000000A6   0x.... 0x....      BL       __aeabi_f2d
   \   000000AA   0x.... 0x....      LDR.W    R2,??DataTable71_4  ;; 0xd234eb9a
   \   000000AE   0x.... 0x....      LDR.W    R3,??DataTable71_5  ;; 0x3fe37952
   \   000000B2   0x.... 0x....      BL       __aeabi_dmul
   \   000000B6   0x0004             MOVS     R4,R0
   \   000000B8   0x000D             MOVS     R5,R1
   \   000000BA   0x0038             MOVS     R0,R7
   \   000000BC   0x.... 0x....      BL       __aeabi_f2d
   \   000000C0   0x0022             MOVS     R2,R4
   \   000000C2   0x002B             MOVS     R3,R5
   \   000000C4   0x.... 0x....      BL       __aeabi_dmul
   \   000000C8   0x0004             MOVS     R4,R0
   \   000000CA   0x000D             MOVS     R5,R1
   \   000000CC   0x0038             MOVS     R0,R7
   \   000000CE   0x.... 0x....      BL       __aeabi_f2d
   \   000000D2   0x0022             MOVS     R2,R4
   \   000000D4   0x002B             MOVS     R3,R5
   \   000000D6   0x.... 0x....      BL       __aeabi_dmul
   \   000000DA   0x0002             MOVS     R2,R0
   \   000000DC   0x000B             MOVS     R3,R1
   \   000000DE   0x4640             MOV      R0,R8
   \   000000E0   0x4649             MOV      R1,R9
   \   000000E2   0x.... 0x....      BL       __aeabi_dsub
   \   000000E6   0x4680             MOV      R8,R0
   \   000000E8   0x4689             MOV      R9,R1
   \   000000EA   0x0038             MOVS     R0,R7
   \   000000EC   0x.... 0x....      BL       __aeabi_f2d
   \   000000F0   0x.... 0x....      LDR.W    R2,??DataTable71_6  ;; 0x21ff2e49
   \   000000F4   0x.... 0x....      LDR.W    R3,??DataTable72  ;; 0x3fd5f6fd
   \   000000F8   0x.... 0x....      BL       __aeabi_dmul
   \   000000FC   0x0004             MOVS     R4,R0
   \   000000FE   0x000D             MOVS     R5,R1
   \   00000100   0x0038             MOVS     R0,R7
   \   00000102   0x.... 0x....      BL       __aeabi_f2d
   \   00000106   0x0022             MOVS     R2,R4
   \   00000108   0x002B             MOVS     R3,R5
   \   0000010A   0x.... 0x....      BL       __aeabi_dmul
   \   0000010E   0x0002             MOVS     R2,R0
   \   00000110   0x000B             MOVS     R3,R1
   \   00000112   0x4640             MOV      R0,R8
   \   00000114   0x4649             MOV      R1,R9
   \   00000116   0x.... 0x....      BL       __aeabi_dsub
   \   0000011A   0x0004             MOVS     R4,R0
   \   0000011C   0x000D             MOVS     R5,R1
   \   0000011E   0x0038             MOVS     R0,R7
   \   00000120   0x.... 0x....      BL       __aeabi_f2d
   \   00000124   0x.... 0x....      LDR.W    R2,??DataTable72_1  ;; 0x45a1cac1
   \   00000128   0x.... 0x....      LDR.W    R3,??DataTable72_2  ;; 0x4025f3b6
   \   0000012C   0x.... 0x....      BL       __aeabi_dmul
   \   00000130   0x0002             MOVS     R2,R0
   \   00000132   0x000B             MOVS     R3,R1
   \   00000134   0x0020             MOVS     R0,R4
   \   00000136   0x0029             MOVS     R1,R5
   \   00000138   0x.... 0x....      BL       __aeabi_dsub
   \   0000013C   0x.... 0x....      LDR.W    R2,??DataTable72_3  ;; 0xed916873
   \   00000140   0x.... 0x....      LDR.W    R3,??DataTable76  ;; 0xc0221f7c
   \   00000144   0x.... 0x....      BL       __aeabi_dadd
   \   00000148   0x.... 0x....      BL       __aeabi_d2f
   \   0000014C   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   1651            
   1652          }
   1653          
   1654          
   1655          /**
   1656          * @brief  Configures the Power Amplifier Table and registers.
   1657          * @param  cPALevelMaxIndex number of levels to set. This parameter shall be in the range [0:7].
   1658          * @param  cWidth step width expressed in terms of bit period units Tb/8.
   1659          *         This parameter shall be in the range [1:4].
   1660          * @param  xCLoad one of the possible value of the enum type PALoadCapacitor.
   1661          *         @arg LOAD_0_PF    No additional PA load capacitor
   1662          *         @arg LOAD_1_2_PF  1.2pF additional PA load capacitor
   1663          *         @arg LOAD_2_4_PF  2.4pF additional PA load capacitor
   1664          *         @arg LOAD_3_6_PF  3.6pF additional PA load capacitor
   1665          * @param  pcPAtable pointer to an array of PA values in the range [0: 90], where 0 implies no
   1666          *         output power, 1 will be the maximum level and 90 the minimum one
   1667          *         The first element shall be the lower level (PA_LEVEL[0]) value and the last element
   1668          *         the higher level one (PA_LEVEL[paLevelMaxIndex]).
   1669          * @retval None.
   1670          */

   \                                 In section .text, align 2, keep-with-next
   1671          void SpiritRadioSetPATable(uint8_t cPALevelMaxIndex, uint8_t cWidth, PALoadCapacitor xCLoad, uint8_t* pcPAtable)
   1672          {
   \                     SpiritRadioSetPATable: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   1673            uint8_t palevel[9], address;
   1674            
   1675            /* Check the parameters */
   1676            s_assert_param(IS_PA_MAX_INDEX(cPALevelMaxIndex));
   \   0000000E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000010   0x2C08             CMP      R4,#+8
   \   00000012   0xDB05             BLT.N    ??SpiritRadioSetPATable_0
   \   00000014   0xF240 0x618C      MOVW     R1,#+1676
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable54
   \   0000001C   0x.... 0x....      BL       s_assert_failed
   1677            s_assert_param(IS_PA_STEP_WIDTH(cWidth));
   \                     ??SpiritRadioSetPATable_0: (+1)
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD002             BEQ.N    ??SpiritRadioSetPATable_1
   \   00000026   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000028   0x2D05             CMP      R5,#+5
   \   0000002A   0xDB05             BLT.N    ??SpiritRadioSetPATable_2
   \                     ??SpiritRadioSetPATable_1: (+1)
   \   0000002C   0xF240 0x618D      MOVW     R1,#+1677
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable54
   \   00000034   0x.... 0x....      BL       s_assert_failed
   1678            s_assert_param(IS_PA_LOAD_CAP(xCLoad));
   \                     ??SpiritRadioSetPATable_2: (+1)
   \   00000038   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003A   0x2E00             CMP      R6,#+0
   \   0000003C   0xD00E             BEQ.N    ??SpiritRadioSetPATable_3
   \   0000003E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000040   0x2E40             CMP      R6,#+64
   \   00000042   0xD00B             BEQ.N    ??SpiritRadioSetPATable_3
   \   00000044   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000046   0x2E80             CMP      R6,#+128
   \   00000048   0xD008             BEQ.N    ??SpiritRadioSetPATable_3
   \   0000004A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004C   0x2EC0             CMP      R6,#+192
   \   0000004E   0xD005             BEQ.N    ??SpiritRadioSetPATable_3
   \   00000050   0xF240 0x618E      MOVW     R1,#+1678
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable54
   \   00000058   0x.... 0x....      BL       s_assert_failed
   1679            
   1680            /* Check the PA levels are in the range */
   1681            for(int i=0; i<=cPALevelMaxIndex; i++)
   \                     ??SpiritRadioSetPATable_3: (+1)
   \   0000005C   0xF05F 0x0900      MOVS     R9,#+0
   \                     ??SpiritRadioSetPATable_4: (+1)
   \   00000060   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000062   0x454C             CMP      R4,R9
   \   00000064   0xDB12             BLT.N    ??SpiritRadioSetPATable_5
   1682            {
   1683              s_assert_param(IS_PAPOWER(*pcPAtable));
   \   00000066   0x7838             LDRB     R0,[R7, #+0]
   \   00000068   0x285B             CMP      R0,#+91
   \   0000006A   0xDB05             BLT.N    ??SpiritRadioSetPATable_6
   \   0000006C   0xF240 0x6193      MOVW     R1,#+1683
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable54
   \   00000074   0x.... 0x....      BL       s_assert_failed
   1684              palevel[cPALevelMaxIndex-i]=*pcPAtable;
   \                     ??SpiritRadioSetPATable_6: (+1)
   \   00000078   0x7838             LDRB     R0,[R7, #+0]
   \   0000007A   0xA901             ADD      R1,SP,#+4
   \   0000007C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007E   0xEBB4 0x0209      SUBS     R2,R4,R9
   \   00000082   0x5450             STRB     R0,[R2, R1]
   1685              pcPAtable++;
   \   00000084   0x1C7F             ADDS     R7,R7,#+1
   1686            }
   \   00000086   0xF119 0x0901      ADDS     R9,R9,#+1
   \   0000008A   0xE7E9             B.N      ??SpiritRadioSetPATable_4
   1687            
   1688            /* Sets the PA_POWER[0] register */
   1689            palevel[cPALevelMaxIndex+1]=xCLoad|((cWidth-1)<<3)|cPALevelMaxIndex;
   \                     ??SpiritRadioSetPATable_5: (+1)
   \   0000008C   0x1E68             SUBS     R0,R5,#+1
   \   0000008E   0xEA56 0x00C0      ORRS     R0,R6,R0, LSL #+3
   \   00000092   0x4320             ORRS     R0,R4,R0
   \   00000094   0xA901             ADD      R1,SP,#+4
   \   00000096   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000098   0x1861             ADDS     R1,R4,R1
   \   0000009A   0x7048             STRB     R0,[R1, #+1]
   1690            
   1691            /* Sets the base address */
   1692            address=PA_POWER8_BASE+7-cPALevelMaxIndex;
   \   0000009C   0xF1D4 0x0017      RSBS     R0,R4,#+23
   \   000000A0   0x4680             MOV      R8,R0
   1693            
   1694            /* Configures the PA_POWER registers */
   1695            g_xStatus = SpiritSpiWriteRegisters(address, cPALevelMaxIndex+2, palevel);
   \   000000A2   0xAA01             ADD      R2,SP,#+4
   \   000000A4   0x1CA1             ADDS     R1,R4,#+2
   \   000000A6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000A8   0x4640             MOV      R0,R8
   \   000000AA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AC   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   000000B0   0x9000             STR      R0,[SP, #+0]
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable62
   \   000000B6   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   000000BA   0x8001             STRH     R1,[R0, #+0]
   1696            
   1697          }
   \   000000BC   0xB005             ADD      SP,SP,#+20
   \   000000BE   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   1698          
   1699          
   1700          /**
   1701          * @brief  Returns the Power Amplifier Table and registers.
   1702          * @param  pcPALevelMaxIndex pointer to the number of levels settled.
   1703          *         This parameter shall be in the range [0:7].
   1704          * @param  pcPAtable pointer to an array of 8 elements containing the PA value.
   1705          *         The first element will be the PA_LEVEL_0 and the last element
   1706          *         will be PA_LEVEL_7. Any value equals to 0 implies that level has
   1707          *         no output power (output stage is in high impedance).
   1708          * @retval None
   1709          */

   \                                 In section .text, align 2, keep-with-next
   1710          void SpiritRadioGetPATable(uint8_t* pcPALevelMaxIndex, uint8_t* pcPAtable)
   1711          {
   \                     SpiritRadioGetPATable: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1712            uint8_t palevelvect[9];
   1713            
   1714            /* Reads the PA_LEVEL_x registers and the PA_POWER_0 register */
   1715            g_xStatus = SpiritSpiReadRegisters(PA_POWER8_BASE, 9, palevelvect);
   \   00000008   0xAA01             ADD      R2,SP,#+4
   \   0000000A   0x2109             MOVS     R1,#+9
   \   0000000C   0x2010             MOVS     R0,#+16
   \   0000000E   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   00000012   0x9000             STR      R0,[SP, #+0]
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable62
   \   00000018   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   0000001C   0x8001             STRH     R1,[R0, #+0]
   1716            
   1717            /* Fill the PAtable */
   1718            for(int i=7; i>=0; i--)
   \   0000001E   0x2007             MOVS     R0,#+7
   \                     ??SpiritRadioGetPATable_0: (+1)
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD405             BMI.N    ??SpiritRadioGetPATable_1
   1719            {
   1720              *pcPAtable = palevelvect[i];
   \   00000024   0xA901             ADD      R1,SP,#+4
   \   00000026   0x5C41             LDRB     R1,[R0, R1]
   \   00000028   0x7029             STRB     R1,[R5, #+0]
   1721              pcPAtable++;
   \   0000002A   0x1C6D             ADDS     R5,R5,#+1
   1722            }
   \   0000002C   0x1E40             SUBS     R0,R0,#+1
   \   0000002E   0xE7F7             B.N      ??SpiritRadioGetPATable_0
   1723            
   1724            /* Return the settled index */
   1725            *pcPALevelMaxIndex = palevelvect[8]&0x07;
   \                     ??SpiritRadioGetPATable_1: (+1)
   \   00000030   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   00000034   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000038   0x7020             STRB     R0,[R4, #+0]
   1726            
   1727          }
   \   0000003A   0xB005             ADD      SP,SP,#+20
   \   0000003C   0xBD30             POP      {R4,R5,PC}       ;; return
   1728          
   1729          
   1730          /**
   1731          * @brief  Sets a specific PA_LEVEL register.
   1732          * @param  cIndex PA_LEVEL to set. This parameter shall be in the range [0:7].
   1733          * @param  cPower PA value to write in the register. Be sure that this values is in the
   1734          *         correct range [0 : 90].
   1735          * @retval None.
   1736          */

   \                                 In section .text, align 2, keep-with-next
   1737          void SpiritRadioSetPALevel(uint8_t cIndex, uint8_t cPower)
   1738          {
   \                     SpiritRadioSetPALevel: (+1)
   \   00000000   0xB532             PUSH     {R1,R4,R5,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   1739            uint8_t address;
   1740            
   1741            /* Check the parameters */
   1742            s_assert_param(IS_PA_MAX_INDEX(cIndex));
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C08             CMP      R4,#+8
   \   0000000A   0xDB05             BLT.N    ??SpiritRadioSetPALevel_0
   \   0000000C   0xF240 0x61CE      MOVW     R1,#+1742
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable54
   \   00000014   0x.... 0x....      BL       s_assert_failed
   1743            s_assert_param(IS_PAPOWER(cPower));
   \                     ??SpiritRadioSetPALevel_0: (+1)
   \   00000018   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   0000001C   0x285B             CMP      R0,#+91
   \   0000001E   0xDB05             BLT.N    ??SpiritRadioSetPALevel_1
   \   00000020   0xF240 0x61CF      MOVW     R1,#+1743
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable54
   \   00000028   0x.... 0x....      BL       s_assert_failed
   1744            
   1745            /* Sets the base address */
   1746            address=PA_POWER8_BASE+7-cIndex;
   \                     ??SpiritRadioSetPALevel_1: (+1)
   \   0000002C   0xF1D4 0x0017      RSBS     R0,R4,#+23
   \   00000030   0x0005             MOVS     R5,R0
   1747            
   1748            /* Configures the PA_LEVEL register */
   1749            g_xStatus = SpiritSpiWriteRegisters(address, 1, &cPower);
   \   00000032   0xAA02             ADD      R2,SP,#+8
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0x0028             MOVS     R0,R5
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   0000003E   0x9000             STR      R0,[SP, #+0]
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable62
   \   00000044   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   00000048   0x8001             STRH     R1,[R0, #+0]
   1750            
   1751          }
   \   0000004A   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
   1752          
   1753          
   1754          /**
   1755          * @brief  Returns a specific PA_LEVEL register.
   1756          * @param  cIndex PA_LEVEL to read. This parameter shall be in the range [0:7].
   1757          * @retval uint8_t PA_LEVEL value. A value equal to zero
   1758          *         implies no output power (output stage is in high impedance).
   1759          */

   \                                 In section .text, align 2, keep-with-next
   1760          uint8_t SpiritRadioGetPALevel(uint8_t cIndex)
   1761          {
   \                     SpiritRadioGetPALevel: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   1762            uint8_t address, tempRegValue;
   1763            
   1764            /* Check the parameters */
   1765            s_assert_param(IS_PA_MAX_INDEX(cIndex));
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C08             CMP      R4,#+8
   \   0000000A   0xDB05             BLT.N    ??SpiritRadioGetPALevel_0
   \   0000000C   0xF240 0x61E5      MOVW     R1,#+1765
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable54
   \   00000014   0x.... 0x....      BL       s_assert_failed
   1766            
   1767            /* Sets the base address */
   1768            address=PA_POWER8_BASE+7-cIndex;
   \                     ??SpiritRadioGetPALevel_0: (+1)
   \   00000018   0xF1D4 0x0017      RSBS     R0,R4,#+23
   \   0000001C   0x0005             MOVS     R5,R0
   1769            
   1770            /* Reads the PA_LEVEL[cIndex] register and return the value */
   1771            g_xStatus = SpiritSpiReadRegisters(address, 1, &tempRegValue);
   \   0000001E   0xAA00             ADD      R2,SP,#+0
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0x0028             MOVS     R0,R5
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000002A   0x9001             STR      R0,[SP, #+4]
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable62
   \   00000030   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000034   0x8001             STRH     R1,[R0, #+0]
   1772            return tempRegValue;
   \   00000036   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000003A   0xBD3E             POP      {R1-R5,PC}       ;; return
   1773            
   1774          }
   1775          
   1776          
   1777          /**
   1778          * @brief  Sets the output stage additional load capacitor bank.
   1779          * @param  xCLoad one of the possible value of the enum type PALoadCapacitor.
   1780          *         @arg LOAD_0_PF    No additional PA load capacitor
   1781          *         @arg LOAD_1_2_PF  1.2pF additional PA load capacitor
   1782          *         @arg LOAD_2_4_PF  2.4pF additional PA load capacitor
   1783          *         @arg LOAD_3_6_PF  3.6pF additional PA load capacitor
   1784          * @retval None.
   1785          */

   \                                 In section .text, align 2, keep-with-next
   1786          void SpiritRadioSetPACwc(PALoadCapacitor xCLoad)
   1787          {
   \                     SpiritRadioSetPACwc: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1788            uint8_t tempRegValue;
   1789            
   1790            /* Check the parameters */
   1791            s_assert_param(IS_PA_LOAD_CAP(xCLoad));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD00E             BEQ.N    ??SpiritRadioSetPACwc_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C40             CMP      R4,#+64
   \   0000000E   0xD00B             BEQ.N    ??SpiritRadioSetPACwc_0
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C80             CMP      R4,#+128
   \   00000014   0xD008             BEQ.N    ??SpiritRadioSetPACwc_0
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0x2CC0             CMP      R4,#+192
   \   0000001A   0xD005             BEQ.N    ??SpiritRadioSetPACwc_0
   \   0000001C   0xF240 0x61FF      MOVW     R1,#+1791
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable54
   \   00000024   0x.... 0x....      BL       s_assert_failed
   1792            
   1793            /* Reads the PA_POWER_0 register */
   1794            SpiritSpiReadRegisters(PA_POWER0_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioSetPACwc_0: (+1)
   \   00000028   0xAA00             ADD      R2,SP,#+0
   \   0000002A   0x2101             MOVS     R1,#+1
   \   0000002C   0x2018             MOVS     R0,#+24
   \   0000002E   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   1795            
   1796            /* Mask the CWC[1:0] field and write the new value */
   1797            tempRegValue &= 0x3F;
   \   00000032   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000036   0xF010 0x003F      ANDS     R0,R0,#0x3F
   \   0000003A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1798            tempRegValue |= xCLoad;
   \   0000003E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000042   0x4320             ORRS     R0,R4,R0
   \   00000044   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1799            
   1800            /* Configures the PA_POWER_0 register */
   1801            g_xStatus = SpiritSpiWriteRegisters(PA_POWER0_BASE, 1, &tempRegValue);
   \   00000048   0xAA00             ADD      R2,SP,#+0
   \   0000004A   0x2101             MOVS     R1,#+1
   \   0000004C   0x2018             MOVS     R0,#+24
   \   0000004E   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000052   0x9001             STR      R0,[SP, #+4]
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable62
   \   00000058   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   0000005C   0x8001             STRH     R1,[R0, #+0]
   1802            
   1803          }
   \   0000005E   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   1804          
   1805          
   1806          /**
   1807          * @brief  Returns the output stage additional load capacitor bank.
   1808          * @param  None.
   1809          * @retval PALoadCapacitor Output stage additional load capacitor bank.
   1810          *         This parameter can be:
   1811          *         @arg LOAD_0_PF    No additional PA load capacitor
   1812          *         @arg LOAD_1_2_PF  1.2pF additional PA load capacitor
   1813          *         @arg LOAD_2_4_PF  2.4pF additional PA load capacitor
   1814          *         @arg LOAD_3_6_PF  3.6pF additional PA load capacitor
   1815          */

   \                                 In section .text, align 2, keep-with-next
   1816          PALoadCapacitor SpiritRadioGetPACwc(void)
   1817          {
   \                     SpiritRadioGetPACwc: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   1818            uint8_t tempRegValue;
   1819            
   1820            /* Reads the PA_POWER_0 register */
   1821            g_xStatus = SpiritSpiReadRegisters(PA_POWER0_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2018             MOVS     R0,#+24
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable62
   \   00000014   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000018   0x8001             STRH     R1,[R0, #+0]
   1822            
   1823            /* Mask the CWC[1:0] field and return the value*/
   1824            return (PALoadCapacitor)(tempRegValue & 0xC0);
   \   0000001A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001E   0xF010 0x00C0      ANDS     R0,R0,#0xC0
   \   00000022   0xBD0E             POP      {R1-R3,PC}       ;; return
   1825            
   1826          }
   1827          
   1828          
   1829          /**
   1830          * @brief  Sets a specific PA_LEVEL_MAX_INDEX.
   1831          * @param  cIndex PA_LEVEL_MAX_INDEX to set. This parameter shall be in the range [0:7].
   1832          * @retval None
   1833          */

   \                                 In section .text, align 2, keep-with-next
   1834          void SpiritRadioSetPALevelMaxIndex(uint8_t cIndex)
   1835          {
   \                     SpiritRadioSetPALevelMaxIndex: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1836            uint8_t tempRegValue;
   1837            
   1838            /* Check the parameters */
   1839            s_assert_param(IS_PA_MAX_INDEX(cIndex));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C08             CMP      R4,#+8
   \   00000008   0xDB04             BLT.N    ??SpiritRadioSetPALevelMaxIndex_0
   \   0000000A   0xF240 0x712F      MOVW     R1,#+1839
   \   0000000E   0x....             LDR.N    R0,??DataTable54
   \   00000010   0x.... 0x....      BL       s_assert_failed
   1840            
   1841            /* Reads the PA_POWER_0 register */
   1842            SpiritSpiReadRegisters(PA_POWER0_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioSetPALevelMaxIndex_0: (+1)
   \   00000014   0xAA00             ADD      R2,SP,#+0
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0x2018             MOVS     R0,#+24
   \   0000001A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   1843            
   1844            /* Mask the PA_LEVEL_MAX_INDEX[1:0] field and write the new value */
   1845            tempRegValue &= 0xF8;
   \   0000001E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000022   0xF010 0x00F8      ANDS     R0,R0,#0xF8
   \   00000026   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1846            tempRegValue |= cIndex;
   \   0000002A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000002E   0x4320             ORRS     R0,R4,R0
   \   00000030   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1847            
   1848            /* Configures the PA_POWER_0 register */
   1849            g_xStatus = SpiritSpiWriteRegisters(PA_POWER0_BASE, 1, &tempRegValue);
   \   00000034   0xAA00             ADD      R2,SP,#+0
   \   00000036   0x2101             MOVS     R1,#+1
   \   00000038   0x2018             MOVS     R0,#+24
   \   0000003A   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   0000003E   0x9001             STR      R0,[SP, #+4]
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable62
   \   00000044   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000048   0x8001             STRH     R1,[R0, #+0]
   1850            
   1851          }
   \   0000004A   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   1852          
   1853          
   1854          /**
   1855          * @brief  Returns the actual PA_LEVEL_MAX_INDEX.
   1856          * @param  None.
   1857          * @retval uint8_t Actual PA_LEVEL_MAX_INDEX. This parameter will be in the range [0:7].
   1858          */

   \                                 In section .text, align 2, keep-with-next
   1859          uint8_t SpiritRadioGetPALevelMaxIndex(void)
   1860          {
   \                     SpiritRadioGetPALevelMaxIndex: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   1861            uint8_t tempRegValue;
   1862            
   1863            /* Reads the PA_POWER_0 register */
   1864            g_xStatus = SpiritSpiReadRegisters(PA_POWER0_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2018             MOVS     R0,#+24
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable62
   \   00000014   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000018   0x8001             STRH     R1,[R0, #+0]
   1865            
   1866            /* Mask the PA_LEVEL_MAX_INDEX[1:0] field and return the value */
   1867            return (tempRegValue & 0x07);
   \   0000001A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001E   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000022   0xBD0E             POP      {R1-R3,PC}       ;; return
   1868            
   1869          }
   1870          
   1871          
   1872          /**
   1873          * @brief  Sets a specific PA_RAMP_STEP_WIDTH.
   1874          * @param  cWidth step width expressed in terms of bit period units Tb/8.
   1875          *         This parameter shall be in the range [1:4].
   1876          * @retval None.
   1877          */

   \                                 In section .text, align 2, keep-with-next
   1878          void SpiritRadioSetPAStepWidth(uint8_t cWidth)
   1879          {
   \                     SpiritRadioSetPAStepWidth: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1880            uint8_t tempRegValue;
   1881            
   1882            /* Check the parameters */
   1883            s_assert_param(IS_PA_STEP_WIDTH(cWidth));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD002             BEQ.N    ??SpiritRadioSetPAStepWidth_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C05             CMP      R4,#+5
   \   0000000E   0xDB04             BLT.N    ??SpiritRadioSetPAStepWidth_1
   \                     ??SpiritRadioSetPAStepWidth_0: (+1)
   \   00000010   0xF240 0x715B      MOVW     R1,#+1883
   \   00000014   0x....             LDR.N    R0,??DataTable54
   \   00000016   0x.... 0x....      BL       s_assert_failed
   1884            
   1885            /* Reads the PA_POWER_0 register */
   1886            SpiritSpiReadRegisters(PA_POWER0_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioSetPAStepWidth_1: (+1)
   \   0000001A   0xAA00             ADD      R2,SP,#+0
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x2018             MOVS     R0,#+24
   \   00000020   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   1887            
   1888            /* Mask the PA_RAMP_STEP_WIDTH[1:0] field and write the new value */
   1889            tempRegValue &= 0xE7;
   \   00000024   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000028   0xF010 0x00E7      ANDS     R0,R0,#0xE7
   \   0000002C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1890            tempRegValue |= (cWidth-1)<<3;
   \   00000030   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000034   0x1E61             SUBS     R1,R4,#+1
   \   00000036   0xEA50 0x00C1      ORRS     R0,R0,R1, LSL #+3
   \   0000003A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1891            
   1892            /* Configures the PA_POWER_0 register */
   1893            g_xStatus = SpiritSpiWriteRegisters(PA_POWER0_BASE, 1, &tempRegValue);
   \   0000003E   0xAA00             ADD      R2,SP,#+0
   \   00000040   0x2101             MOVS     R1,#+1
   \   00000042   0x2018             MOVS     R0,#+24
   \   00000044   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000048   0x9001             STR      R0,[SP, #+4]
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable62
   \   0000004E   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000052   0x8001             STRH     R1,[R0, #+0]
   1894            
   1895          }
   \   00000054   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   1896          
   1897          
   1898          /**
   1899          * @brief  Returns the actual PA_RAMP_STEP_WIDTH.
   1900          * @param  None.
   1901          * @retval uint8_t Step width value expressed in terms of bit period units Tb/8.
   1902          *         This parameter will be in the range [1:4].
   1903          */

   \                                 In section .text, align 2, keep-with-next
   1904          uint8_t SpiritRadioGetPAStepWidth(void)
   1905          {
   \                     SpiritRadioGetPAStepWidth: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   1906            uint8_t tempRegValue;
   1907            
   1908            /* Reads the PA_POWER_0 register */
   1909            g_xStatus = SpiritSpiReadRegisters(PA_POWER0_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2018             MOVS     R0,#+24
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable62
   \   00000014   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000018   0x8001             STRH     R1,[R0, #+0]
   1910            
   1911            /* Mask the PA_RAMP_STEP_WIDTH[1:0] field and return the value */
   1912            tempRegValue &= 0x18;
   \   0000001A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001E   0xF010 0x0018      ANDS     R0,R0,#0x18
   \   00000022   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1913            return  ((tempRegValue>>3)+1);
   \   00000026   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0x08C0             LSRS     R0,R0,#+3
   \   0000002E   0x1C40             ADDS     R0,R0,#+1
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0xBD0E             POP      {R1-R3,PC}       ;; return
   1914            
   1915          }
   1916          
   1917          
   1918          /**
   1919          * @brief  Enables or Disables the Power Ramping.
   1920          * @param  xNewState new state for power ramping.
   1921          *         This parameter can be: S_ENABLE or S_DISABLE.
   1922          * @retval None.
   1923          */

   \                                 In section .text, align 2, keep-with-next
   1924          void SpiritRadioPARamping(SpiritFunctionalState xNewState)
   1925          {
   \                     SpiritRadioPARamping: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1926            uint8_t tempRegValue = 0x00;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1927            
   1928            /* Check the parameters */
   1929            s_assert_param(IS_SPIRIT_FUNCTIONAL_STATE(xNewState));
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD007             BEQ.N    ??SpiritRadioPARamping_0
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C01             CMP      R4,#+1
   \   00000014   0xD004             BEQ.N    ??SpiritRadioPARamping_0
   \   00000016   0xF240 0x7189      MOVW     R1,#+1929
   \   0000001A   0x....             LDR.N    R0,??DataTable54
   \   0000001C   0x.... 0x....      BL       s_assert_failed
   1930            
   1931            /* Reads the PA_POWER_0 register and configure the PA_RAMP_ENABLE field */
   1932            SpiritSpiReadRegisters(PA_POWER0_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioPARamping_0: (+1)
   \   00000020   0xAA00             ADD      R2,SP,#+0
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0x2018             MOVS     R0,#+24
   \   00000026   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   1933            if(xNewState == S_ENABLE)
   \   0000002A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002C   0x2C01             CMP      R4,#+1
   \   0000002E   0xD106             BNE.N    ??SpiritRadioPARamping_1
   1934            {
   1935              tempRegValue |= PA_POWER0_PA_RAMP_MASK;
   \   00000030   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000034   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000038   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000003C   0xE005             B.N      ??SpiritRadioPARamping_2
   1936            }
   1937            else
   1938            {
   1939              tempRegValue &= (~PA_POWER0_PA_RAMP_MASK);
   \                     ??SpiritRadioPARamping_1: (+1)
   \   0000003E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000042   0xF010 0x00DF      ANDS     R0,R0,#0xDF
   \   00000046   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1940            }
   1941            
   1942            /* Sets the PA_POWER_0 register */
   1943            g_xStatus = SpiritSpiWriteRegisters(PA_POWER0_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioPARamping_2: (+1)
   \   0000004A   0xAA00             ADD      R2,SP,#+0
   \   0000004C   0x2101             MOVS     R1,#+1
   \   0000004E   0x2018             MOVS     R0,#+24
   \   00000050   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000054   0x9001             STR      R0,[SP, #+4]
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable62
   \   0000005A   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   0000005E   0x8001             STRH     R1,[R0, #+0]
   1944            
   1945          }
   \   00000060   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   1946          
   1947          
   1948          /**
   1949          * @brief  Returns the Power Ramping enable bit.
   1950          * @param  xNewState new state for power ramping.
   1951          *         This parameter can be: S_ENABLE or S_DISABLE.
   1952          * @retval None.
   1953          */

   \                                 In section .text, align 2, keep-with-next
   1954          SpiritFunctionalState SpiritRadioGetPARamping(void)
   1955          {
   \                     SpiritRadioGetPARamping: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   1956            uint8_t tempRegValue;
   1957            
   1958            /* Reads the PA_POWER_0 register and configure the PA_RAMP_ENABLE field */
   1959            g_xStatus = SpiritSpiReadRegisters(PA_POWER0_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2018             MOVS     R0,#+24
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable62
   \   00000014   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000018   0x8001             STRH     R1,[R0, #+0]
   1960            
   1961            /* Mask and return data */
   1962            return (SpiritFunctionalState)((tempRegValue>>5) & 0x01);
   \   0000001A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001E   0xF3C0 0x1040      UBFX     R0,R0,#+5,#+1
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0xBD0E             POP      {R1-R3,PC}       ;; return
   1963            
   1964          }
   1965          
   1966          
   1967          /**
   1968          * @brief  Enables or Disables the AFC.
   1969          * @param  xNewState new state for AFC.
   1970          *         This parameter can be: S_ENABLE or S_DISABLE.
   1971          * @retval None.
   1972          */

   \                                 In section .text, align 2, keep-with-next
   1973          void SpiritRadioAFC(SpiritFunctionalState xNewState)
   1974          {
   \                     SpiritRadioAFC: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1975            uint8_t tempRegValue = 0x00;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1976            
   1977            /* Check the parameters */
   1978            s_assert_param(IS_SPIRIT_FUNCTIONAL_STATE(xNewState));
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD007             BEQ.N    ??SpiritRadioAFC_0
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C01             CMP      R4,#+1
   \   00000014   0xD004             BEQ.N    ??SpiritRadioAFC_0
   \   00000016   0xF240 0x71BA      MOVW     R1,#+1978
   \   0000001A   0x....             LDR.N    R0,??DataTable54
   \   0000001C   0x.... 0x....      BL       s_assert_failed
   1979            
   1980            /* Reads the AFC_2 register and configure the AFC Enabled field */
   1981            SpiritSpiReadRegisters(AFC2_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioAFC_0: (+1)
   \   00000020   0xAA00             ADD      R2,SP,#+0
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0x201E             MOVS     R0,#+30
   \   00000026   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   1982            if(xNewState == S_ENABLE)
   \   0000002A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002C   0x2C01             CMP      R4,#+1
   \   0000002E   0xD106             BNE.N    ??SpiritRadioAFC_1
   1983            {
   1984              tempRegValue |= AFC2_AFC_MASK;
   \   00000030   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000034   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000038   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000003C   0xE005             B.N      ??SpiritRadioAFC_2
   1985            }
   1986            else
   1987            {
   1988              tempRegValue &= (~AFC2_AFC_MASK);
   \                     ??SpiritRadioAFC_1: (+1)
   \   0000003E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000042   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   00000046   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1989            }
   1990            
   1991            /* Sets the AFC_2 register */
   1992            g_xStatus = SpiritSpiWriteRegisters(AFC2_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioAFC_2: (+1)
   \   0000004A   0xAA00             ADD      R2,SP,#+0
   \   0000004C   0x2101             MOVS     R1,#+1
   \   0000004E   0x201E             MOVS     R0,#+30
   \   00000050   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000054   0x9001             STR      R0,[SP, #+4]
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable62
   \   0000005A   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   0000005E   0x8001             STRH     R1,[R0, #+0]
   1993            
   1994          }
   \   00000060   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   1995          
   1996          
   1997          /**
   1998          * @brief  Enables or Disables the AFC freeze on sync word detection.
   1999          * @param  xNewState new state for AFC freeze on sync word detection.
   2000          *         This parameter can be: S_ENABLE or S_DISABLE.
   2001          * @retval None.
   2002          */

   \                                 In section .text, align 2, keep-with-next
   2003          void SpiritRadioAFCFreezeOnSync(SpiritFunctionalState xNewState)
   2004          {
   \                     SpiritRadioAFCFreezeOnSync: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2005            uint8_t tempRegValue = 0x00;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2006            
   2007            /* Check the parameters */
   2008            s_assert_param(IS_SPIRIT_FUNCTIONAL_STATE(xNewState));
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD007             BEQ.N    ??SpiritRadioAFCFreezeOnSync_0
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C01             CMP      R4,#+1
   \   00000014   0xD004             BEQ.N    ??SpiritRadioAFCFreezeOnSync_0
   \   00000016   0xF44F 0x61FB      MOV      R1,#+2008
   \   0000001A   0x....             LDR.N    R0,??DataTable54
   \   0000001C   0x.... 0x....      BL       s_assert_failed
   2009            
   2010            /* Reads the AFC_2 register and configure the AFC Freeze on Sync field */
   2011            SpiritSpiReadRegisters(AFC2_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioAFCFreezeOnSync_0: (+1)
   \   00000020   0xAA00             ADD      R2,SP,#+0
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0x201E             MOVS     R0,#+30
   \   00000026   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   2012            if(xNewState == S_ENABLE)
   \   0000002A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002C   0x2C01             CMP      R4,#+1
   \   0000002E   0xD106             BNE.N    ??SpiritRadioAFCFreezeOnSync_1
   2013            {
   2014              tempRegValue |= AFC2_AFC_FREEZE_ON_SYNC_MASK;
   \   00000030   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000034   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000038   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000003C   0xE005             B.N      ??SpiritRadioAFCFreezeOnSync_2
   2015            }
   2016            else
   2017            {
   2018              tempRegValue &= (~AFC2_AFC_FREEZE_ON_SYNC_MASK);
   \                     ??SpiritRadioAFCFreezeOnSync_1: (+1)
   \   0000003E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000042   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   00000046   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2019            }
   2020            
   2021            /* Sets the AFC_2 register */
   2022            g_xStatus = SpiritSpiWriteRegisters(AFC2_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioAFCFreezeOnSync_2: (+1)
   \   0000004A   0xAA00             ADD      R2,SP,#+0
   \   0000004C   0x2101             MOVS     R1,#+1
   \   0000004E   0x201E             MOVS     R0,#+30
   \   00000050   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000054   0x9001             STR      R0,[SP, #+4]
   \   00000056   0x....             LDR.N    R0,??DataTable62
   \   00000058   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   0000005C   0x8001             STRH     R1,[R0, #+0]
   2023            
   2024          }
   \   0000005E   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   2025          
   2026          
   2027          /**
   2028          * @brief  Sets the AFC working mode.
   2029          * @param  xMode the AFC mode. This parameter can be one of the values defined in @ref AFCMode :
   2030          *         @arg AFC_SLICER_CORRECTION     AFC loop closed on slicer
   2031          *         @arg AFC_2ND_IF_CORRECTION     AFC loop closed on 2nd conversion stage
   2032          * @retval None.
   2033          */

   \                                 In section .text, align 2, keep-with-next
   2034          void SpiritRadioSetAFCMode(AFCMode xMode)
   2035          {
   \                     SpiritRadioSetAFCMode: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2036            uint8_t tempRegValue = 0x00;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2037            
   2038            /* Check the parameters */
   2039            s_assert_param(IS_AFC_MODE(xMode));
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD007             BEQ.N    ??SpiritRadioSetAFCMode_0
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C20             CMP      R4,#+32
   \   00000014   0xD004             BEQ.N    ??SpiritRadioSetAFCMode_0
   \   00000016   0xF240 0x71F7      MOVW     R1,#+2039
   \   0000001A   0x....             LDR.N    R0,??DataTable54
   \   0000001C   0x.... 0x....      BL       s_assert_failed
   2040            
   2041            /* Reads the AFC_2 register and configure the AFC Mode field */
   2042            SpiritSpiReadRegisters(AFC2_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioSetAFCMode_0: (+1)
   \   00000020   0xAA00             ADD      R2,SP,#+0
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0x201E             MOVS     R0,#+30
   \   00000026   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   2043            if(xMode == AFC_2ND_IF_CORRECTION)
   \   0000002A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002C   0x2C20             CMP      R4,#+32
   \   0000002E   0xD106             BNE.N    ??SpiritRadioSetAFCMode_1
   2044            {
   2045              tempRegValue |= AFC_2ND_IF_CORRECTION;
   \   00000030   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000034   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000038   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000003C   0xE005             B.N      ??SpiritRadioSetAFCMode_2
   2046            }
   2047            else
   2048            {
   2049              tempRegValue &= (~AFC_2ND_IF_CORRECTION);
   \                     ??SpiritRadioSetAFCMode_1: (+1)
   \   0000003E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000042   0xF010 0x00DF      ANDS     R0,R0,#0xDF
   \   00000046   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2050            }
   2051            
   2052            /* Sets the AFC_2 register */
   2053            g_xStatus = SpiritSpiWriteRegisters(AFC2_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioSetAFCMode_2: (+1)
   \   0000004A   0xAA00             ADD      R2,SP,#+0
   \   0000004C   0x2101             MOVS     R1,#+1
   \   0000004E   0x201E             MOVS     R0,#+30
   \   00000050   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000054   0x9001             STR      R0,[SP, #+4]
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable95
   \   0000005A   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   0000005E   0x8001             STRH     R1,[R0, #+0]
   2054            
   2055          }
   \   00000060   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   2056          
   2057          
   2058          /**
   2059          * @brief  Returns the AFC working mode.
   2060          * @param  None.
   2061          * @retval AFCMode Settled AFC mode. This parameter will be one of the values defined in @ref AFCMode :
   2062          *         @arg AFC_SLICER_CORRECTION     AFC loop closed on slicer
   2063          *         @arg AFC_2ND_IF_CORRECTION     AFC loop closed on 2nd conversion stage
   2064          */

   \                                 In section .text, align 2, keep-with-next
   2065          AFCMode SpiritRadioGetAFCMode(void)
   2066          {
   \                     SpiritRadioGetAFCMode: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   2067            uint8_t tempRegValue;
   2068            
   2069            /* Reads the AFC_2 register */
   2070            g_xStatus = SpiritSpiReadRegisters(AFC2_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x201E             MOVS     R0,#+30
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable95
   \   00000014   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000018   0x8001             STRH     R1,[R0, #+0]
   2071            
   2072            /* Mask the AFC Mode field and returns the value */
   2073            return (AFCMode)(tempRegValue & 0x20);
   \   0000001A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001E   0xF010 0x0020      ANDS     R0,R0,#0x20
   \   00000022   0xBD0E             POP      {R1-R3,PC}       ;; return
   2074            
   2075          }
   2076          
   2077          
   2078          /**
   2079          * @brief  Sets the AFC peak detector leakage.
   2080          * @param  cLeakage the peak detector leakage. This parameter shall be in the range:
   2081          *         [0:31].
   2082          * @retval None.
   2083          */

   \                                 In section .text, align 2, keep-with-next
   2084          void SpiritRadioSetAFCPDLeakage(uint8_t cLeakage)
   2085          {
   \                     SpiritRadioSetAFCPDLeakage: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2086            uint8_t tempRegValue = 0x00;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2087            
   2088            /* Check the parameters */
   2089            s_assert_param(IS_AFC_PD_LEAKAGE(cLeakage));
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C20             CMP      R4,#+32
   \   0000000E   0xDB04             BLT.N    ??SpiritRadioSetAFCPDLeakage_0
   \   00000010   0xF640 0x0129      MOVW     R1,#+2089
   \   00000014   0x....             LDR.N    R0,??DataTable54
   \   00000016   0x.... 0x....      BL       s_assert_failed
   2090            
   2091            /* Reads the AFC_2 register and configure the AFC PD leakage field */
   2092            SpiritSpiReadRegisters(AFC2_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioSetAFCPDLeakage_0: (+1)
   \   0000001A   0xAA00             ADD      R2,SP,#+0
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x201E             MOVS     R0,#+30
   \   00000020   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   2093            tempRegValue &= 0xE0;
   \   00000024   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000028   0xF010 0x00E0      ANDS     R0,R0,#0xE0
   \   0000002C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2094            tempRegValue |= cLeakage;
   \   00000030   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000034   0x4320             ORRS     R0,R4,R0
   \   00000036   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2095            
   2096            /* Sets the AFC_2 register */
   2097            g_xStatus = SpiritSpiWriteRegisters(AFC2_BASE, 1, &tempRegValue);
   \   0000003A   0xAA00             ADD      R2,SP,#+0
   \   0000003C   0x2101             MOVS     R1,#+1
   \   0000003E   0x201E             MOVS     R0,#+30
   \   00000040   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000044   0x9001             STR      R0,[SP, #+4]
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable95
   \   0000004A   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   0000004E   0x8001             STRH     R1,[R0, #+0]
   2098            
   2099          }
   \   00000050   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   2100          
   2101          
   2102          /**
   2103          * @brief  Returns the AFC peak detector leakage.
   2104          * @param  None.
   2105          * @retval uint8_t Peak detector leakage value. This parameter will be in the range:
   2106          *         [0:31].
   2107          */

   \                                 In section .text, align 2, keep-with-next
   2108          uint8_t SpiritRadioGetAFCPDLeakage(void)
   2109          {
   \                     SpiritRadioGetAFCPDLeakage: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   2110            uint8_t tempRegValue;
   2111            
   2112            /* Reads the AFC_2 register */
   2113            g_xStatus = SpiritSpiReadRegisters(AFC2_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x201E             MOVS     R0,#+30
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable95
   \   00000014   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000018   0x8001             STRH     R1,[R0, #+0]
   2114            
   2115            /* Mask the AFC PD leakage field and return the value */
   2116            return (tempRegValue & 0x1F);
   \   0000001A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001E   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   00000022   0xBD0E             POP      {R1-R3,PC}       ;; return
   2117            
   2118          }
   2119          
   2120          
   2121          /**
   2122          * @brief  Sets the length of the AFC fast period expressed as number of samples.
   2123          * @param  cLength length of the fast period in number of samples.
   2124          * @retval None.
   2125          */

   \                                 In section .text, align 2, keep-with-next
   2126          void SpiritRadioSetAFCFastPeriod(uint8_t cLength)
   2127          {
   \                     SpiritRadioSetAFCFastPeriod: (+1)
   \   00000000   0xB501             PUSH     {R0,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   2128            /* Sets the AFC_1 register */
   2129            g_xStatus = SpiritSpiWriteRegisters(AFC1_BASE, 1, &cLength);
   \   00000004   0xAA02             ADD      R2,SP,#+8
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x201F             MOVS     R0,#+31
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   0000000E   0x9000             STR      R0,[SP, #+0]
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable95
   \   00000014   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   00000018   0x8001             STRH     R1,[R0, #+0]
   2130            
   2131          }
   \   0000001A   0xBD07             POP      {R0-R2,PC}       ;; return
   2132          
   2133          
   2134          /**
   2135          * @brief  Returns the AFC fast period expressed as number of samples.
   2136          * @param  None.
   2137          * @retval uint8_t Length of the fast period in number of samples.
   2138          */

   \                                 In section .text, align 2, keep-with-next
   2139          uint8_t SpiritRadioGetAFCFastPeriod(void)
   2140          {
   \                     SpiritRadioGetAFCFastPeriod: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   2141            uint8_t tempRegValue;
   2142            
   2143            /* Reads the AFC 1 register and return the value */
   2144            g_xStatus = SpiritSpiReadRegisters(AFC1_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x201F             MOVS     R0,#+31
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable95
   \   00000014   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000018   0x8001             STRH     R1,[R0, #+0]
   2145            
   2146            return tempRegValue;
   \   0000001A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001E   0xBD0E             POP      {R1-R3,PC}       ;; return
   2147            
   2148          }
   2149          
   2150          
   2151          /**
   2152          * @brief  Sets the AFC loop gain in fast mode.
   2153          * @param  cGain AFC loop gain in fast mode. This parameter shall be in the range:
   2154          *         [0:15].
   2155          * @retval None.
   2156          */

   \                                 In section .text, align 2, keep-with-next
   2157          void SpiritRadioSetAFCFastGain(uint8_t cGain)
   2158          {
   \                     SpiritRadioSetAFCFastGain: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2159            uint8_t tempRegValue = 0x00;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2160            
   2161            /* Check the parameters */
   2162            s_assert_param(IS_AFC_FAST_GAIN(cGain));
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C10             CMP      R4,#+16
   \   0000000E   0xDB05             BLT.N    ??SpiritRadioSetAFCFastGain_0
   \   00000010   0xF640 0x0172      MOVW     R1,#+2162
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable95_1
   \   00000018   0x.... 0x....      BL       s_assert_failed
   2163            
   2164            /* Reads the AFC_0 register and configure the AFC Fast Gain field */
   2165            SpiritSpiReadRegisters(AFC0_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioSetAFCFastGain_0: (+1)
   \   0000001C   0xAA00             ADD      R2,SP,#+0
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0x2020             MOVS     R0,#+32
   \   00000022   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   2166            tempRegValue &= 0x0F;
   \   00000026   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000002A   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   0000002E   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2167            tempRegValue |= cGain<<4;
   \   00000032   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000036   0xEA50 0x1004      ORRS     R0,R0,R4, LSL #+4
   \   0000003A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2168            
   2169            /* Sets the AFC_0 register */
   2170            g_xStatus = SpiritSpiWriteRegisters(AFC0_BASE, 1, &tempRegValue);
   \   0000003E   0xAA00             ADD      R2,SP,#+0
   \   00000040   0x2101             MOVS     R1,#+1
   \   00000042   0x2020             MOVS     R0,#+32
   \   00000044   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000048   0x9001             STR      R0,[SP, #+4]
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable95
   \   0000004E   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000052   0x8001             STRH     R1,[R0, #+0]
   2171            
   2172          }
   \   00000054   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   2173          
   2174          
   2175          /**
   2176          * @brief  Returns the AFC loop gain in fast mode.
   2177          * @param  None.
   2178          * @retval uint8_t AFC loop gain in fast mode. This parameter will be in the range:
   2179          *         [0:15].
   2180          */

   \                                 In section .text, align 2, keep-with-next
   2181          uint8_t SpiritRadioGetAFCFastGain(void)
   2182          {
   \                     SpiritRadioGetAFCFastGain: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   2183            uint8_t tempRegValue;
   2184            
   2185            /* Reads the AFC_0 register, mask the AFC Fast Gain field and return the value  */
   2186            g_xStatus = SpiritSpiReadRegisters(AFC0_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2020             MOVS     R0,#+32
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable95
   \   00000014   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000018   0x8001             STRH     R1,[R0, #+0]
   2187            
   2188            return ((tempRegValue & 0xF0)>>4);
   \   0000001A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x0900             LSRS     R0,R0,#+4
   \   00000022   0xBD0E             POP      {R1-R3,PC}       ;; return
   2189            
   2190          }
   2191          
   2192          
   2193          /**
   2194          * @brief  Sets the AFC loop gain in slow mode.
   2195          * @param  cGain AFC loop gain in slow mode. This parameter shall be in the range:
   2196          *         [0:15].
   2197          * @retval None.
   2198          */

   \                                 In section .text, align 2, keep-with-next
   2199          void SpiritRadioSetAFCSlowGain(uint8_t cGain)
   2200          {
   \                     SpiritRadioSetAFCSlowGain: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2201            uint8_t tempRegValue = 0x00;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2202            
   2203            /* Check the parameters */
   2204            s_assert_param(IS_AFC_SLOW_GAIN(cGain));
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C10             CMP      R4,#+16
   \   0000000E   0xDB05             BLT.N    ??SpiritRadioSetAFCSlowGain_0
   \   00000010   0xF640 0x019C      MOVW     R1,#+2204
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable95_1
   \   00000018   0x.... 0x....      BL       s_assert_failed
   2205            
   2206            /* Reads the AFC_0 register and configure the AFC Slow Gain field */
   2207            SpiritSpiReadRegisters(AFC0_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioSetAFCSlowGain_0: (+1)
   \   0000001C   0xAA00             ADD      R2,SP,#+0
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0x2020             MOVS     R0,#+32
   \   00000022   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   2208            tempRegValue &= 0xF0;
   \   00000026   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000002A   0xF010 0x00F0      ANDS     R0,R0,#0xF0
   \   0000002E   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2209            tempRegValue |= cGain;
   \   00000032   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000036   0x4320             ORRS     R0,R4,R0
   \   00000038   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2210            
   2211            /* Sets the AFC_0 register */
   2212            g_xStatus = SpiritSpiWriteRegisters(AFC0_BASE, 1, &tempRegValue);
   \   0000003C   0xAA00             ADD      R2,SP,#+0
   \   0000003E   0x2101             MOVS     R1,#+1
   \   00000040   0x2020             MOVS     R0,#+32
   \   00000042   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000046   0x9001             STR      R0,[SP, #+4]
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable95
   \   0000004C   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000050   0x8001             STRH     R1,[R0, #+0]
   2213            
   2214          }
   \   00000052   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   2215          
   2216          
   2217          /**
   2218          * @brief  Returns the AFC loop gain in slow mode.
   2219          * @param  None.
   2220          * @retval uint8_t AFC loop gain in slow mode. This parameter will be in the range:
   2221          *         [0:15].
   2222          */

   \                                 In section .text, align 2, keep-with-next
   2223          uint8_t SpiritRadioGetAFCSlowGain(void)
   2224          {
   \                     SpiritRadioGetAFCSlowGain: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   2225            uint8_t tempRegValue;
   2226            
   2227            /* Reads the AFC_0 register, mask the AFC Slow Gain field and return the value */
   2228            g_xStatus = SpiritSpiReadRegisters(AFC0_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2020             MOVS     R0,#+32
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable95
   \   00000014   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000018   0x8001             STRH     R1,[R0, #+0]
   2229            
   2230            return (tempRegValue & 0x0F);
   \   0000001A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001E   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000022   0xBD0E             POP      {R1-R3,PC}       ;; return
   2231            
   2232          }
   2233          
   2234          
   2235          /**
   2236          * @brief  Returns the AFC correction from the corresponding register.
   2237          * @param  None.
   2238          * @retval int8_t AFC correction, read from the corresponding register.
   2239          *         This parameter will be in the range [-128:127].
   2240          */

   \                                 In section .text, align 2, keep-with-next
   2241          int8_t SpiritRadioGetAFCCorrectionReg(void)
   2242          {
   \                     SpiritRadioGetAFCCorrectionReg: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   2243            uint8_t tempRegValue;
   2244            
   2245            /* Reads the AFC_CORR register, cast the read value as signed char and return it */
   2246            g_xStatus = SpiritSpiReadRegisters(AFC_CORR_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x20C4             MOVS     R0,#+196
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable95
   \   00000014   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000018   0x8001             STRH     R1,[R0, #+0]
   2247            
   2248            return (int8_t)tempRegValue;
   \   0000001A   0xF99D 0x0000      LDRSB    R0,[SP, #+0]
   \   0000001E   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000020   0xBD0E             POP      {R1-R3,PC}       ;; return
   2249            
   2250          }
   2251          
   2252          
   2253          /**
   2254          * @brief  Returns the AFC correction expressed in Hz.
   2255          * @param  None.
   2256          * @retval int32_t AFC correction expressed in Hz
   2257          *         according to the following formula:<ul>
   2258          *         <li> Fafc[Hz]= (Fxtal/(12*2^10))*2*AFC_CORR  where </li>
   2259          *         <li> AFC_CORR is the value read in the AFC_CORR register </li> </ul>
   2260          */

   \                                 In section .text, align 2, keep-with-next
   2261          int32_t SpiritRadioGetAFCCorrectionHz(void)
   2262          {
   \                     SpiritRadioGetAFCCorrectionHz: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   2263            int8_t correction;
   2264            
   2265            /* Reads the AFC correction register */
   2266            correction = SpiritRadioGetAFCCorrectionReg();
   \   00000002   0x.... 0x....      BL       SpiritRadioGetAFCCorrectionReg
   \   00000006   0x0006             MOVS     R6,R0
   2267            
   2268            /* Calculates and return the Frequency Correction */
   2269            return (int32_t)(s_lXtalFrequency/(12*pow(2,10))*2*correction);
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable95_2
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x.... 0x....      BL       __aeabi_ui2d
   \   00000012   0x0004             MOVS     R4,R0
   \   00000014   0x000D             MOVS     R5,R1
   \   00000016   0x2200             MOVS     R2,#+0
   \   00000018   0x.... 0x....      LDR.W    R3,??DataTable95_3  ;; 0x40240000
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   00000022   0x.... 0x....      BL       pow
   \   00000026   0x2200             MOVS     R2,#+0
   \   00000028   0x.... 0x....      LDR.W    R3,??DataTable95_4  ;; 0x40280000
   \   0000002C   0x.... 0x....      BL       __aeabi_dmul
   \   00000030   0x0002             MOVS     R2,R0
   \   00000032   0x000B             MOVS     R3,R1
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x0029             MOVS     R1,R5
   \   00000038   0x.... 0x....      BL       __aeabi_ddiv
   \   0000003C   0x2200             MOVS     R2,#+0
   \   0000003E   0xF05F 0x4380      MOVS     R3,#+1073741824
   \   00000042   0x.... 0x....      BL       __aeabi_dmul
   \   00000046   0x0004             MOVS     R4,R0
   \   00000048   0x000D             MOVS     R5,R1
   \   0000004A   0xB276             SXTB     R6,R6            ;; SignExt  R6,R6,#+24,#+24
   \   0000004C   0x0030             MOVS     R0,R6
   \   0000004E   0x.... 0x....      BL       __aeabi_i2d
   \   00000052   0x0022             MOVS     R2,R4
   \   00000054   0x002B             MOVS     R3,R5
   \   00000056   0x.... 0x....      BL       __aeabi_dmul
   \   0000005A   0x.... 0x....      BL       __aeabi_d2iz
   \   0000005E   0xBD70             POP      {R4-R6,PC}       ;; return
   2270            
   2271          }
   2272          
   2273          
   2274          /**
   2275          * @brief  Corrects the frequency offset through the AFC mechanism.
   2276          * @param  None.
   2277          * @retval None.
   2278          */

   \                                 In section .text, align 2, keep-with-next
   2279          void SpiritRadioAutoSetFOffset(void)
   2280          {
   \                     SpiritRadioAutoSetFOffset: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   2281            int32_t fOffset;
   2282            
   2283            /* Reads the AFC correction and the actual frequency offset */
   2284            fOffset = SpiritRadioGetFrequencyOffset() + SpiritRadioGetAFCCorrectionHz();
   \   00000002   0x.... 0x....      BL       SpiritRadioGetFrequencyOffset
   \   00000006   0x0005             MOVS     R5,R0
   \   00000008   0x.... 0x....      BL       SpiritRadioGetAFCCorrectionHz
   \   0000000C   0x1940             ADDS     R0,R0,R5
   \   0000000E   0x0004             MOVS     R4,R0
   2285            
   2286            /* Re-Sets the new frequency offset */
   2287            SpiritRadioSetFrequencyOffset(fOffset);
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       SpiritRadioSetFrequencyOffset
   2288            
   2289          }
   \   00000016   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2290          
   2291          
   2292          /**
   2293          * @brief  Enables or Disables the AGC.
   2294          * @param  xNewState new state for AGC.
   2295          *         This parameter can be: S_ENABLE or S_DISABLE
   2296          * @retval None.
   2297          */

   \                                 In section .text, align 2, keep-with-next
   2298          void SpiritRadioAGC(SpiritFunctionalState xNewState)
   2299          {
   \                     SpiritRadioAGC: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2300            uint8_t tempRegValue = 0x00;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2301            
   2302            /* Check the parameters */
   2303            s_assert_param(IS_SPIRIT_FUNCTIONAL_STATE(xNewState));
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD008             BEQ.N    ??SpiritRadioAGC_0
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C01             CMP      R4,#+1
   \   00000014   0xD005             BEQ.N    ??SpiritRadioAGC_0
   \   00000016   0xF640 0x01FF      MOVW     R1,#+2303
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable95_1
   \   0000001E   0x.... 0x....      BL       s_assert_failed
   2304            
   2305            /* Reads the AGCCTRL_0 register and configure the AGC Enabled field */
   2306            SpiritSpiReadRegisters(AGCCTRL0_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioAGC_0: (+1)
   \   00000022   0xAA00             ADD      R2,SP,#+0
   \   00000024   0x2101             MOVS     R1,#+1
   \   00000026   0x2026             MOVS     R0,#+38
   \   00000028   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   2307            if(xNewState == S_ENABLE)
   \   0000002C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002E   0x2C01             CMP      R4,#+1
   \   00000030   0xD106             BNE.N    ??SpiritRadioAGC_1
   2308            {
   2309              tempRegValue |= AGCCTRL0_AGC_MASK;
   \   00000032   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000036   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000003A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000003E   0xE005             B.N      ??SpiritRadioAGC_2
   2310            }
   2311            else
   2312            {
   2313              tempRegValue &= (~AGCCTRL0_AGC_MASK);
   \                     ??SpiritRadioAGC_1: (+1)
   \   00000040   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000044   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   00000048   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2314            }
   2315            
   2316            /* Sets the AGCCTRL_0 register */
   2317            g_xStatus = SpiritSpiWriteRegisters(AGCCTRL0_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioAGC_2: (+1)
   \   0000004C   0xAA00             ADD      R2,SP,#+0
   \   0000004E   0x2101             MOVS     R1,#+1
   \   00000050   0x2026             MOVS     R0,#+38
   \   00000052   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000056   0x9001             STR      R0,[SP, #+4]
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable95
   \   0000005C   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000060   0x8001             STRH     R1,[R0, #+0]
   2318            
   2319          }
   \   00000062   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   2320          
   2321          
   2322          /**
   2323          * @brief  Sets the AGC working mode.
   2324          * @param  xMode the AGC mode. This parameter can be one of the values defined in @ref AGCMode :
   2325          *         @arg AGC_LINEAR_MODE     AGC works in linear mode
   2326          *         @arg AGC_BINARY_MODE     AGC works in binary mode
   2327          * @retval None.
   2328          */

   \                                 In section .text, align 2, keep-with-next
   2329          void SpiritRadioSetAGCMode(AGCMode xMode)
   2330          {
   \                     SpiritRadioSetAGCMode: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2331            uint8_t tempRegValue = 0x00;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2332            
   2333            /* Check the parameters */
   2334            s_assert_param(IS_AGC_MODE(xMode));
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD008             BEQ.N    ??SpiritRadioSetAGCMode_0
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C40             CMP      R4,#+64
   \   00000014   0xD005             BEQ.N    ??SpiritRadioSetAGCMode_0
   \   00000016   0xF640 0x111E      MOVW     R1,#+2334
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable95_1
   \   0000001E   0x.... 0x....      BL       s_assert_failed
   2335            
   2336            /* Reads the AGCCTRL_0 register and configure the AGC Mode field */
   2337            SpiritSpiReadRegisters(AGCCTRL0_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioSetAGCMode_0: (+1)
   \   00000022   0xAA00             ADD      R2,SP,#+0
   \   00000024   0x2101             MOVS     R1,#+1
   \   00000026   0x2026             MOVS     R0,#+38
   \   00000028   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   2338            if(xMode == AGC_BINARY_MODE)
   \   0000002C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002E   0x2C40             CMP      R4,#+64
   \   00000030   0xD106             BNE.N    ??SpiritRadioSetAGCMode_1
   2339            {
   2340              tempRegValue |= AGC_BINARY_MODE;
   \   00000032   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000036   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000003A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000003E   0xE005             B.N      ??SpiritRadioSetAGCMode_2
   2341            }
   2342            else
   2343            {
   2344              tempRegValue &= (~AGC_BINARY_MODE);
   \                     ??SpiritRadioSetAGCMode_1: (+1)
   \   00000040   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000044   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   00000048   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2345            }
   2346            
   2347            /* Sets the AGCCTRL_0 register */
   2348            g_xStatus = SpiritSpiWriteRegisters(AGCCTRL0_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioSetAGCMode_2: (+1)
   \   0000004C   0xAA00             ADD      R2,SP,#+0
   \   0000004E   0x2101             MOVS     R1,#+1
   \   00000050   0x2026             MOVS     R0,#+38
   \   00000052   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000056   0x9001             STR      R0,[SP, #+4]
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable95
   \   0000005C   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000060   0x8001             STRH     R1,[R0, #+0]
   2349            
   2350          }
   \   00000062   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   2351          
   2352          
   2353          /**
   2354          * @brief  Returns the AGC working mode.
   2355          * @param  None.
   2356          * @retval AGCMode Settled AGC mode.  This parameter can be one of the values defined in @ref AGCMode :
   2357          *         @arg AGC_LINEAR_MODE     AGC works in linear mode
   2358          *         @arg AGC_BINARY_MODE     AGC works in binary mode
   2359          */

   \                                 In section .text, align 2, keep-with-next
   2360          AGCMode SpiritRadioGetAGCMode(void)
   2361          {
   \                     SpiritRadioGetAGCMode: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   2362            uint8_t tempRegValue;
   2363            
   2364            /* Reads the AGCCTRL_0 register, mask the AGC Mode field and return the value */
   2365            g_xStatus = SpiritSpiReadRegisters(AGCCTRL0_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2026             MOVS     R0,#+38
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable95
   \   00000014   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000018   0x8001             STRH     R1,[R0, #+0]
   2366            
   2367            return  (AGCMode)(tempRegValue & 0x40);
   \   0000001A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001E   0xF010 0x0040      ANDS     R0,R0,#0x40
   \   00000022   0xBD0E             POP      {R1-R3,PC}       ;; return
   2368            
   2369          }
   2370          
   2371          
   2372          /**
   2373          * @brief  Enables or Disables the AGC freeze on steady state.
   2374          * @param  xNewState new state for AGC freeze on steady state.
   2375          *         This parameter can be: S_ENABLE or S_DISABLE.
   2376          * @retval None.
   2377          */

   \                                 In section .text, align 2, keep-with-next
   2378          void SpiritRadioAGCFreezeOnSteady(SpiritFunctionalState xNewState)
   2379          {
   \                     SpiritRadioAGCFreezeOnSteady: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2380            uint8_t tempRegValue = 0x00;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2381            
   2382            /* Check the parameters */
   2383            s_assert_param(IS_SPIRIT_FUNCTIONAL_STATE(xNewState));
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD008             BEQ.N    ??SpiritRadioAGCFreezeOnSteady_0
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C01             CMP      R4,#+1
   \   00000014   0xD005             BEQ.N    ??SpiritRadioAGCFreezeOnSteady_0
   \   00000016   0xF640 0x114F      MOVW     R1,#+2383
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable95_1
   \   0000001E   0x.... 0x....      BL       s_assert_failed
   2384            
   2385            /* Reads the AGCCTRL_2 register and configure the AGC Freeze On Steady field */
   2386            SpiritSpiReadRegisters(AGCCTRL2_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioAGCFreezeOnSteady_0: (+1)
   \   00000022   0xAA00             ADD      R2,SP,#+0
   \   00000024   0x2101             MOVS     R1,#+1
   \   00000026   0x2024             MOVS     R0,#+36
   \   00000028   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   2387            if(xNewState == S_ENABLE)
   \   0000002C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002E   0x2C01             CMP      R4,#+1
   \   00000030   0xD106             BNE.N    ??SpiritRadioAGCFreezeOnSteady_1
   2388            {
   2389              tempRegValue |= AGCCTRL2_FREEZE_ON_STEADY_MASK;
   \   00000032   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000036   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000003A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000003E   0xE005             B.N      ??SpiritRadioAGCFreezeOnSteady_2
   2390            }
   2391            else
   2392            {
   2393              tempRegValue &= (~AGCCTRL2_FREEZE_ON_STEADY_MASK);
   \                     ??SpiritRadioAGCFreezeOnSteady_1: (+1)
   \   00000040   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000044   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   00000048   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2394            }
   2395            
   2396            /* Sets the AGCCTRL_2 register */
   2397            g_xStatus = SpiritSpiWriteRegisters(AGCCTRL2_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioAGCFreezeOnSteady_2: (+1)
   \   0000004C   0xAA00             ADD      R2,SP,#+0
   \   0000004E   0x2101             MOVS     R1,#+1
   \   00000050   0x2024             MOVS     R0,#+36
   \   00000052   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000056   0x9001             STR      R0,[SP, #+4]
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable95
   \   0000005C   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000060   0x8001             STRH     R1,[R0, #+0]
   2398            
   2399          }
   \   00000062   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   2400          
   2401          
   2402          /**
   2403          * @brief  Enable or Disable the AGC freeze on sync detection.
   2404          * @param  xNewState new state for AGC freeze on sync detection.
   2405          *         This parameter can be: S_ENABLE or S_DISABLE.
   2406          * @retval None.
   2407          */

   \                                 In section .text, align 2, keep-with-next
   2408          void SpiritRadioAGCFreezeOnSync(SpiritFunctionalState xNewState)
   2409          {
   \                     SpiritRadioAGCFreezeOnSync: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2410            uint8_t tempRegValue = 0x00;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2411            
   2412            /* Check the parameters */
   2413            s_assert_param(IS_SPIRIT_FUNCTIONAL_STATE(xNewState));
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD008             BEQ.N    ??SpiritRadioAGCFreezeOnSync_0
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C01             CMP      R4,#+1
   \   00000014   0xD005             BEQ.N    ??SpiritRadioAGCFreezeOnSync_0
   \   00000016   0xF640 0x116D      MOVW     R1,#+2413
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable95_1
   \   0000001E   0x.... 0x....      BL       s_assert_failed
   2414            
   2415            /* Reads the AGCCTRL_2 register and configure the AGC Freeze On Sync field */
   2416            SpiritSpiReadRegisters(AGCCTRL2_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioAGCFreezeOnSync_0: (+1)
   \   00000022   0xAA00             ADD      R2,SP,#+0
   \   00000024   0x2101             MOVS     R1,#+1
   \   00000026   0x2024             MOVS     R0,#+36
   \   00000028   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   2417            if(xNewState == S_ENABLE)
   \   0000002C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002E   0x2C01             CMP      R4,#+1
   \   00000030   0xD106             BNE.N    ??SpiritRadioAGCFreezeOnSync_1
   2418            {
   2419              tempRegValue |= AGCCTRL2_FREEZE_ON_SYNC_MASK;
   \   00000032   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000036   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000003A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000003E   0xE005             B.N      ??SpiritRadioAGCFreezeOnSync_2
   2420            }
   2421            else
   2422            {
   2423              tempRegValue &= (~AGCCTRL2_FREEZE_ON_SYNC_MASK);
   \                     ??SpiritRadioAGCFreezeOnSync_1: (+1)
   \   00000040   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000044   0xF010 0x00DF      ANDS     R0,R0,#0xDF
   \   00000048   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2424            }
   2425            
   2426            /* Sets the AGCCTRL_2 register */
   2427            g_xStatus = SpiritSpiWriteRegisters(AGCCTRL2_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioAGCFreezeOnSync_2: (+1)
   \   0000004C   0xAA00             ADD      R2,SP,#+0
   \   0000004E   0x2101             MOVS     R1,#+1
   \   00000050   0x2024             MOVS     R0,#+36
   \   00000052   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000056   0x9001             STR      R0,[SP, #+4]
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable95
   \   0000005C   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000060   0x8001             STRH     R1,[R0, #+0]
   2428            
   2429          }
   \   00000062   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   2430          
   2431          
   2432          /**
   2433          * @brief  Enable or Disable the AGC to start with max attenuation.
   2434          * @param  xNewState new state for AGC start with max attenuation mode.
   2435          *         This parameter can be: S_ENABLE or S_DISABLE.
   2436          * @retval None.
   2437          */

   \                                 In section .text, align 2, keep-with-next
   2438          void SpiritRadioAGCStartMaxAttenuation(SpiritFunctionalState xNewState)
   2439          {
   \                     SpiritRadioAGCStartMaxAttenuation: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2440            uint8_t tempRegValue = 0x00;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2441            
   2442            /* Check the parameters */
   2443            s_assert_param(IS_SPIRIT_FUNCTIONAL_STATE(xNewState));
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD008             BEQ.N    ??SpiritRadioAGCStartMaxAttenuation_0
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C01             CMP      R4,#+1
   \   00000014   0xD005             BEQ.N    ??SpiritRadioAGCStartMaxAttenuation_0
   \   00000016   0xF640 0x118B      MOVW     R1,#+2443
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable95_1
   \   0000001E   0x.... 0x....      BL       s_assert_failed
   2444            
   2445            /* Reads the AGCCTRL_2 register and configure the AGC Start Max Attenuation field */
   2446            SpiritSpiReadRegisters(AGCCTRL2_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioAGCStartMaxAttenuation_0: (+1)
   \   00000022   0xAA00             ADD      R2,SP,#+0
   \   00000024   0x2101             MOVS     R1,#+1
   \   00000026   0x2024             MOVS     R0,#+36
   \   00000028   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   2447            if(xNewState == S_ENABLE)
   \   0000002C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002E   0x2C01             CMP      R4,#+1
   \   00000030   0xD106             BNE.N    ??SpiritRadioAGCStartMaxAttenuation_1
   2448            {
   2449              tempRegValue |= AGCCTRL2_START_MAX_ATTENUATION_MASK;
   \   00000032   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000036   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000003A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000003E   0xE005             B.N      ??SpiritRadioAGCStartMaxAttenuation_2
   2450            }
   2451            else
   2452            {
   2453              tempRegValue &= (~AGCCTRL2_START_MAX_ATTENUATION_MASK);
   \                     ??SpiritRadioAGCStartMaxAttenuation_1: (+1)
   \   00000040   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000044   0xF010 0x00EF      ANDS     R0,R0,#0xEF
   \   00000048   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2454            }
   2455            
   2456            /* Sets the AGCCTRL_2 register */
   2457            g_xStatus = SpiritSpiWriteRegisters(AGCCTRL2_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioAGCStartMaxAttenuation_2: (+1)
   \   0000004C   0xAA00             ADD      R2,SP,#+0
   \   0000004E   0x2101             MOVS     R1,#+1
   \   00000050   0x2024             MOVS     R0,#+36
   \   00000052   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000056   0x9001             STR      R0,[SP, #+4]
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable95
   \   0000005C   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000060   0x8001             STRH     R1,[R0, #+0]
   2458            
   2459          }
   \   00000062   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   2460          
   2461          
   2462          /**
   2463          * @brief  Sets the AGC measure time.
   2464          * @param  nTime AGC measure time expressed in us. This parameter shall be in the range [0, 393216/F_Xo].
   2465          * @retval None.
   2466          */

   \                                 In section .text, align 2, keep-with-next
   2467          void SpiritRadioSetAGCMeasureTimeUs(uint16_t nTime)
   2468          {
   \                     SpiritRadioSetAGCMeasureTimeUs: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0006             MOVS     R6,R0
   2469            uint8_t tempRegValue, measure;
   2470            
   2471            /* Check the parameter */
   2472            s_assert_param(IS_AGC_MEASURE_TIME_US(nTime,s_lXtalFrequency));
   \   00000006   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000008   0x0030             MOVS     R0,R6
   \   0000000A   0x.... 0x....      BL       __aeabi_ui2d
   \   0000000E   0x0002             MOVS     R2,R0
   \   00000010   0x000B             MOVS     R3,R1
   \   00000012   0x0014             MOVS     R4,R2
   \   00000014   0x001D             MOVS     R5,R3
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable95_2
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x.... 0x....      BL       __aeabi_ui2d
   \   00000020   0x0002             MOVS     R2,R0
   \   00000022   0x000B             MOVS     R3,R1
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable95_5  ;; 0x41180000
   \   0000002A   0x.... 0x....      BL       __aeabi_ddiv
   \   0000002E   0x0022             MOVS     R2,R4
   \   00000030   0x002B             MOVS     R3,R5
   \   00000032   0x.... 0x....      BL       __aeabi_cdrcmple
   \   00000036   0xD905             BLS.N    ??SpiritRadioSetAGCMeasureTimeUs_0
   \   00000038   0xF640 0x11A8      MOVW     R1,#+2472
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable95_1
   \   00000040   0x.... 0x....      BL       s_assert_failed
   2473            
   2474            /* Reads the AGCCTRL_2 register */
   2475            SpiritSpiReadRegisters(AGCCTRL2_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioSetAGCMeasureTimeUs_0: (+1)
   \   00000044   0xAA00             ADD      R2,SP,#+0
   \   00000046   0x2101             MOVS     R1,#+1
   \   00000048   0x2024             MOVS     R0,#+36
   \   0000004A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   2476            
   2477            /* Calculates the measure time value to write in the register */
   2478            measure = (uint8_t)lroundf(log2((float)nTime/1e6 * s_lXtalFrequency/12));
   \   0000004E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000050   0x0030             MOVS     R0,R6
   \   00000052   0x.... 0x....      BL       __aeabi_ui2f
   \   00000056   0x.... 0x....      BL       __aeabi_f2d
   \   0000005A   0x2200             MOVS     R2,#+0
   \   0000005C   0x.... 0x....      LDR.W    R3,??DataTable95_6  ;; 0x412e8480
   \   00000060   0x.... 0x....      BL       __aeabi_ddiv
   \   00000064   0x0004             MOVS     R4,R0
   \   00000066   0x000D             MOVS     R5,R1
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable95_2
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0x.... 0x....      BL       __aeabi_ui2d
   \   00000072   0x0022             MOVS     R2,R4
   \   00000074   0x002B             MOVS     R3,R5
   \   00000076   0x.... 0x....      BL       __aeabi_dmul
   \   0000007A   0x2200             MOVS     R2,#+0
   \   0000007C   0x.... 0x....      LDR.W    R3,??DataTable95_4  ;; 0x40280000
   \   00000080   0x.... 0x....      BL       __aeabi_ddiv
   \   00000084   0x.... 0x....      BL       log2
   \   00000088   0x.... 0x....      BL       __aeabi_d2f
   \   0000008C   0x.... 0x....      BL       lroundf
   \   00000090   0x0007             MOVS     R7,R0
   2479            (measure>15) ? (measure=15):(measure);
   \   00000092   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000094   0x2F10             CMP      R7,#+16
   \   00000096   0xDB02             BLT.N    ??SpiritRadioSetAGCMeasureTimeUs_1
   \   00000098   0x270F             MOVS     R7,#+15
   \   0000009A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000009C   0xE000             B.N      ??SpiritRadioSetAGCMeasureTimeUs_2
   \                     ??SpiritRadioSetAGCMeasureTimeUs_1: (+1)
   \   0000009E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   2480            
   2481            /* Mask the MEAS_TIME field and write the new value */
   2482            tempRegValue &= 0xF0;
   \                     ??SpiritRadioSetAGCMeasureTimeUs_2: (+1)
   \   000000A0   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000A4   0xF010 0x00F0      ANDS     R0,R0,#0xF0
   \   000000A8   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2483            tempRegValue |= measure;
   \   000000AC   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000B0   0x4338             ORRS     R0,R7,R0
   \   000000B2   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2484            
   2485            /* Sets the AGCCTRL_2 register */
   2486            g_xStatus = SpiritSpiWriteRegisters(AGCCTRL2_BASE, 1, &tempRegValue);
   \   000000B6   0xAA00             ADD      R2,SP,#+0
   \   000000B8   0x2101             MOVS     R1,#+1
   \   000000BA   0x2024             MOVS     R0,#+36
   \   000000BC   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   000000C0   0x9001             STR      R0,[SP, #+4]
   \   000000C2   0x.... 0x....      LDR.W    R0,??DataTable95
   \   000000C6   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   000000CA   0x8001             STRH     R1,[R0, #+0]
   2487            
   2488          }
   \   000000CC   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
   2489          
   2490          
   2491          /**
   2492          * @brief  Returns the AGC measure time.
   2493          * @param  None.
   2494          * @retval uint16_t AGC measure time expressed in us. This parameter will be in the range [0, 393216/F_Xo].
   2495          */

   \                                 In section .text, align 2, keep-with-next
   2496          uint16_t SpiritRadioGetAGCMeasureTimeUs(void)
   2497          {
   \                     SpiritRadioGetAGCMeasureTimeUs: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   2498            uint8_t measure;
   2499            
   2500            /* Reads the AGCCTRL_2 register */
   2501            g_xStatus = SpiritSpiReadRegisters(AGCCTRL2_BASE, 1, &measure);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2024             MOVS     R0,#+36
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable95
   \   00000014   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000018   0x8001             STRH     R1,[R0, #+0]
   2502            
   2503            /* Mask the MEAS_TIME field */
   2504            measure &= 0x0F;
   \   0000001A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001E   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000022   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2505            
   2506            /* Calculates the measure time value to write in the register */
   2507            return (uint16_t)((12.0/s_lXtalFrequency)*(float)pow(2,measure)*1e6);
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable95_2
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x.... 0x....      BL       __aeabi_ui2d
   \   00000030   0x0002             MOVS     R2,R0
   \   00000032   0x000B             MOVS     R3,R1
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable95_4  ;; 0x40280000
   \   0000003A   0x.... 0x....      BL       __aeabi_ddiv
   \   0000003E   0x0004             MOVS     R4,R0
   \   00000040   0x000D             MOVS     R5,R1
   \   00000042   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000046   0x.... 0x....      BL       __aeabi_ui2d
   \   0000004A   0x0002             MOVS     R2,R0
   \   0000004C   0x000B             MOVS     R3,R1
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   00000054   0x.... 0x....      BL       pow
   \   00000058   0x.... 0x....      BL       __aeabi_d2f
   \   0000005C   0x.... 0x....      BL       __aeabi_f2d
   \   00000060   0x0022             MOVS     R2,R4
   \   00000062   0x002B             MOVS     R3,R5
   \   00000064   0x.... 0x....      BL       __aeabi_dmul
   \   00000068   0x2200             MOVS     R2,#+0
   \   0000006A   0x.... 0x....      LDR.W    R3,??DataTable95_6  ;; 0x412e8480
   \   0000006E   0x.... 0x....      BL       __aeabi_dmul
   \   00000072   0x.... 0x....      BL       __aeabi_d2iz
   \   00000076   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000078   0xBD3E             POP      {R1-R5,PC}       ;; return
   2508            
   2509          }
   2510          
   2511          
   2512          /**
   2513          * @brief  Sets the AGC measure time.
   2514          * @param  cTime AGC measure time to write in the MEAS_TIME field of AGCCTRL_2 register.
   2515          *         This parameter shall be in the range [0:15].
   2516          * @retval None.
   2517          */

   \                                 In section .text, align 2, keep-with-next
   2518          void SpiritRadioSetAGCMeasureTime(uint8_t cTime)
   2519          {
   \                     SpiritRadioSetAGCMeasureTime: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2520            uint8_t tempRegValue;
   2521            
   2522            /* Check the parameter */
   2523            s_assert_param(IS_AGC_MEASURE_TIME(cTime));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C10             CMP      R4,#+16
   \   00000008   0xDB05             BLT.N    ??SpiritRadioSetAGCMeasureTime_0
   \   0000000A   0xF640 0x11DB      MOVW     R1,#+2523
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable95_1
   \   00000012   0x.... 0x....      BL       s_assert_failed
   2524            
   2525            /* Reads the AGCCTRL_2 register */
   2526            SpiritSpiReadRegisters(AGCCTRL2_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioSetAGCMeasureTime_0: (+1)
   \   00000016   0xAA00             ADD      R2,SP,#+0
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x2024             MOVS     R0,#+36
   \   0000001C   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   2527            
   2528            /* Mask the MEAS_TIME field and write the new value */
   2529            tempRegValue &= 0xF0;
   \   00000020   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000024   0xF010 0x00F0      ANDS     R0,R0,#0xF0
   \   00000028   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2530            tempRegValue |= cTime;
   \   0000002C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000030   0x4320             ORRS     R0,R4,R0
   \   00000032   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2531            
   2532            /* Sets the AGCCTRL_2 register */
   2533            g_xStatus = SpiritSpiWriteRegisters(AGCCTRL2_BASE, 1, &tempRegValue);
   \   00000036   0xAA00             ADD      R2,SP,#+0
   \   00000038   0x2101             MOVS     R1,#+1
   \   0000003A   0x2024             MOVS     R0,#+36
   \   0000003C   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000040   0x9001             STR      R0,[SP, #+4]
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable95
   \   00000046   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   0000004A   0x8001             STRH     R1,[R0, #+0]
   2534            
   2535          }
   \   0000004C   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   2536          
   2537          
   2538          /**
   2539          * @brief  Returns the AGC measure time.
   2540          * @param  None.
   2541          * @retval uint8_t AGC measure time read from the MEAS_TIME field of AGCCTRL_2 register.
   2542          *         This parameter will be in the range [0:15].
   2543          */

   \                                 In section .text, align 2, keep-with-next
   2544          uint8_t SpiritRadioGetAGCMeasureTime(void)
   2545          {
   \                     SpiritRadioGetAGCMeasureTime: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   2546            uint8_t tempRegValue;
   2547            
   2548            /* Reads the AGCCTRL_2 register, mask the MEAS_TIME field and return the value  */
   2549            g_xStatus = SpiritSpiReadRegisters(AGCCTRL2_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2024             MOVS     R0,#+36
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable95
   \   00000014   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000018   0x8001             STRH     R1,[R0, #+0]
   2550            
   2551            return (tempRegValue & 0x0F);
   \   0000001A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001E   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000022   0xBD0E             POP      {R1-R3,PC}       ;; return
   2552            
   2553          }
   2554          
   2555          
   2556          /**
   2557          * @brief  Sets the AGC hold time.
   2558          * @param  cTime AGC hold time expressed in us. This parameter shall be in the range[0, 756/F_Xo].
   2559          * @retval None.
   2560          */

   \                                 In section .text, align 2, keep-with-next
   2561          void SpiritRadioSetAGCHoldTimeUs(uint8_t cTime)
   2562          {
   \                     SpiritRadioSetAGCHoldTimeUs: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0006             MOVS     R6,R0
   2563            uint8_t tempRegValue, hold;
   2564            
   2565            /* Check the parameter */
   2566            s_assert_param(IS_AGC_HOLD_TIME_US(cTime,s_lXtalFrequency));
   \   00000006   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000008   0x0030             MOVS     R0,R6
   \   0000000A   0x.... 0x....      BL       __aeabi_ui2d
   \   0000000E   0x0002             MOVS     R2,R0
   \   00000010   0x000B             MOVS     R3,R1
   \   00000012   0x0014             MOVS     R4,R2
   \   00000014   0x001D             MOVS     R5,R3
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable95_2
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x.... 0x....      BL       __aeabi_ui2d
   \   00000020   0x0002             MOVS     R2,R0
   \   00000022   0x000B             MOVS     R3,R1
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable95_7  ;; 0x4087a000
   \   0000002A   0x.... 0x....      BL       __aeabi_ddiv
   \   0000002E   0x0022             MOVS     R2,R4
   \   00000030   0x002B             MOVS     R3,R5
   \   00000032   0x.... 0x....      BL       __aeabi_cdrcmple
   \   00000036   0xD905             BLS.N    ??SpiritRadioSetAGCHoldTimeUs_0
   \   00000038   0xF640 0x2106      MOVW     R1,#+2566
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable95_1
   \   00000040   0x.... 0x....      BL       s_assert_failed
   2567            
   2568            /* Reads the AGCCTRL_0 register */
   2569            SpiritSpiReadRegisters(AGCCTRL0_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioSetAGCHoldTimeUs_0: (+1)
   \   00000044   0xAA00             ADD      R2,SP,#+0
   \   00000046   0x2101             MOVS     R1,#+1
   \   00000048   0x2026             MOVS     R0,#+38
   \   0000004A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   2570            
   2571            /* Calculates the hold time value to write in the register */
   2572            hold = (uint8_t)lroundf(((float)cTime/1e6 * s_lXtalFrequency)/12);
   \   0000004E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000050   0x0030             MOVS     R0,R6
   \   00000052   0x.... 0x....      BL       __aeabi_ui2f
   \   00000056   0x.... 0x....      BL       __aeabi_f2d
   \   0000005A   0x2200             MOVS     R2,#+0
   \   0000005C   0x.... 0x....      LDR.W    R3,??DataTable95_6  ;; 0x412e8480
   \   00000060   0x.... 0x....      BL       __aeabi_ddiv
   \   00000064   0x0004             MOVS     R4,R0
   \   00000066   0x000D             MOVS     R5,R1
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable95_2
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0x.... 0x....      BL       __aeabi_ui2d
   \   00000072   0x0022             MOVS     R2,R4
   \   00000074   0x002B             MOVS     R3,R5
   \   00000076   0x.... 0x....      BL       __aeabi_dmul
   \   0000007A   0x2200             MOVS     R2,#+0
   \   0000007C   0x.... 0x....      LDR.W    R3,??DataTable95_4  ;; 0x40280000
   \   00000080   0x.... 0x....      BL       __aeabi_ddiv
   \   00000084   0x.... 0x....      BL       __aeabi_d2f
   \   00000088   0x.... 0x....      BL       lroundf
   \   0000008C   0x0007             MOVS     R7,R0
   2573            (hold>63) ? (hold=63):(hold);
   \   0000008E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000090   0x2F40             CMP      R7,#+64
   \   00000092   0xDB02             BLT.N    ??SpiritRadioSetAGCHoldTimeUs_1
   \   00000094   0x273F             MOVS     R7,#+63
   \   00000096   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000098   0xE000             B.N      ??SpiritRadioSetAGCHoldTimeUs_2
   \                     ??SpiritRadioSetAGCHoldTimeUs_1: (+1)
   \   0000009A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   2574            
   2575            /* Mask the HOLD_TIME field and write the new value */
   2576            tempRegValue &= 0xC0;
   \                     ??SpiritRadioSetAGCHoldTimeUs_2: (+1)
   \   0000009C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000A0   0xF010 0x00C0      ANDS     R0,R0,#0xC0
   \   000000A4   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2577            tempRegValue |= hold;
   \   000000A8   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000AC   0x4338             ORRS     R0,R7,R0
   \   000000AE   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2578            
   2579            /* Sets the AGCCTRL_0 register */
   2580            g_xStatus = SpiritSpiWriteRegisters(AGCCTRL0_BASE, 1, &tempRegValue);
   \   000000B2   0xAA00             ADD      R2,SP,#+0
   \   000000B4   0x2101             MOVS     R1,#+1
   \   000000B6   0x2026             MOVS     R0,#+38
   \   000000B8   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   000000BC   0x9001             STR      R0,[SP, #+4]
   \   000000BE   0x.... 0x....      LDR.W    R0,??DataTable95
   \   000000C2   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   000000C6   0x8001             STRH     R1,[R0, #+0]
   2581            
   2582          }
   \   000000C8   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
   2583          
   2584          
   2585          /**
   2586          * @brief  Returns the AGC hold time.
   2587          * @param  None.
   2588          * @retval uint8_t AGC hold time expressed in us. This parameter will be in the range:
   2589          *         [0, 756/F_Xo].
   2590          */

   \                                 In section .text, align 2, keep-with-next
   2591          uint8_t SpiritRadioGetAGCHoldTimeUs(void)
   2592          {
   \                     SpiritRadioGetAGCHoldTimeUs: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   2593            uint8_t tempRegValue;
   2594            
   2595            /* Reads the AGCCTRL_0 register */
   2596            g_xStatus = SpiritSpiReadRegisters(AGCCTRL0_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2026             MOVS     R0,#+38
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable95
   \   00000014   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000018   0x8001             STRH     R1,[R0, #+0]
   2597            
   2598            /* Mask the HOLD_TIME field */
   2599            tempRegValue &= 0x3F;
   \   0000001A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001E   0xF010 0x003F      ANDS     R0,R0,#0x3F
   \   00000022   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2600            
   2601            /* Calculates the hold time value and return it */
   2602            return (uint8_t)lroundf ((12.0/s_lXtalFrequency)*(tempRegValue*1e6));
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable95_2
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x.... 0x....      BL       __aeabi_ui2d
   \   00000030   0x0002             MOVS     R2,R0
   \   00000032   0x000B             MOVS     R3,R1
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable95_4  ;; 0x40280000
   \   0000003A   0x.... 0x....      BL       __aeabi_ddiv
   \   0000003E   0x0004             MOVS     R4,R0
   \   00000040   0x000D             MOVS     R5,R1
   \   00000042   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000046   0x.... 0x....      BL       __aeabi_ui2d
   \   0000004A   0x2200             MOVS     R2,#+0
   \   0000004C   0x.... 0x....      LDR.W    R3,??DataTable95_6  ;; 0x412e8480
   \   00000050   0x.... 0x....      BL       __aeabi_dmul
   \   00000054   0x0022             MOVS     R2,R4
   \   00000056   0x002B             MOVS     R3,R5
   \   00000058   0x.... 0x....      BL       __aeabi_dmul
   \   0000005C   0x.... 0x....      BL       __aeabi_d2f
   \   00000060   0x.... 0x....      BL       lroundf
   \   00000064   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000066   0xBD3E             POP      {R1-R5,PC}       ;; return
   2603            
   2604          }
   2605          
   2606          
   2607          /**
   2608          * @brief  Sets the AGC hold time.
   2609          * @param  cTime AGC hold time to write in the HOLD_TIME field of AGCCTRL_0 register.
   2610          *         This parameter shall be in the range [0:63].
   2611          * @retval None.
   2612          */

   \                                 In section .text, align 2, keep-with-next
   2613          void SpiritRadioSetAGCHoldTime(uint8_t cTime)
   2614          {
   \                     SpiritRadioSetAGCHoldTime: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2615            uint8_t tempRegValue;
   2616            
   2617            /* Check the parameter */
   2618            s_assert_param(IS_AGC_HOLD_TIME(cTime));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C40             CMP      R4,#+64
   \   00000008   0xDB05             BLT.N    ??SpiritRadioSetAGCHoldTime_0
   \   0000000A   0xF640 0x213A      MOVW     R1,#+2618
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable95_1
   \   00000012   0x.... 0x....      BL       s_assert_failed
   2619            
   2620            /* Reads the AGCCTRL_0 register */
   2621            SpiritSpiReadRegisters(AGCCTRL0_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioSetAGCHoldTime_0: (+1)
   \   00000016   0xAA00             ADD      R2,SP,#+0
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x2026             MOVS     R0,#+38
   \   0000001C   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   2622            
   2623            /* Mask the HOLD_TIME field and write the new value */
   2624            tempRegValue &= 0xC0;
   \   00000020   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000024   0xF010 0x00C0      ANDS     R0,R0,#0xC0
   \   00000028   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2625            tempRegValue |= cTime;
   \   0000002C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000030   0x4320             ORRS     R0,R4,R0
   \   00000032   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2626            
   2627            /* Sets the AGCCTRL_0 register */
   2628            g_xStatus = SpiritSpiWriteRegisters(AGCCTRL0_BASE, 1, &tempRegValue);
   \   00000036   0xAA00             ADD      R2,SP,#+0
   \   00000038   0x2101             MOVS     R1,#+1
   \   0000003A   0x2026             MOVS     R0,#+38
   \   0000003C   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000040   0x9001             STR      R0,[SP, #+4]
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable95
   \   00000046   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   0000004A   0x8001             STRH     R1,[R0, #+0]
   2629            
   2630          }
   \   0000004C   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   2631          
   2632          
   2633          /**
   2634          * @brief  Returns the AGC hold time.
   2635          * @param  None.
   2636          * @retval uint8_t AGC hold time read from the HOLD_TIME field of AGCCTRL_0 register.
   2637          *         This parameter will be in the range [0:63].
   2638          */

   \                                 In section .text, align 2, keep-with-next
   2639          uint8_t SpiritRadioGetAGCHoldTime(void)
   2640          {
   \                     SpiritRadioGetAGCHoldTime: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   2641            uint8_t tempRegValue;
   2642            
   2643            /* Reads the AGCCTRL_0 register, mask the MEAS_TIME field and return the value  */
   2644            g_xStatus = SpiritSpiReadRegisters(AGCCTRL0_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2026             MOVS     R0,#+38
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable95
   \   00000014   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000018   0x8001             STRH     R1,[R0, #+0]
   2645            
   2646            return (tempRegValue & 0x3F);
   \   0000001A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001E   0xF010 0x003F      ANDS     R0,R0,#0x3F
   \   00000022   0xBD0E             POP      {R1-R3,PC}       ;; return
   2647            
   2648          }
   2649          
   2650          
   2651          /**
   2652          * @brief  Sets the AGC high threshold.
   2653          * @param  cHighThreshold AGC high threshold to write in the THRESHOLD_HIGH field of AGCCTRL_1 register.
   2654          *         This parameter shall be in the range [0:15].
   2655          * @retval None.
   2656          */

   \                                 In section .text, align 2, keep-with-next
   2657          void SpiritRadioSetAGCHighThreshold(uint8_t cHighThreshold)
   2658          {
   \                     SpiritRadioSetAGCHighThreshold: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2659            uint8_t tempRegValue;
   2660            
   2661            /* Check the parameter */
   2662            s_assert_param(IS_AGC_THRESHOLD(cHighThreshold));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C10             CMP      R4,#+16
   \   00000008   0xDB05             BLT.N    ??SpiritRadioSetAGCHighThreshold_0
   \   0000000A   0xF640 0x2166      MOVW     R1,#+2662
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable95_1
   \   00000012   0x.... 0x....      BL       s_assert_failed
   2663            
   2664            /* Reads the AGCCTRL_1 register */
   2665            SpiritSpiReadRegisters(AGCCTRL1_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioSetAGCHighThreshold_0: (+1)
   \   00000016   0xAA00             ADD      R2,SP,#+0
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x2025             MOVS     R0,#+37
   \   0000001C   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   2666            
   2667            /* Mask the THRESHOLD_HIGH field and write the new value */
   2668            tempRegValue &= 0x0F;
   \   00000020   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000024   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000028   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2669            tempRegValue |= cHighThreshold<<4;
   \   0000002C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000030   0xEA50 0x1004      ORRS     R0,R0,R4, LSL #+4
   \   00000034   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2670            
   2671            /* Sets the AGCCTRL_1 register */
   2672            g_xStatus = SpiritSpiWriteRegisters(AGCCTRL1_BASE, 1, &tempRegValue);
   \   00000038   0xAA00             ADD      R2,SP,#+0
   \   0000003A   0x2101             MOVS     R1,#+1
   \   0000003C   0x2025             MOVS     R0,#+37
   \   0000003E   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000042   0x9001             STR      R0,[SP, #+4]
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable95
   \   00000048   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   0000004C   0x8001             STRH     R1,[R0, #+0]
   2673            
   2674          }
   \   0000004E   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   2675          
   2676          
   2677          /**
   2678          * @brief  Returns the AGC high threshold.
   2679          * @param  None.
   2680          * @retval uint8_t AGC high threshold read from the THRESHOLD_HIGH field of AGCCTRL_1 register.
   2681          *         This parameter will be in the range [0:15].
   2682          */

   \                                 In section .text, align 2, keep-with-next
   2683          uint8_t SpiritRadioGetAGCHighThreshold(void)
   2684          {
   \                     SpiritRadioGetAGCHighThreshold: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   2685            uint8_t tempRegValue;
   2686            
   2687            /* Reads the AGCCTRL_1 register, mask the THRESHOLD_HIGH field and return the value */
   2688            g_xStatus = SpiritSpiReadRegisters(AGCCTRL1_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2025             MOVS     R0,#+37
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable95
   \   00000014   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000018   0x8001             STRH     R1,[R0, #+0]
   2689            
   2690            return ((tempRegValue & 0xF0)>>4);
   \   0000001A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x0900             LSRS     R0,R0,#+4
   \   00000022   0xBD0E             POP      {R1-R3,PC}       ;; return
   2691            
   2692          }
   2693          
   2694          
   2695          /**
   2696          * @brief  Sets the AGC low threshold.
   2697          * @param  cLowThreshold AGC low threshold to write in the THRESHOLD_LOW field of AGCCTRL_1 register.
   2698          *         This parameter shall be in the range [0:15].
   2699          * @retval None.
   2700          */

   \                                 In section .text, align 2, keep-with-next
   2701          void SpiritRadioSetAGCLowThreshold(uint8_t cLowThreshold)
   2702          {
   \                     SpiritRadioSetAGCLowThreshold: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2703            uint8_t tempRegValue;
   2704            
   2705            /* Check the parameter */
   2706            s_assert_param(IS_AGC_THRESHOLD(cLowThreshold));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C10             CMP      R4,#+16
   \   00000008   0xDB05             BLT.N    ??SpiritRadioSetAGCLowThreshold_0
   \   0000000A   0xF640 0x2192      MOVW     R1,#+2706
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable95_1
   \   00000012   0x.... 0x....      BL       s_assert_failed
   2707            
   2708            /* Reads the AGCCTRL_1 register */
   2709            SpiritSpiReadRegisters(AGCCTRL1_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioSetAGCLowThreshold_0: (+1)
   \   00000016   0xAA00             ADD      R2,SP,#+0
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x2025             MOVS     R0,#+37
   \   0000001C   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   2710            
   2711            /* Mask the THRESHOLD_LOW field and write the new value */
   2712            tempRegValue &= 0xF0;
   \   00000020   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000024   0xF010 0x00F0      ANDS     R0,R0,#0xF0
   \   00000028   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2713            tempRegValue |= cLowThreshold;
   \   0000002C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000030   0x4320             ORRS     R0,R4,R0
   \   00000032   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2714            
   2715            /* Sets the AGCCTRL_1 register */
   2716            g_xStatus = SpiritSpiWriteRegisters(AGCCTRL1_BASE, 1, &tempRegValue);
   \   00000036   0xAA00             ADD      R2,SP,#+0
   \   00000038   0x2101             MOVS     R1,#+1
   \   0000003A   0x2025             MOVS     R0,#+37
   \   0000003C   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000040   0x9001             STR      R0,[SP, #+4]
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable95
   \   00000046   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   0000004A   0x8001             STRH     R1,[R0, #+0]
   2717            
   2718          }
   \   0000004C   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   2719          
   2720          
   2721          /**
   2722          * @brief  Returns the AGC low threshold.
   2723          * @param  None.
   2724          * @retval uint8_t AGC low threshold read from the THRESHOLD_LOW field of AGCCTRL_1 register.
   2725          *         This parameter will be in the range [0:15].
   2726          */

   \                                 In section .text, align 2, keep-with-next
   2727          uint8_t SpiritRadioGetAGCLowThreshold(void)
   2728          {
   \                     SpiritRadioGetAGCLowThreshold: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   2729            uint8_t tempRegValue;
   2730            
   2731            /* Reads the AGCCTRL_1 register, mask the THRESHOLD_LOW field and return the value  */
   2732            g_xStatus = SpiritSpiReadRegisters(AGCCTRL1_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2025             MOVS     R0,#+37
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable95
   \   00000014   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000018   0x8001             STRH     R1,[R0, #+0]
   2733            
   2734            return (tempRegValue & 0x0F);
   \   0000001A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001E   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000022   0xBD0E             POP      {R1-R3,PC}       ;; return
   2735            
   2736          }
   2737          
   2738          
   2739          /**
   2740          * @brief  Sets the clock recovery algorithm.
   2741          * @param  xMode the Clock Recovery mode. This parameter can be one of the values defined in @ref ClkRecMode :
   2742          *         @arg CLK_REC_PLL     PLL alogrithm for clock recovery
   2743          *         @arg CLK_REC_DLL     DLL alogrithm for clock recovery
   2744          * @retval None.
   2745          */

   \                                 In section .text, align 2, keep-with-next
   2746          void SpiritRadioSetClkRecMode(ClkRecMode xMode)
   2747          {
   \                     SpiritRadioSetClkRecMode: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2748            uint8_t tempRegValue;
   2749            
   2750            /* Check the parameter */
   2751            s_assert_param(IS_CLK_REC_MODE(xMode));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??SpiritRadioSetClkRecMode_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C08             CMP      R4,#+8
   \   0000000E   0xD004             BEQ.N    ??SpiritRadioSetClkRecMode_0
   \   00000010   0xF640 0x21BF      MOVW     R1,#+2751
   \   00000014   0x....             LDR.N    R0,??DataTable95_1
   \   00000016   0x.... 0x....      BL       s_assert_failed
   2752            
   2753            /* Reads the FDEV_0 register */
   2754            SpiritSpiReadRegisters(FDEV0_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioSetClkRecMode_0: (+1)
   \   0000001A   0xAA00             ADD      R2,SP,#+0
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x201C             MOVS     R0,#+28
   \   00000020   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   2755            
   2756            /* Mask the CLOCK_REC_ALGO_SEL field and write the new value */
   2757            tempRegValue &= 0xF7;
   \   00000024   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000028   0xF010 0x00F7      ANDS     R0,R0,#0xF7
   \   0000002C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2758            tempRegValue |= (uint8_t)xMode;
   \   00000030   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000034   0x4320             ORRS     R0,R4,R0
   \   00000036   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2759            
   2760            /* Sets the FDEV_0 register */
   2761            g_xStatus = SpiritSpiWriteRegisters(FDEV0_BASE, 1, &tempRegValue);
   \   0000003A   0xAA00             ADD      R2,SP,#+0
   \   0000003C   0x2101             MOVS     R1,#+1
   \   0000003E   0x201C             MOVS     R0,#+28
   \   00000040   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000044   0x9001             STR      R0,[SP, #+4]
   \   00000046   0x....             LDR.N    R0,??DataTable95
   \   00000048   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   0000004C   0x8001             STRH     R1,[R0, #+0]
   2762            
   2763          }
   \   0000004E   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   2764          
   2765          
   2766          /**
   2767          * @brief  Returns the Clock Recovery working mode.
   2768          * @param  None.
   2769          * @retval ClkRecMode Clock Recovery mode. This parameter can be one of the values defined in @ref ClkRecMode :
   2770          *         @arg CLK_REC_PLL     PLL alogrithm for clock recovery
   2771          *         @arg CLK_REC_DLL     DLL alogrithm for clock recovery
   2772          */

   \                                 In section .text, align 2, keep-with-next
   2773          ClkRecMode SpiritRadioGetClkRecMode(void)
   2774          {
   \                     SpiritRadioGetClkRecMode: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   2775            uint8_t tempRegValue;
   2776            
   2777            /* Reads the FDEV_0 register, mask the CLOCK_REC_ALGO_SEL field and return the value */
   2778            g_xStatus = SpiritSpiReadRegisters(FDEV0_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x201C             MOVS     R0,#+28
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x....             LDR.N    R0,??DataTable95
   \   00000012   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000016   0x8001             STRH     R1,[R0, #+0]
   2779            
   2780            return (ClkRecMode)(tempRegValue & 0x08);
   \   00000018   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001C   0xF010 0x0008      ANDS     R0,R0,#0x8
   \   00000020   0xBD0E             POP      {R1-R3,PC}       ;; return
   2781            
   2782          }
   2783          
   2784          
   2785          /**
   2786          * @brief  Sets the clock recovery proportional gain.
   2787          * @param  cPGain the Clock Recovery proportional gain to write in the CLK_REC_P_GAIN field of CLOCKREC register.
   2788          *         It represents is log2 value of the clock recovery proportional gain.
   2789          *          This parameter shall be in the range [0:7].
   2790          * @retval None.
   2791          */

   \                                 In section .text, align 2, keep-with-next
   2792          void SpiritRadioSetClkRecPGain(uint8_t cPGain)
   2793          {
   \                     SpiritRadioSetClkRecPGain: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2794            uint8_t tempRegValue;
   2795            
   2796            /* Check the parameter */
   2797            s_assert_param(IS_CLK_REC_P_GAIN(cPGain));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C08             CMP      R4,#+8
   \   00000008   0xDB04             BLT.N    ??SpiritRadioSetClkRecPGain_0
   \   0000000A   0xF640 0x21ED      MOVW     R1,#+2797
   \   0000000E   0x....             LDR.N    R0,??DataTable95_1
   \   00000010   0x.... 0x....      BL       s_assert_failed
   2798            
   2799            /* Reads the CLOCKREC register */
   2800            SpiritSpiReadRegisters(CLOCKREC_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioSetClkRecPGain_0: (+1)
   \   00000014   0xAA00             ADD      R2,SP,#+0
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0x2023             MOVS     R0,#+35
   \   0000001A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   2801            
   2802            /* Mask the CLK_REC_P_GAIN field and write the new value */
   2803            tempRegValue &= 0x1F;
   \   0000001E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000022   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   00000026   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2804            tempRegValue |= (cPGain<<5);
   \   0000002A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000002E   0xEA50 0x1044      ORRS     R0,R0,R4, LSL #+5
   \   00000032   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2805            
   2806            /* Sets the CLOCKREC register */
   2807            g_xStatus = SpiritSpiWriteRegisters(CLOCKREC_BASE, 1, &tempRegValue);
   \   00000036   0xAA00             ADD      R2,SP,#+0
   \   00000038   0x2101             MOVS     R1,#+1
   \   0000003A   0x2023             MOVS     R0,#+35
   \   0000003C   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000040   0x9001             STR      R0,[SP, #+4]
   \   00000042   0x....             LDR.N    R0,??DataTable95
   \   00000044   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000048   0x8001             STRH     R1,[R0, #+0]
   2808            
   2809          }
   \   0000004A   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   2810          
   2811          
   2812          /**
   2813          * @brief  Returns the log2 of the clock recovery proportional gain.
   2814          * @param  None.
   2815          * @retval uint8_t Clock Recovery proportional gain read from the CLK_REC_P_GAIN field of CLOCKREC register.
   2816          *         This parameter will be in the range [0:7].
   2817          */

   \                                 In section .text, align 2, keep-with-next
   2818          uint8_t SpiritRadioGetClkRecPGain(void)
   2819          {
   \                     SpiritRadioGetClkRecPGain: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   2820            uint8_t tempRegValue;
   2821            
   2822            /* Reads the CLOCKREC register, mask the CLK_REC_P_GAIN field and return the value  */
   2823            g_xStatus = SpiritSpiReadRegisters(CLOCKREC_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2023             MOVS     R0,#+35
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x....             LDR.N    R0,??DataTable95
   \   00000012   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000016   0x8001             STRH     R1,[R0, #+0]
   2824            
   2825            return ((tempRegValue & 0xEF)>>5);
   \   00000018   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0x0940             LSRS     R0,R0,#+5
   \   00000020   0xBD0E             POP      {R1-R3,PC}       ;; return
   2826            
   2827          }
   2828          
   2829          
   2830          /**
   2831          * @brief  Sets the clock recovery integral gain.
   2832          * @param  cIGain the Clock Recovery integral gain to write in the CLK_REC_I_GAIN field of CLOCKREC register.
   2833          *         This parameter shall be in the range [0:15].
   2834          * @retval None.
   2835          */

   \                                 In section .text, align 2, keep-with-next
   2836          void SpiritRadioSetClkRecIGain(uint8_t cIGain)
   2837          {
   \                     SpiritRadioSetClkRecIGain: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2838            uint8_t tempRegValue;
   2839            
   2840            /* Check the parameter */
   2841            s_assert_param(IS_CLK_REC_I_GAIN(cIGain));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C10             CMP      R4,#+16
   \   00000008   0xDB04             BLT.N    ??SpiritRadioSetClkRecIGain_0
   \   0000000A   0xF640 0x3119      MOVW     R1,#+2841
   \   0000000E   0x....             LDR.N    R0,??DataTable95_1
   \   00000010   0x.... 0x....      BL       s_assert_failed
   2842            
   2843            /* Reads the CLOCKREC register */
   2844            SpiritSpiReadRegisters(CLOCKREC_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioSetClkRecIGain_0: (+1)
   \   00000014   0xAA00             ADD      R2,SP,#+0
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0x2023             MOVS     R0,#+35
   \   0000001A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   2845            
   2846            /* Mask the CLK_REC_P_GAIN field and write the new value */
   2847            tempRegValue &= 0xF0;
   \   0000001E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000022   0xF010 0x00F0      ANDS     R0,R0,#0xF0
   \   00000026   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2848            tempRegValue |= cIGain;
   \   0000002A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000002E   0x4320             ORRS     R0,R4,R0
   \   00000030   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2849            
   2850            /* Sets the CLOCKREC register */
   2851            g_xStatus = SpiritSpiWriteRegisters(CLOCKREC_BASE, 1, &tempRegValue);
   \   00000034   0xAA00             ADD      R2,SP,#+0
   \   00000036   0x2101             MOVS     R1,#+1
   \   00000038   0x2023             MOVS     R0,#+35
   \   0000003A   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   0000003E   0x9001             STR      R0,[SP, #+4]
   \   00000040   0x....             LDR.N    R0,??DataTable95
   \   00000042   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000046   0x8001             STRH     R1,[R0, #+0]
   2852            
   2853          }
   \   00000048   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   2854          
   2855          
   2856          /**
   2857          * @brief  Returns the clock recovery integral gain.
   2858          * @param  None.
   2859          * @retval uint8_t Clock Recovery integral gain read from the
   2860          *         CLK_REC_I_GAIN field of CLOCKREC register.
   2861          *         This parameter will be in the range [0:15].
   2862          */

   \                                 In section .text, align 2, keep-with-next
   2863          uint8_t SpiritRadioGetClkRecIGain(void)
   2864          {
   \                     SpiritRadioGetClkRecIGain: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   2865            uint8_t tempRegValue;
   2866            
   2867            /* Reads the CLOCKREC register, mask the CLK_REC_I_GAIN field and return the value */
   2868            g_xStatus = SpiritSpiReadRegisters(CLOCKREC_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2023             MOVS     R0,#+35
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x....             LDR.N    R0,??DataTable95
   \   00000012   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000016   0x8001             STRH     R1,[R0, #+0]
   2869            
   2870            return (tempRegValue & 0x0F);
   \   00000018   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001C   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000020   0xBD0E             POP      {R1-R3,PC}       ;; return
   2871            
   2872          }
   2873          
   2874          
   2875          /**
   2876          * @brief  Sets the postfilter length for clock recovery algorithm.
   2877          * @param  xLength the postfilter length in symbols. This parameter can be one of the values defined in @ref PstFltLength :
   2878          *         @arg PSTFLT_LENGTH_8     Postfilter length is 8 symbols
   2879          *         @arg PSTFLT_LENGTH_16    Postfilter length is 16 symbols
   2880          * @retval None.
   2881          */

   \                                 In section .text, align 2, keep-with-next
   2882          void SpiritRadioSetClkRecPstFltLength(PstFltLength xLength)
   2883          {
   \                     SpiritRadioSetClkRecPstFltLength: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2884            uint8_t tempRegValue;
   2885            
   2886            /* Check the parameter */
   2887            s_assert_param(IS_PST_FLT_LENGTH(xLength));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??SpiritRadioSetClkRecPstFltLength_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C10             CMP      R4,#+16
   \   0000000E   0xD004             BEQ.N    ??SpiritRadioSetClkRecPstFltLength_0
   \   00000010   0xF640 0x3147      MOVW     R1,#+2887
   \   00000014   0x....             LDR.N    R0,??DataTable95_1
   \   00000016   0x.... 0x....      BL       s_assert_failed
   2888            
   2889            /* Reads the CLOCKREC register */
   2890            SpiritSpiReadRegisters(CLOCKREC_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioSetClkRecPstFltLength_0: (+1)
   \   0000001A   0xAA00             ADD      R2,SP,#+0
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x2023             MOVS     R0,#+35
   \   00000020   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   2891            
   2892            /* Mask the PSTFLT_LEN field and write the new value */
   2893            tempRegValue &= 0xEF;
   \   00000024   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000028   0xF010 0x00EF      ANDS     R0,R0,#0xEF
   \   0000002C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2894            tempRegValue |= (uint8_t)xLength;
   \   00000030   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000034   0x4320             ORRS     R0,R4,R0
   \   00000036   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2895            
   2896            /* Sets the CLOCKREC register */
   2897            g_xStatus = SpiritSpiWriteRegisters(CLOCKREC_BASE, 1, &tempRegValue);
   \   0000003A   0xAA00             ADD      R2,SP,#+0
   \   0000003C   0x2101             MOVS     R1,#+1
   \   0000003E   0x2023             MOVS     R0,#+35
   \   00000040   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   00000044   0x9001             STR      R0,[SP, #+4]
   \   00000046   0x....             LDR.N    R0,??DataTable95
   \   00000048   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   0000004C   0x8001             STRH     R1,[R0, #+0]
   2898            
   2899          }
   \   0000004E   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   2900          
   2901          
   2902          /**
   2903          * @brief  Returns the postfilter length for clock recovery algorithm.
   2904          * @param  None.
   2905          * @retval PstFltLength Postfilter length in symbols. This parameter can be one of the values defined in @ref PstFltLength :
   2906          *         @arg PSTFLT_LENGTH_8     Postfilter length is 8 symbols
   2907          *         @arg PSTFLT_LENGTH_16    Postfilter length is 16 symbols
   2908          */

   \                                 In section .text, align 2, keep-with-next
   2909          PstFltLength SpiritRadioGetClkRecPstFltLength(void)
   2910          {
   \                     SpiritRadioGetClkRecPstFltLength: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   2911            uint8_t tempRegValue;
   2912            
   2913            /* Reads the CLOCKREC register, mask the PSTFLT_LEN field and return the value */
   2914            g_xStatus = SpiritSpiReadRegisters(CLOCKREC_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2023             MOVS     R0,#+35
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x....             LDR.N    R0,??DataTable95
   \   00000012   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000016   0x8001             STRH     R1,[R0, #+0]
   2915            
   2916            return (PstFltLength)(tempRegValue & 0x10);
   \   00000018   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001C   0xF010 0x0010      ANDS     R0,R0,#0x10
   \   00000020   0xBD0E             POP      {R1-R3,PC}       ;; return
   2917            
   2918          }
   2919          
   2920          
   2921          /**
   2922          * @brief  Enables or Disables the received data blanking when the CS is under the threshold.
   2923          * @param  xNewState new state of this mode.
   2924          *         This parameter can be: S_ENABLE or S_DISABLE .
   2925          * @retval None.
   2926          */

   \                                 In section .text, align 2, keep-with-next
   2927          void SpiritRadioCsBlanking(SpiritFunctionalState xNewState)
   2928          {
   \                     SpiritRadioCsBlanking: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2929            uint8_t tempRegValue;
   2930            
   2931            /* Check the parameters */
   2932            s_assert_param(IS_SPIRIT_FUNCTIONAL_STATE(xNewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??SpiritRadioCsBlanking_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD004             BEQ.N    ??SpiritRadioCsBlanking_0
   \   00000010   0xF640 0x3174      MOVW     R1,#+2932
   \   00000014   0x....             LDR.N    R0,??DataTable95_1
   \   00000016   0x.... 0x....      BL       s_assert_failed
   2933            
   2934            /* Reads the ANT_SELECT_CONF_BASE and mask the CS_BLANKING BIT field */
   2935            SpiritSpiReadRegisters(ANT_SELECT_CONF_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioCsBlanking_0: (+1)
   \   0000001A   0xAA00             ADD      R2,SP,#+0
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x2027             MOVS     R0,#+39
   \   00000020   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   2936            
   2937            if(xNewState == S_ENABLE)
   \   00000024   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000026   0x2C01             CMP      R4,#+1
   \   00000028   0xD106             BNE.N    ??SpiritRadioCsBlanking_1
   2938            {
   2939              tempRegValue |= ANT_SELECT_CS_BLANKING_MASK;
   \   0000002A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000002E   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000032   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000036   0xE005             B.N      ??SpiritRadioCsBlanking_2
   2940            }
   2941            else
   2942            {
   2943              tempRegValue &= (~ANT_SELECT_CS_BLANKING_MASK);
   \                     ??SpiritRadioCsBlanking_1: (+1)
   \   00000038   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000003C   0xF010 0x00EF      ANDS     R0,R0,#0xEF
   \   00000040   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2944            }
   2945            
   2946            /* Writes the new value in the ANT_SELECT_CONF register */
   2947            g_xStatus = SpiritSpiWriteRegisters(ANT_SELECT_CONF_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioCsBlanking_2: (+1)
   \   00000044   0xAA00             ADD      R2,SP,#+0
   \   00000046   0x2101             MOVS     R1,#+1
   \   00000048   0x2027             MOVS     R0,#+39
   \   0000004A   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   0000004E   0x9001             STR      R0,[SP, #+4]
   \   00000050   0x....             LDR.N    R0,??DataTable95
   \   00000052   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000056   0x8001             STRH     R1,[R0, #+0]
   2948            
   2949            
   2950          }
   \   00000058   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   2951          
   2952          /**
   2953          * @brief  Enables or Disables the persistent RX mode.
   2954          * @param  xNewState new state of this mode.
   2955          *         This parameter can be: S_ENABLE or S_DISABLE .
   2956          * @retval None.
   2957          */

   \                                 In section .text, align 2, keep-with-next
   2958          void SpiritRadioPersistenRx(SpiritFunctionalState xNewState)
   2959          {
   \                     SpiritRadioPersistenRx: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2960            uint8_t tempRegValue;
   2961            
   2962            /* Check the parameters */
   2963            s_assert_param(IS_SPIRIT_FUNCTIONAL_STATE(xNewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??SpiritRadioPersistenRx_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD004             BEQ.N    ??SpiritRadioPersistenRx_0
   \   00000010   0xF640 0x3193      MOVW     R1,#+2963
   \   00000014   0x....             LDR.N    R0,??DataTable95_1
   \   00000016   0x.... 0x....      BL       s_assert_failed
   2964            
   2965            /* Reads the PROTOCOL0_BASE and mask the PROTOCOL0_PERS_RX_MASK bitfield */
   2966            SpiritSpiReadRegisters(PROTOCOL0_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioPersistenRx_0: (+1)
   \   0000001A   0xAA00             ADD      R2,SP,#+0
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x2052             MOVS     R0,#+82
   \   00000020   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   2967            
   2968            if(xNewState == S_ENABLE)
   \   00000024   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000026   0x2C01             CMP      R4,#+1
   \   00000028   0xD106             BNE.N    ??SpiritRadioPersistenRx_1
   2969            {
   2970              tempRegValue |= PROTOCOL0_PERS_RX_MASK;
   \   0000002A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000002E   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000032   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000036   0xE005             B.N      ??SpiritRadioPersistenRx_2
   2971            }
   2972            else
   2973            {
   2974              tempRegValue &= (~PROTOCOL0_PERS_RX_MASK);
   \                     ??SpiritRadioPersistenRx_1: (+1)
   \   00000038   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000003C   0xF010 0x00FD      ANDS     R0,R0,#0xFD
   \   00000040   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2975            }
   2976            
   2977            /* Writes the new value in the PROTOCOL0_BASE register */
   2978            g_xStatus = SpiritSpiWriteRegisters(PROTOCOL0_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioPersistenRx_2: (+1)
   \   00000044   0xAA00             ADD      R2,SP,#+0
   \   00000046   0x2101             MOVS     R1,#+1
   \   00000048   0x2052             MOVS     R0,#+82
   \   0000004A   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   0000004E   0x9001             STR      R0,[SP, #+4]
   \   00000050   0x....             LDR.N    R0,??DataTable95
   \   00000052   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000056   0x8001             STRH     R1,[R0, #+0]
   2979            
   2980          }
   \   00000058   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   2981          
   2982          /**
   2983          * @brief  Enables or Disables the synthesizer reference divider.
   2984          * @param  xNewState new state for synthesizer reference divider.
   2985          *         This parameter can be: S_ENABLE or S_DISABLE .
   2986          * @retval None.
   2987          */

   \                                 In section .text, align 2, keep-with-next
   2988          void SpiritRadioSetRefDiv(SpiritFunctionalState xNewState)
   2989          {
   \                     SpiritRadioSetRefDiv: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2990            uint8_t tempRegValue;
   2991            
   2992            /* Check the parameters */
   2993            s_assert_param(IS_SPIRIT_FUNCTIONAL_STATE(xNewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??SpiritRadioSetRefDiv_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD004             BEQ.N    ??SpiritRadioSetRefDiv_0
   \   00000010   0xF640 0x31B1      MOVW     R1,#+2993
   \   00000014   0x....             LDR.N    R0,??DataTable95_1
   \   00000016   0x.... 0x....      BL       s_assert_failed
   2994            
   2995            /* Reads the SYNTH_CONFIG1_BASE and mask the REFDIV bit field */
   2996            SpiritSpiReadRegisters(SYNTH_CONFIG1_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioSetRefDiv_0: (+1)
   \   0000001A   0xAA00             ADD      R2,SP,#+0
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x209E             MOVS     R0,#+158
   \   00000020   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   2997          
   2998            if(xNewState == S_ENABLE)
   \   00000024   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000026   0x2C01             CMP      R4,#+1
   \   00000028   0xD106             BNE.N    ??SpiritRadioSetRefDiv_1
   2999            {
   3000              tempRegValue |= 0x80;
   \   0000002A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000002E   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000032   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000036   0xE005             B.N      ??SpiritRadioSetRefDiv_2
   3001            }
   3002            else
   3003            {
   3004              tempRegValue &= 0x7F;
   \                     ??SpiritRadioSetRefDiv_1: (+1)
   \   00000038   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000003C   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   00000040   0xF88D 0x0000      STRB     R0,[SP, #+0]
   3005            }
   3006            
   3007            /* Writes the new value in the SYNTH_CONFIG1_BASE register */
   3008            g_xStatus = SpiritSpiWriteRegisters(SYNTH_CONFIG1_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioSetRefDiv_2: (+1)
   \   00000044   0xAA00             ADD      R2,SP,#+0
   \   00000046   0x2101             MOVS     R1,#+1
   \   00000048   0x209E             MOVS     R0,#+158
   \   0000004A   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   0000004E   0x9001             STR      R0,[SP, #+4]
   \   00000050   0x....             LDR.N    R0,??DataTable95
   \   00000052   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000056   0x8001             STRH     R1,[R0, #+0]
   3009            
   3010          }
   \   00000058   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   3011          
   3012          /**
   3013          * @brief  Get the the synthesizer reference divider state.
   3014          * @param  void.
   3015          * @retval None.
   3016          */

   \                                 In section .text, align 2, keep-with-next
   3017          SpiritFunctionalState SpiritRadioGetRefDiv(void)
   3018          {
   \                     SpiritRadioGetRefDiv: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   3019            uint8_t tempRegValue;
   3020            
   3021            g_xStatus = SpiritSpiReadRegisters(SYNTH_CONFIG1_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x209E             MOVS     R0,#+158
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x....             LDR.N    R0,??DataTable95
   \   00000012   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000016   0x8001             STRH     R1,[R0, #+0]
   3022            
   3023            if(((tempRegValue>>7)&0x1))
   \   00000018   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0x09C0             LSRS     R0,R0,#+7
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD001             BEQ.N    ??SpiritRadioGetRefDiv_0
   3024            {
   3025              return S_ENABLE;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xE000             B.N      ??SpiritRadioGetRefDiv_1
   3026            }
   3027            else
   3028            {
   3029              return S_DISABLE;
   \                     ??SpiritRadioGetRefDiv_0: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \                     ??SpiritRadioGetRefDiv_1: (+1)
   \   0000002C   0xBD0E             POP      {R1-R3,PC}       ;; return
   3030            }
   3031            
   3032          }
   3033          
   3034          /**
   3035          * @brief  Enables or Disables the synthesizer reference divider.
   3036          * @param  xNewState new state for synthesizer reference divider.
   3037          *         This parameter can be: S_ENABLE or S_DISABLE .
   3038          * @retval None.
   3039          */

   \                                 In section .text, align 2, keep-with-next
   3040          void SpiritRadioSetDigDiv(SpiritFunctionalState xNewState)
   3041          {
   \                     SpiritRadioSetDigDiv: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   3042            uint8_t tempRegValue;
   3043            
   3044            /* Check the parameters */
   3045            s_assert_param(IS_SPIRIT_FUNCTIONAL_STATE(xNewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??SpiritRadioSetDigDiv_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD004             BEQ.N    ??SpiritRadioSetDigDiv_0
   \   00000010   0xF640 0x31E5      MOVW     R1,#+3045
   \   00000014   0x....             LDR.N    R0,??DataTable95_1
   \   00000016   0x.... 0x....      BL       s_assert_failed
   3046            
   3047            /* Reads the XO_RCO_TEST_BASE and mask the PD_CLKDIV bit field */
   3048            SpiritSpiReadRegisters(XO_RCO_TEST_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioSetDigDiv_0: (+1)
   \   0000001A   0xAA00             ADD      R2,SP,#+0
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x20B4             MOVS     R0,#+180
   \   00000020   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   3049          
   3050            if(xNewState == S_ENABLE)
   \   00000024   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000026   0x2C01             CMP      R4,#+1
   \   00000028   0xD106             BNE.N    ??SpiritRadioSetDigDiv_1
   3051            {
   3052              tempRegValue &= 0xf7;
   \   0000002A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000002E   0xF010 0x00F7      ANDS     R0,R0,#0xF7
   \   00000032   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000036   0xE005             B.N      ??SpiritRadioSetDigDiv_2
   3053            }
   3054            else
   3055            {
   3056              
   3057              tempRegValue |= 0x08;
   \                     ??SpiritRadioSetDigDiv_1: (+1)
   \   00000038   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000003C   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000040   0xF88D 0x0000      STRB     R0,[SP, #+0]
   3058            }
   3059            
   3060            /* Writes the new value in the XO_RCO_TEST_BASE register */
   3061            g_xStatus = SpiritSpiWriteRegisters(XO_RCO_TEST_BASE, 1, &tempRegValue);
   \                     ??SpiritRadioSetDigDiv_2: (+1)
   \   00000044   0xAA00             ADD      R2,SP,#+0
   \   00000046   0x2101             MOVS     R1,#+1
   \   00000048   0x20B4             MOVS     R0,#+180
   \   0000004A   0x.... 0x....      BL       SdkEvalSpiWriteRegisters
   \   0000004E   0x9001             STR      R0,[SP, #+4]
   \   00000050   0x....             LDR.N    R0,??DataTable95
   \   00000052   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000056   0x8001             STRH     R1,[R0, #+0]
   3062            
   3063          }
   \   00000058   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   3064          
   3065          /**
   3066          * @brief  Get the the synthesizer reference divider state.
   3067          * @param  void.
   3068          * @retval None.
   3069          */

   \                                 In section .text, align 2, keep-with-next
   3070          SpiritFunctionalState SpiritRadioGetDigDiv(void)
   3071          {
   \                     SpiritRadioGetDigDiv: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   3072            uint8_t tempRegValue;
   3073            
   3074            g_xStatus = SpiritSpiReadRegisters(XO_RCO_TEST_BASE, 1, &tempRegValue);
   \   00000004   0xAA00             ADD      R2,SP,#+0
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x20B4             MOVS     R0,#+180
   \   0000000A   0x.... 0x....      BL       SdkEvalSpiReadRegisters
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0x....             LDR.N    R0,??DataTable95
   \   00000012   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000016   0x8001             STRH     R1,[R0, #+0]
   3075            
   3076            if(((tempRegValue>>3)&0x1))
   \   00000018   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001C   0xF3C0 0x00C0      UBFX     R0,R0,#+3,#+1
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD001             BEQ.N    ??SpiritRadioGetDigDiv_0
   3077            {
   3078              return S_DISABLE;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE000             B.N      ??SpiritRadioGetDigDiv_1
   3079            }
   3080            else
   3081            {
   3082              return S_ENABLE;
   \                     ??SpiritRadioGetDigDiv_0: (+1)
   \   0000002A   0x2001             MOVS     R0,#+1
   \                     ??SpiritRadioGetDigDiv_1: (+1)
   \   0000002C   0xBD0E             POP      {R1-R3,PC}       ;; return
   3083            }
   3084            
   3085          }
   3086          
   3087          /**
   3088          * @brief  Returns the XTAL frequency.
   3089          * @param  void.
   3090          * @retval uint32_t XTAL frequency.
   3091          */

   \                                 In section .text, align 2, keep-with-next
   3092          uint32_t SpiritRadioGetXtalFrequency(void)
   3093          {
   3094            return s_lXtalFrequency; 
   \                     SpiritRadioGetXtalFrequency: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable95_2
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   3095          }
   3096          
   3097          /**
   3098          * @brief  Sets the XTAL frequency.
   3099          * @param  uint32_t XTAL frequency.
   3100          * @retval void.
   3101          */

   \                                 In section .text, align 2, keep-with-next
   3102          void SpiritRadioSetXtalFrequency(uint32_t lXtalFrequency)
   3103          {
   3104            s_lXtalFrequency = lXtalFrequency; 
   \                     SpiritRadioSetXtalFrequency: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable95_2
   \   00000002   0x6008             STR      R0,[R1, #+0]
   3105          }
   \   00000004   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x412E8480         DC32     0x412e8480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x2E5F5680         DC32     0x2e5f5680

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x390C2FE1         DC32     0x390c2fe1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x1701E480         DC32     0x1701e480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x1C146A61         DC32     0x1c146a61

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x11D260C0         DC32     0x11d260c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \   00000000   0x0007C831         DC32     0x7c831

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x14CED7E1         DC32     0x14ced7e1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x08E18F40         DC32     0x8e18f40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x0A6FD061         DC32     0xa6fd061

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x........         DC32     s_lXtalFrequency

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x........         DC32     g_xStatus

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0x02DC6C00         DC32     0x2dc6c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \   00000000   0x000C3564         DC32     0xc3564

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x016E3600         DC32     0x16e3600

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x017D7840         DC32     0x17d7840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   0x018CBA80         DC32     0x18cba80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \   00000000   0x02FAF080         DC32     0x2faf080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \   00000000   0x03197500         DC32     0x3197500

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_5:
   \   00000000   0x018CBA81         DC32     0x18cba81

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x........         DC32     s_vectcBHalfFactor

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0x........         DC32     s_vectnBandwidth26M

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \   00000000   0x40590000         DC32     0x40590000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_3:
   \   00000000   0x........         DC32     s_lXtalFrequency

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x4178CBA8         DC32     0x4178cba8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   0x........         DC32     s_vectnVCOFreq

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   0x........         DC32     s_vectcBandRegValue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \   00000000   0x........         DC32     g_xStatus

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \   00000000   0x412E8480         DC32     0x412e8480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31:
   \   00000000   0x2E5F5680         DC32     0x2e5f5680

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_1:
   \   00000000   0x390C2FE1         DC32     0x390c2fe1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_2:
   \   00000000   0x1701E480         DC32     0x1701e480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_3:
   \   00000000   0x1C146A61         DC32     0x1c146a61

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_4:
   \   00000000   0x11D260C0         DC32     0x11d260c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_5:
   \   00000000   0x14CED7E1         DC32     0x14ced7e1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_6:
   \   00000000   0x08E18F40         DC32     0x8e18f40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_7:
   \   00000000   0x0A6FD061         DC32     0xa6fd061

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_8:
   \   00000000   0x099CF4E2         DC32     0x99cf4e2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_9:
   \   00000000   0x1339E9C4         DC32     0x1339e9c4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_10:
   \   00000000   0x19A28D06         DC32     0x19a28d06

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_11:
   \   00000000   0x33451A0B         DC32     0x33451a0b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32:
   \   00000000   0x0007C831         DC32     0x7c831

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33:
   \   00000000   0x........         DC32     s_lXtalFrequency

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33_1:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33_2:
   \   00000000   0x000C3564         DC32     0xc3564

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35:
   \   00000000   0x........         DC32     s_vectnBandwidth26M

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46:
   \   00000000   0x40590000         DC32     0x40590000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable54:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable55:
   \   00000000   0x4178CBA8         DC32     0x4178cba8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable55_1:
   \   00000000   0xC1F80000         DC32     0xc1f80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable55_2:
   \   00000000   0x41400001         DC32     0x41400001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable56:
   \   00000000   0x573EAB36         DC32     0x573eab36

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable56_1:
   \   00000000   0x4022D15B         DC32     0x4022d15b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable56_2:
   \   00000000   0xC28F5C29         DC32     0xc28f5c29

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57:
   \   00000000   0x........         DC32     g_xStatus

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57_1:
   \   00000000   0x402828F5         DC32     0x402828f5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57_2:
   \   00000000   0xCFB762D8         DC32     0xcfb762d8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57_3:
   \   00000000   0x3FB5332A         DC32     0x3fb5332a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable58:
   \   00000000   0x0346DC5D         DC32     0x346dc5d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable58_1:
   \   00000000   0x3FF10B78         DC32     0x3ff10b78

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable60:
   \   00000000   0xCFD4BF0A         DC32     0xcfd4bf0a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable60_1:
   \   00000000   0x3FEA8A9B         DC32     0x3fea8a9b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable60_2:
   \   00000000   0x4189374C         DC32     0x4189374c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable60_3:
   \   00000000   0x403C2560         DC32     0x403c2560

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable60_4:
   \   00000000   0xDB22D0E5         DC32     0xdb22d0e5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable60_5:
   \   00000000   0x40471EF9         DC32     0x40471ef9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable62:
   \   00000000   0x........         DC32     g_xStatus

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable62_1:
   \   00000000   0x353F7CEE         DC32     0x353f7cee

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable62_2:
   \   00000000   0xC046BA5E         DC32     0xc046ba5e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable62_3:
   \   00000000   0xD4FDF3B6         DC32     0xd4fdf3b6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable62_4:
   \   00000000   0x403A0978         DC32     0x403a0978

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable62_5:
   \   00000000   0xAA79BBAE         DC32     0xaa79bbae

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable63:
   \   00000000   0x3FC66E43         DC32     0x3fc66e43

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable64:
   \   00000000   0xF36262CC         DC32     0xf36262cc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable64_1:
   \   00000000   0x3FE46D71         DC32     0x3fe46d71

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable65:
   \   00000000   0x2A305532         DC32     0x2a305532

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable65_1:
   \   00000000   0x3FF013A9         DC32     0x3ff013a9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable65_2:
   \   00000000   0xFDF3B646         DC32     0xfdf3b646

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable65_3:
   \   00000000   0x402478D4         DC32     0x402478d4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable65_4:
   \   00000000   0x6CF41F21         DC32     0x6cf41f21

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable68:
   \   00000000   0xC0217D56         DC32     0xc0217d56

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable71:
   \   00000000   0xC046C000         DC32     0xc046c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable71_1:
   \   00000000   0x403A2000         DC32     0x403a2000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable71_2:
   \   00000000   0xE1FF63F9         DC32     0xe1ff63f9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable71_3:
   \   00000000   0xBF72A553         DC32     0xbf72a553

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable71_4:
   \   00000000   0xD234EB9A         DC32     0xd234eb9a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable71_5:
   \   00000000   0x3FE37952         DC32     0x3fe37952

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable71_6:
   \   00000000   0x21FF2E49         DC32     0x21ff2e49

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72:
   \   00000000   0x3FD5F6FD         DC32     0x3fd5f6fd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72_1:
   \   00000000   0x45A1CAC1         DC32     0x45a1cac1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72_2:
   \   00000000   0x4025F3B6         DC32     0x4025f3b6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72_3:
   \   00000000   0xED916873         DC32     0xed916873

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable76:
   \   00000000   0xC0221F7C         DC32     0xc0221f7c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable95:
   \   00000000   0x........         DC32     g_xStatus

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable95_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable95_2:
   \   00000000   0x........         DC32     s_lXtalFrequency

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable95_3:
   \   00000000   0x40240000         DC32     0x40240000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable95_4:
   \   00000000   0x40280000         DC32     0x40280000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable95_5:
   \   00000000   0x41180000         DC32     0x41180000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable95_6:
   \   00000000   0x412E8480         DC32     0x412e8480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable95_7:
   \   00000000   0x4087A000         DC32     0x4087a000

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x45 0x3A          DC8 45H, 3AH, 5CH, 41H, 43H, 51H, 5CH, 50H
   \              0x5C 0x41    
   \              0x43 0x51    
   \              0x5C 0x50    
   \   00000008   0x72 0x6F          DC8 72H, 6FH, 6AH, 5FH, 76H, 65H, 72H, 30H
   \              0x6A 0x5F    
   \              0x76 0x65    
   \              0x72 0x30    
   \   00000010   0x39 0x61          DC8 39H, 61H, 5FH, 31H, 35H, 31H, 30H, 32H
   \              0x5F 0x31    
   \              0x35 0x31    
   \              0x30 0x32    
   \   00000018   0x30 0x31          DC8 30H, 31H, 35H, 5CH, 42H, 61H, 73H, 65H
   \              0x35 0x5C    
   \              0x42 0x61    
   \              0x73 0x65    
   \   00000020   0x5F 0x30          DC8 5FH, 30H, 32H, 5CH, 32H, 30H, 31H, 33H
   \              0x32 0x5C    
   \              0x32 0x30    
   \              0x31 0x33    
   \   00000028   0x5F 0x31          DC8 5FH, 31H, 31H, 5FH, 32H, 35H, 5FH, 53H
   \              0x31 0x5F    
   \              0x32 0x35    
   \              0x5F 0x53    
   \   00000030   0x70 0x69          DC8 70H, 69H, 72H, 69H, 74H, 31H, 5FH, 45H
   \              0x72 0x69    
   \              0x74 0x31    
   \              0x5F 0x45    
   \   00000038   0x6C 0x65          DC8 6CH, 65H, 6BH, 74H, 72H, 6FH, 6CH, 75H
   \              0x6B 0x74    
   \              0x72 0x6F    
   \              0x6C 0x75    
   \   00000040   0x78 0x5C          DC8 78H, 5CH, 53H, 50H, 49H, 52H, 49H, 54H
   \              0x53 0x50    
   \              0x49 0x52    
   \              0x49 0x54    
   \   00000048   0x31 0x5F          DC8 31H, 5FH, 4CH, 69H, 62H, 72H, 61H, 72H
   \              0x4C 0x69    
   \              0x62 0x72    
   \              0x61 0x72    
   \   00000050   0x79 0x5F          DC8 79H, 5FH, 50H, 72H, 6FH, 6AH, 65H, 63H
   \              0x50 0x72    
   \              0x6F 0x6A    
   \              0x65 0x63    
   \   00000058   0x74 0x5C          DC8 74H, 5CH, 53H, 50H, 49H, 52H, 49H, 54H
   \              0x53 0x50    
   \              0x49 0x52    
   \              0x49 0x54    
   \   00000060   0x31 0x5F          DC8 31H, 5FH, 4CH, 69H, 62H, 72H, 61H, 72H
   \              0x4C 0x69    
   \              0x62 0x72    
   \              0x61 0x72    
   \   00000068   0x79 0x5C          DC8 79H, 5CH, 53H, 6FH, 75H, 72H, 63H, 65H
   \              0x53 0x6F    
   \              0x75 0x72    
   \              0x63 0x65    
   \   00000070   0x5C 0x73          DC8 5CH, 73H, 72H, 63H, 5CH, 53H, 50H, 49H
   \              0x72 0x63    
   \              0x5C 0x53    
   \              0x50 0x49    
   \   00000078   0x52 0x49          DC8 52H, 49H, 54H, 5FH, 52H, 61H, 64H, 69H
   \              0x54 0x5F    
   \              0x52 0x61    
   \              0x64 0x69    
   \   00000080   0x6F 0x2E          DC8 6FH, 2EH, 63H, 0
   \              0x63 0x00    
   3106          
   3107          /**
   3108          * @}
   3109          */
   3110          
   3111          
   3112          /**
   3113          * @}
   3114          */
   3115          
   3116          
   3117          /**
   3118          * @}
   3119          */
   3120          
   3121          
   3122          
   3123          /******************* (C) COPYRIGHT 2012 STMicroelectronics *****END OF FILE****/
   3124          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   SpiritRadioAFC
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      16   SpiritRadioAFCFreezeOnSync
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      16   SpiritRadioAGC
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      16   SpiritRadioAGCFreezeOnSteady
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      16   SpiritRadioAGCFreezeOnSync
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      16   SpiritRadioAGCStartMaxAttenuation
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      16   SpiritRadioAutoSetFOffset
        16   -> SpiritRadioGetAFCCorrectionHz
        16   -> SpiritRadioGetFrequencyOffset
        16   -> SpiritRadioSetFrequencyOffset
      16   SpiritRadioCWTransmitMode
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      16   SpiritRadioCsBlanking
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      16   SpiritRadioGetAFCCorrectionHz
        16   -> SpiritRadioGetAFCCorrectionReg
        16   -> __aeabi_d2iz
        16   -> __aeabi_ddiv
        16   -> __aeabi_dmul
        16   -> __aeabi_i2d
        16   -> __aeabi_ui2d
        16   -> pow
      16   SpiritRadioGetAFCCorrectionReg
        16   -> SdkEvalSpiReadRegisters
      16   SpiritRadioGetAFCFastGain
        16   -> SdkEvalSpiReadRegisters
      16   SpiritRadioGetAFCFastPeriod
        16   -> SdkEvalSpiReadRegisters
      16   SpiritRadioGetAFCMode
        16   -> SdkEvalSpiReadRegisters
      16   SpiritRadioGetAFCPDLeakage
        16   -> SdkEvalSpiReadRegisters
      16   SpiritRadioGetAFCSlowGain
        16   -> SdkEvalSpiReadRegisters
      16   SpiritRadioGetAGCHighThreshold
        16   -> SdkEvalSpiReadRegisters
      16   SpiritRadioGetAGCHoldTime
        16   -> SdkEvalSpiReadRegisters
      24   SpiritRadioGetAGCHoldTimeUs
        24   -> SdkEvalSpiReadRegisters
        24   -> __aeabi_d2f
        24   -> __aeabi_ddiv
        24   -> __aeabi_dmul
        24   -> __aeabi_ui2d
        24   -> lroundf
      16   SpiritRadioGetAGCLowThreshold
        16   -> SdkEvalSpiReadRegisters
      16   SpiritRadioGetAGCMeasureTime
        16   -> SdkEvalSpiReadRegisters
      24   SpiritRadioGetAGCMeasureTimeUs
        24   -> SdkEvalSpiReadRegisters
        24   -> __aeabi_d2f
        24   -> __aeabi_d2iz
        24   -> __aeabi_ddiv
        24   -> __aeabi_dmul
        24   -> __aeabi_f2d
        24   -> __aeabi_ui2d
        24   -> pow
      16   SpiritRadioGetAGCMode
        16   -> SdkEvalSpiReadRegisters
      16   SpiritRadioGetBand
        16   -> SdkEvalSpiReadRegisters
      24   SpiritRadioGetCenterFrequency
        24   -> SpiritRadioGetChannel
        24   -> SpiritRadioGetChannelSpace
        24   -> SpiritRadioGetFrequencyBase
        24   -> SpiritRadioGetFrequencyOffset
      16   SpiritRadioGetChannel
        16   -> SdkEvalSpiReadRegisters
      24   SpiritRadioGetChannelBW
        24   -> SdkEvalSpiReadRegisters
        24   -> __aeabi_d2uiz
        24   -> __aeabi_ddiv
        24   -> __aeabi_dmul
        24   -> __aeabi_ui2d
      16   SpiritRadioGetChannelSpace
        16   -> SdkEvalSpiReadRegisters
      16   SpiritRadioGetClkRecIGain
        16   -> SdkEvalSpiReadRegisters
      16   SpiritRadioGetClkRecMode
        16   -> SdkEvalSpiReadRegisters
      16   SpiritRadioGetClkRecPGain
        16   -> SdkEvalSpiReadRegisters
      16   SpiritRadioGetClkRecPstFltLength
        16   -> SdkEvalSpiReadRegisters
      16   SpiritRadioGetDatarate
        16   -> SdkEvalSpiReadRegisters
        16   -> SpiritGeneralGetSpiritVersion
        16   -> SpiritRadioGetDigDiv
      16   SpiritRadioGetDigDiv
        16   -> SdkEvalSpiReadRegisters
      32   SpiritRadioGetFrequencyBase
        32   -> SpiritRadioGetBand
        32   -> SpiritRadioGetRefDiv
        32   -> SpiritRadioGetSynthWord
        32   -> __aeabi_d2uiz
        32   -> __aeabi_ddiv
        32   -> __aeabi_dmul
        32   -> __aeabi_i2d
        32   -> __aeabi_ui2d
        32   -> round
      24   SpiritRadioGetFrequencyDev
        24   -> SdkEvalSpiReadRegisters
        24   -> SpiritGeneralGetSpiritVersion
      16   SpiritRadioGetFrequencyOffset
        16   -> SdkEvalSpiReadRegisters
      64   SpiritRadioGetInfo
        64   -> SdkEvalSpiReadRegisters
        64   -> SpiritGeneralGetSpiritVersion
        64   -> SpiritRadioGetChannel
        64   -> SpiritRadioGetDigDiv
        64   -> SpiritRadioGetRefDiv
        64   -> __aeabi_d2iz
        64   -> __aeabi_d2uiz
        64   -> __aeabi_ddiv
        64   -> __aeabi_dmul
        64   -> __aeabi_i2d
        64   -> __aeabi_ui2d
        64   -> round
      16   SpiritRadioGetModulation
        16   -> SdkEvalSpiReadRegisters
      16   SpiritRadioGetOokPeakDecay
        16   -> SdkEvalSpiReadRegisters
      16   SpiritRadioGetPACwc
        16   -> SdkEvalSpiReadRegisters
      24   SpiritRadioGetPALevel
        24   -> SdkEvalSpiReadRegisters
        24   -> s_assert_failed
      16   SpiritRadioGetPALevelMaxIndex
        16   -> SdkEvalSpiReadRegisters
      40   SpiritRadioGetPALeveldBm
        40   -> SdkEvalSpiReadRegisters
        40   -> __aeabi_d2f
        40   -> __aeabi_dadd
        40   -> __aeabi_ddiv
        40   -> __aeabi_dmul
        40   -> __aeabi_dsub
        40   -> __aeabi_f2d
        40   -> __aeabi_ui2d
        40   -> s_assert_failed
      16   SpiritRadioGetPARamping
        16   -> SdkEvalSpiReadRegisters
      16   SpiritRadioGetPAStepWidth
        16   -> SdkEvalSpiReadRegisters
      32   SpiritRadioGetPATable
        32   -> SdkEvalSpiReadRegisters
      56   SpiritRadioGetPATabledBm
        56   -> SdkEvalSpiReadRegisters
        56   -> __aeabi_d2f
        56   -> __aeabi_dadd
        56   -> __aeabi_ddiv
        56   -> __aeabi_dmul
        56   -> __aeabi_dsub
        56   -> __aeabi_f2d
        56   -> __aeabi_ui2d
      16   SpiritRadioGetRefDiv
        16   -> SdkEvalSpiReadRegisters
      16   SpiritRadioGetSynthWord
        16   -> SdkEvalSpiReadRegisters
      16   SpiritRadioGetXtalFlag
        16   -> SdkEvalSpiReadRegisters
       0   SpiritRadioGetXtalFrequency
      48   SpiritRadioInit
        48   -> SdkEvalSpiCommandStrobes
        48   -> SdkEvalSpiReadRegisters
        48   -> SdkEvalSpiWriteRegisters
        48   -> SpiritGeneralGetSpiritVersion
        48   -> SpiritManagementWaTRxFcMem
        48   -> SpiritRadioAFCFreezeOnSync
        48   -> SpiritRadioSearchChannelBwME
        48   -> SpiritRadioSearchDatarateME
        48   -> SpiritRadioSearchFreqDevME
        48   -> SpiritRadioSetDigDiv
        48   -> SpiritRadioSetFrequencyBase
        48   -> SpiritRadioSetXtalFlag
        48   -> SpiritRefreshStatus
        48   -> __aeabi_d2iz
        48   -> __aeabi_ddiv
        48   -> __aeabi_ui2d
        48   -> s_assert_failed
      16   SpiritRadioPARamping
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      16   SpiritRadioPersistenRx
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      48   SpiritRadioSearchChannelBwME
        48   -> SpiritGeneralGetSpiritVersion
        48   -> SpiritRadioGetDigDiv
        48   -> s_assert_failed
      40   SpiritRadioSearchDatarateME
        40   -> SpiritGeneralGetSpiritVersion
        40   -> SpiritRadioGetDigDiv
        40   -> s_assert_failed
      40   SpiritRadioSearchFreqDevME
        40   -> SpiritGeneralGetSpiritVersion
        40   -> s_assert_failed
      32   SpiritRadioSearchWCP
        32   -> s_assert_failed
      16   SpiritRadioSetAFCFastGain
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      16   SpiritRadioSetAFCFastPeriod
        16   -> SdkEvalSpiWriteRegisters
      16   SpiritRadioSetAFCMode
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      16   SpiritRadioSetAFCPDLeakage
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      16   SpiritRadioSetAFCSlowGain
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      16   SpiritRadioSetAGCHighThreshold
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      16   SpiritRadioSetAGCHoldTime
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      32   SpiritRadioSetAGCHoldTimeUs
        32   -> SdkEvalSpiReadRegisters
        32   -> SdkEvalSpiWriteRegisters
        32   -> __aeabi_d2f
        32   -> __aeabi_ddiv
        32   -> __aeabi_dmul
        32   -> __aeabi_f2d
        32   -> __aeabi_ui2d
        32   -> __aeabi_ui2f
        32   -> lroundf
        32   -> s_assert_failed
        32 __aeabi_cdrcmple
      16   SpiritRadioSetAGCLowThreshold
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      16   SpiritRadioSetAGCMeasureTime
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      32   SpiritRadioSetAGCMeasureTimeUs
        32   -> SdkEvalSpiReadRegisters
        32   -> SdkEvalSpiWriteRegisters
        32   -> __aeabi_d2f
        32   -> __aeabi_ddiv
        32   -> __aeabi_dmul
        32   -> __aeabi_f2d
        32   -> __aeabi_ui2d
        32   -> __aeabi_ui2f
        32   -> log2
        32   -> lroundf
        32   -> s_assert_failed
        32 __aeabi_cdrcmple
      16   SpiritRadioSetAGCMode
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      16   SpiritRadioSetBand
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      16   SpiritRadioSetChannel
        16   -> SdkEvalSpiWriteRegisters
      16   SpiritRadioSetChannelBW
        16   -> SdkEvalSpiWriteRegisters
        16   -> SpiritGeneralGetSpiritVersion
        16   -> SpiritRadioGetDigDiv
        16   -> SpiritRadioSearchChannelBwME
        16   -> s_assert_failed
      16   SpiritRadioSetChannelSpace
        16   -> SdkEvalSpiWriteRegisters
      16   SpiritRadioSetClkRecIGain
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      16   SpiritRadioSetClkRecMode
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      16   SpiritRadioSetClkRecPGain
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      16   SpiritRadioSetClkRecPstFltLength
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      16   SpiritRadioSetDatarate
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> SpiritRadioSearchDatarateME
        16   -> s_assert_failed
      16   SpiritRadioSetDigDiv
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      64   SpiritRadioSetFrequencyBase
        64   -> SdkEvalSpiWriteRegisters
        64   -> SpiritCalibrationSelectVco
        64   -> SpiritGeneralGetSpiritVersion
        64   -> SpiritManagementWaVcoCalibration
        64   -> SpiritRadioGetChannel
        64   -> SpiritRadioGetChannelSpace
        64   -> SpiritRadioGetFrequencyOffset
        64   -> SpiritRadioGetRefDiv
        64   -> SpiritRadioSearchWCP
        64   -> __aeabi_d2uiz
        64   -> __aeabi_ddiv
        64   -> __aeabi_dmul
        64   -> __aeabi_i2d
        64   -> __aeabi_ui2d
        64   -> s_assert_failed
      16   SpiritRadioSetFrequencyDev
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> SpiritRadioSearchFreqDevME
        16   -> s_assert_failed
      24   SpiritRadioSetFrequencyOffset
        24   -> SdkEvalSpiWriteRegisters
        24   -> s_assert_failed
      40   SpiritRadioSetFrequencyOffsetPpm
        40   -> SdkEvalSpiWriteRegisters
        40   -> SpiritRadioGetBand
        40   -> SpiritRadioGetRefDiv
        40   -> SpiritRadioGetSynthWord
        40   -> __aeabi_d2iz
        40   -> __aeabi_ddiv
        40   -> __aeabi_ui2d
        40   -> s_assert_failed
      16   SpiritRadioSetModulation
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      16   SpiritRadioSetOokPeakDecay
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      16   SpiritRadioSetPACwc
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      24   SpiritRadioSetPALevel
        24   -> SdkEvalSpiWriteRegisters
        24   -> s_assert_failed
      16   SpiritRadioSetPALevelMaxIndex
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      48   SpiritRadioSetPALeveldBm
        48   -> SdkEvalSpiWriteRegisters
        48   -> __aeabi_d2f
        48   -> __aeabi_d2iz
        48   -> __aeabi_dadd
        48   -> __aeabi_ddiv
        48   -> __aeabi_dmul
        48   -> __aeabi_dsub
        48   -> __aeabi_f2d
        48   -> round
        48   -> s_assert_failed
        48 __aeabi_cfcmple
        48 __aeabi_cfrcmple
      16   SpiritRadioSetPAStepWidth
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      48   SpiritRadioSetPATable
        48   -> SdkEvalSpiWriteRegisters
        48   -> s_assert_failed
      72   SpiritRadioSetPATabledBm
        72   -> SdkEvalSpiWriteRegisters
        72   -> __aeabi_d2f
        72   -> __aeabi_d2iz
        72   -> __aeabi_dadd
        72   -> __aeabi_ddiv
        72   -> __aeabi_dmul
        72   -> __aeabi_dsub
        72   -> __aeabi_f2d
        72   -> round
        72   -> s_assert_failed
        72 __aeabi_cfcmple
        72 __aeabi_cfrcmple
      16   SpiritRadioSetRefDiv
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
      24   SpiritRadioSetSynthWord
        24   -> SdkEvalSpiReadRegisters
        24   -> SdkEvalSpiWriteRegisters
      16   SpiritRadioSetXtalFlag
        16   -> SdkEvalSpiReadRegisters
        16   -> SdkEvalSpiWriteRegisters
        16   -> s_assert_failed
       0   SpiritRadioSetXtalFrequency


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable17_3
       4  ??DataTable17_4
       4  ??DataTable17_5
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable19
       4  ??DataTable23
       4  ??DataTable24
       4  ??DataTable26
       4  ??DataTable27
       4  ??DataTable30
       4  ??DataTable31
       4  ??DataTable31_1
       4  ??DataTable31_10
       4  ??DataTable31_11
       4  ??DataTable31_2
       4  ??DataTable31_3
       4  ??DataTable31_4
       4  ??DataTable31_5
       4  ??DataTable31_6
       4  ??DataTable31_7
       4  ??DataTable31_8
       4  ??DataTable31_9
       4  ??DataTable32
       4  ??DataTable33
       4  ??DataTable33_1
       4  ??DataTable33_2
       4  ??DataTable35
       4  ??DataTable46
       4  ??DataTable54
       4  ??DataTable55
       4  ??DataTable55_1
       4  ??DataTable55_2
       4  ??DataTable56
       4  ??DataTable56_1
       4  ??DataTable56_2
       4  ??DataTable57
       4  ??DataTable57_1
       4  ??DataTable57_2
       4  ??DataTable57_3
       4  ??DataTable58
       4  ??DataTable58_1
       4  ??DataTable60
       4  ??DataTable60_1
       4  ??DataTable60_2
       4  ??DataTable60_3
       4  ??DataTable60_4
       4  ??DataTable60_5
       4  ??DataTable62
       4  ??DataTable62_1
       4  ??DataTable62_2
       4  ??DataTable62_3
       4  ??DataTable62_4
       4  ??DataTable62_5
       4  ??DataTable63
       4  ??DataTable64
       4  ??DataTable64_1
       4  ??DataTable65
       4  ??DataTable65_1
       4  ??DataTable65_2
       4  ??DataTable65_3
       4  ??DataTable65_4
       4  ??DataTable68
       4  ??DataTable71
       4  ??DataTable71_1
       4  ??DataTable71_2
       4  ??DataTable71_3
       4  ??DataTable71_4
       4  ??DataTable71_5
       4  ??DataTable71_6
       4  ??DataTable72
       4  ??DataTable72_1
       4  ??DataTable72_2
       4  ??DataTable72_3
       4  ??DataTable76
       4  ??DataTable95
       4  ??DataTable95_1
       4  ??DataTable95_2
       4  ??DataTable95_3
       4  ??DataTable95_4
       4  ??DataTable95_5
       4  ??DataTable95_6
       4  ??DataTable95_7
     132  ?_0
      98  SpiritRadioAFC
      96  SpiritRadioAFCFreezeOnSync
     100  SpiritRadioAGC
     100  SpiritRadioAGCFreezeOnSteady
     100  SpiritRadioAGCFreezeOnSync
     100  SpiritRadioAGCStartMaxAttenuation
      24  SpiritRadioAutoSetFOffset
      92  SpiritRadioCWTransmitMode
      90  SpiritRadioCsBlanking
      96  SpiritRadioGetAFCCorrectionHz
      34  SpiritRadioGetAFCCorrectionReg
      36  SpiritRadioGetAFCFastGain
      32  SpiritRadioGetAFCFastPeriod
      36  SpiritRadioGetAFCMode
      36  SpiritRadioGetAFCPDLeakage
      36  SpiritRadioGetAFCSlowGain
      36  SpiritRadioGetAGCHighThreshold
      36  SpiritRadioGetAGCHoldTime
     104  SpiritRadioGetAGCHoldTimeUs
      36  SpiritRadioGetAGCLowThreshold
      36  SpiritRadioGetAGCMeasureTime
     122  SpiritRadioGetAGCMeasureTimeUs
      36  SpiritRadioGetAGCMode
      78  SpiritRadioGetBand
      36  SpiritRadioGetCenterFrequency
      30  SpiritRadioGetChannel
     114  SpiritRadioGetChannelBW
      38  SpiritRadioGetChannelSpace
      34  SpiritRadioGetClkRecIGain
      34  SpiritRadioGetClkRecMode
      34  SpiritRadioGetClkRecPGain
      34  SpiritRadioGetClkRecPstFltLength
      84  SpiritRadioGetDatarate
      46  SpiritRadioGetDigDiv
      98  SpiritRadioGetFrequencyBase
      84  SpiritRadioGetFrequencyDev
      72  SpiritRadioGetFrequencyOffset
     580  SpiritRadioGetInfo
      36  SpiritRadioGetModulation
      36  SpiritRadioGetOokPeakDecay
      36  SpiritRadioGetPACwc
      60  SpiritRadioGetPALevel
      36  SpiritRadioGetPALevelMaxIndex
     336  SpiritRadioGetPALeveldBm
      38  SpiritRadioGetPARamping
      52  SpiritRadioGetPAStepWidth
      62  SpiritRadioGetPATable
     356  SpiritRadioGetPATabledBm
      46  SpiritRadioGetRefDiv
      60  SpiritRadioGetSynthWord
      38  SpiritRadioGetXtalFlag
       6  SpiritRadioGetXtalFrequency
    1532  SpiritRadioInit
      98  SpiritRadioPARamping
      90  SpiritRadioPersistenRx
     552  SpiritRadioSearchChannelBwME
     346  SpiritRadioSearchDatarateME
     360  SpiritRadioSearchFreqDevME
     472  SpiritRadioSearchWCP
      86  SpiritRadioSetAFCFastGain
      28  SpiritRadioSetAFCFastPeriod
      98  SpiritRadioSetAFCMode
      82  SpiritRadioSetAFCPDLeakage
      84  SpiritRadioSetAFCSlowGain
      80  SpiritRadioSetAGCHighThreshold
      78  SpiritRadioSetAGCHoldTime
     202  SpiritRadioSetAGCHoldTimeUs
      78  SpiritRadioSetAGCLowThreshold
      78  SpiritRadioSetAGCMeasureTime
     206  SpiritRadioSetAGCMeasureTimeUs
     100  SpiritRadioSetAGCMode
     114  SpiritRadioSetBand
      28  SpiritRadioSetChannel
     218  SpiritRadioSetChannelBW
      48  SpiritRadioSetChannelSpace
      74  SpiritRadioSetClkRecIGain
      80  SpiritRadioSetClkRecMode
      76  SpiritRadioSetClkRecPGain
      80  SpiritRadioSetClkRecPstFltLength
     100  SpiritRadioSetDatarate
      90  SpiritRadioSetDigDiv
     504  SpiritRadioSetFrequencyBase
     122  SpiritRadioSetFrequencyDev
     120  SpiritRadioSetFrequencyOffset
     196  SpiritRadioSetFrequencyOffsetPpm
     100  SpiritRadioSetModulation
      94  SpiritRadioSetOokPeakDecay
      96  SpiritRadioSetPACwc
      76  SpiritRadioSetPALevel
      76  SpiritRadioSetPALevelMaxIndex
     406  SpiritRadioSetPALeveldBm
      86  SpiritRadioSetPAStepWidth
     194  SpiritRadioSetPATable
     538  SpiritRadioSetPATabledBm
      90  SpiritRadioSetRefDiv
      94  SpiritRadioSetSynthWord
     112  SpiritRadioSetXtalFlag
       6  SpiritRadioSetXtalFrequency
       4  s_lXtalFrequency
       4  s_vectcBHalfFactor
       4  s_vectcBandRegValue
     180  s_vectnBandwidth26M
      32  s_vectnVCOFreq

 
      4 bytes in section .bss
    352 bytes in section .rodata
 12 990 bytes in section .text
 
 12 990 bytes of CODE  memory
    352 bytes of CONST memory
      4 bytes of DATA  memory

Errors: none
Warnings: none
