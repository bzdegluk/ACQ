###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        20/Nov/2015  05:05:38
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_adc.c
#    Command line =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_adc.c
#        -D USE_STDPERIPH_DRIVER -D VECT_TAB_FLASH -D STM32L1XX_MD -D
#        IAR_ARM_CM3 -D USE_FULL_ASSERT -D SPIRIT_USE_FULL_ASSERT -D
#        USE_SYSTICK_DELAY -D SDK -lC
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\List\
#        -o
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\.\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\examples\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\runtime\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\SDK_Eval_STM32L\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\SPIRIT1_Library\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\SDK_Eval_Util\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\SDK_Virtual_Com\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32_USB-FS-Device_Lib\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\ACQ\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\CMSIS\Include\"
#    List file    =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\List\stm32l1xx_adc.lst
#    Object file  =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\Obj\stm32l1xx_adc.o
#
###############################################################################

E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_adc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_adc.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    31-December-2010
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Analog to Digital Convertor (ADC) peripheral:           
      9            *           - Initialization and Configuration
     10            *           - Power saving
     11            *           - Analog Watchdog configuration              
     12            *           - Temperature Sensor & Vrefint (Voltage Reference internal) management 
     13            *           - Regular Channels Configuration
     14            *           - Regular Channels DMA Configuration
     15            *           - Injected channels Configuration      
     16            *           - Interrupts and flags management       
     17            *         
     18            *  @verbatim
     19            *                               
     20            *          ===================================================================      
     21            *                                   How to use this driver
     22            *          ===================================================================          
     23            *            - Configure the ADC Prescaler, conversion resolution and data 
     24            *              alignment using the ADC_Init() function.
     25            *            - Activate the ADC peripheral using ADC_Cmd() function.  
     26            *
     27            *          Regular channels group configuration
     28            *          ====================================    
     29            *            - To configure the ADC regular channels group features, use 
     30            *              ADC_Init() and ADC_RegularChannelConfig() functions.
     31            *            - To activate the continuous mode, use the ADC_continuousModeCmd()
     32            *              function.
     33            *            - To configurate and activate the Discontinuous mode, use the 
     34            *              ADC_DiscModeChannelCountConfig() and ADC_DiscModeCmd() functions.        
     35            *            - To read the ADC converted values, use the ADC_GetConversionValue()
     36            *              function.
     37            *
     38            *          DMA for Regular channels group features configuration
     39            *          ====================================================== 
     40            *           - To enable the DMA mode for regular channels group, use the 
     41            *             ADC_DMACmd() function.
     42            *           - To enable the generation of DMA requests continuously at the end
     43            *             of the last DMA transfer, use the ADC_DMARequestAfterLastTransferCmd() 
     44            *             function.    
     45                       
     46            *          Injected channels group configuration
     47            *          =====================================    
     48            *            - To configure the ADC Injected channels group features, use 
     49            *              ADC_InjectedChannelConfig() and  ADC_InjectedSequencerLengthConfig()
     50            *              functions.
     51            *            - To activate the continuous mode, use the ADC_continuousModeCmd()
     52            *              function.
     53            *            - To activate the Injected Discontinuous mode, use the 
     54            *              ADC_InjectedDiscModeCmd() function.  
     55            *            - To activate the AutoInjected mode, use the ADC_AutoInjectedConvCmd() 
     56            *              function.        
     57            *            - To read the ADC converted values, use the ADC_GetInjectedConversionValue() 
     58            *              function.
     59            *              
     60            *  @endverbatim
     61            *         
     62            ******************************************************************************
     63            * @attention
     64            *
     65            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     66            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     67            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     68            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     69            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     70            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     71            *
     72            * <h2><center>&copy; COPYRIGHT 2010 STMicroelectronics</center></h2>
     73            ******************************************************************************  
     74            */ 
     75          
     76          /* Includes ------------------------------------------------------------------*/
     77          #include "stm32l1xx_adc.h"
     78          #include "stm32l1xx_rcc.h"
     79          
     80          /** @addtogroup STM32L1xx_StdPeriph_Driver
     81            * @{
     82            */
     83          
     84          /** @defgroup ADC 
     85            * @brief ADC driver modules
     86            * @{
     87            */
     88          
     89          /* Private typedef -----------------------------------------------------------*/
     90          /* Private define ------------------------------------------------------------*/
     91          /* ADC DISCNUM mask */
     92          #define CR1_DISCNUM_RESET         ((uint32_t)0xFFFF1FFF)
     93             
     94          /* ADC AWDCH mask */
     95          #define CR1_AWDCH_RESET           ((uint32_t)0xFFFFFFE0) 
     96            
     97          /* ADC Analog watchdog enable mode mask */
     98          #define CR1_AWDMODE_RESET         ((uint32_t)0xFF3FFDFF)
     99            
    100          /* CR1 register Mask */
    101          #define CR1_CLEAR_MASK            ((uint32_t)0xFCFFFEFF) 
    102             
    103          /* ADC DELAY mask */            
    104          #define CR2_DELS_RESET            ((uint32_t)0xFFFFFF0F)
    105             
    106          /* ADC JEXTEN mask */
    107          #define CR2_JEXTEN_RESET          ((uint32_t)0xFFCFFFFF)
    108            
    109          /* ADC JEXTSEL mask */
    110          #define CR2_JEXTSEL_RESET         ((uint32_t)0xFFF0FFFF)
    111            
    112          /* CR2 register Mask */
    113          #define CR2_CLEAR_MASK            ((uint32_t)0xC0FFF7FD)
    114          
    115          /* ADC SQx mask */
    116          #define SQR5_SQ_SET               ((uint32_t)0x0000001F)  
    117          #define SQR4_SQ_SET               ((uint32_t)0x0000001F)  
    118          #define SQR3_SQ_SET               ((uint32_t)0x0000001F)  
    119          #define SQR2_SQ_SET               ((uint32_t)0x0000001F)  
    120          #define SQR1_SQ_SET               ((uint32_t)0x0000001F)
    121          
    122          /* ADC L Mask */
    123          #define SQR1_L_RESET              ((uint32_t)0xFE0FFFFF) 
    124          
    125          /* ADC JSQx mask */
    126          #define JSQR_JSQ_SET              ((uint32_t)0x0000001F) 
    127           
    128          /* ADC JL mask */
    129          #define JSQR_JL_SET               ((uint32_t)0x00300000) 
    130          #define JSQR_JL_RESET             ((uint32_t)0xFFCFFFFF) 
    131          
    132          /* ADC SMPx mask */
    133          #define SMPR1_SMP_SET             ((uint32_t)0x00000007)  
    134          #define SMPR2_SMP_SET             ((uint32_t)0x00000007)
    135          #define SMPR3_SMP_SET             ((uint32_t)0x00000007) 
    136          
    137          /* ADC JDRx registers offset */
    138          #define JDR_OFFSET                ((uint8_t)0x30)   
    139            
    140          /* ADC CCR register Mask */
    141          #define CR_CLEAR_MASK             ((uint32_t)0xFFFCFFFF) 
    142          
    143          /* Private macro -------------------------------------------------------------*/
    144          /* Private variables ---------------------------------------------------------*/
    145          /* Private function prototypes -----------------------------------------------*/
    146          /* Private functions ---------------------------------------------------------*/
    147          
    148          /** @defgroup ADC_Private_Functions
    149            * @{
    150            */
    151          
    152          /** @defgroup ADC_Group1 Initialization and Configuration functions
    153           *  @brief   Initialization and Configuration functions 
    154           *
    155          @verbatim    
    156           ===============================================================================
    157                                Initialization and Configuration functions
    158           ===============================================================================  
    159            This section provides functions allowing to:
    160             - Initialize and configure the ADC Prescaler
    161             - ADC Conversion Resolution (12bit..6bit)
    162             - Scan Conversion Mode (multichannels or one channel) for regular group
    163             - ADC Continuous Conversion Mode (Continuous or Single conversion) for regular group
    164             - External trigger Edge and source of regular group, 
    165             - Converted data alignment (left or right)
    166             - The number of ADC conversions that will be done using the sequencer for regular channel group
    167             - Enable or disable the ADC peripheral
    168             
    169          @endverbatim
    170            * @{
    171            */
    172          
    173          /**
    174            * @brief  Deinitializes ADC1 peripheral registers to their default reset values.
    175            * @param  None
    176            * @retval None
    177            */

   \                                 In section .text, align 2, keep-with-next
    178          void ADC_DeInit(ADC_TypeDef* ADCx)
    179          {
   \                     ADC_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    180            /* Check the parameters */
    181            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable20  ;; 0x40012400
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD004             BEQ.N    ??ADC_DeInit_0
   \   0000000C   0x21B5             MOVS     R1,#+181
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000012   0x.... 0x....      BL       assert_failed
    182            
    183            /* Enable ADC1 reset state */
    184            RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);
   \                     ??ADC_DeInit_0: (+1)
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0xF44F 0x7000      MOV      R0,#+512
   \   0000001C   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    185            /* Release ADC1 from reset state */
    186            RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0xF44F 0x7000      MOV      R0,#+512
   \   00000026   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    187          }
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
    188          
    189          /**
    190            * @brief  Initializes the ADCx peripheral according to the specified parameters
    191            *         in the ADC_InitStruct.
    192            * @note   This function is used to configure the global features of the ADC ( 
    193            *         Resolution and Data Alignment), however, the rest of the configuration
    194            *         parameters are specific to the regular channels group (scan mode 
    195            *         activation, continuous mode activation, External trigger source and 
    196            *         edge, number of conversion in the regular channels group sequencer).   
    197            * @param  ADCx: where x can be 1 to select the ADC peripheral.
    198            * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains 
    199            *         the configuration information for the specified ADC peripheral.
    200            * @retval None
    201            */

   \                                 In section .text, align 2, keep-with-next
    202          void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)               
    203          {
   \                     ADC_Init: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    204            uint32_t tmpreg1 = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    205            uint8_t tmpreg2 = 0;
   \   00000008   0x2700             MOVS     R7,#+0
    206            
    207            /* Check the parameters */
    208            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable20  ;; 0x40012400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD004             BEQ.N    ??ADC_Init_0
   \   00000012   0x21D0             MOVS     R1,#+208
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000018   0x.... 0x....      BL       assert_failed
    209            assert_param(IS_ADC_RESOLUTION(ADC_InitStruct->ADC_Resolution)); 
   \                     ??ADC_Init_0: (+1)
   \   0000001C   0x6828             LDR      R0,[R5, #+0]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD010             BEQ.N    ??ADC_Init_1
   \   00000022   0x6828             LDR      R0,[R5, #+0]
   \   00000024   0xF1B0 0x7F80      CMP      R0,#+16777216
   \   00000028   0xD00C             BEQ.N    ??ADC_Init_1
   \   0000002A   0x6828             LDR      R0,[R5, #+0]
   \   0000002C   0xF1B0 0x7F00      CMP      R0,#+33554432
   \   00000030   0xD008             BEQ.N    ??ADC_Init_1
   \   00000032   0x6828             LDR      R0,[R5, #+0]
   \   00000034   0xF1B0 0x7F40      CMP      R0,#+50331648
   \   00000038   0xD004             BEQ.N    ??ADC_Init_1
   \   0000003A   0x21D1             MOVS     R1,#+209
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000040   0x.... 0x....      BL       assert_failed
    210            assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));
   \                     ??ADC_Init_1: (+1)
   \   00000044   0x7928             LDRB     R0,[R5, #+4]
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD007             BEQ.N    ??ADC_Init_2
   \   0000004A   0x7928             LDRB     R0,[R5, #+4]
   \   0000004C   0x2801             CMP      R0,#+1
   \   0000004E   0xD004             BEQ.N    ??ADC_Init_2
   \   00000050   0x21D2             MOVS     R1,#+210
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000056   0x.... 0x....      BL       assert_failed
    211            assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode)); 
   \                     ??ADC_Init_2: (+1)
   \   0000005A   0x7968             LDRB     R0,[R5, #+5]
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD007             BEQ.N    ??ADC_Init_3
   \   00000060   0x7968             LDRB     R0,[R5, #+5]
   \   00000062   0x2801             CMP      R0,#+1
   \   00000064   0xD004             BEQ.N    ??ADC_Init_3
   \   00000066   0x21D3             MOVS     R1,#+211
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable21
   \   0000006C   0x.... 0x....      BL       assert_failed
    212            assert_param(IS_ADC_EXT_TRIG_EDGE(ADC_InitStruct->ADC_ExternalTrigConvEdge)); 
   \                     ??ADC_Init_3: (+1)
   \   00000070   0x68A8             LDR      R0,[R5, #+8]
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD010             BEQ.N    ??ADC_Init_4
   \   00000076   0x68A8             LDR      R0,[R5, #+8]
   \   00000078   0xF1B0 0x5F80      CMP      R0,#+268435456
   \   0000007C   0xD00C             BEQ.N    ??ADC_Init_4
   \   0000007E   0x68A8             LDR      R0,[R5, #+8]
   \   00000080   0xF1B0 0x5F00      CMP      R0,#+536870912
   \   00000084   0xD008             BEQ.N    ??ADC_Init_4
   \   00000086   0x68A8             LDR      R0,[R5, #+8]
   \   00000088   0xF1B0 0x5F40      CMP      R0,#+805306368
   \   0000008C   0xD004             BEQ.N    ??ADC_Init_4
   \   0000008E   0x21D4             MOVS     R1,#+212
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000094   0x.... 0x....      BL       assert_failed
    213            assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));    
   \                     ??ADC_Init_4: (+1)
   \   00000098   0x68E8             LDR      R0,[R5, #+12]
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD030             BEQ.N    ??ADC_Init_5
   \   0000009E   0x68E8             LDR      R0,[R5, #+12]
   \   000000A0   0xF1B0 0x7F80      CMP      R0,#+16777216
   \   000000A4   0xD02C             BEQ.N    ??ADC_Init_5
   \   000000A6   0x68E8             LDR      R0,[R5, #+12]
   \   000000A8   0xF1B0 0x7F00      CMP      R0,#+33554432
   \   000000AC   0xD028             BEQ.N    ??ADC_Init_5
   \   000000AE   0x68E8             LDR      R0,[R5, #+12]
   \   000000B0   0xF1B0 0x7F40      CMP      R0,#+50331648
   \   000000B4   0xD024             BEQ.N    ??ADC_Init_5
   \   000000B6   0x68E8             LDR      R0,[R5, #+12]
   \   000000B8   0xF1B0 0x6F80      CMP      R0,#+67108864
   \   000000BC   0xD020             BEQ.N    ??ADC_Init_5
   \   000000BE   0x68E8             LDR      R0,[R5, #+12]
   \   000000C0   0xF1B0 0x6FA0      CMP      R0,#+83886080
   \   000000C4   0xD01C             BEQ.N    ??ADC_Init_5
   \   000000C6   0x68E8             LDR      R0,[R5, #+12]
   \   000000C8   0xF1B0 0x6FC0      CMP      R0,#+100663296
   \   000000CC   0xD018             BEQ.N    ??ADC_Init_5
   \   000000CE   0x68E8             LDR      R0,[R5, #+12]
   \   000000D0   0xF1B0 0x6FE0      CMP      R0,#+117440512
   \   000000D4   0xD014             BEQ.N    ??ADC_Init_5
   \   000000D6   0x68E8             LDR      R0,[R5, #+12]
   \   000000D8   0xF1B0 0x6F00      CMP      R0,#+134217728
   \   000000DC   0xD010             BEQ.N    ??ADC_Init_5
   \   000000DE   0x68E8             LDR      R0,[R5, #+12]
   \   000000E0   0xF1B0 0x6F10      CMP      R0,#+150994944
   \   000000E4   0xD00C             BEQ.N    ??ADC_Init_5
   \   000000E6   0x68E8             LDR      R0,[R5, #+12]
   \   000000E8   0xF1B0 0x6F20      CMP      R0,#+167772160
   \   000000EC   0xD008             BEQ.N    ??ADC_Init_5
   \   000000EE   0x68E8             LDR      R0,[R5, #+12]
   \   000000F0   0xF1B0 0x6F70      CMP      R0,#+251658240
   \   000000F4   0xD004             BEQ.N    ??ADC_Init_5
   \   000000F6   0x21D5             MOVS     R1,#+213
   \   000000F8   0x.... 0x....      LDR.W    R0,??DataTable21
   \   000000FC   0x.... 0x....      BL       assert_failed
    214            assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
   \                     ??ADC_Init_5: (+1)
   \   00000100   0x6928             LDR      R0,[R5, #+16]
   \   00000102   0x2800             CMP      R0,#+0
   \   00000104   0xD008             BEQ.N    ??ADC_Init_6
   \   00000106   0x6928             LDR      R0,[R5, #+16]
   \   00000108   0xF5B0 0x6F00      CMP      R0,#+2048
   \   0000010C   0xD004             BEQ.N    ??ADC_Init_6
   \   0000010E   0x21D6             MOVS     R1,#+214
   \   00000110   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000114   0x.... 0x....      BL       assert_failed
    215            assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfConversion));
   \                     ??ADC_Init_6: (+1)
   \   00000118   0x7D28             LDRB     R0,[R5, #+20]
   \   0000011A   0x2800             CMP      R0,#+0
   \   0000011C   0xD002             BEQ.N    ??ADC_Init_7
   \   0000011E   0x7D28             LDRB     R0,[R5, #+20]
   \   00000120   0x281C             CMP      R0,#+28
   \   00000122   0xDB04             BLT.N    ??ADC_Init_8
   \                     ??ADC_Init_7: (+1)
   \   00000124   0x21D7             MOVS     R1,#+215
   \   00000126   0x.... 0x....      LDR.W    R0,??DataTable21
   \   0000012A   0x.... 0x....      BL       assert_failed
    216            
    217            /*---------------------------- ADCx CR1 Configuration -----------------*/
    218            /* Get the ADCx CR1 value */
    219            tmpreg1 = ADCx->CR1;
   \                     ??ADC_Init_8: (+1)
   \   0000012E   0x6860             LDR      R0,[R4, #+4]
   \   00000130   0x0006             MOVS     R6,R0
    220            /* Clear RES and SCAN bits */ 
    221            tmpreg1 &= CR1_CLEAR_MASK;
   \   00000132   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0xfcfffeff
   \   00000136   0x4006             ANDS     R6,R0,R6
    222            /* Configure ADCx: scan conversion mode and resolution */
    223            /* Set SCAN bit according to ADC_ScanConvMode value */
    224            /* Set RES bit according to ADC_Resolution value */ 
    225            tmpreg1 |= (uint32_t)(((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8) | ADC_InitStruct->ADC_Resolution);
   \   00000138   0x7928             LDRB     R0,[R5, #+4]
   \   0000013A   0x6829             LDR      R1,[R5, #+0]
   \   0000013C   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000140   0x4306             ORRS     R6,R0,R6
    226            /* Write to ADCx CR1 */
    227            ADCx->CR1 = tmpreg1;
   \   00000142   0x6066             STR      R6,[R4, #+4]
    228            
    229            /*---------------------------- ADCx CR2 Configuration -----------------*/
    230            /* Get the ADCx CR2 value */
    231            tmpreg1 = ADCx->CR2;
   \   00000144   0x68A0             LDR      R0,[R4, #+8]
   \   00000146   0x0006             MOVS     R6,R0
    232            /* Clear CONT, ALIGN, EXTEN and EXTSEL bits */
    233            tmpreg1 &= CR2_CLEAR_MASK;
   \   00000148   0x.... 0x....      LDR.W    R0,??DataTable28  ;; 0xc0fff7fd
   \   0000014C   0x4006             ANDS     R6,R0,R6
    234            /* Configure ADCx: external trigger event and edge, data alignment and continuous conversion mode */
    235            /* Set ALIGN bit according to ADC_DataAlign value */
    236            /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
    237            /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
    238            /* Set CONT bit according to ADC_ContinuousConvMode value */
    239            tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv | 
    240                        ADC_InitStruct->ADC_ExternalTrigConvEdge | ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
   \   0000014E   0x6928             LDR      R0,[R5, #+16]
   \   00000150   0x68E9             LDR      R1,[R5, #+12]
   \   00000152   0x4308             ORRS     R0,R1,R0
   \   00000154   0x68A9             LDR      R1,[R5, #+8]
   \   00000156   0x4308             ORRS     R0,R1,R0
   \   00000158   0x7969             LDRB     R1,[R5, #+5]
   \   0000015A   0xEA50 0x0041      ORRS     R0,R0,R1, LSL #+1
   \   0000015E   0x4306             ORRS     R6,R0,R6
    241            /* Write to ADCx CR2 */
    242            ADCx->CR2 = tmpreg1;
   \   00000160   0x60A6             STR      R6,[R4, #+8]
    243            
    244            /*---------------------------- ADCx SQR1 Configuration -----------------*/
    245            /* Get the ADCx SQR1 value */
    246            tmpreg1 = ADCx->SQR1;
   \   00000162   0x6B20             LDR      R0,[R4, #+48]
   \   00000164   0x0006             MOVS     R6,R0
    247            /* Clear L bits */
    248            tmpreg1 &= SQR1_L_RESET;
   \   00000166   0xF036 0x76F8      BICS     R6,R6,#0x1F00000
    249            /* Configure ADCx: regular channel sequence length */
    250            /* Set L bits according to ADC_NbrOfConversion value */ 
    251            tmpreg2 |= (uint8_t)(ADC_InitStruct->ADC_NbrOfConversion - (uint8_t)1);
   \   0000016A   0x7D28             LDRB     R0,[R5, #+20]
   \   0000016C   0x1E40             SUBS     R0,R0,#+1
   \   0000016E   0x4307             ORRS     R7,R0,R7
    252            tmpreg1 |= ((uint32_t)tmpreg2 << 20);
   \   00000170   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000172   0xEA56 0x5607      ORRS     R6,R6,R7, LSL #+20
    253            /* Write to ADCx SQR1 */
    254            ADCx->SQR1 = tmpreg1;
   \   00000176   0x6326             STR      R6,[R4, #+48]
    255          }
   \   00000178   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    256          
    257          /**
    258            * @brief  Fills each ADC_InitStruct member with its default value.
    259            * @note   This function is used to initialize the global features of the ADC ( 
    260            *         Resolution and Data Alignment), however, the rest of the configuration
    261            *         parameters are specific to the regular channels group (scan mode 
    262            *         activation, continuous mode activation, External trigger source and 
    263            *         edge, number of conversion in the regular channels group sequencer).   
    264            * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure which will 
    265            *         be initialized.
    266            * @retval None
    267            */

   \                                 In section .text, align 2, keep-with-next
    268          void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)                            
    269          {
    270            /* Reset ADC init structure parameters values */
    271            /* Initialize the ADC_Resolution member */
    272            ADC_InitStruct->ADC_Resolution = ADC_Resolution_12b;
   \                     ADC_StructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    273          
    274            /* Initialize the ADC_ScanConvMode member */
    275            ADC_InitStruct->ADC_ScanConvMode = DISABLE;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x7101             STRB     R1,[R0, #+4]
    276          
    277            /* Initialize the ADC_ContinuousConvMode member */
    278            ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x7141             STRB     R1,[R0, #+5]
    279          
    280            /* Initialize the ADC_ExternalTrigConvEdge member */
    281            ADC_InitStruct->ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x6081             STR      R1,[R0, #+8]
    282          
    283            /* Initialize the ADC_ExternalTrigConv member */
    284            ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T2_CC2;
   \   00000010   0xF05F 0x7140      MOVS     R1,#+50331648
   \   00000014   0x60C1             STR      R1,[R0, #+12]
    285          
    286            /* Initialize the ADC_DataAlign member */
    287            ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x6101             STR      R1,[R0, #+16]
    288          
    289            /* Initialize the ADC_NbrOfConversion member */
    290            ADC_InitStruct->ADC_NbrOfConversion = 1;
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x7501             STRB     R1,[R0, #+20]
    291          }
   \   0000001E   0x4770             BX       LR               ;; return
    292          
    293          /**
    294            * @brief  Initializes the ADCs peripherals according to the specified parameters
    295            *          in the ADC_CommonInitStruct.
    296            * @param  ADC_CommonInitStruct: pointer to an ADC_CommonInitTypeDef structure 
    297            *         that contains the configuration information (Prescaler) for ADC1 peripheral.
    298            * @retval None
    299            */

   \                                 In section .text, align 2, keep-with-next
    300          void ADC_CommonInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)                           
    301          {
   \                     ADC_CommonInit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    302            uint32_t tmpreg = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    303            
    304            /* Check the parameters */
    305            assert_param(IS_ADC_PRESCALER(ADC_CommonInitStruct->ADC_Prescaler));
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD00D             BEQ.N    ??ADC_CommonInit_0
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0xF5B0 0x3F80      CMP      R0,#+65536
   \   00000012   0xD009             BEQ.N    ??ADC_CommonInit_0
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0xF5B0 0x3F00      CMP      R0,#+131072
   \   0000001A   0xD005             BEQ.N    ??ADC_CommonInit_0
   \   0000001C   0xF240 0x1131      MOVW     R1,#+305
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000024   0x.... 0x....      BL       assert_failed
    306          
    307            /*---------------------------- ADC CCR Configuration -----------------*/
    308            /* Get the ADC CCR value */
    309            tmpreg = ADC->CCR;
   \                     ??ADC_CommonInit_0: (+1)
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable29  ;; 0x40012704
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x0005             MOVS     R5,R0
    310          
    311            /* Clear ADCPRE bit */ 
    312            tmpreg &= CR_CLEAR_MASK;
   \   00000030   0xF435 0x3540      BICS     R5,R5,#0x30000
    313            
    314            /* Configure ADCx: ADC prescaler according to ADC_Prescaler */                
    315            tmpreg |= (uint32_t)(ADC_CommonInitStruct->ADC_Prescaler);        
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x4305             ORRS     R5,R0,R5
    316                          
    317            /* Write to ADC CCR */
    318            ADC->CCR = tmpreg;
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable29  ;; 0x40012704
   \   0000003C   0x6005             STR      R5,[R0, #+0]
    319          }
   \   0000003E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    320          
    321          /**
    322            * @brief  Fills each ADC_CommonInitStruct member with its default value.
    323            * @param  ADC_CommonInitStruct: pointer to an ADC_CommonInitTypeDef structure
    324            *         which will be initialized.
    325            * @retval None
    326            */

   \                                 In section .text, align 2, keep-with-next
    327          void ADC_CommonStructInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)                      
    328          {
    329            /* Reset ADC init structure parameters values */
    330            /* Initialize the ADC_Prescaler member */
    331            ADC_CommonInitStruct->ADC_Prescaler = ADC_Prescaler_Div1;
   \                     ADC_CommonStructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    332          
    333          }
   \   00000004   0x4770             BX       LR               ;; return
    334          
    335          /**
    336            * @brief  Enables or disables the specified ADC peripheral.
    337            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
    338            * @param  NewState: new state of the ADCx peripheral. 
    339            *         This parameter can be: ENABLE or DISABLE.
    340            * @retval None
    341            */

   \                                 In section .text, align 2, keep-with-next
    342          void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    343          {
   \                     ADC_Cmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    344            /* Check the parameters */
    345            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable20  ;; 0x40012400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD005             BEQ.N    ??ADC_Cmd_0
   \   0000000E   0xF240 0x1159      MOVW     R1,#+345
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000016   0x.... 0x....      BL       assert_failed
    346            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??ADC_Cmd_0: (+1)
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD008             BEQ.N    ??ADC_Cmd_1
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D01             CMP      R5,#+1
   \   00000024   0xD005             BEQ.N    ??ADC_Cmd_1
   \   00000026   0xF44F 0x71AD      MOV      R1,#+346
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable21
   \   0000002E   0x.... 0x....      BL       assert_failed
    347          
    348            if (NewState != DISABLE)
   \                     ??ADC_Cmd_1: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD004             BEQ.N    ??ADC_Cmd_2
    349            {
    350              /* Set the ADON bit to wake up the ADC from power down mode */
    351              ADCx->CR2 |= (uint32_t)ADC_CR2_ADON;
   \   00000038   0x68A0             LDR      R0,[R4, #+8]
   \   0000003A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000003E   0x60A0             STR      R0,[R4, #+8]
   \   00000040   0xE003             B.N      ??ADC_Cmd_3
    352            }
    353            else
    354            {
    355              /* Disable the selected ADC peripheral */
    356              ADCx->CR2 &= (uint32_t)(~ADC_CR2_ADON);
   \                     ??ADC_Cmd_2: (+1)
   \   00000042   0x68A0             LDR      R0,[R4, #+8]
   \   00000044   0x0840             LSRS     R0,R0,#+1
   \   00000046   0x0040             LSLS     R0,R0,#+1
   \   00000048   0x60A0             STR      R0,[R4, #+8]
    357            }
    358          }
   \                     ??ADC_Cmd_3: (+1)
   \   0000004A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    359          
    360          /**
    361            * @}
    362            */
    363          
    364          /** @defgroup ADC_Group2 Power saving functions
    365           *  @brief   Power saving functions 
    366           *
    367          @verbatim   
    368           ===============================================================================
    369                                        Power saving functions
    370           ===============================================================================  
    371          
    372            This section provides functions allowing to reduce power consumption.
    373            The two function must be combined to get the maximal benefits:
    374            When the ADC frequency is higher than the CPU one, it is recommended to  
    375            1. Insert a freeze delay : 
    376               ==> using ADC_DelaySelectionConfig(ADC1, ADC_DelayLength_Freeze);
    377            2. Enable the power down in Idle and Delay phases :
    378               ==> using ADC_PowerDownCmd(ADC1, ADC_PowerDown_Idle_Delay, ENABLE);
    379          
    380          @endverbatim
    381            * @{
    382            */
    383          
    384          /**
    385            * @brief  Enables or disables the ADC Power Down during Delay and/or Idle phase.
    386            * @note   ADC power-on and power-off can be managed by hardware to cut the 
    387            *         consumption when the ADC is not converting. 
    388            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
    389            * @param  ADC_PowerDown: The ADC power down configuration. 
    390            *         This parameter can be one of the following values:
    391            *     @arg ADC_PowerDown_Delay:      ADC is powered down during delay phase  
    392            *     @arg ADC_PowerDown_Idle:       ADC is powered down during Idle phase 
    393            *     @arg ADC_PowerDown_Idle_Delay: ADC is powered down during Delay and Idle phases
    394            * @note   The ADC can be powered down: 
    395            *         - During the hardware delay insertion (using the ADC_PowerDown_Delay
    396            *           parameter) 
    397            *           => The ADC is powered up again at the end of the delay. 
    398            *         - During the ADC is waiting for a trigger event ( using the 
    399            *           ADC_PowerDown_Idle parameter) 
    400            *           => The ADC is powered up at the next trigger event.
    401            *         - During the hardware delay insertion or the ADC is waiting for a 
    402            *           trigger event (using the ADC_PowerDown_Idle_Delay parameter) 
    403            *            => The ADC is powered up only at the end of the delay and at the 
    404            *              next trigger event.     
    405            * @param  NewState: new state of the ADCx power down. 
    406            *         This parameter can be: ENABLE or DISABLE.
    407            * @retval None
    408            */

   \                                 In section .text, align 2, keep-with-next
    409          void ADC_PowerDownCmd(ADC_TypeDef* ADCx, uint32_t ADC_PowerDown, FunctionalState NewState)
    410          {
   \                     ADC_PowerDownCmd: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    411            /* Check the parameters */
    412            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable20  ;; 0x40012400
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD005             BEQ.N    ??ADC_PowerDownCmd_0
   \   00000010   0xF44F 0x71CE      MOV      R1,#+412
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000018   0x.... 0x....      BL       assert_failed
    413            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??ADC_PowerDownCmd_0: (+1)
   \   0000001C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000001E   0x2E00             CMP      R6,#+0
   \   00000020   0xD008             BEQ.N    ??ADC_PowerDownCmd_1
   \   00000022   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000024   0x2E01             CMP      R6,#+1
   \   00000026   0xD005             BEQ.N    ??ADC_PowerDownCmd_1
   \   00000028   0xF240 0x119D      MOVW     R1,#+413
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000030   0x.... 0x....      BL       assert_failed
    414            assert_param(IS_ADC_POWER_DOWN(ADC_PowerDown));
   \                     ??ADC_PowerDownCmd_1: (+1)
   \   00000034   0xF5B5 0x3F80      CMP      R5,#+65536
   \   00000038   0xD00B             BEQ.N    ??ADC_PowerDownCmd_2
   \   0000003A   0xF5B5 0x3F00      CMP      R5,#+131072
   \   0000003E   0xD008             BEQ.N    ??ADC_PowerDownCmd_2
   \   00000040   0xF5B5 0x3F40      CMP      R5,#+196608
   \   00000044   0xD005             BEQ.N    ??ADC_PowerDownCmd_2
   \   00000046   0xF44F 0x71CF      MOV      R1,#+414
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable21
   \   0000004E   0x.... 0x....      BL       assert_failed
    415            
    416            if (NewState != DISABLE)
   \                     ??ADC_PowerDownCmd_2: (+1)
   \   00000052   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000054   0x2E00             CMP      R6,#+0
   \   00000056   0xD003             BEQ.N    ??ADC_PowerDownCmd_3
    417            {
    418              /* Enable the ADC power-down during Delay and/or Idle phase */
    419              ADCx->CR1 |= ADC_PowerDown;
   \   00000058   0x6860             LDR      R0,[R4, #+4]
   \   0000005A   0x4328             ORRS     R0,R5,R0
   \   0000005C   0x6060             STR      R0,[R4, #+4]
   \   0000005E   0xE002             B.N      ??ADC_PowerDownCmd_4
    420            }
    421            else
    422            {
    423              /* Disable The ADC power-down during Delay and/or Idle phase */
    424              ADCx->CR1 &= (uint32_t)~ADC_PowerDown;
   \                     ??ADC_PowerDownCmd_3: (+1)
   \   00000060   0x6860             LDR      R0,[R4, #+4]
   \   00000062   0x43A8             BICS     R0,R0,R5
   \   00000064   0x6060             STR      R0,[R4, #+4]
    425            }
    426          }
   \                     ??ADC_PowerDownCmd_4: (+1)
   \   00000066   0xBD70             POP      {R4-R6,PC}       ;; return
    427          
    428          /**
    429            * @brief  Defines the length of the delay which is applied after a conversion 
    430            *         or a sequence of conversion.
    431            * @note   When the CPU clock is not fast enough to manage the data rate, a 
    432            *         Hardware delay can be introduced between ADC conversions to reduce 
    433            *         this data rate. 
    434            * @note   The Hardware delay is inserted after :
    435            *         - each regular conversion
    436            *         - after each sequence of injected conversions
    437            * @note   No Hardware delay is inserted between conversions of different groups.
    438            * @note   When the hardware delay is not enough, the Freeze Delay Mode can be 
    439            *         selected and a new conversion can start only if all the previous data 
    440            *         of the same group have been treated:
    441            *         - for a regular conversion: once the ADC conversion data register has 
    442            *           been read (using ADC_GetConversionValue() function) or if the EOC 
    443            *           Flag has been cleared (using ADC_ClearFlag() function).
    444            *         - for an injected conversion: when the JEOC bit has been cleared 
    445            *           (using ADC_ClearFlag() function).
    446            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
    447            * @param  ADC_DelayLength: The length of delay which is applied after a 
    448            *         conversion or a sequence of conversion. 
    449            *   This parameter can be one of the following values:
    450            *     @arg ADC_DelayLength_None: No delay 
    451            *     @arg ADC_DelayLength_Freeze: Delay until the converted data has been read.
    452            *     @arg ADC_DelayLength_7Cycles: Delay length equal to 7 APB clock cycles
    453            *     @arg ADC_DelayLength_15Cycles: Delay length equal to 15 APB clock cycles	
    454            *     @arg ADC_DelayLength_31Cycles: Delay length equal to 31 APB clock cycles	
    455            *     @arg ADC_DelayLength_63Cycles: Delay length equal to 63 APB clock cycles	
    456            *     @arg ADC_DelayLength_127Cycles: Delay length equal to 127 APB clock cycles	
    457            *     @arg ADC_DelayLength_255Cycles: Delay length equal to 255 APB clock cycles	
    458            * @retval None
    459            */

   \                                 In section .text, align 2, keep-with-next
    460          void ADC_DelaySelectionConfig(ADC_TypeDef* ADCx, uint8_t ADC_DelayLength)
    461          {
   \                     ADC_DelaySelectionConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    462            uint32_t tmpreg = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    463             
    464            /* Check the parameters */
    465            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable20  ;; 0x40012400
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD005             BEQ.N    ??ADC_DelaySelectionConfig_0
   \   00000010   0xF240 0x11D1      MOVW     R1,#+465
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000018   0x.... 0x....      BL       assert_failed
    466            assert_param(IS_ADC_DELAY_LENGTH(ADC_DelayLength));
   \                     ??ADC_DelaySelectionConfig_0: (+1)
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD01A             BEQ.N    ??ADC_DelaySelectionConfig_1
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D10             CMP      R5,#+16
   \   00000026   0xD017             BEQ.N    ??ADC_DelaySelectionConfig_1
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D20             CMP      R5,#+32
   \   0000002C   0xD014             BEQ.N    ??ADC_DelaySelectionConfig_1
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0x2D30             CMP      R5,#+48
   \   00000032   0xD011             BEQ.N    ??ADC_DelaySelectionConfig_1
   \   00000034   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000036   0x2D40             CMP      R5,#+64
   \   00000038   0xD00E             BEQ.N    ??ADC_DelaySelectionConfig_1
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x2D50             CMP      R5,#+80
   \   0000003E   0xD00B             BEQ.N    ??ADC_DelaySelectionConfig_1
   \   00000040   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000042   0x2D60             CMP      R5,#+96
   \   00000044   0xD008             BEQ.N    ??ADC_DelaySelectionConfig_1
   \   00000046   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000048   0x2D70             CMP      R5,#+112
   \   0000004A   0xD005             BEQ.N    ??ADC_DelaySelectionConfig_1
   \   0000004C   0xF44F 0x71E9      MOV      R1,#+466
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000054   0x.... 0x....      BL       assert_failed
    467          
    468            /* Get the old register value */    
    469            tmpreg = ADCx->CR2;
   \                     ??ADC_DelaySelectionConfig_1: (+1)
   \   00000058   0x68A0             LDR      R0,[R4, #+8]
   \   0000005A   0x0006             MOVS     R6,R0
    470            /* Clear the old delay length */
    471            tmpreg &= CR2_DELS_RESET;
   \   0000005C   0xF036 0x06F0      BICS     R6,R6,#0xF0
    472            /* Set the delay length */
    473            tmpreg |= ADC_DelayLength;
   \   00000060   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000062   0x432E             ORRS     R6,R5,R6
    474            /* Store the new register value */
    475            ADCx->CR2 = tmpreg;
   \   00000064   0x60A6             STR      R6,[R4, #+8]
    476          
    477          }
   \   00000066   0xBD70             POP      {R4-R6,PC}       ;; return
    478          
    479          /**
    480            * @}
    481            */
    482          
    483          /** @defgroup ADC_Group3 Analog Watchdog configuration functions
    484           *  @brief   Analog Watchdog configuration functions 
    485           *
    486          @verbatim   
    487           ===============================================================================
    488                              Analog Watchdog configuration functions
    489           ===============================================================================  
    490          
    491            This section provides functions allowing to configure the Analog Watchdog
    492            (AWD) feature in the ADC.
    493            
    494            A typical configuration Analog Watchdog is done following these steps :
    495             1. the ADC guarded channel(s) is (are) selected using the 
    496                ADC_AnalogWatchdogSingleChannelConfig() function.
    497             2. The Analog watchdog lower and higher threshold are configured using the  
    498               ADC_AnalogWatchdogThresholdsConfig() function.
    499             3. The Analog watchdog is enabled and configured to enable the check, on one
    500                or more channels, using the  ADC_AnalogWatchdogCmd() function.
    501          
    502          @endverbatim
    503            * @{
    504            */
    505            
    506          /**
    507            * @brief  Enables or disables the analog watchdog on single/all regular
    508            *         or injected channels
    509            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
    510            * @param  ADC_AnalogWatchdog: the ADC analog watchdog configuration.
    511            *   This parameter can be one of the following values:
    512            *     @arg ADC_AnalogWatchdog_SingleRegEnable: Analog watchdog on a single 
    513            *          regular channel
    514            *     @arg ADC_AnalogWatchdog_SingleInjecEnable: Analog watchdog on a single 
    515            *          injected channel
    516            *     @arg ADC_AnalogWatchdog_SingleRegOrInjecEnable: Analog watchdog on a 
    517            *          single regular or injected channel       
    518            *     @arg ADC_AnalogWatchdog_AllRegEnable: Analog watchdog on all regular 
    519            *          channel
    520            *     @arg ADC_AnalogWatchdog_AllInjecEnable: Analog watchdog on all injected 
    521            *          channel
    522            *     @arg ADC_AnalogWatchdog_AllRegAllInjecEnable: Analog watchdog on all 
    523            *           regular and injected channels
    524            *     @arg ADC_AnalogWatchdog_None: No channel guarded by the analog watchdog
    525            * @retval None	  
    526            */

   \                                 In section .text, align 2, keep-with-next
    527          void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog)
    528          {
   \                     ADC_AnalogWatchdogCmd: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    529            uint32_t tmpreg = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    530          
    531            /* Check the parameters */
    532            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable20  ;; 0x40012400
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD005             BEQ.N    ??ADC_AnalogWatchdogCmd_0
   \   00000010   0xF44F 0x7105      MOV      R1,#+532
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000018   0x.... 0x....      BL       assert_failed
    533            assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
   \                     ??ADC_AnalogWatchdogCmd_0: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable30  ;; 0x800200
   \   00000020   0x4285             CMP      R5,R0
   \   00000022   0xD018             BEQ.N    ??ADC_AnalogWatchdogCmd_1
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable30_1  ;; 0x400200
   \   00000028   0x4285             CMP      R5,R0
   \   0000002A   0xD014             BEQ.N    ??ADC_AnalogWatchdogCmd_1
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable30_2  ;; 0xc00200
   \   00000030   0x4285             CMP      R5,R0
   \   00000032   0xD010             BEQ.N    ??ADC_AnalogWatchdogCmd_1
   \   00000034   0xF5B5 0x0F00      CMP      R5,#+8388608
   \   00000038   0xD00D             BEQ.N    ??ADC_AnalogWatchdogCmd_1
   \   0000003A   0xF5B5 0x0F80      CMP      R5,#+4194304
   \   0000003E   0xD00A             BEQ.N    ??ADC_AnalogWatchdogCmd_1
   \   00000040   0xF5B5 0x0F40      CMP      R5,#+12582912
   \   00000044   0xD007             BEQ.N    ??ADC_AnalogWatchdogCmd_1
   \   00000046   0x2D00             CMP      R5,#+0
   \   00000048   0xD005             BEQ.N    ??ADC_AnalogWatchdogCmd_1
   \   0000004A   0xF240 0x2115      MOVW     R1,#+533
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000052   0x.... 0x....      BL       assert_failed
    534          
    535            /* Get the old register value */
    536            tmpreg = ADCx->CR1;
   \                     ??ADC_AnalogWatchdogCmd_1: (+1)
   \   00000056   0x6860             LDR      R0,[R4, #+4]
   \   00000058   0x0006             MOVS     R6,R0
    537            /* Clear AWDEN, JAWDEN and AWDSGL bits */   
    538            tmpreg &= CR1_AWDMODE_RESET;
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable32  ;; 0xff3ffdff
   \   0000005E   0x4006             ANDS     R6,R0,R6
    539            /* Set the analog watchdog enable mode */
    540            tmpreg |= ADC_AnalogWatchdog;
   \   00000060   0x432E             ORRS     R6,R5,R6
    541            /* Store the new register value */
    542            ADCx->CR1 = tmpreg;
   \   00000062   0x6066             STR      R6,[R4, #+4]
    543          }
   \   00000064   0xBD70             POP      {R4-R6,PC}       ;; return
    544          
    545          /**
    546            * @brief  Configures the high and low thresholds of the analog watchdog. 
    547            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
    548            * @param  HighThreshold: the ADC analog watchdog High threshold value.
    549            *         This parameter must be a 12bit value.
    550            * @param  LowThreshold: the ADC analog watchdog Low threshold value.
    551            *         This parameter must be a 12bit value.
    552            * @retval None
    553            */

   \                                 In section .text, align 2, keep-with-next
    554          void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,
    555                                                  uint16_t LowThreshold)
    556          {
   \                     ADC_AnalogWatchdogThresholdsConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    557            /* Check the parameters */
    558            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable20  ;; 0x40012400
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD005             BEQ.N    ??ADC_AnalogWatchdogThresholdsConfig_0
   \   00000010   0xF240 0x212E      MOVW     R1,#+558
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000018   0x.... 0x....      BL       assert_failed
    559            assert_param(IS_ADC_THRESHOLD(HighThreshold));
   \                     ??ADC_AnalogWatchdogThresholdsConfig_0: (+1)
   \   0000001C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000001E   0xF5B5 0x5F80      CMP      R5,#+4096
   \   00000022   0xDB05             BLT.N    ??ADC_AnalogWatchdogThresholdsConfig_1
   \   00000024   0xF240 0x212F      MOVW     R1,#+559
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable21
   \   0000002C   0x.... 0x....      BL       assert_failed
    560            assert_param(IS_ADC_THRESHOLD(LowThreshold));
   \                     ??ADC_AnalogWatchdogThresholdsConfig_1: (+1)
   \   00000030   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000032   0xF5B6 0x5F80      CMP      R6,#+4096
   \   00000036   0xDB05             BLT.N    ??ADC_AnalogWatchdogThresholdsConfig_2
   \   00000038   0xF44F 0x710C      MOV      R1,#+560
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000040   0x.... 0x....      BL       assert_failed
    561          
    562            /* Set the ADCx high threshold */
    563            ADCx->HTR = HighThreshold;
   \                     ??ADC_AnalogWatchdogThresholdsConfig_2: (+1)
   \   00000044   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000046   0x62A5             STR      R5,[R4, #+40]
    564            /* Set the ADCx low threshold */
    565            ADCx->LTR = LowThreshold;
   \   00000048   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000004A   0x62E6             STR      R6,[R4, #+44]
    566          }
   \   0000004C   0xBD70             POP      {R4-R6,PC}       ;; return
    567          
    568          /**
    569            * @brief  Configures the analog watchdog guarded single channel
    570            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
    571            * @param  ADC_Channel: the ADC channel to configure for the analog watchdog. 
    572            *   This parameter can be one of the following values:
    573            *     @arg ADC_Channel_0: ADC Channel0 selected
    574            *     @arg ADC_Channel_1: ADC Channel1 selected
    575            *     @arg ADC_Channel_2: ADC Channel2 selected
    576            *     @arg ADC_Channel_3: ADC Channel3 selected
    577            *     @arg ADC_Channel_4: ADC Channel4 selected
    578            *     @arg ADC_Channel_5: ADC Channel5 selected
    579            *     @arg ADC_Channel_6: ADC Channel6 selected
    580            *     @arg ADC_Channel_7: ADC Channel7 selected
    581            *     @arg ADC_Channel_8: ADC Channel8 selected
    582            *     @arg ADC_Channel_9: ADC Channel9 selected
    583            *     @arg ADC_Channel_10: ADC Channel10 selected
    584            *     @arg ADC_Channel_11: ADC Channel11 selected
    585            *     @arg ADC_Channel_12: ADC Channel12 selected
    586            *     @arg ADC_Channel_13: ADC Channel13 selected
    587            *     @arg ADC_Channel_14: ADC Channel14 selected
    588            *     @arg ADC_Channel_15: ADC Channel15 selected
    589            *     @arg ADC_Channel_16: ADC Channel16 selected
    590            *     @arg ADC_Channel_17: ADC Channel17 selected
    591            *     @arg ADC_Channel_18: ADC Channel18 selected
    592            *     @arg ADC_Channel_19: ADC Channel19 selected
    593            *     @arg ADC_Channel_20: ADC Channel20 selected
    594            *     @arg ADC_Channel_21: ADC Channel21 selected
    595            *     @arg ADC_Channel_22: ADC Channel22 selected
    596            *     @arg ADC_Channel_23: ADC Channel23 selected
    597            *     @arg ADC_Channel_24: ADC Channel24 selected
    598            *     @arg ADC_Channel_25: ADC Channel25 selected
    599            * @retval None
    600            */

   \                                 In section .text, align 2, keep-with-next
    601          void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel)
    602          {
   \                     ADC_AnalogWatchdogSingleChannelConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    603            uint32_t tmpreg = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    604          
    605            /* Check the parameters */
    606            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable20  ;; 0x40012400
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD005             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_0
   \   00000010   0xF240 0x215E      MOVW     R1,#+606
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000018   0x.... 0x....      BL       assert_failed
    607            assert_param(IS_ADC_CHANNEL(ADC_Channel));
   \                     ??ADC_AnalogWatchdogSingleChannelConfig_0: (+1)
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD050             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D01             CMP      R5,#+1
   \   00000026   0xD04D             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D02             CMP      R5,#+2
   \   0000002C   0xD04A             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0x2D03             CMP      R5,#+3
   \   00000032   0xD047             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   00000034   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000036   0x2D04             CMP      R5,#+4
   \   00000038   0xD044             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x2D05             CMP      R5,#+5
   \   0000003E   0xD041             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   00000040   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000042   0x2D06             CMP      R5,#+6
   \   00000044   0xD03E             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   00000046   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000048   0x2D07             CMP      R5,#+7
   \   0000004A   0xD03B             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   0000004C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004E   0x2D08             CMP      R5,#+8
   \   00000050   0xD038             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   00000052   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000054   0x2D09             CMP      R5,#+9
   \   00000056   0xD035             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   00000058   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005A   0x2D0A             CMP      R5,#+10
   \   0000005C   0xD032             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   0000005E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000060   0x2D0B             CMP      R5,#+11
   \   00000062   0xD02F             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   00000064   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000066   0x2D0C             CMP      R5,#+12
   \   00000068   0xD02C             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   0000006A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000006C   0x2D0D             CMP      R5,#+13
   \   0000006E   0xD029             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   00000070   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000072   0x2D0E             CMP      R5,#+14
   \   00000074   0xD026             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   00000076   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000078   0x2D0F             CMP      R5,#+15
   \   0000007A   0xD023             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   0000007C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000007E   0x2D10             CMP      R5,#+16
   \   00000080   0xD020             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   00000082   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000084   0x2D11             CMP      R5,#+17
   \   00000086   0xD01D             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   00000088   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000008A   0x2D12             CMP      R5,#+18
   \   0000008C   0xD01A             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   0000008E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000090   0x2D13             CMP      R5,#+19
   \   00000092   0xD017             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   00000094   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000096   0x2D14             CMP      R5,#+20
   \   00000098   0xD014             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   0000009A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000009C   0x2D15             CMP      R5,#+21
   \   0000009E   0xD011             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   000000A0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A2   0x2D16             CMP      R5,#+22
   \   000000A4   0xD00E             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   000000A6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A8   0x2D17             CMP      R5,#+23
   \   000000AA   0xD00B             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   000000AC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000AE   0x2D18             CMP      R5,#+24
   \   000000B0   0xD008             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   000000B2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000B4   0x2D19             CMP      R5,#+25
   \   000000B6   0xD005             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   000000B8   0xF240 0x215F      MOVW     R1,#+607
   \   000000BC   0x.... 0x....      LDR.W    R0,??DataTable21
   \   000000C0   0x.... 0x....      BL       assert_failed
    608          
    609            /* Get the old register value */
    610            tmpreg = ADCx->CR1;
   \                     ??ADC_AnalogWatchdogSingleChannelConfig_1: (+1)
   \   000000C4   0x6860             LDR      R0,[R4, #+4]
   \   000000C6   0x0006             MOVS     R6,R0
    611            /* Clear the Analog watchdog channel select bits */
    612            tmpreg &= CR1_AWDCH_RESET;
   \   000000C8   0x0976             LSRS     R6,R6,#+5
   \   000000CA   0x0176             LSLS     R6,R6,#+5
    613            /* Set the Analog watchdog channel */
    614            tmpreg |= ADC_Channel;
   \   000000CC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000CE   0x432E             ORRS     R6,R5,R6
    615            /* Store the new register value */
    616            ADCx->CR1 = tmpreg;
   \   000000D0   0x6066             STR      R6,[R4, #+4]
    617          }
   \   000000D2   0xBD70             POP      {R4-R6,PC}       ;; return
    618          
    619          /**
    620            * @}
    621            */
    622          
    623          /** @defgroup ADC_Group4 Temperature Sensor & Vrefint (Voltage Reference internal) management function
    624           *  @brief   Temperature Sensor & Vrefint (Voltage Reference internal) management function 
    625           *
    626          @verbatim   
    627           ===============================================================================
    628            Temperature Sensor & Vrefint (Voltage Reference internal) management function
    629           ===============================================================================  
    630          
    631            This section provides a function allowing to enable/ disable the internal 
    632            connections between the ADC and the Temperature Sensor and the Vrefint source.
    633               
    634            A typical configuration to get the Temperature sensor and Vrefint channels 
    635            voltages or is done following these steps :
    636             1. Enable the internal connection of Temperature sensor and Vrefint sources 
    637                with the ADC channels using ADC_TempSensorVrefintCmd() function. 
    638             2. select the ADC_Channel_TempSensor and/or ADC_Channel_Vrefint using 
    639                ADC_RegularChannelConfig() or  ADC_InjectedChannelConfig() functions 
    640             3. Get the voltage values, using ADC_GetConversionValue() or  
    641                ADC_GetInjectedConversionValue().
    642           
    643          @endverbatim
    644            * @{
    645            */
    646            
    647          /**
    648            * @brief  Enables or disables the temperature sensor and Vrefint channel.
    649            * @param  NewState: new state of the temperature sensor and Vref int channels.
    650            *         This parameter can be: ENABLE or DISABLE.
    651            * @retval None
    652            */

   \                                 In section .text, align 2, keep-with-next
    653          void ADC_TempSensorVrefintCmd(FunctionalState NewState)                
    654          {
   \                     ADC_TempSensorVrefintCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    655            /* Check the parameters */
    656            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD008             BEQ.N    ??ADC_TempSensorVrefintCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD005             BEQ.N    ??ADC_TempSensorVrefintCmd_0
   \   00000010   0xF44F 0x7124      MOV      R1,#+656
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000018   0x.... 0x....      BL       assert_failed
    657          
    658            if (NewState != DISABLE)
   \                     ??ADC_TempSensorVrefintCmd_0: (+1)
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD008             BEQ.N    ??ADC_TempSensorVrefintCmd_1
    659            {
    660              /* Enable the temperature sensor and Vrefint channel*/
    661              ADC->CCR |= (uint32_t)ADC_CCR_TSVREFE;
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable29  ;; 0x40012704
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0xF450 0x0000      ORRS     R0,R0,#0x800000
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable29  ;; 0x40012704
   \   00000030   0x6008             STR      R0,[R1, #+0]
   \   00000032   0xE007             B.N      ??ADC_TempSensorVrefintCmd_2
    662            }
    663            else
    664            {
    665              /* Disable the temperature sensor and Vrefint channel*/
    666              ADC->CCR &= (uint32_t)(~ADC_CCR_TSVREFE);
   \                     ??ADC_TempSensorVrefintCmd_1: (+1)
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable29  ;; 0x40012704
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0xF430 0x0000      BICS     R0,R0,#0x800000
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable29  ;; 0x40012704
   \   00000042   0x6008             STR      R0,[R1, #+0]
    667            }
    668          }
   \                     ??ADC_TempSensorVrefintCmd_2: (+1)
   \   00000044   0xBD10             POP      {R4,PC}          ;; return
    669          
    670          /**
    671            * @}
    672            */
    673          
    674          /** @defgroup ADC_Group5 Regular Channels Configuration functions
    675           *  @brief   Regular Channels Configuration functions 
    676           *
    677          @verbatim   
    678           ===============================================================================
    679                            Regular Channels Configuration functions
    680           ===============================================================================  
    681          
    682            This section provides functions allowing to manage the ADC regular channels,
    683            it is composed of 2 sub sections : 
    684            
    685            1. Configuration and management functions for regular channels: This subsection 
    686               provides functions allowing to configure the ADC regular channels :    
    687                    - Configure the rank in the regular group sequencer for each channel
    688                    - Configure the sampling time for each channel
    689                    - select the conversion Trigger for regular channels
    690                    - select the desired EOC event behavior configuration
    691                    - Activate the continuous Mode  (*)
    692                    - Activate the Discontinuous Mode 
    693               Please Note that the following features for regular channels are configurated
    694               using the ADC_Init() function : 
    695                    - scan mode activation 
    696                    - continuous mode activation (**) 
    697                    - External trigger source  
    698                    - External trigger edge 
    699                    - number of conversion in the regular channels group sequencer.
    700               
    701               @note : (*) and (**) are performing the same configuration
    702               
    703            2. Get the conversion data: This subsection provides an important function in 
    704               the ADC peripheral since it returns the converted data of the current 
    705               regular channel. When the Conversion value is read, the EOC Flag is 
    706               automatically cleared.
    707            
    708          @endverbatim
    709            * @{
    710            */
    711          
    712          /**
    713            * @brief  Configures for the selected ADC regular channel its corresponding
    714            *         rank in the sequencer and its sampling time.
    715            * @param  ADCx: where x can be 1 to select the ADC peripheral.
    716            * @param  ADC_Channel: the ADC channel to configure. 
    717            *   This parameter can be one of the following values:
    718            *     @arg ADC_Channel_0: ADC Channel0 selected
    719            *     @arg ADC_Channel_1: ADC Channel1 selected
    720            *     @arg ADC_Channel_2: ADC Channel2 selected
    721            *     @arg ADC_Channel_3: ADC Channel3 selected
    722            *     @arg ADC_Channel_4: ADC Channel4 selected
    723            *     @arg ADC_Channel_5: ADC Channel5 selected
    724            *     @arg ADC_Channel_6: ADC Channel6 selected
    725            *     @arg ADC_Channel_7: ADC Channel7 selected
    726            *     @arg ADC_Channel_8: ADC Channel8 selected
    727            *     @arg ADC_Channel_9: ADC Channel9 selected
    728            *     @arg ADC_Channel_10: ADC Channel10 selected
    729            *     @arg ADC_Channel_11: ADC Channel11 selected
    730            *     @arg ADC_Channel_12: ADC Channel12 selected
    731            *     @arg ADC_Channel_13: ADC Channel13 selected
    732            *     @arg ADC_Channel_14: ADC Channel14 selected
    733            *     @arg ADC_Channel_15: ADC Channel15 selected
    734            *     @arg ADC_Channel_16: ADC Channel16 selected
    735            *     @arg ADC_Channel_17: ADC Channel17 selected
    736            *     @arg ADC_Channel_18: ADC Channel18 selected 
    737            *     @arg ADC_Channel_19: ADC Channel19 selected
    738            *     @arg ADC_Channel_20: ADC Channel20 selected
    739            *     @arg ADC_Channel_21: ADC Channel21 selected
    740            *     @arg ADC_Channel_22: ADC Channel22 selected
    741            *     @arg ADC_Channel_23: ADC Channel23 selected
    742            *     @arg ADC_Channel_24: ADC Channel24 selected
    743            *     @arg ADC_Channel_25: ADC Channel25 selected
    744            * @param  Rank: The rank in the regular group sequencer. This parameter
    745            *               must be between 1 to 26.
    746            * @param  ADC_SampleTime: The sample time value to be set for the selected 
    747            *         channel. 
    748            *   This parameter can be one of the following values:
    749            *     @arg ADC_SampleTime_4Cycles: Sample time equal to 4 cycles  
    750            *     @arg ADC_SampleTime_9Cycles: Sample time equal to 9 cycles
    751            *     @arg ADC_SampleTime_16Cycles: Sample time equal to 16 cycles
    752            *     @arg ADC_SampleTime_24Cycles: Sample time equal to 24 cycles	
    753            *     @arg ADC_SampleTime_48Cycles: Sample time equal to 48 cycles	
    754            *     @arg ADC_SampleTime_96Cycles: Sample time equal to 96 cycles	
    755            *     @arg ADC_SampleTime_192Cycles: Sample time equal to 192 cycles	
    756            *     @arg ADC_SampleTime_384Cycles: Sample time equal to 384 cycles	
    757            * @retval None
    758            */

   \                                 In section .text, align 2, keep-with-next
    759          void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
    760          {
   \                     ADC_RegularChannelConfig: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    761            uint32_t tmpreg1 = 0, tmpreg2 = 0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   \   00000010   0xF05F 0x0900      MOVS     R9,#+0
    762          
    763            /* Check the parameters */
    764            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable20  ;; 0x40012400
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD005             BEQ.N    ??ADC_RegularChannelConfig_0
   \   0000001C   0xF44F 0x713F      MOV      R1,#+764
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000024   0x.... 0x....      BL       assert_failed
    765            assert_param(IS_ADC_CHANNEL(ADC_Channel));
   \                     ??ADC_RegularChannelConfig_0: (+1)
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD050             BEQ.N    ??ADC_RegularChannelConfig_1
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0x2D01             CMP      R5,#+1
   \   00000032   0xD04D             BEQ.N    ??ADC_RegularChannelConfig_1
   \   00000034   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000036   0x2D02             CMP      R5,#+2
   \   00000038   0xD04A             BEQ.N    ??ADC_RegularChannelConfig_1
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x2D03             CMP      R5,#+3
   \   0000003E   0xD047             BEQ.N    ??ADC_RegularChannelConfig_1
   \   00000040   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000042   0x2D04             CMP      R5,#+4
   \   00000044   0xD044             BEQ.N    ??ADC_RegularChannelConfig_1
   \   00000046   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000048   0x2D05             CMP      R5,#+5
   \   0000004A   0xD041             BEQ.N    ??ADC_RegularChannelConfig_1
   \   0000004C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004E   0x2D06             CMP      R5,#+6
   \   00000050   0xD03E             BEQ.N    ??ADC_RegularChannelConfig_1
   \   00000052   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000054   0x2D07             CMP      R5,#+7
   \   00000056   0xD03B             BEQ.N    ??ADC_RegularChannelConfig_1
   \   00000058   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005A   0x2D08             CMP      R5,#+8
   \   0000005C   0xD038             BEQ.N    ??ADC_RegularChannelConfig_1
   \   0000005E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000060   0x2D09             CMP      R5,#+9
   \   00000062   0xD035             BEQ.N    ??ADC_RegularChannelConfig_1
   \   00000064   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000066   0x2D0A             CMP      R5,#+10
   \   00000068   0xD032             BEQ.N    ??ADC_RegularChannelConfig_1
   \   0000006A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000006C   0x2D0B             CMP      R5,#+11
   \   0000006E   0xD02F             BEQ.N    ??ADC_RegularChannelConfig_1
   \   00000070   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000072   0x2D0C             CMP      R5,#+12
   \   00000074   0xD02C             BEQ.N    ??ADC_RegularChannelConfig_1
   \   00000076   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000078   0x2D0D             CMP      R5,#+13
   \   0000007A   0xD029             BEQ.N    ??ADC_RegularChannelConfig_1
   \   0000007C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000007E   0x2D0E             CMP      R5,#+14
   \   00000080   0xD026             BEQ.N    ??ADC_RegularChannelConfig_1
   \   00000082   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000084   0x2D0F             CMP      R5,#+15
   \   00000086   0xD023             BEQ.N    ??ADC_RegularChannelConfig_1
   \   00000088   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000008A   0x2D10             CMP      R5,#+16
   \   0000008C   0xD020             BEQ.N    ??ADC_RegularChannelConfig_1
   \   0000008E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000090   0x2D11             CMP      R5,#+17
   \   00000092   0xD01D             BEQ.N    ??ADC_RegularChannelConfig_1
   \   00000094   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000096   0x2D12             CMP      R5,#+18
   \   00000098   0xD01A             BEQ.N    ??ADC_RegularChannelConfig_1
   \   0000009A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000009C   0x2D13             CMP      R5,#+19
   \   0000009E   0xD017             BEQ.N    ??ADC_RegularChannelConfig_1
   \   000000A0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A2   0x2D14             CMP      R5,#+20
   \   000000A4   0xD014             BEQ.N    ??ADC_RegularChannelConfig_1
   \   000000A6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A8   0x2D15             CMP      R5,#+21
   \   000000AA   0xD011             BEQ.N    ??ADC_RegularChannelConfig_1
   \   000000AC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000AE   0x2D16             CMP      R5,#+22
   \   000000B0   0xD00E             BEQ.N    ??ADC_RegularChannelConfig_1
   \   000000B2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000B4   0x2D17             CMP      R5,#+23
   \   000000B6   0xD00B             BEQ.N    ??ADC_RegularChannelConfig_1
   \   000000B8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000BA   0x2D18             CMP      R5,#+24
   \   000000BC   0xD008             BEQ.N    ??ADC_RegularChannelConfig_1
   \   000000BE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000C0   0x2D19             CMP      R5,#+25
   \   000000C2   0xD005             BEQ.N    ??ADC_RegularChannelConfig_1
   \   000000C4   0xF240 0x21FD      MOVW     R1,#+765
   \   000000C8   0x.... 0x....      LDR.W    R0,??DataTable21
   \   000000CC   0x.... 0x....      BL       assert_failed
    766            assert_param(IS_ADC_REGULAR_RANK(Rank));
   \                     ??ADC_RegularChannelConfig_1: (+1)
   \   000000D0   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000D2   0x2E00             CMP      R6,#+0
   \   000000D4   0xD002             BEQ.N    ??ADC_RegularChannelConfig_2
   \   000000D6   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000D8   0x2E1C             CMP      R6,#+28
   \   000000DA   0xDB05             BLT.N    ??ADC_RegularChannelConfig_3
   \                     ??ADC_RegularChannelConfig_2: (+1)
   \   000000DC   0xF240 0x21FE      MOVW     R1,#+766
   \   000000E0   0x.... 0x....      LDR.W    R0,??DataTable21
   \   000000E4   0x.... 0x....      BL       assert_failed
    767            assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
   \                     ??ADC_RegularChannelConfig_3: (+1)
   \   000000E8   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000EA   0x2F00             CMP      R7,#+0
   \   000000EC   0xD01A             BEQ.N    ??ADC_RegularChannelConfig_4
   \   000000EE   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000F0   0x2F01             CMP      R7,#+1
   \   000000F2   0xD017             BEQ.N    ??ADC_RegularChannelConfig_4
   \   000000F4   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000F6   0x2F02             CMP      R7,#+2
   \   000000F8   0xD014             BEQ.N    ??ADC_RegularChannelConfig_4
   \   000000FA   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000FC   0x2F03             CMP      R7,#+3
   \   000000FE   0xD011             BEQ.N    ??ADC_RegularChannelConfig_4
   \   00000100   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000102   0x2F04             CMP      R7,#+4
   \   00000104   0xD00E             BEQ.N    ??ADC_RegularChannelConfig_4
   \   00000106   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000108   0x2F05             CMP      R7,#+5
   \   0000010A   0xD00B             BEQ.N    ??ADC_RegularChannelConfig_4
   \   0000010C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000010E   0x2F06             CMP      R7,#+6
   \   00000110   0xD008             BEQ.N    ??ADC_RegularChannelConfig_4
   \   00000112   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000114   0x2F07             CMP      R7,#+7
   \   00000116   0xD005             BEQ.N    ??ADC_RegularChannelConfig_4
   \   00000118   0xF240 0x21FF      MOVW     R1,#+767
   \   0000011C   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000120   0x.... 0x....      BL       assert_failed
    768          
    769            /* if ADC_Channel_20 ... ADC_Channel_25 is selected */
    770            if (ADC_Channel > ADC_Channel_19)
   \                     ??ADC_RegularChannelConfig_4: (+1)
   \   00000124   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000126   0x2D14             CMP      R5,#+20
   \   00000128   0xDB17             BLT.N    ??ADC_RegularChannelConfig_5
    771            {
    772              /* Get the old register value */
    773              tmpreg1 = ADCx->SMPR1;
   \   0000012A   0x68E0             LDR      R0,[R4, #+12]
   \   0000012C   0x4680             MOV      R8,R0
    774              /* Calculate the mask to clear */
    775              tmpreg2 = SMPR1_SMP_SET << (3 * (ADC_Channel - 20));
   \   0000012E   0x2007             MOVS     R0,#+7
   \   00000130   0xF1B5 0x0114      SUBS     R1,R5,#+20
   \   00000134   0x2203             MOVS     R2,#+3
   \   00000136   0x4351             MULS     R1,R2,R1
   \   00000138   0x4088             LSLS     R0,R0,R1
   \   0000013A   0x4681             MOV      R9,R0
    776              /* Clear the old sample time */
    777              tmpreg1 &= ~tmpreg2;
   \   0000013C   0xEA38 0x0809      BICS     R8,R8,R9
    778              /* Calculate the mask to set */
    779              tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 20));
   \   00000140   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000142   0xF1B5 0x0014      SUBS     R0,R5,#+20
   \   00000146   0x2103             MOVS     R1,#+3
   \   00000148   0x4348             MULS     R0,R1,R0
   \   0000014A   0xFA17 0xF000      LSLS     R0,R7,R0
   \   0000014E   0x4681             MOV      R9,R0
    780              /* Set the new sample time */
    781              tmpreg1 |= tmpreg2;
   \   00000150   0xEA59 0x0808      ORRS     R8,R9,R8
    782              /* Store the new register value */
    783              ADCx->SMPR1 = tmpreg1;
   \   00000154   0xF8C4 0x800C      STR      R8,[R4, #+12]
   \   00000158   0xE02F             B.N      ??ADC_RegularChannelConfig_6
    784            }
    785            
    786             /* if ADC_Channel_10 ... ADC_Channel_19 is selected */
    787            else if (ADC_Channel > ADC_Channel_9)
   \                     ??ADC_RegularChannelConfig_5: (+1)
   \   0000015A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000015C   0x2D0A             CMP      R5,#+10
   \   0000015E   0xDB17             BLT.N    ??ADC_RegularChannelConfig_7
    788            {
    789              /* Get the old register value */
    790              tmpreg1 = ADCx->SMPR2;
   \   00000160   0x6920             LDR      R0,[R4, #+16]
   \   00000162   0x4680             MOV      R8,R0
    791              /* Calculate the mask to clear */
    792              tmpreg2 = SMPR2_SMP_SET << (3 * (ADC_Channel - 10));
   \   00000164   0x2007             MOVS     R0,#+7
   \   00000166   0xF1B5 0x010A      SUBS     R1,R5,#+10
   \   0000016A   0x2203             MOVS     R2,#+3
   \   0000016C   0x4351             MULS     R1,R2,R1
   \   0000016E   0x4088             LSLS     R0,R0,R1
   \   00000170   0x4681             MOV      R9,R0
    793              /* Clear the old sample time */
    794              tmpreg1 &= ~tmpreg2;
   \   00000172   0xEA38 0x0809      BICS     R8,R8,R9
    795              /* Calculate the mask to set */
    796              tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
   \   00000176   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000178   0xF1B5 0x000A      SUBS     R0,R5,#+10
   \   0000017C   0x2103             MOVS     R1,#+3
   \   0000017E   0x4348             MULS     R0,R1,R0
   \   00000180   0xFA17 0xF000      LSLS     R0,R7,R0
   \   00000184   0x4681             MOV      R9,R0
    797              /* Set the new sample time */
    798              tmpreg1 |= tmpreg2;
   \   00000186   0xEA59 0x0808      ORRS     R8,R9,R8
    799              /* Store the new register value */
    800              ADCx->SMPR2 = tmpreg1;
   \   0000018A   0xF8C4 0x8010      STR      R8,[R4, #+16]
   \   0000018E   0xE014             B.N      ??ADC_RegularChannelConfig_6
    801            }
    802            
    803            else /* ADC_Channel include in ADC_Channel_[0..9] */
    804            {
    805              /* Get the old register value */
    806              tmpreg1 = ADCx->SMPR3;
   \                     ??ADC_RegularChannelConfig_7: (+1)
   \   00000190   0x6960             LDR      R0,[R4, #+20]
   \   00000192   0x4680             MOV      R8,R0
    807              /* Calculate the mask to clear */
    808              tmpreg2 = SMPR3_SMP_SET << (3 * ADC_Channel);
   \   00000194   0x2007             MOVS     R0,#+7
   \   00000196   0x2103             MOVS     R1,#+3
   \   00000198   0xFB01 0xF105      MUL      R1,R1,R5
   \   0000019C   0x4088             LSLS     R0,R0,R1
   \   0000019E   0x4681             MOV      R9,R0
    809              /* Clear the old sample time */
    810              tmpreg1 &= ~tmpreg2;
   \   000001A0   0xEA38 0x0809      BICS     R8,R8,R9
    811              /* Calculate the mask to set */
    812              tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
   \   000001A4   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000001A6   0x2003             MOVS     R0,#+3
   \   000001A8   0xFB00 0xF005      MUL      R0,R0,R5
   \   000001AC   0xFA17 0xF000      LSLS     R0,R7,R0
   \   000001B0   0x4681             MOV      R9,R0
    813              /* Set the new sample time */
    814              tmpreg1 |= tmpreg2;
   \   000001B2   0xEA59 0x0808      ORRS     R8,R9,R8
    815              /* Store the new register value */
    816              ADCx->SMPR3 = tmpreg1;
   \   000001B6   0xF8C4 0x8014      STR      R8,[R4, #+20]
    817            }
    818            /* For Rank 1 to 6 */
    819            if (Rank < 7)
   \                     ??ADC_RegularChannelConfig_6: (+1)
   \   000001BA   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000001BC   0x2E07             CMP      R6,#+7
   \   000001BE   0xDA15             BGE.N    ??ADC_RegularChannelConfig_8
    820            {
    821              /* Get the old register value */
    822              tmpreg1 = ADCx->SQR5;
   \   000001C0   0x6C20             LDR      R0,[R4, #+64]
   \   000001C2   0x4680             MOV      R8,R0
    823              /* Calculate the mask to clear */
    824              tmpreg2 = SQR5_SQ_SET << (5 * (Rank - 1));
   \   000001C4   0x201F             MOVS     R0,#+31
   \   000001C6   0x1E71             SUBS     R1,R6,#+1
   \   000001C8   0x2205             MOVS     R2,#+5
   \   000001CA   0x4351             MULS     R1,R2,R1
   \   000001CC   0x4088             LSLS     R0,R0,R1
   \   000001CE   0x4681             MOV      R9,R0
    825              /* Clear the old SQx bits for the selected rank */
    826              tmpreg1 &= ~tmpreg2;
   \   000001D0   0xEA38 0x0809      BICS     R8,R8,R9
    827              /* Calculate the mask to set */
    828              tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
   \   000001D4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001D6   0x1E70             SUBS     R0,R6,#+1
   \   000001D8   0x2105             MOVS     R1,#+5
   \   000001DA   0x4348             MULS     R0,R1,R0
   \   000001DC   0xFA15 0xF000      LSLS     R0,R5,R0
   \   000001E0   0x4681             MOV      R9,R0
    829              /* Set the SQx bits for the selected rank */
    830              tmpreg1 |= tmpreg2;
   \   000001E2   0xEA59 0x0808      ORRS     R8,R9,R8
    831              /* Store the new register value */
    832              ADCx->SQR5 = tmpreg1;
   \   000001E6   0xF8C4 0x8040      STR      R8,[R4, #+64]
   \   000001EA   0xE065             B.N      ??ADC_RegularChannelConfig_9
    833            }
    834            /* For Rank 7 to 12 */
    835            else if (Rank < 13)
   \                     ??ADC_RegularChannelConfig_8: (+1)
   \   000001EC   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000001EE   0x2E0D             CMP      R6,#+13
   \   000001F0   0xDA15             BGE.N    ??ADC_RegularChannelConfig_10
    836            {
    837              /* Get the old register value */
    838              tmpreg1 = ADCx->SQR4;
   \   000001F2   0x6BE0             LDR      R0,[R4, #+60]
   \   000001F4   0x4680             MOV      R8,R0
    839              /* Calculate the mask to clear */
    840              tmpreg2 = SQR4_SQ_SET << (5 * (Rank - 7));
   \   000001F6   0x201F             MOVS     R0,#+31
   \   000001F8   0x1FF1             SUBS     R1,R6,#+7
   \   000001FA   0x2205             MOVS     R2,#+5
   \   000001FC   0x4351             MULS     R1,R2,R1
   \   000001FE   0x4088             LSLS     R0,R0,R1
   \   00000200   0x4681             MOV      R9,R0
    841              /* Clear the old SQx bits for the selected rank */
    842              tmpreg1 &= ~tmpreg2;
   \   00000202   0xEA38 0x0809      BICS     R8,R8,R9
    843              /* Calculate the mask to set */
    844              tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
   \   00000206   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000208   0x1FF0             SUBS     R0,R6,#+7
   \   0000020A   0x2105             MOVS     R1,#+5
   \   0000020C   0x4348             MULS     R0,R1,R0
   \   0000020E   0xFA15 0xF000      LSLS     R0,R5,R0
   \   00000212   0x4681             MOV      R9,R0
    845              /* Set the SQx bits for the selected rank */
    846              tmpreg1 |= tmpreg2;
   \   00000214   0xEA59 0x0808      ORRS     R8,R9,R8
    847              /* Store the new register value */
    848              ADCx->SQR4 = tmpreg1;
   \   00000218   0xF8C4 0x803C      STR      R8,[R4, #+60]
   \   0000021C   0xE04C             B.N      ??ADC_RegularChannelConfig_9
    849            }  
    850            /* For Rank 13 to 18 */
    851            else if (Rank < 19)
   \                     ??ADC_RegularChannelConfig_10: (+1)
   \   0000021E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000220   0x2E13             CMP      R6,#+19
   \   00000222   0xDA17             BGE.N    ??ADC_RegularChannelConfig_11
    852            {
    853              /* Get the old register value */
    854              tmpreg1 = ADCx->SQR3;
   \   00000224   0x6BA0             LDR      R0,[R4, #+56]
   \   00000226   0x4680             MOV      R8,R0
    855              /* Calculate the mask to clear */
    856              tmpreg2 = SQR3_SQ_SET << (5 * (Rank - 13));
   \   00000228   0x201F             MOVS     R0,#+31
   \   0000022A   0xF1B6 0x010D      SUBS     R1,R6,#+13
   \   0000022E   0x2205             MOVS     R2,#+5
   \   00000230   0x4351             MULS     R1,R2,R1
   \   00000232   0x4088             LSLS     R0,R0,R1
   \   00000234   0x4681             MOV      R9,R0
    857              /* Clear the old SQx bits for the selected rank */
    858              tmpreg1 &= ~tmpreg2;
   \   00000236   0xEA38 0x0809      BICS     R8,R8,R9
    859              /* Calculate the mask to set */
    860              tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
   \   0000023A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000023C   0xF1B6 0x000D      SUBS     R0,R6,#+13
   \   00000240   0x2105             MOVS     R1,#+5
   \   00000242   0x4348             MULS     R0,R1,R0
   \   00000244   0xFA15 0xF000      LSLS     R0,R5,R0
   \   00000248   0x4681             MOV      R9,R0
    861              /* Set the SQx bits for the selected rank */
    862              tmpreg1 |= tmpreg2;
   \   0000024A   0xEA59 0x0808      ORRS     R8,R9,R8
    863              /* Store the new register value */
    864              ADCx->SQR3 = tmpreg1;
   \   0000024E   0xF8C4 0x8038      STR      R8,[R4, #+56]
   \   00000252   0xE031             B.N      ??ADC_RegularChannelConfig_9
    865            }
    866              
    867            /* For Rank 19 to 24 */
    868            else if (Rank < 25)
   \                     ??ADC_RegularChannelConfig_11: (+1)
   \   00000254   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000256   0x2E19             CMP      R6,#+25
   \   00000258   0xDA17             BGE.N    ??ADC_RegularChannelConfig_12
    869            {
    870              /* Get the old register value */
    871              tmpreg1 = ADCx->SQR2;
   \   0000025A   0x6B60             LDR      R0,[R4, #+52]
   \   0000025C   0x4680             MOV      R8,R0
    872              /* Calculate the mask to clear */
    873              tmpreg2 = SQR2_SQ_SET << (5 * (Rank - 19));
   \   0000025E   0x201F             MOVS     R0,#+31
   \   00000260   0xF1B6 0x0113      SUBS     R1,R6,#+19
   \   00000264   0x2205             MOVS     R2,#+5
   \   00000266   0x4351             MULS     R1,R2,R1
   \   00000268   0x4088             LSLS     R0,R0,R1
   \   0000026A   0x4681             MOV      R9,R0
    874              /* Clear the old SQx bits for the selected rank */
    875              tmpreg1 &= ~tmpreg2;
   \   0000026C   0xEA38 0x0809      BICS     R8,R8,R9
    876              /* Calculate the mask to set */
    877              tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 19));
   \   00000270   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000272   0xF1B6 0x0013      SUBS     R0,R6,#+19
   \   00000276   0x2105             MOVS     R1,#+5
   \   00000278   0x4348             MULS     R0,R1,R0
   \   0000027A   0xFA15 0xF000      LSLS     R0,R5,R0
   \   0000027E   0x4681             MOV      R9,R0
    878              /* Set the SQx bits for the selected rank */
    879              tmpreg1 |= tmpreg2;
   \   00000280   0xEA59 0x0808      ORRS     R8,R9,R8
    880              /* Store the new register value */
    881              ADCx->SQR2 = tmpreg1;
   \   00000284   0xF8C4 0x8034      STR      R8,[R4, #+52]
   \   00000288   0xE016             B.N      ??ADC_RegularChannelConfig_9
    882            }   
    883            
    884            /* For Rank 25 to 27 */
    885            else
    886            {
    887              /* Get the old register value */
    888              tmpreg1 = ADCx->SQR1;
   \                     ??ADC_RegularChannelConfig_12: (+1)
   \   0000028A   0x6B20             LDR      R0,[R4, #+48]
   \   0000028C   0x4680             MOV      R8,R0
    889              /* Calculate the mask to clear */
    890              tmpreg2 = SQR1_SQ_SET << (5 * (Rank - 25));
   \   0000028E   0x201F             MOVS     R0,#+31
   \   00000290   0xF1B6 0x0119      SUBS     R1,R6,#+25
   \   00000294   0x2205             MOVS     R2,#+5
   \   00000296   0x4351             MULS     R1,R2,R1
   \   00000298   0x4088             LSLS     R0,R0,R1
   \   0000029A   0x4681             MOV      R9,R0
    891              /* Clear the old SQx bits for the selected rank */
    892              tmpreg1 &= ~tmpreg2;
   \   0000029C   0xEA38 0x0809      BICS     R8,R8,R9
    893              /* Calculate the mask to set */
    894              tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 25));
   \   000002A0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000002A2   0xF1B6 0x0019      SUBS     R0,R6,#+25
   \   000002A6   0x2105             MOVS     R1,#+5
   \   000002A8   0x4348             MULS     R0,R1,R0
   \   000002AA   0xFA15 0xF000      LSLS     R0,R5,R0
   \   000002AE   0x4681             MOV      R9,R0
    895              /* Set the SQx bits for the selected rank */
    896              tmpreg1 |= tmpreg2;
   \   000002B0   0xEA59 0x0808      ORRS     R8,R9,R8
    897              /* Store the new register value */
    898              ADCx->SQR1 = tmpreg1;
   \   000002B4   0xF8C4 0x8030      STR      R8,[R4, #+48]
    899            }
    900          }
   \                     ??ADC_RegularChannelConfig_9: (+1)
   \   000002B8   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    901          
    902          /**
    903            * @brief  Enables the selected ADC software start conversion of the regular channels.
    904            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
    905            * @retval None
    906            */

   \                                 In section .text, align 2, keep-with-next
    907          void ADC_SoftwareStartConv(ADC_TypeDef* ADCx)
    908          {
   \                     ADC_SoftwareStartConv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    909            /* Check the parameters */
    910            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable20  ;; 0x40012400
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD005             BEQ.N    ??ADC_SoftwareStartConv_0
   \   0000000C   0xF240 0x318E      MOVW     R1,#+910
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000014   0x.... 0x....      BL       assert_failed
    911          
    912            /* Enable the selected ADC conversion for regular group */
    913            ADCx->CR2 |= (uint32_t)ADC_CR2_SWSTART;
   \                     ??ADC_SoftwareStartConv_0: (+1)
   \   00000018   0x68A0             LDR      R0,[R4, #+8]
   \   0000001A   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \   0000001E   0x60A0             STR      R0,[R4, #+8]
    914          }
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    915          
    916          /**
    917            * @brief  Gets the selected ADC Software start regular conversion Status.
    918            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
    919            * @retval The new state of ADC software start conversion (SET or RESET).
    920            */

   \                                 In section .text, align 2, keep-with-next
    921          FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)
    922          {
   \                     ADC_GetSoftwareStartConvStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    923            FlagStatus bitstatus = RESET;
   \   00000004   0x2500             MOVS     R5,#+0
    924          
    925            /* Check the parameters */
    926            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable20  ;; 0x40012400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD005             BEQ.N    ??ADC_GetSoftwareStartConvStatus_0
   \   0000000E   0xF240 0x319E      MOVW     R1,#+926
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000016   0x.... 0x....      BL       assert_failed
    927          
    928            /* Check the status of SWSTART bit */
    929            if ((ADCx->CR2 & ADC_CR2_SWSTART) != (uint32_t)RESET)
   \                     ??ADC_GetSoftwareStartConvStatus_0: (+1)
   \   0000001A   0x68A0             LDR      R0,[R4, #+8]
   \   0000001C   0x0040             LSLS     R0,R0,#+1
   \   0000001E   0xD502             BPL.N    ??ADC_GetSoftwareStartConvStatus_1
    930            {
    931              /* SWSTART bit is set */
    932              bitstatus = SET;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x0005             MOVS     R5,R0
   \   00000024   0xE001             B.N      ??ADC_GetSoftwareStartConvStatus_2
    933            }
    934            else
    935            {
    936              /* SWSTART bit is reset */
    937              bitstatus = RESET;
   \                     ??ADC_GetSoftwareStartConvStatus_1: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x0005             MOVS     R5,R0
    938            }
    939            /* Return the SWSTART bit status */
    940            return  bitstatus;
   \                     ??ADC_GetSoftwareStartConvStatus_2: (+1)
   \   0000002A   0x0028             MOVS     R0,R5
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    941          }
    942          
    943          /**
    944            * @brief  Enables or disables the EOC on each regular channel conversion
    945            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
    946            * @param  NewState: new state of the selected ADC EOC flag rising
    947            *    This parameter can be: ENABLE or DISABLE.
    948            * @retval None
    949            */

   \                                 In section .text, align 2, keep-with-next
    950          void ADC_EOCOnEachRegularChannelCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    951          {
   \                     ADC_EOCOnEachRegularChannelCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    952            /* Check the parameters */
    953            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable20  ;; 0x40012400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD005             BEQ.N    ??ADC_EOCOnEachRegularChannelCmd_0
   \   0000000E   0xF240 0x31B9      MOVW     R1,#+953
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000016   0x.... 0x....      BL       assert_failed
    954            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??ADC_EOCOnEachRegularChannelCmd_0: (+1)
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD008             BEQ.N    ??ADC_EOCOnEachRegularChannelCmd_1
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D01             CMP      R5,#+1
   \   00000024   0xD005             BEQ.N    ??ADC_EOCOnEachRegularChannelCmd_1
   \   00000026   0xF240 0x31BA      MOVW     R1,#+954
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable21
   \   0000002E   0x.... 0x....      BL       assert_failed
    955          
    956            if (NewState != DISABLE)
   \                     ??ADC_EOCOnEachRegularChannelCmd_1: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD004             BEQ.N    ??ADC_EOCOnEachRegularChannelCmd_2
    957            {
    958              /* Enable the selected ADC EOC rising on each regular channel conversion */
    959              ADCx->CR2 |= ADC_CR2_EOCS;
   \   00000038   0x68A0             LDR      R0,[R4, #+8]
   \   0000003A   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   0000003E   0x60A0             STR      R0,[R4, #+8]
   \   00000040   0xE003             B.N      ??ADC_EOCOnEachRegularChannelCmd_3
    960            }
    961            else
    962            {
    963              /* Disable the selected ADC EOC rising on each regular channel conversion */
    964              ADCx->CR2 &= (uint32_t)~ADC_CR2_EOCS;
   \                     ??ADC_EOCOnEachRegularChannelCmd_2: (+1)
   \   00000042   0x68A0             LDR      R0,[R4, #+8]
   \   00000044   0xF430 0x6080      BICS     R0,R0,#0x400
   \   00000048   0x60A0             STR      R0,[R4, #+8]
    965            }
    966          }
   \                     ??ADC_EOCOnEachRegularChannelCmd_3: (+1)
   \   0000004A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    967          
    968          /**
    969            * @brief  Enables or disables the ADC continuous conversion mode 
    970            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
    971            * @param  NewState: new state of the selected ADC continuous conversion mode
    972            *         This parameter can be: ENABLE or DISABLE.
    973            * @retval None
    974            */

   \                                 In section .text, align 2, keep-with-next
    975          void ADC_ContinuousModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    976          {
   \                     ADC_ContinuousModeCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    977            /* Check the parameters */
    978            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable20  ;; 0x40012400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD005             BEQ.N    ??ADC_ContinuousModeCmd_0
   \   0000000E   0xF240 0x31D2      MOVW     R1,#+978
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000016   0x.... 0x....      BL       assert_failed
    979            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??ADC_ContinuousModeCmd_0: (+1)
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD008             BEQ.N    ??ADC_ContinuousModeCmd_1
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D01             CMP      R5,#+1
   \   00000024   0xD005             BEQ.N    ??ADC_ContinuousModeCmd_1
   \   00000026   0xF240 0x31D3      MOVW     R1,#+979
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable21
   \   0000002E   0x.... 0x....      BL       assert_failed
    980          
    981            if (NewState != DISABLE)
   \                     ??ADC_ContinuousModeCmd_1: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD004             BEQ.N    ??ADC_ContinuousModeCmd_2
    982            {
    983              /* Enable the selected ADC continuous conversion mode */
    984              ADCx->CR2 |= (uint32_t)ADC_CR2_CONT;
   \   00000038   0x68A0             LDR      R0,[R4, #+8]
   \   0000003A   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000003E   0x60A0             STR      R0,[R4, #+8]
   \   00000040   0xE003             B.N      ??ADC_ContinuousModeCmd_3
    985            }
    986            else
    987            {
    988              /* Disable the selected ADC continuous conversion mode */
    989              ADCx->CR2 &= (uint32_t)(~ADC_CR2_CONT);
   \                     ??ADC_ContinuousModeCmd_2: (+1)
   \   00000042   0x68A0             LDR      R0,[R4, #+8]
   \   00000044   0xF030 0x0002      BICS     R0,R0,#0x2
   \   00000048   0x60A0             STR      R0,[R4, #+8]
    990            }
    991          }
   \                     ??ADC_ContinuousModeCmd_3: (+1)
   \   0000004A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    992          
    993          /**
    994            * @brief  Configures the discontinuous mode for the selected ADC regular
    995            *         group channel.
    996            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
    997            * @param  Number: specifies the discontinuous mode regular channel count value. 
    998            *         This number must be between 1 and 8.
    999            * @retval None
   1000            */

   \                                 In section .text, align 2, keep-with-next
   1001          void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number)
   1002          {
   \                     ADC_DiscModeChannelCountConfig: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1003            uint32_t tmpreg1 = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1004            uint32_t tmpreg2 = 0;
   \   00000008   0x2700             MOVS     R7,#+0
   1005          
   1006            /* Check the parameters */
   1007            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   0000000A   0x....             LDR.N    R0,??DataTable20  ;; 0x40012400
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD005             BEQ.N    ??ADC_DiscModeChannelCountConfig_0
   \   00000010   0xF240 0x31EF      MOVW     R1,#+1007
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000018   0x.... 0x....      BL       assert_failed
   1008            assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
   \                     ??ADC_DiscModeChannelCountConfig_0: (+1)
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD002             BEQ.N    ??ADC_DiscModeChannelCountConfig_1
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D09             CMP      R5,#+9
   \   00000026   0xDB05             BLT.N    ??ADC_DiscModeChannelCountConfig_2
   \                     ??ADC_DiscModeChannelCountConfig_1: (+1)
   \   00000028   0xF44F 0x717C      MOV      R1,#+1008
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000030   0x.... 0x....      BL       assert_failed
   1009          
   1010            /* Get the old register value */
   1011            tmpreg1 = ADCx->CR1;
   \                     ??ADC_DiscModeChannelCountConfig_2: (+1)
   \   00000034   0x6860             LDR      R0,[R4, #+4]
   \   00000036   0x0006             MOVS     R6,R0
   1012            /* Clear the old discontinuous mode channel count */
   1013            tmpreg1 &= CR1_DISCNUM_RESET;
   \   00000038   0xF436 0x4660      BICS     R6,R6,#0xE000
   1014            /* Set the discontinuous mode channel count */
   1015            tmpreg2 = Number - 1;
   \   0000003C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003E   0x1E68             SUBS     R0,R5,#+1
   \   00000040   0x0007             MOVS     R7,R0
   1016            tmpreg1 |= tmpreg2 << 13;
   \   00000042   0xEA56 0x3647      ORRS     R6,R6,R7, LSL #+13
   1017            /* Store the new register value */
   1018            ADCx->CR1 = tmpreg1;
   \   00000046   0x6066             STR      R6,[R4, #+4]
   1019          }
   \   00000048   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1020          
   1021          /**
   1022            * @brief  Enables or disables the discontinuous mode on regular group
   1023            *         channel for the specified ADC
   1024            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
   1025            * @param  NewState: new state of the selected ADC discontinuous mode on regular 
   1026            *         group channel. 
   1027            *         This parameter can be: ENABLE or DISABLE.
   1028            * @retval None
   1029            */

   \                                 In section .text, align 2, keep-with-next
   1030          void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
   1031          {
   \                     ADC_DiscModeCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1032            /* Check the parameters */
   1033            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000006   0x....             LDR.N    R0,??DataTable20  ;; 0x40012400
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD004             BEQ.N    ??ADC_DiscModeCmd_0
   \   0000000C   0xF240 0x4109      MOVW     R1,#+1033
   \   00000010   0x....             LDR.N    R0,??DataTable21
   \   00000012   0x.... 0x....      BL       assert_failed
   1034            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??ADC_DiscModeCmd_0: (+1)
   \   00000016   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD007             BEQ.N    ??ADC_DiscModeCmd_1
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D01             CMP      R5,#+1
   \   00000020   0xD004             BEQ.N    ??ADC_DiscModeCmd_1
   \   00000022   0xF240 0x410A      MOVW     R1,#+1034
   \   00000026   0x....             LDR.N    R0,??DataTable21
   \   00000028   0x.... 0x....      BL       assert_failed
   1035          
   1036            if (NewState != DISABLE)
   \                     ??ADC_DiscModeCmd_1: (+1)
   \   0000002C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002E   0x2D00             CMP      R5,#+0
   \   00000030   0xD004             BEQ.N    ??ADC_DiscModeCmd_2
   1037            {
   1038              /* Enable the selected ADC regular discontinuous mode */
   1039              ADCx->CR1 |= (uint32_t)ADC_CR1_DISCEN;
   \   00000032   0x6860             LDR      R0,[R4, #+4]
   \   00000034   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   00000038   0x6060             STR      R0,[R4, #+4]
   \   0000003A   0xE003             B.N      ??ADC_DiscModeCmd_3
   1040            }
   1041            else
   1042            {
   1043              /* Disable the selected ADC regular discontinuous mode */
   1044              ADCx->CR1 &= (uint32_t)(~ADC_CR1_DISCEN);
   \                     ??ADC_DiscModeCmd_2: (+1)
   \   0000003C   0x6860             LDR      R0,[R4, #+4]
   \   0000003E   0xF430 0x6000      BICS     R0,R0,#0x800
   \   00000042   0x6060             STR      R0,[R4, #+4]
   1045            }
   1046          }
   \                     ??ADC_DiscModeCmd_3: (+1)
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1047          
   1048          /**
   1049            * @brief  Returns the last ADCx conversion result data for regular channel.  
   1050            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
   1051            * @retval The Data conversion value.
   1052            */

   \                                 In section .text, align 2, keep-with-next
   1053          uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
   1054          {
   \                     ADC_GetConversionValue: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1055            /* Check the parameters */
   1056            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000004   0x....             LDR.N    R0,??DataTable20  ;; 0x40012400
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD004             BEQ.N    ??ADC_GetConversionValue_0
   \   0000000A   0xF44F 0x6184      MOV      R1,#+1056
   \   0000000E   0x....             LDR.N    R0,??DataTable21
   \   00000010   0x.... 0x....      BL       assert_failed
   1057          
   1058            /* Return the selected ADC conversion value */
   1059            return (uint16_t) ADCx->DR;
   \                     ??ADC_GetConversionValue_0: (+1)
   \   00000014   0x6DA0             LDR      R0,[R4, #+88]
   \   00000016   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
   1060          }
   1061          
   1062          /**
   1063            * @}
   1064            */
   1065          
   1066          /** @defgroup ADC_Group6 Regular Channels DMA Configuration functions
   1067           *  @brief   Regular Channels DMA Configuration functions 
   1068           *
   1069          @verbatim   
   1070           ===============================================================================
   1071                             Regular Channels DMA Configuration functions
   1072           ===============================================================================  
   1073          
   1074            This section provides functions allowing to configure the DMA for ADC regular 
   1075            channels.
   1076            Since converted regular channel values are stored into a unique data register, 
   1077            it is useful to use DMA for conversion of more than one regular channel. This 
   1078            avoids the loss of the data already stored in the ADC Data register. 
   1079            
   1080            When the DMA mode is enabled (using the ADC_DMACmd() function), after each
   1081            conversion of a regular channel, a DMA request is generated.
   1082            
   1083            Depending on the "DMA disable selection" configuration (using the 
   1084            ADC_DMARequestAfterLastTransferCmd() function), at the end of the last DMA 
   1085            transfer, two possibilities are allowed:
   1086            - No new DMA request is issued to the DMA controller (feature DISABLED) 
   1087            - Requests can continue to be generated (feature ENABLED).
   1088          
   1089          @endverbatim
   1090            * @{
   1091            */
   1092          
   1093          /**
   1094            * @brief  Enables or disables the specified ADC DMA request.
   1095            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
   1096            * @param  NewState: new state of the selected ADC DMA transfer.
   1097            *         This parameter can be: ENABLE or DISABLE.
   1098            * @retval None
   1099            */

   \                                 In section .text, align 2, keep-with-next
   1100          void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
   1101          {
   \                     ADC_DMACmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1102            /* Check the parameters */
   1103            assert_param(IS_ADC_DMA_PERIPH(ADCx));
   \   00000006   0x....             LDR.N    R0,??DataTable20  ;; 0x40012400
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD004             BEQ.N    ??ADC_DMACmd_0
   \   0000000C   0xF240 0x414F      MOVW     R1,#+1103
   \   00000010   0x....             LDR.N    R0,??DataTable21
   \   00000012   0x.... 0x....      BL       assert_failed
   1104            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??ADC_DMACmd_0: (+1)
   \   00000016   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD007             BEQ.N    ??ADC_DMACmd_1
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D01             CMP      R5,#+1
   \   00000020   0xD004             BEQ.N    ??ADC_DMACmd_1
   \   00000022   0xF44F 0x618A      MOV      R1,#+1104
   \   00000026   0x....             LDR.N    R0,??DataTable21
   \   00000028   0x.... 0x....      BL       assert_failed
   1105          
   1106            if (NewState != DISABLE)
   \                     ??ADC_DMACmd_1: (+1)
   \   0000002C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002E   0x2D00             CMP      R5,#+0
   \   00000030   0xD004             BEQ.N    ??ADC_DMACmd_2
   1107            {
   1108              /* Enable the selected ADC DMA request */
   1109              ADCx->CR2 |= (uint32_t)ADC_CR2_DMA;
   \   00000032   0x68A0             LDR      R0,[R4, #+8]
   \   00000034   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000038   0x60A0             STR      R0,[R4, #+8]
   \   0000003A   0xE003             B.N      ??ADC_DMACmd_3
   1110            }
   1111            else
   1112            {
   1113              /* Disable the selected ADC DMA request */
   1114              ADCx->CR2 &= (uint32_t)(~ADC_CR2_DMA);
   \                     ??ADC_DMACmd_2: (+1)
   \   0000003C   0x68A0             LDR      R0,[R4, #+8]
   \   0000003E   0xF430 0x7080      BICS     R0,R0,#0x100
   \   00000042   0x60A0             STR      R0,[R4, #+8]
   1115            }
   1116          }
   \                     ??ADC_DMACmd_3: (+1)
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1117          
   1118          
   1119          /**
   1120            * @brief  Enables or disables the ADC DMA request after last transfer (Single-ADC mode)  
   1121            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
   1122            * @param  NewState: new state of the selected ADC EOC flag rising
   1123            *         This parameter can be: ENABLE or DISABLE.
   1124            * @retval None
   1125            */

   \                                 In section .text, align 2, keep-with-next
   1126          void ADC_DMARequestAfterLastTransferCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
   1127          {
   \                     ADC_DMARequestAfterLastTransferCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1128            /* Check the parameters */
   1129            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000006   0x....             LDR.N    R0,??DataTable20  ;; 0x40012400
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD004             BEQ.N    ??ADC_DMARequestAfterLastTransferCmd_0
   \   0000000C   0xF240 0x4169      MOVW     R1,#+1129
   \   00000010   0x....             LDR.N    R0,??DataTable21
   \   00000012   0x.... 0x....      BL       assert_failed
   1130            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??ADC_DMARequestAfterLastTransferCmd_0: (+1)
   \   00000016   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD007             BEQ.N    ??ADC_DMARequestAfterLastTransferCmd_1
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D01             CMP      R5,#+1
   \   00000020   0xD004             BEQ.N    ??ADC_DMARequestAfterLastTransferCmd_1
   \   00000022   0xF240 0x416A      MOVW     R1,#+1130
   \   00000026   0x....             LDR.N    R0,??DataTable21
   \   00000028   0x.... 0x....      BL       assert_failed
   1131          
   1132            if (NewState != DISABLE)
   \                     ??ADC_DMARequestAfterLastTransferCmd_1: (+1)
   \   0000002C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002E   0x2D00             CMP      R5,#+0
   \   00000030   0xD004             BEQ.N    ??ADC_DMARequestAfterLastTransferCmd_2
   1133            {
   1134              /* Enable the selected ADC DMA request after last transfer */
   1135              ADCx->CR2 |= ADC_CR2_DDS;
   \   00000032   0x68A0             LDR      R0,[R4, #+8]
   \   00000034   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000038   0x60A0             STR      R0,[R4, #+8]
   \   0000003A   0xE003             B.N      ??ADC_DMARequestAfterLastTransferCmd_3
   1136            }
   1137            else
   1138            {
   1139              /* Disable the selected ADC DMA request after last transfer */
   1140              ADCx->CR2 &= (uint32_t)~ADC_CR2_DDS;
   \                     ??ADC_DMARequestAfterLastTransferCmd_2: (+1)
   \   0000003C   0x68A0             LDR      R0,[R4, #+8]
   \   0000003E   0xF430 0x7000      BICS     R0,R0,#0x200
   \   00000042   0x60A0             STR      R0,[R4, #+8]
   1141            }
   1142          }
   \                     ??ADC_DMARequestAfterLastTransferCmd_3: (+1)
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1143          
   1144          /**
   1145            * @}
   1146            */
   1147          
   1148          /** @defgroup ADC_Group7 Injected channels Configuration functions
   1149           *  @brief   Injected channels Configuration functions 
   1150           *
   1151          @verbatim   
   1152           ===============================================================================
   1153                               Injected channels Configuration functions
   1154           ===============================================================================  
   1155          
   1156            This section provide functions allowing to configure the ADC Injected channels,
   1157            it is composed of 2 sub sections : 
   1158              
   1159            1. Configuration functions for Injected channels: This subsection provides 
   1160               functions allowing to configure the ADC injected channels :    
   1161              - Configure the rank in the injected group sequencer for each channel
   1162              - Configure the sampling time for each channel    
   1163              - Activate the Auto injected Mode  
   1164              - Activate the Discontinuous Mode 
   1165              - scan mode activation  
   1166              - External/software trigger source   
   1167              - External trigger edge 
   1168              - injected channels sequencer.
   1169              
   1170             2. Get the Specified Injected channel conversion data: This subsection 
   1171                provides an important function in the ADC peripheral since it returns the 
   1172                converted data of the specific injected channel.
   1173          
   1174          @endverbatim
   1175            * @{
   1176            */ 
   1177          
   1178          /**
   1179            * @brief  Configures for the selected ADC injected channel its corresponding
   1180            *         rank in the sequencer and its sample time.
   1181            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
   1182            * @param  ADC_Channel: the ADC channel to configure. 
   1183            *   This parameter can be one of the following values:
   1184            *     @arg ADC_Channel_0: ADC Channel0 selected
   1185            *     @arg ADC_Channel_1: ADC Channel1 selected
   1186            *     @arg ADC_Channel_2: ADC Channel2 selected
   1187            *     @arg ADC_Channel_3: ADC Channel3 selected
   1188            *     @arg ADC_Channel_4: ADC Channel4 selected
   1189            *     @arg ADC_Channel_5: ADC Channel5 selected
   1190            *     @arg ADC_Channel_6: ADC Channel6 selected
   1191            *     @arg ADC_Channel_7: ADC Channel7 selected
   1192            *     @arg ADC_Channel_8: ADC Channel8 selected
   1193            *     @arg ADC_Channel_9: ADC Channel9 selected
   1194            *     @arg ADC_Channel_10: ADC Channel10 selected
   1195            *     @arg ADC_Channel_11: ADC Channel11 selected
   1196            *     @arg ADC_Channel_12: ADC Channel12 selected
   1197            *     @arg ADC_Channel_13: ADC Channel13 selected
   1198            *     @arg ADC_Channel_14: ADC Channel14 selected
   1199            *     @arg ADC_Channel_15: ADC Channel15 selected
   1200            *     @arg ADC_Channel_16: ADC Channel16 selected
   1201            *     @arg ADC_Channel_17: ADC Channel17 selected
   1202            *     @arg ADC_Channel_18: ADC Channel18 selected 
   1203            *     @arg ADC_Channel_19: ADC Channel19 selected
   1204            *     @arg ADC_Channel_20: ADC Channel20 selected
   1205            *     @arg ADC_Channel_21: ADC Channel21 selected
   1206            *     @arg ADC_Channel_22: ADC Channel22 selected
   1207            *     @arg ADC_Channel_23: ADC Channel23 selected
   1208            *     @arg ADC_Channel_24: ADC Channel24 selected
   1209            *     @arg ADC_Channel_25: ADC Channel25 selected
   1210            * @param  Rank: The rank in the injected group sequencer. This parameter
   1211            *         must be between 1 to 4.
   1212            * @param  ADC_SampleTime: The sample time value to be set for the selected 
   1213            *         channel. This parameter can be one of the following values:
   1214            *     @arg ADC_SampleTime_4Cycles: Sample time equal to 4 cycles  
   1215            *     @arg ADC_SampleTime_9Cycles: Sample time equal to 9 cycles
   1216            *     @arg ADC_SampleTime_16Cycles: Sample time equal to 16 cycles
   1217            *     @arg ADC_SampleTime_24Cycles: Sample time equal to 24 cycles	
   1218            *     @arg ADC_SampleTime_48Cycles: Sample time equal to 48 cycles	
   1219            *     @arg ADC_SampleTime_96Cycles: Sample time equal to 96 cycles	
   1220            *     @arg ADC_SampleTime_192Cycles: Sample time equal to 192 cycles	
   1221            *     @arg ADC_SampleTime_384Cycles: Sample time equal to 384 cycles	
   1222            * @retval None
   1223            */

   \                                 In section .text, align 2, keep-with-next
   1224          void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
   1225          {
   \                     ADC_InjectedChannelConfig: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   1226            uint32_t tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   \   00000010   0xF05F 0x0900      MOVS     R9,#+0
   \   00000014   0xF05F 0x0A00      MOVS     R10,#+0
   1227          
   1228            /* Check the parameters */
   1229            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000018   0x....             LDR.N    R0,??DataTable20  ;; 0x40012400
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD004             BEQ.N    ??ADC_InjectedChannelConfig_0
   \   0000001E   0xF240 0x41CD      MOVW     R1,#+1229
   \   00000022   0x....             LDR.N    R0,??DataTable21
   \   00000024   0x.... 0x....      BL       assert_failed
   1230            assert_param(IS_ADC_CHANNEL(ADC_Channel));
   \                     ??ADC_InjectedChannelConfig_0: (+1)
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD04F             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0x2D01             CMP      R5,#+1
   \   00000032   0xD04C             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   00000034   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000036   0x2D02             CMP      R5,#+2
   \   00000038   0xD049             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x2D03             CMP      R5,#+3
   \   0000003E   0xD046             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   00000040   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000042   0x2D04             CMP      R5,#+4
   \   00000044   0xD043             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   00000046   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000048   0x2D05             CMP      R5,#+5
   \   0000004A   0xD040             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   0000004C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004E   0x2D06             CMP      R5,#+6
   \   00000050   0xD03D             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   00000052   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000054   0x2D07             CMP      R5,#+7
   \   00000056   0xD03A             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   00000058   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005A   0x2D08             CMP      R5,#+8
   \   0000005C   0xD037             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   0000005E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000060   0x2D09             CMP      R5,#+9
   \   00000062   0xD034             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   00000064   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000066   0x2D0A             CMP      R5,#+10
   \   00000068   0xD031             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   0000006A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000006C   0x2D0B             CMP      R5,#+11
   \   0000006E   0xD02E             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   00000070   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000072   0x2D0C             CMP      R5,#+12
   \   00000074   0xD02B             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   00000076   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000078   0x2D0D             CMP      R5,#+13
   \   0000007A   0xD028             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   0000007C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000007E   0x2D0E             CMP      R5,#+14
   \   00000080   0xD025             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   00000082   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000084   0x2D0F             CMP      R5,#+15
   \   00000086   0xD022             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   00000088   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000008A   0x2D10             CMP      R5,#+16
   \   0000008C   0xD01F             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   0000008E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000090   0x2D11             CMP      R5,#+17
   \   00000092   0xD01C             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   00000094   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000096   0x2D12             CMP      R5,#+18
   \   00000098   0xD019             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   0000009A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000009C   0x2D13             CMP      R5,#+19
   \   0000009E   0xD016             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   000000A0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A2   0x2D14             CMP      R5,#+20
   \   000000A4   0xD013             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   000000A6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A8   0x2D15             CMP      R5,#+21
   \   000000AA   0xD010             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   000000AC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000AE   0x2D16             CMP      R5,#+22
   \   000000B0   0xD00D             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   000000B2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000B4   0x2D17             CMP      R5,#+23
   \   000000B6   0xD00A             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   000000B8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000BA   0x2D18             CMP      R5,#+24
   \   000000BC   0xD007             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   000000BE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000C0   0x2D19             CMP      R5,#+25
   \   000000C2   0xD004             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   000000C4   0xF240 0x41CE      MOVW     R1,#+1230
   \   000000C8   0x....             LDR.N    R0,??DataTable21
   \   000000CA   0x.... 0x....      BL       assert_failed
   1231            assert_param(IS_ADC_INJECTED_RANK(Rank));
   \                     ??ADC_InjectedChannelConfig_1: (+1)
   \   000000CE   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000D0   0x2E00             CMP      R6,#+0
   \   000000D2   0xD002             BEQ.N    ??ADC_InjectedChannelConfig_2
   \   000000D4   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000D6   0x2E05             CMP      R6,#+5
   \   000000D8   0xDB04             BLT.N    ??ADC_InjectedChannelConfig_3
   \                     ??ADC_InjectedChannelConfig_2: (+1)
   \   000000DA   0xF240 0x41CF      MOVW     R1,#+1231
   \   000000DE   0x....             LDR.N    R0,??DataTable21
   \   000000E0   0x.... 0x....      BL       assert_failed
   1232            assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
   \                     ??ADC_InjectedChannelConfig_3: (+1)
   \   000000E4   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000E6   0x2F00             CMP      R7,#+0
   \   000000E8   0xD019             BEQ.N    ??ADC_InjectedChannelConfig_4
   \   000000EA   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000EC   0x2F01             CMP      R7,#+1
   \   000000EE   0xD016             BEQ.N    ??ADC_InjectedChannelConfig_4
   \   000000F0   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000F2   0x2F02             CMP      R7,#+2
   \   000000F4   0xD013             BEQ.N    ??ADC_InjectedChannelConfig_4
   \   000000F6   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000F8   0x2F03             CMP      R7,#+3
   \   000000FA   0xD010             BEQ.N    ??ADC_InjectedChannelConfig_4
   \   000000FC   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000FE   0x2F04             CMP      R7,#+4
   \   00000100   0xD00D             BEQ.N    ??ADC_InjectedChannelConfig_4
   \   00000102   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000104   0x2F05             CMP      R7,#+5
   \   00000106   0xD00A             BEQ.N    ??ADC_InjectedChannelConfig_4
   \   00000108   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000010A   0x2F06             CMP      R7,#+6
   \   0000010C   0xD007             BEQ.N    ??ADC_InjectedChannelConfig_4
   \   0000010E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000110   0x2F07             CMP      R7,#+7
   \   00000112   0xD004             BEQ.N    ??ADC_InjectedChannelConfig_4
   \   00000114   0xF44F 0x619A      MOV      R1,#+1232
   \   00000118   0x....             LDR.N    R0,??DataTable21
   \   0000011A   0x.... 0x....      BL       assert_failed
   1233            
   1234            /* if ADC_Channel_20 ... ADC_Channel_25 is selected */
   1235            if (ADC_Channel > ADC_Channel_19)
   \                     ??ADC_InjectedChannelConfig_4: (+1)
   \   0000011E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000120   0x2D14             CMP      R5,#+20
   \   00000122   0xDB17             BLT.N    ??ADC_InjectedChannelConfig_5
   1236            {
   1237              /* Get the old register value */
   1238              tmpreg1 = ADCx->SMPR1;
   \   00000124   0x68E0             LDR      R0,[R4, #+12]
   \   00000126   0x4680             MOV      R8,R0
   1239              /* Calculate the mask to clear */
   1240              tmpreg2 = SMPR1_SMP_SET << (3 * (ADC_Channel - 20));
   \   00000128   0x2007             MOVS     R0,#+7
   \   0000012A   0xF1B5 0x0114      SUBS     R1,R5,#+20
   \   0000012E   0x2203             MOVS     R2,#+3
   \   00000130   0x4351             MULS     R1,R2,R1
   \   00000132   0x4088             LSLS     R0,R0,R1
   \   00000134   0x4681             MOV      R9,R0
   1241              /* Clear the old sample time */
   1242              tmpreg1 &= ~tmpreg2;
   \   00000136   0xEA38 0x0809      BICS     R8,R8,R9
   1243              /* Calculate the mask to set */
   1244              tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 20));
   \   0000013A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000013C   0xF1B5 0x0014      SUBS     R0,R5,#+20
   \   00000140   0x2103             MOVS     R1,#+3
   \   00000142   0x4348             MULS     R0,R1,R0
   \   00000144   0xFA17 0xF000      LSLS     R0,R7,R0
   \   00000148   0x4681             MOV      R9,R0
   1245              /* Set the new sample time */
   1246              tmpreg1 |= tmpreg2;
   \   0000014A   0xEA59 0x0808      ORRS     R8,R9,R8
   1247              /* Store the new register value */
   1248              ADCx->SMPR1 = tmpreg1;
   \   0000014E   0xF8C4 0x800C      STR      R8,[R4, #+12]
   \   00000152   0xE02F             B.N      ??ADC_InjectedChannelConfig_6
   1249            }
   1250            
   1251             /* if ADC_Channel_10 ... ADC_Channel_19 is selected */
   1252            else if (ADC_Channel > ADC_Channel_9)
   \                     ??ADC_InjectedChannelConfig_5: (+1)
   \   00000154   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000156   0x2D0A             CMP      R5,#+10
   \   00000158   0xDB17             BLT.N    ??ADC_InjectedChannelConfig_7
   1253            {
   1254              /* Get the old register value */
   1255              tmpreg1 = ADCx->SMPR2;
   \   0000015A   0x6920             LDR      R0,[R4, #+16]
   \   0000015C   0x4680             MOV      R8,R0
   1256              /* Calculate the mask to clear */
   1257              tmpreg2 = SMPR2_SMP_SET << (3 * (ADC_Channel - 10));
   \   0000015E   0x2007             MOVS     R0,#+7
   \   00000160   0xF1B5 0x010A      SUBS     R1,R5,#+10
   \   00000164   0x2203             MOVS     R2,#+3
   \   00000166   0x4351             MULS     R1,R2,R1
   \   00000168   0x4088             LSLS     R0,R0,R1
   \   0000016A   0x4681             MOV      R9,R0
   1258              /* Clear the old sample time */
   1259              tmpreg1 &= ~tmpreg2;
   \   0000016C   0xEA38 0x0809      BICS     R8,R8,R9
   1260              /* Calculate the mask to set */
   1261              tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
   \   00000170   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000172   0xF1B5 0x000A      SUBS     R0,R5,#+10
   \   00000176   0x2103             MOVS     R1,#+3
   \   00000178   0x4348             MULS     R0,R1,R0
   \   0000017A   0xFA17 0xF000      LSLS     R0,R7,R0
   \   0000017E   0x4681             MOV      R9,R0
   1262              /* Set the new sample time */
   1263              tmpreg1 |= tmpreg2;
   \   00000180   0xEA59 0x0808      ORRS     R8,R9,R8
   1264              /* Store the new register value */
   1265              ADCx->SMPR2 = tmpreg1;
   \   00000184   0xF8C4 0x8010      STR      R8,[R4, #+16]
   \   00000188   0xE014             B.N      ??ADC_InjectedChannelConfig_6
   1266            }
   1267            
   1268            else /* ADC_Channel include in ADC_Channel_[0..9] */
   1269            {
   1270              /* Get the old register value */
   1271              tmpreg1 = ADCx->SMPR3;
   \                     ??ADC_InjectedChannelConfig_7: (+1)
   \   0000018A   0x6960             LDR      R0,[R4, #+20]
   \   0000018C   0x4680             MOV      R8,R0
   1272              /* Calculate the mask to clear */
   1273              tmpreg2 = SMPR3_SMP_SET << (3 * ADC_Channel);
   \   0000018E   0x2007             MOVS     R0,#+7
   \   00000190   0x2103             MOVS     R1,#+3
   \   00000192   0xFB01 0xF105      MUL      R1,R1,R5
   \   00000196   0x4088             LSLS     R0,R0,R1
   \   00000198   0x4681             MOV      R9,R0
   1274              /* Clear the old sample time */
   1275              tmpreg1 &= ~tmpreg2;
   \   0000019A   0xEA38 0x0809      BICS     R8,R8,R9
   1276              /* Calculate the mask to set */
   1277              tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
   \   0000019E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000001A0   0x2003             MOVS     R0,#+3
   \   000001A2   0xFB00 0xF005      MUL      R0,R0,R5
   \   000001A6   0xFA17 0xF000      LSLS     R0,R7,R0
   \   000001AA   0x4681             MOV      R9,R0
   1278              /* Set the new sample time */
   1279              tmpreg1 |= tmpreg2;
   \   000001AC   0xEA59 0x0808      ORRS     R8,R9,R8
   1280              /* Store the new register value */
   1281              ADCx->SMPR3 = tmpreg1;
   \   000001B0   0xF8C4 0x8014      STR      R8,[R4, #+20]
   1282            }
   1283            
   1284            /* Rank configuration */
   1285            /* Get the old register value */
   1286            tmpreg1 = ADCx->JSQR;
   \                     ??ADC_InjectedChannelConfig_6: (+1)
   \   000001B4   0x6C60             LDR      R0,[R4, #+68]
   \   000001B6   0x4680             MOV      R8,R0
   1287            /* Get JL value: Number = JL+1 */
   1288            tmpreg3 =  (tmpreg1 & JSQR_JL_SET)>> 20;
   \   000001B8   0xF3C8 0x5001      UBFX     R0,R8,#+20,#+2
   \   000001BC   0x4682             MOV      R10,R0
   1289            /* Calculate the mask to clear: ((Rank-1)+(4- (JL+1))) */ 
   1290            tmpreg2 = JSQR_JSQ_SET << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
   \   000001BE   0x201F             MOVS     R0,#+31
   \   000001C0   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000001C2   0x1CF1             ADDS     R1,R6,#+3
   \   000001C4   0xEBB1 0x010A      SUBS     R1,R1,R10
   \   000001C8   0x1E49             SUBS     R1,R1,#+1
   \   000001CA   0x2205             MOVS     R2,#+5
   \   000001CC   0x4351             MULS     R1,R2,R1
   \   000001CE   0x4088             LSLS     R0,R0,R1
   \   000001D0   0x4681             MOV      R9,R0
   1291            /* Clear the old JSQx bits for the selected rank */
   1292            tmpreg1 &= ~tmpreg2;
   \   000001D2   0xEA38 0x0809      BICS     R8,R8,R9
   1293            /* Calculate the mask to set: ((Rank-1)+(4- (JL+1))) */ 
   1294            tmpreg2 = (uint32_t)ADC_Channel << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
   \   000001D6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001D8   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000001DA   0x1CF0             ADDS     R0,R6,#+3
   \   000001DC   0xEBB0 0x000A      SUBS     R0,R0,R10
   \   000001E0   0x1E40             SUBS     R0,R0,#+1
   \   000001E2   0x2105             MOVS     R1,#+5
   \   000001E4   0x4348             MULS     R0,R1,R0
   \   000001E6   0xFA15 0xF000      LSLS     R0,R5,R0
   \   000001EA   0x4681             MOV      R9,R0
   1295            /* Set the JSQx bits for the selected rank */
   1296            tmpreg1 |= tmpreg2;
   \   000001EC   0xEA59 0x0808      ORRS     R8,R9,R8
   1297            /* Store the new register value */
   1298            ADCx->JSQR = tmpreg1;
   \   000001F0   0xF8C4 0x8044      STR      R8,[R4, #+68]
   1299          }
   \   000001F4   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   1300          
   1301          /**
   1302            * @brief  Configures the sequencer length for injected channels
   1303            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
   1304            * @param  Length: The sequencer length. 
   1305            *         This parameter must be a number between 1 to 4.
   1306            * @retval None
   1307            */

   \                                 In section .text, align 2, keep-with-next
   1308          void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length)
   1309          {
   \                     ADC_InjectedSequencerLengthConfig: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1310            uint32_t tmpreg1 = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1311            uint32_t tmpreg2 = 0;
   \   00000008   0x2700             MOVS     R7,#+0
   1312          
   1313            /* Check the parameters */
   1314            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable34  ;; 0x40012400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD004             BEQ.N    ??ADC_InjectedSequencerLengthConfig_0
   \   00000012   0xF240 0x5122      MOVW     R1,#+1314
   \   00000016   0x....             LDR.N    R0,??DataTable21
   \   00000018   0x.... 0x....      BL       assert_failed
   1315            assert_param(IS_ADC_INJECTED_LENGTH(Length));
   \                     ??ADC_InjectedSequencerLengthConfig_0: (+1)
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD002             BEQ.N    ??ADC_InjectedSequencerLengthConfig_1
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D05             CMP      R5,#+5
   \   00000026   0xDB04             BLT.N    ??ADC_InjectedSequencerLengthConfig_2
   \                     ??ADC_InjectedSequencerLengthConfig_1: (+1)
   \   00000028   0xF240 0x5123      MOVW     R1,#+1315
   \   0000002C   0x....             LDR.N    R0,??DataTable21
   \   0000002E   0x.... 0x....      BL       assert_failed
   1316            
   1317            /* Get the old register value */
   1318            tmpreg1 = ADCx->JSQR;
   \                     ??ADC_InjectedSequencerLengthConfig_2: (+1)
   \   00000032   0x6C60             LDR      R0,[R4, #+68]
   \   00000034   0x0006             MOVS     R6,R0
   1319            /* Clear the old injected sequence length JL bits */
   1320            tmpreg1 &= JSQR_JL_RESET;
   \   00000036   0xF436 0x1640      BICS     R6,R6,#0x300000
   1321            /* Set the injected sequence length JL bits */
   1322            tmpreg2 = Length - 1; 
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x1E68             SUBS     R0,R5,#+1
   \   0000003E   0x0007             MOVS     R7,R0
   1323            tmpreg1 |= tmpreg2 << 20;
   \   00000040   0xEA56 0x5607      ORRS     R6,R6,R7, LSL #+20
   1324            /* Store the new register value */
   1325            ADCx->JSQR = tmpreg1;
   \   00000044   0x6466             STR      R6,[R4, #+68]
   1326          }
   \   00000046   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1327          
   1328          /**
   1329            * @brief  Set the injected channels conversion value offset
   1330            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
   1331            * @param  ADC_InjectedChannel: the ADC injected channel to set its offset. 
   1332            *   This parameter can be one of the following values:
   1333            *     @arg ADC_InjectedChannel_1: Injected Channel1 selected
   1334            *     @arg ADC_InjectedChannel_2: Injected Channel2 selected
   1335            *     @arg ADC_InjectedChannel_3: Injected Channel3 selected
   1336            *     @arg ADC_InjectedChannel_4: Injected Channel4 selected
   1337            * @param  Offset: the offset value for the selected ADC injected channel
   1338            *         This parameter must be a 12bit value.
   1339            * @retval None
   1340            */

   \                                 In section .text, align 2, keep-with-next
   1341          void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset)
   1342          {
   \                     ADC_SetInjectedOffset: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1343            __IO uint32_t tmp = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x9000             STR      R0,[SP, #+0]
   1344            
   1345            /* Check the parameters */
   1346            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable34  ;; 0x40012400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD005             BEQ.N    ??ADC_SetInjectedOffset_0
   \   00000016   0xF240 0x5142      MOVW     R1,#+1346
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable34_1
   \   0000001E   0x.... 0x....      BL       assert_failed
   1347            assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
   \                     ??ADC_SetInjectedOffset_0: (+1)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D18             CMP      R5,#+24
   \   00000026   0xD00E             BEQ.N    ??ADC_SetInjectedOffset_1
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D1C             CMP      R5,#+28
   \   0000002C   0xD00B             BEQ.N    ??ADC_SetInjectedOffset_1
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0x2D20             CMP      R5,#+32
   \   00000032   0xD008             BEQ.N    ??ADC_SetInjectedOffset_1
   \   00000034   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000036   0x2D24             CMP      R5,#+36
   \   00000038   0xD005             BEQ.N    ??ADC_SetInjectedOffset_1
   \   0000003A   0xF240 0x5143      MOVW     R1,#+1347
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable34_1
   \   00000042   0x.... 0x....      BL       assert_failed
   1348            assert_param(IS_ADC_OFFSET(Offset));  
   \                     ??ADC_SetInjectedOffset_1: (+1)
   \   00000046   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000048   0xF5B6 0x5F80      CMP      R6,#+4096
   \   0000004C   0xDB05             BLT.N    ??ADC_SetInjectedOffset_2
   \   0000004E   0xF240 0x5144      MOVW     R1,#+1348
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable34_1
   \   00000056   0x.... 0x....      BL       assert_failed
   1349            
   1350            tmp = (uint32_t)ADCx;
   \                     ??ADC_SetInjectedOffset_2: (+1)
   \   0000005A   0x9400             STR      R4,[SP, #+0]
   1351            tmp += ADC_InjectedChannel;
   \   0000005C   0x9800             LDR      R0,[SP, #+0]
   \   0000005E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000060   0x1828             ADDS     R0,R5,R0
   \   00000062   0x9000             STR      R0,[SP, #+0]
   1352            
   1353            /* Set the selected injected channel data offset */
   1354            *(__IO uint32_t *) tmp = (uint32_t)Offset;
   \   00000064   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000066   0x9800             LDR      R0,[SP, #+0]
   \   00000068   0x6006             STR      R6,[R0, #+0]
   1355          }
   \   0000006A   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
   1356          
   1357          /**
   1358            * @brief  Configures the ADCx external trigger for injected channels conversion.
   1359            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
   1360            * @param  ADC_ExternalTrigInjecConv: specifies the ADC trigger to start injected 
   1361            *    conversion. This parameter can be one of the following values:                    
   1362            *     @arg ADC_ExternalTrigInjecConv_T9_CC1: Timer9 capture compare1 selected 
   1363            *     @arg ADC_ExternalTrigInjecConv_T9_TRGO: Timer9 TRGO event selected 
   1364            *     @arg ADC_ExternalTrigInjecConv_T2_TRGO: Timer2 TRGO event selected 
   1365            *     @arg ADC_ExternalTrigInjecConv_T2_CC1: Timer2 capture compare1 selected
   1366            *     @arg ADC_ExternalTrigInjecConv_T3_CC4: Timer3 capture compare4 selected 
   1367            *     @arg ADC_ExternalTrigInjecConv_T4_TRGO: Timer4 TRGO event selected 
   1368            *     @arg ADC_ExternalTrigInjecConv_T4_CC1: Timer4 capture compare1 selected                       
   1369            *     @arg ADC_ExternalTrigInjecConv_T4_CC2: Timer4 capture compare2 selected 
   1370            *     @arg ADC_ExternalTrigInjecConv_T4_CC3: Timer4 capture compare3 selected                        
   1371            *     @arg ADC_ExternalTrigInjecConv_T10_CC1: Timer10 capture compare1 selected
   1372            *     @arg ADC_ExternalTrigInjecConv_T7_TRGO: Timer7 TRGO event selected                         
   1373            *     @arg ADC_ExternalTrigInjecConv_Ext_IT15: External interrupt line 15 event selected                          
   1374            * @retval None
   1375            */

   \                                 In section .text, align 2, keep-with-next
   1376          void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv)
   1377          {
   \                     ADC_ExternalTrigInjectedConvConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1378            uint32_t tmpreg = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1379          
   1380            /* Check the parameters */
   1381            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable34  ;; 0x40012400
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD005             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_0
   \   00000010   0xF240 0x5165      MOVW     R1,#+1381
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable34_1
   \   00000018   0x.... 0x....      BL       assert_failed
   1382            assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
   \                     ??ADC_ExternalTrigInjectedConvConfig_0: (+1)
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD026             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   00000020   0xF5B5 0x3F80      CMP      R5,#+65536
   \   00000024   0xD023             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   00000026   0xF5B5 0x3F00      CMP      R5,#+131072
   \   0000002A   0xD020             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   0000002C   0xF5B5 0x3F40      CMP      R5,#+196608
   \   00000030   0xD01D             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   00000032   0xF5B5 0x2F80      CMP      R5,#+262144
   \   00000036   0xD01A             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   00000038   0xF5B5 0x2FA0      CMP      R5,#+327680
   \   0000003C   0xD017             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   0000003E   0xF5B5 0x2FC0      CMP      R5,#+393216
   \   00000042   0xD014             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   00000044   0xF5B5 0x2FE0      CMP      R5,#+458752
   \   00000048   0xD011             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   0000004A   0xF5B5 0x2F00      CMP      R5,#+524288
   \   0000004E   0xD00E             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   00000050   0xF5B5 0x2F10      CMP      R5,#+589824
   \   00000054   0xD00B             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   00000056   0xF5B5 0x2F20      CMP      R5,#+655360
   \   0000005A   0xD008             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   0000005C   0xF5B5 0x2F70      CMP      R5,#+983040
   \   00000060   0xD005             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   00000062   0xF240 0x5166      MOVW     R1,#+1382
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable34_1
   \   0000006A   0x.... 0x....      BL       assert_failed
   1383          
   1384            /* Get the old register value */
   1385            tmpreg = ADCx->CR2;
   \                     ??ADC_ExternalTrigInjectedConvConfig_1: (+1)
   \   0000006E   0x68A0             LDR      R0,[R4, #+8]
   \   00000070   0x0006             MOVS     R6,R0
   1386            /* Clear the old external event selection for injected group */
   1387            tmpreg &= CR2_JEXTSEL_RESET;
   \   00000072   0xF436 0x2670      BICS     R6,R6,#0xF0000
   1388            /* Set the external event selection for injected group */
   1389            tmpreg |= ADC_ExternalTrigInjecConv;
   \   00000076   0x432E             ORRS     R6,R5,R6
   1390            /* Store the new register value */
   1391            ADCx->CR2 = tmpreg;
   \   00000078   0x60A6             STR      R6,[R4, #+8]
   1392          }
   \   0000007A   0xBD70             POP      {R4-R6,PC}       ;; return
   1393          
   1394          /**
   1395            * @brief  Configures the ADCx external trigger edge for injected channels conversion.
   1396            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
   1397            * @param  ADC_ExternalTrigInjecConvEdge: specifies the ADC external trigger
   1398            *         edge to start injected conversion. 
   1399            *   This parameter can be one of the following values:
   1400            *     @arg ADC_ExternalTrigConvEdge_None: external trigger disabled for 
   1401            *          injected conversion
   1402            *     @arg ADC_ExternalTrigConvEdge_Rising: detection on rising edge
   1403            *     @arg ADC_ExternalTrigConvEdge_Falling: detection on falling edge
   1404            *     @arg ADC_External ADC_ExternalTrigConvEdge_RisingFalling: detection on 
   1405            *          both rising and falling edge
   1406            * @retval None
   1407            */

   \                                 In section .text, align 2, keep-with-next
   1408          void ADC_ExternalTrigInjectedConvEdgeConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConvEdge)
   1409          {
   \                     ADC_ExternalTrigInjectedConvEdgeConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1410            uint32_t tmpreg = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1411          
   1412            /* Check the parameters */
   1413            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable34  ;; 0x40012400
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD005             BEQ.N    ??ADC_ExternalTrigInjectedConvEdgeConfig_0
   \   00000010   0xF240 0x5185      MOVW     R1,#+1413
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable34_1
   \   00000018   0x.... 0x....      BL       assert_failed
   1414            assert_param(IS_ADC_EXT_INJEC_TRIG_EDGE(ADC_ExternalTrigInjecConvEdge));
   \                     ??ADC_ExternalTrigInjectedConvEdgeConfig_0: (+1)
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD00E             BEQ.N    ??ADC_ExternalTrigInjectedConvEdgeConfig_1
   \   00000020   0xF5B5 0x1F80      CMP      R5,#+1048576
   \   00000024   0xD00B             BEQ.N    ??ADC_ExternalTrigInjectedConvEdgeConfig_1
   \   00000026   0xF5B5 0x1F00      CMP      R5,#+2097152
   \   0000002A   0xD008             BEQ.N    ??ADC_ExternalTrigInjectedConvEdgeConfig_1
   \   0000002C   0xF5B5 0x1F40      CMP      R5,#+3145728
   \   00000030   0xD005             BEQ.N    ??ADC_ExternalTrigInjectedConvEdgeConfig_1
   \   00000032   0xF240 0x5186      MOVW     R1,#+1414
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable34_1
   \   0000003A   0x.... 0x....      BL       assert_failed
   1415          
   1416            /* Get the old register value */
   1417            tmpreg = ADCx->CR2;
   \                     ??ADC_ExternalTrigInjectedConvEdgeConfig_1: (+1)
   \   0000003E   0x68A0             LDR      R0,[R4, #+8]
   \   00000040   0x0006             MOVS     R6,R0
   1418            /* Clear the old external trigger edge for injected group */
   1419            tmpreg &= CR2_JEXTEN_RESET;
   \   00000042   0xF436 0x1640      BICS     R6,R6,#0x300000
   1420            /* Set the new external trigger edge for injected group */
   1421            tmpreg |= ADC_ExternalTrigInjecConvEdge;
   \   00000046   0x432E             ORRS     R6,R5,R6
   1422            /* Store the new register value */
   1423            ADCx->CR2 = tmpreg;
   \   00000048   0x60A6             STR      R6,[R4, #+8]
   1424          }
   \   0000004A   0xBD70             POP      {R4-R6,PC}       ;; return
   1425          
   1426          /**
   1427            * @brief  Enables the selected ADC software start conversion of the injected 
   1428            *         channels.
   1429            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
   1430            * @retval None
   1431            */

   \                                 In section .text, align 2, keep-with-next
   1432          void ADC_SoftwareStartInjectedConv(ADC_TypeDef* ADCx)
   1433          {
   \                     ADC_SoftwareStartInjectedConv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1434            /* Check the parameters */
   1435            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable34  ;; 0x40012400
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD004             BEQ.N    ??ADC_SoftwareStartInjectedConv_0
   \   0000000C   0xF240 0x519B      MOVW     R1,#+1435
   \   00000010   0x....             LDR.N    R0,??DataTable34_1
   \   00000012   0x.... 0x....      BL       assert_failed
   1436            /* Enable the selected ADC conversion for injected group */
   1437            ADCx->CR2 |= (uint32_t)ADC_CR2_JSWSTART;
   \                     ??ADC_SoftwareStartInjectedConv_0: (+1)
   \   00000016   0x68A0             LDR      R0,[R4, #+8]
   \   00000018   0xF450 0x0080      ORRS     R0,R0,#0x400000
   \   0000001C   0x60A0             STR      R0,[R4, #+8]
   1438          }
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
   1439          
   1440          /**
   1441            * @brief  Gets the selected ADC Software start injected conversion Status.
   1442            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
   1443            * @retval The new state of ADC software start injected conversion (SET or RESET).
   1444            */

   \                                 In section .text, align 2, keep-with-next
   1445          FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)
   1446          {
   \                     ADC_GetSoftwareStartInjectedConvCmdStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1447            FlagStatus bitstatus = RESET;
   \   00000004   0x2500             MOVS     R5,#+0
   1448          
   1449            /* Check the parameters */
   1450            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000006   0x....             LDR.N    R0,??DataTable34  ;; 0x40012400
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD004             BEQ.N    ??ADC_GetSoftwareStartInjectedConvCmdStatus_0
   \   0000000C   0xF240 0x51AA      MOVW     R1,#+1450
   \   00000010   0x....             LDR.N    R0,??DataTable34_1
   \   00000012   0x.... 0x....      BL       assert_failed
   1451          
   1452            /* Check the status of JSWSTART bit */
   1453            if ((ADCx->CR2 & ADC_CR2_JSWSTART) != (uint32_t)RESET)
   \                     ??ADC_GetSoftwareStartInjectedConvCmdStatus_0: (+1)
   \   00000016   0x68A0             LDR      R0,[R4, #+8]
   \   00000018   0x0240             LSLS     R0,R0,#+9
   \   0000001A   0xD502             BPL.N    ??ADC_GetSoftwareStartInjectedConvCmdStatus_1
   1454            {
   1455              /* JSWSTART bit is set */
   1456              bitstatus = SET;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x0005             MOVS     R5,R0
   \   00000020   0xE001             B.N      ??ADC_GetSoftwareStartInjectedConvCmdStatus_2
   1457            }
   1458            else
   1459            {
   1460              /* JSWSTART bit is reset */
   1461              bitstatus = RESET;
   \                     ??ADC_GetSoftwareStartInjectedConvCmdStatus_1: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x0005             MOVS     R5,R0
   1462            }
   1463            /* Return the JSWSTART bit status */
   1464            return  bitstatus;
   \                     ??ADC_GetSoftwareStartInjectedConvCmdStatus_2: (+1)
   \   00000026   0x0028             MOVS     R0,R5
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1465          }
   1466          
   1467          /**
   1468            * @brief  Enables or disables the selected ADC automatic injected group
   1469            *         conversion after regular one.
   1470            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
   1471            * @param  NewState: new state of the selected ADC auto injected
   1472            *         conversion. 
   1473            *         This parameter can be: ENABLE or DISABLE.
   1474            * @retval None
   1475            */

   \                                 In section .text, align 2, keep-with-next
   1476          void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
   1477          {
   \                     ADC_AutoInjectedConvCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1478            /* Check the parameters */
   1479            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000006   0x....             LDR.N    R0,??DataTable34  ;; 0x40012400
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD004             BEQ.N    ??ADC_AutoInjectedConvCmd_0
   \   0000000C   0xF240 0x51C7      MOVW     R1,#+1479
   \   00000010   0x....             LDR.N    R0,??DataTable34_1
   \   00000012   0x.... 0x....      BL       assert_failed
   1480            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??ADC_AutoInjectedConvCmd_0: (+1)
   \   00000016   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD007             BEQ.N    ??ADC_AutoInjectedConvCmd_1
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D01             CMP      R5,#+1
   \   00000020   0xD004             BEQ.N    ??ADC_AutoInjectedConvCmd_1
   \   00000022   0xF44F 0x61B9      MOV      R1,#+1480
   \   00000026   0x....             LDR.N    R0,??DataTable34_1
   \   00000028   0x.... 0x....      BL       assert_failed
   1481          
   1482            if (NewState != DISABLE)
   \                     ??ADC_AutoInjectedConvCmd_1: (+1)
   \   0000002C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002E   0x2D00             CMP      R5,#+0
   \   00000030   0xD004             BEQ.N    ??ADC_AutoInjectedConvCmd_2
   1483            {
   1484              /* Enable the selected ADC automatic injected group conversion */
   1485              ADCx->CR1 |= (uint32_t)ADC_CR1_JAUTO;
   \   00000032   0x6860             LDR      R0,[R4, #+4]
   \   00000034   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000038   0x6060             STR      R0,[R4, #+4]
   \   0000003A   0xE003             B.N      ??ADC_AutoInjectedConvCmd_3
   1486            }
   1487            else
   1488            {
   1489              /* Disable the selected ADC automatic injected group conversion */
   1490              ADCx->CR1 &= (uint32_t)(~ADC_CR1_JAUTO);
   \                     ??ADC_AutoInjectedConvCmd_2: (+1)
   \   0000003C   0x6860             LDR      R0,[R4, #+4]
   \   0000003E   0xF430 0x6080      BICS     R0,R0,#0x400
   \   00000042   0x6060             STR      R0,[R4, #+4]
   1491            }
   1492          }
   \                     ??ADC_AutoInjectedConvCmd_3: (+1)
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1493          
   1494          /**
   1495            * @brief  Enables or disables the discontinuous mode for injected group
   1496            *         channel for the specified ADC
   1497            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
   1498            * @param  NewState: new state of the selected ADC discontinuous mode
   1499            *         on injected group channel. This parameter can be: ENABLE or DISABLE.
   1500            * @retval None
   1501            */

   \                                 In section .text, align 2, keep-with-next
   1502          void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
   1503          {
   \                     ADC_InjectedDiscModeCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1504            /* Check the parameters */
   1505            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000006   0x....             LDR.N    R0,??DataTable34  ;; 0x40012400
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD004             BEQ.N    ??ADC_InjectedDiscModeCmd_0
   \   0000000C   0xF240 0x51E1      MOVW     R1,#+1505
   \   00000010   0x....             LDR.N    R0,??DataTable34_1
   \   00000012   0x.... 0x....      BL       assert_failed
   1506            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??ADC_InjectedDiscModeCmd_0: (+1)
   \   00000016   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD007             BEQ.N    ??ADC_InjectedDiscModeCmd_1
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D01             CMP      R5,#+1
   \   00000020   0xD004             BEQ.N    ??ADC_InjectedDiscModeCmd_1
   \   00000022   0xF240 0x51E2      MOVW     R1,#+1506
   \   00000026   0x....             LDR.N    R0,??DataTable34_1
   \   00000028   0x.... 0x....      BL       assert_failed
   1507          
   1508            if (NewState != DISABLE)
   \                     ??ADC_InjectedDiscModeCmd_1: (+1)
   \   0000002C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002E   0x2D00             CMP      R5,#+0
   \   00000030   0xD004             BEQ.N    ??ADC_InjectedDiscModeCmd_2
   1509            {
   1510              /* Enable the selected ADC injected discontinuous mode */
   1511              ADCx->CR1 |= (uint32_t)ADC_CR1_JDISCEN;
   \   00000032   0x6860             LDR      R0,[R4, #+4]
   \   00000034   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   00000038   0x6060             STR      R0,[R4, #+4]
   \   0000003A   0xE003             B.N      ??ADC_InjectedDiscModeCmd_3
   1512            }
   1513            else
   1514            {
   1515              /* Disable the selected ADC injected discontinuous mode */
   1516              ADCx->CR1 &= (uint32_t)(~ADC_CR1_JDISCEN);
   \                     ??ADC_InjectedDiscModeCmd_2: (+1)
   \   0000003C   0x6860             LDR      R0,[R4, #+4]
   \   0000003E   0xF430 0x5080      BICS     R0,R0,#0x1000
   \   00000042   0x6060             STR      R0,[R4, #+4]
   1517            }
   1518          }
   \                     ??ADC_InjectedDiscModeCmd_3: (+1)
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1519          
   1520          /**
   1521            * @brief  Returns the ADC injected channel conversion result
   1522            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
   1523            * @param  ADC_InjectedChannel: the converted ADC injected channel.
   1524            *   This parameter can be one of the following values:
   1525            *     @arg ADC_InjectedChannel_1: Injected Channel1 selected
   1526            *     @arg ADC_InjectedChannel_2: Injected Channel2 selected
   1527            *     @arg ADC_InjectedChannel_3: Injected Channel3 selected
   1528            *     @arg ADC_InjectedChannel_4: Injected Channel4 selected
   1529            * @retval The Data conversion value.
   1530            */

   \                                 In section .text, align 2, keep-with-next
   1531          uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel)
   1532          {
   \                     ADC_GetInjectedConversionValue: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1533            __IO uint32_t tmp = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
   1534            
   1535            /* Check the parameters */
   1536            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   0000000A   0x....             LDR.N    R0,??DataTable34  ;; 0x40012400
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD004             BEQ.N    ??ADC_GetInjectedConversionValue_0
   \   00000010   0xF44F 0x61C0      MOV      R1,#+1536
   \   00000014   0x....             LDR.N    R0,??DataTable34_1
   \   00000016   0x.... 0x....      BL       assert_failed
   1537            assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
   \                     ??ADC_GetInjectedConversionValue_0: (+1)
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D18             CMP      R5,#+24
   \   0000001E   0xD00D             BEQ.N    ??ADC_GetInjectedConversionValue_1
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D1C             CMP      R5,#+28
   \   00000024   0xD00A             BEQ.N    ??ADC_GetInjectedConversionValue_1
   \   00000026   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000028   0x2D20             CMP      R5,#+32
   \   0000002A   0xD007             BEQ.N    ??ADC_GetInjectedConversionValue_1
   \   0000002C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002E   0x2D24             CMP      R5,#+36
   \   00000030   0xD004             BEQ.N    ??ADC_GetInjectedConversionValue_1
   \   00000032   0xF240 0x6101      MOVW     R1,#+1537
   \   00000036   0x....             LDR.N    R0,??DataTable34_1
   \   00000038   0x.... 0x....      BL       assert_failed
   1538          
   1539            tmp = (uint32_t)ADCx;
   \                     ??ADC_GetInjectedConversionValue_1: (+1)
   \   0000003C   0x9400             STR      R4,[SP, #+0]
   1540            tmp += ADC_InjectedChannel + JDR_OFFSET;
   \   0000003E   0x9800             LDR      R0,[SP, #+0]
   \   00000040   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000042   0xF115 0x0130      ADDS     R1,R5,#+48
   \   00000046   0x1808             ADDS     R0,R1,R0
   \   00000048   0x9000             STR      R0,[SP, #+0]
   1541            
   1542            /* Returns the selected injected channel conversion data value */
   1543            return (uint16_t) (*(__IO uint32_t*)  tmp); 
   \   0000004A   0x9800             LDR      R0,[SP, #+0]
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000050   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1544          }
   1545          
   1546          /**
   1547            * @}
   1548            */
   1549          
   1550          /** @defgroup ADC_Group8 Interrupts and flags management functions
   1551           *  @brief   Interrupts and flags management functions
   1552           *
   1553          @verbatim   
   1554           ===============================================================================
   1555                             Interrupts and flags management functions
   1556           ===============================================================================  
   1557          
   1558            This section provides functions allowing to configure the ADC Interrupts and get 
   1559            the status and clear flags and Interrupts pending bits.
   1560            
   1561            The ADC provide 4 Interrupts sources and 9 Flags which can be divided into 3 groups:
   1562            
   1563            I. Flags and Interrupts for ADC regular channels
   1564            =================================================
   1565            Flags :
   1566            ---------- 
   1567               1. ADC_FLAG_OVR : Overrun detection when regular converted data are lost
   1568          
   1569               2. ADC_FLAG_EOC : Regular channel end of conversion+ to indicate (depending 
   1570                        on EOCS bit, managed by ADC_EOCOnEachRegularChannelCmd() ) the end of :
   1571                         ==> a regular CHANNEL conversion 
   1572                         ==> sequence of regular GROUP conversions .
   1573          
   1574               3. ADC_FLAG_STRT: Regular channel start+ to indicate when regular CHANNEL 
   1575                        conversion starts.
   1576                        
   1577               4. ADC_FLAG_RCNR: Regular channel not ready+ to indicate if a new regular 
   1578                        conversion can be launched
   1579               
   1580            Interrupts :
   1581            ------------
   1582               1. ADC_IT_OVR 
   1583               2. ADC_IT_EOC 
   1584            
   1585            
   1586            II. Flags and Interrupts for ADC Injected channels
   1587            =================================================
   1588            Flags :
   1589            ---------- 
   1590               1. ADC_FLAG_JEOC : Injected channel end of conversion+ to indicate at 
   1591                         the end of injected GROUP conversion  
   1592                        
   1593               2. ADC_FLAG_JSTRT: Injected channel start+  to indicate hardware when 
   1594                         injected GROUP conversion starts.
   1595          
   1596               3. ADC_FLAG_JCNR: Injected channel not ready+ to indicate if a new 
   1597                         injected conversion can be launched.
   1598          
   1599            Interrupts :
   1600            ------------
   1601               1. ADC_IT_JEOC     
   1602          
   1603            III. General Flags and Interrupts for the ADC
   1604            ================================================= 
   1605            Flags :
   1606            ---------- 
   1607               1. ADC_FLAG_AWD: Analog watchdog+ to indicate if the converted voltage 
   1608                        crosses the programmed thresholds values.
   1609                        
   1610               2. ADC_FLAG_ADONS: ADC ON status+ to indicate if the ADC is ready to convert.
   1611           
   1612            Interrupts :
   1613            ------------
   1614               1. ADC_IT_AWD 
   1615          
   1616          @endverbatim
   1617            * @{
   1618            */ 
   1619          
   1620          /**
   1621            * @brief  Enables or disables the specified ADC interrupts.
   1622            * @param  ADCx: where x can be 1 to select the ADC peripheral.
   1623            * @param  ADC_IT: specifies the ADC interrupt sources to be enabled or disabled. 
   1624            *   This parameter can be one of the following values:
   1625            *     @arg ADC_IT_EOC: End of conversion interrupt 
   1626            *     @arg ADC_IT_AWD: Analog watchdog interrupt 
   1627            *     @arg ADC_IT_JEOC: End of injected conversion interrupt 
   1628            *     @arg ADC_IT_OVR: overrun interrupt                        
   1629            * @param  NewState: new state of the specified ADC interrupts.
   1630            *         This parameter can be: ENABLE or DISABLE.
   1631            * @retval None
   1632            */

   \                                 In section .text, align 2, keep-with-next
   1633          void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState)  
   1634          {
   \                     ADC_ITConfig: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000F             MOVS     R7,R1
   \   00000006   0x0015             MOVS     R5,R2
   1635            uint32_t itmask = 0;
   \   00000008   0x2600             MOVS     R6,#+0
   1636          
   1637            /* Check the parameters */
   1638            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   0000000A   0x....             LDR.N    R0,??DataTable34  ;; 0x40012400
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD004             BEQ.N    ??ADC_ITConfig_0
   \   00000010   0xF240 0x6166      MOVW     R1,#+1638
   \   00000014   0x....             LDR.N    R0,??DataTable34_1
   \   00000016   0x.... 0x....      BL       assert_failed
   1639            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??ADC_ITConfig_0: (+1)
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD007             BEQ.N    ??ADC_ITConfig_1
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D01             CMP      R5,#+1
   \   00000024   0xD004             BEQ.N    ??ADC_ITConfig_1
   \   00000026   0xF240 0x6167      MOVW     R1,#+1639
   \   0000002A   0x....             LDR.N    R0,??DataTable34_1
   \   0000002C   0x.... 0x....      BL       assert_failed
   1640            assert_param(IS_ADC_IT(ADC_IT)); 
   \                     ??ADC_ITConfig_1: (+1)
   \   00000030   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000032   0xF5B7 0x7F83      CMP      R7,#+262
   \   00000036   0xD013             BEQ.N    ??ADC_ITConfig_2
   \   00000038   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000003A   0xF240 0x2005      MOVW     R0,#+517
   \   0000003E   0x4287             CMP      R7,R0
   \   00000040   0xD00E             BEQ.N    ??ADC_ITConfig_2
   \   00000042   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000044   0xF240 0x4007      MOVW     R0,#+1031
   \   00000048   0x4287             CMP      R7,R0
   \   0000004A   0xD009             BEQ.N    ??ADC_ITConfig_2
   \   0000004C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000004E   0xF242 0x001A      MOVW     R0,#+8218
   \   00000052   0x4287             CMP      R7,R0
   \   00000054   0xD004             BEQ.N    ??ADC_ITConfig_2
   \   00000056   0xF44F 0x61CD      MOV      R1,#+1640
   \   0000005A   0x....             LDR.N    R0,??DataTable34_1
   \   0000005C   0x.... 0x....      BL       assert_failed
   1641          
   1642            /* Get the ADC IT index */
   1643            itmask = (uint8_t)ADC_IT;
   \                     ??ADC_ITConfig_2: (+1)
   \   00000060   0x0038             MOVS     R0,R7
   \   00000062   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000064   0x0006             MOVS     R6,R0
   1644            itmask = (uint32_t)0x01 << itmask;    
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0xFA10 0xF606      LSLS     R6,R0,R6
   1645          
   1646            if (NewState != DISABLE)
   \   0000006C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000006E   0x2D00             CMP      R5,#+0
   \   00000070   0xD003             BEQ.N    ??ADC_ITConfig_3
   1647            {
   1648              /* Enable the selected ADC interrupts */
   1649              ADCx->CR1 |= itmask;
   \   00000072   0x6860             LDR      R0,[R4, #+4]
   \   00000074   0x4330             ORRS     R0,R6,R0
   \   00000076   0x6060             STR      R0,[R4, #+4]
   \   00000078   0xE002             B.N      ??ADC_ITConfig_4
   1650            }
   1651            else
   1652            {
   1653              /* Disable the selected ADC interrupts */
   1654              ADCx->CR1 &= (~(uint32_t)itmask);
   \                     ??ADC_ITConfig_3: (+1)
   \   0000007A   0x6860             LDR      R0,[R4, #+4]
   \   0000007C   0x43B0             BICS     R0,R0,R6
   \   0000007E   0x6060             STR      R0,[R4, #+4]
   1655            }
   1656          }
   \                     ??ADC_ITConfig_4: (+1)
   \   00000080   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1657          
   1658          /**
   1659            * @brief  Checks whether the specified ADC flag is set or not.
   1660            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
   1661            * @param  ADC_FLAG: specifies the flag to check. 
   1662            *   This parameter can be one of the following values:
   1663            *     @arg ADC_FLAG_AWD: Analog watchdog flag
   1664            *     @arg ADC_FLAG_EOC: End of conversion flag
   1665            *     @arg ADC_FLAG_JEOC: End of injected group conversion flag
   1666            *     @arg ADC_FLAG_JSTRT: Start of injected group conversion flag
   1667            *     @arg ADC_FLAG_STRT: Start of regular group conversion flag
   1668            *     @arg ADC_FLAG_OVR: Overrun flag   
   1669            *     @arg ADC_FLAG_ADONS: ADC ON status 
   1670            *     @arg ADC_FLAG_RCNR: Regular channel not ready 
   1671            *     @arg ADC_FLAG_JCNR: Injected channel not ready 
   1672            * @retval The new state of ADC_FLAG (SET or RESET).
   1673            */

   \                                 In section .text, align 2, keep-with-next
   1674          FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint16_t ADC_FLAG)
   1675          {
   \                     ADC_GetFlagStatus: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1676            FlagStatus bitstatus = RESET;
   \   00000006   0x2600             MOVS     R6,#+0
   1677          
   1678            /* Check the parameters */
   1679            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000008   0x....             LDR.N    R0,??DataTable34  ;; 0x40012400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD004             BEQ.N    ??ADC_GetFlagStatus_0
   \   0000000E   0xF240 0x618F      MOVW     R1,#+1679
   \   00000012   0x....             LDR.N    R0,??DataTable34_1
   \   00000014   0x.... 0x....      BL       assert_failed
   1680            assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
   \                     ??ADC_GetFlagStatus_0: (+1)
   \   00000018   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000001A   0x2D01             CMP      R5,#+1
   \   0000001C   0xD01E             BEQ.N    ??ADC_GetFlagStatus_1
   \   0000001E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000020   0x2D02             CMP      R5,#+2
   \   00000022   0xD01B             BEQ.N    ??ADC_GetFlagStatus_1
   \   00000024   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000026   0x2D04             CMP      R5,#+4
   \   00000028   0xD018             BEQ.N    ??ADC_GetFlagStatus_1
   \   0000002A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002C   0x2D08             CMP      R5,#+8
   \   0000002E   0xD015             BEQ.N    ??ADC_GetFlagStatus_1
   \   00000030   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000032   0x2D10             CMP      R5,#+16
   \   00000034   0xD012             BEQ.N    ??ADC_GetFlagStatus_1
   \   00000036   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000038   0x2D20             CMP      R5,#+32
   \   0000003A   0xD00F             BEQ.N    ??ADC_GetFlagStatus_1
   \   0000003C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000003E   0x2D40             CMP      R5,#+64
   \   00000040   0xD00C             BEQ.N    ??ADC_GetFlagStatus_1
   \   00000042   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000044   0xF5B5 0x7F80      CMP      R5,#+256
   \   00000048   0xD008             BEQ.N    ??ADC_GetFlagStatus_1
   \   0000004A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004C   0xF5B5 0x7F00      CMP      R5,#+512
   \   00000050   0xD004             BEQ.N    ??ADC_GetFlagStatus_1
   \   00000052   0xF44F 0x61D2      MOV      R1,#+1680
   \   00000056   0x....             LDR.N    R0,??DataTable34_1
   \   00000058   0x.... 0x....      BL       assert_failed
   1681          
   1682            /* Check the status of the specified ADC flag */
   1683            if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
   \                     ??ADC_GetFlagStatus_1: (+1)
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000060   0x4228             TST      R0,R5
   \   00000062   0xD002             BEQ.N    ??ADC_GetFlagStatus_2
   1684            {
   1685              /* ADC_FLAG is set */
   1686              bitstatus = SET;
   \   00000064   0x2001             MOVS     R0,#+1
   \   00000066   0x0006             MOVS     R6,R0
   \   00000068   0xE001             B.N      ??ADC_GetFlagStatus_3
   1687            }
   1688            else
   1689            {
   1690              /* ADC_FLAG is reset */
   1691              bitstatus = RESET;
   \                     ??ADC_GetFlagStatus_2: (+1)
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x0006             MOVS     R6,R0
   1692            }
   1693            /* Return the ADC_FLAG status */
   1694            return  bitstatus;
   \                     ??ADC_GetFlagStatus_3: (+1)
   \   0000006E   0x0030             MOVS     R0,R6
   \   00000070   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000072   0xBD70             POP      {R4-R6,PC}       ;; return
   1695          }
   1696          
   1697          /**
   1698            * @brief  Clears the ADCx's pending flags.
   1699            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
   1700            * @param  ADC_FLAG: specifies the flag to clear. 
   1701            *   This parameter can be any combination of the following values:
   1702            *     @arg ADC_FLAG_AWD: Analog watchdog flag
   1703            *     @arg ADC_FLAG_EOC: End of conversion flag
   1704            *     @arg ADC_FLAG_JEOC: End of injected group conversion flag
   1705            *     @arg ADC_FLAG_JSTRT: Start of injected group conversion flag
   1706            *     @arg ADC_FLAG_STRT: Start of regular group conversion flag
   1707            *     @arg ADC_FLAG_OVR: overrun flag                                              
   1708            * @retval None
   1709            */

   \                                 In section .text, align 2, keep-with-next
   1710          void ADC_ClearFlag(ADC_TypeDef* ADCx, uint16_t ADC_FLAG)
   1711          {
   \                     ADC_ClearFlag: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1712            /* Check the parameters */
   1713            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000006   0x....             LDR.N    R0,??DataTable34  ;; 0x40012400
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD004             BEQ.N    ??ADC_ClearFlag_0
   \   0000000C   0xF240 0x61B1      MOVW     R1,#+1713
   \   00000010   0x....             LDR.N    R0,??DataTable34_1
   \   00000012   0x.... 0x....      BL       assert_failed
   1714            assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
   \                     ??ADC_ClearFlag_0: (+1)
   \   00000016   0xF64F 0x70C0      MOVW     R0,#+65472
   \   0000001A   0x4205             TST      R5,R0
   \   0000001C   0xD102             BNE.N    ??ADC_ClearFlag_1
   \   0000001E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD104             BNE.N    ??ADC_ClearFlag_2
   \                     ??ADC_ClearFlag_1: (+1)
   \   00000024   0xF240 0x61B2      MOVW     R1,#+1714
   \   00000028   0x....             LDR.N    R0,??DataTable34_1
   \   0000002A   0x.... 0x....      BL       assert_failed
   1715          
   1716            /* Clear the selected ADC flags */
   1717            ADCx->SR = ~(uint32_t)ADC_FLAG;
   \                     ??ADC_ClearFlag_2: (+1)
   \   0000002E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000030   0x43E8             MVNS     R0,R5
   \   00000032   0x6020             STR      R0,[R4, #+0]
   1718          }
   \   00000034   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1719          
   1720          /**
   1721            * @brief  Checks whether the specified ADC interrupt has occurred or not.
   1722            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
   1723            * @param  ADC_IT: specifies the ADC interrupt source to check. 
   1724            *   This parameter can be one of the following values:
   1725            *     @arg ADC_IT_EOC: End of conversion interrupt 
   1726            *     @arg ADC_IT_AWD: Analog watchdog interrupt 
   1727            *     @arg ADC_IT_JEOC: End of injected conversion interrupt 
   1728            *     @arg ADC_IT_OVR: Overrun interrupt                         
   1729            * @retval The new state of ADC_IT (SET or RESET).
   1730            */

   \                                 In section .text, align 2, keep-with-next
   1731          ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT)
   1732          {
   \                     ADC_GetITStatus: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1733            ITStatus bitstatus = RESET;
   \   00000008   0x2600             MOVS     R6,#+0
   1734            uint32_t itmask = 0, enablestatus = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   1735          
   1736            /* Check the parameters */
   1737            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000010   0x....             LDR.N    R0,??DataTable34  ;; 0x40012400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD004             BEQ.N    ??ADC_GetITStatus_0
   \   00000016   0xF240 0x61C9      MOVW     R1,#+1737
   \   0000001A   0x....             LDR.N    R0,??DataTable34_1
   \   0000001C   0x.... 0x....      BL       assert_failed
   1738            assert_param(IS_ADC_IT(ADC_IT));
   \                     ??ADC_GetITStatus_0: (+1)
   \   00000020   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000022   0xF5B5 0x7F83      CMP      R5,#+262
   \   00000026   0xD013             BEQ.N    ??ADC_GetITStatus_1
   \   00000028   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002A   0xF240 0x2005      MOVW     R0,#+517
   \   0000002E   0x4285             CMP      R5,R0
   \   00000030   0xD00E             BEQ.N    ??ADC_GetITStatus_1
   \   00000032   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000034   0xF240 0x4007      MOVW     R0,#+1031
   \   00000038   0x4285             CMP      R5,R0
   \   0000003A   0xD009             BEQ.N    ??ADC_GetITStatus_1
   \   0000003C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000003E   0xF242 0x001A      MOVW     R0,#+8218
   \   00000042   0x4285             CMP      R5,R0
   \   00000044   0xD004             BEQ.N    ??ADC_GetITStatus_1
   \   00000046   0xF240 0x61CA      MOVW     R1,#+1738
   \   0000004A   0x....             LDR.N    R0,??DataTable34_1
   \   0000004C   0x.... 0x....      BL       assert_failed
   1739          
   1740            /* Get the ADC IT index */
   1741            itmask = (uint32_t)((uint32_t)ADC_IT >> 8);
   \                     ??ADC_GetITStatus_1: (+1)
   \   00000050   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000052   0x0A28             LSRS     R0,R5,#+8
   \   00000054   0x0007             MOVS     R7,R0
   1742          
   1743            /* Get the ADC_IT enable bit status */
   1744            enablestatus = (ADCx->CR1 & ((uint32_t)0x01 << (uint8_t)ADC_IT)); 
   \   00000056   0x6860             LDR      R0,[R4, #+4]
   \   00000058   0x2101             MOVS     R1,#+1
   \   0000005A   0x40A9             LSLS     R1,R1,R5
   \   0000005C   0x4008             ANDS     R0,R1,R0
   \   0000005E   0x4680             MOV      R8,R0
   1745          
   1746            /* Check the status of the specified ADC interrupt */
   1747            if (((uint32_t)(ADCx->SR & (uint32_t)itmask) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x4238             TST      R0,R7
   \   00000064   0xD005             BEQ.N    ??ADC_GetITStatus_2
   \   00000066   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000006A   0xD002             BEQ.N    ??ADC_GetITStatus_2
   1748            {                                                         
   1749              /* ADC_IT is set */
   1750              bitstatus = SET;
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0x0006             MOVS     R6,R0
   \   00000070   0xE001             B.N      ??ADC_GetITStatus_3
   1751            }
   1752            else
   1753            {
   1754              /* ADC_IT is reset */
   1755              bitstatus = RESET;
   \                     ??ADC_GetITStatus_2: (+1)
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x0006             MOVS     R6,R0
   1756            }
   1757            /* Return the ADC_IT status */
   1758            return  bitstatus;
   \                     ??ADC_GetITStatus_3: (+1)
   \   00000076   0x0030             MOVS     R0,R6
   \   00000078   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1759          }
   1760          
   1761          /**
   1762            * @brief  Clears the ADCxs interrupt pending bits.
   1763            * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
   1764            * @param  ADC_IT: specifies the ADC interrupt pending bit to clear.
   1765            *   This parameter can be one of the following values:
   1766            *     @arg ADC_IT_EOC: End of conversion interrupt 
   1767            *     @arg ADC_IT_AWD: Analog watchdog interrupt 
   1768            *     @arg ADC_IT_JEOC: End of injected conversion interrupt 
   1769            *     @arg ADC_IT_OVR: Overrun interrupt                          
   1770            * @retval None
   1771            */

   \                                 In section .text, align 2, keep-with-next
   1772          void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT)
   1773          {
   \                     ADC_ClearITPendingBit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1774            uint8_t itmask = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1775          
   1776            /* Check the parameters */
   1777            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000008   0x....             LDR.N    R0,??DataTable34  ;; 0x40012400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD004             BEQ.N    ??ADC_ClearITPendingBit_0
   \   0000000E   0xF240 0x61F1      MOVW     R1,#+1777
   \   00000012   0x....             LDR.N    R0,??DataTable34_1
   \   00000014   0x.... 0x....      BL       assert_failed
   1778            assert_param(IS_ADC_IT(ADC_IT)); 
   \                     ??ADC_ClearITPendingBit_0: (+1)
   \   00000018   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000001A   0xF5B5 0x7F83      CMP      R5,#+262
   \   0000001E   0xD013             BEQ.N    ??ADC_ClearITPendingBit_1
   \   00000020   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000022   0xF240 0x2005      MOVW     R0,#+517
   \   00000026   0x4285             CMP      R5,R0
   \   00000028   0xD00E             BEQ.N    ??ADC_ClearITPendingBit_1
   \   0000002A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002C   0xF240 0x4007      MOVW     R0,#+1031
   \   00000030   0x4285             CMP      R5,R0
   \   00000032   0xD009             BEQ.N    ??ADC_ClearITPendingBit_1
   \   00000034   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000036   0xF242 0x001A      MOVW     R0,#+8218
   \   0000003A   0x4285             CMP      R5,R0
   \   0000003C   0xD004             BEQ.N    ??ADC_ClearITPendingBit_1
   \   0000003E   0xF240 0x61F2      MOVW     R1,#+1778
   \   00000042   0x....             LDR.N    R0,??DataTable34_1
   \   00000044   0x.... 0x....      BL       assert_failed
   1779          
   1780            /* Get the ADC IT index */
   1781            itmask = (uint8_t)(ADC_IT >> 8);
   \                     ??ADC_ClearITPendingBit_1: (+1)
   \   00000048   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004A   0x0A28             LSRS     R0,R5,#+8
   \   0000004C   0x0006             MOVS     R6,R0
   1782          
   1783            /* Clear the selected ADC interrupt pending bits */
   1784            ADCx->SR = ~(uint32_t)itmask;
   \   0000004E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000050   0x43F0             MVNS     R0,R6
   \   00000052   0x6020             STR      R0,[R4, #+0]
   1785          }
   \   00000054   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x40012400         DC32     0x40012400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   0xFCFFFEFF         DC32     0xfcfffeff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   0xC0FFF7FD         DC32     0xc0fff7fd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29:
   \   00000000   0x40012704         DC32     0x40012704

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30:
   \   00000000   0x00800200         DC32     0x800200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_1:
   \   00000000   0x00400200         DC32     0x400200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_2:
   \   00000000   0x00C00200         DC32     0xc00200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32:
   \   00000000   0xFF3FFDFF         DC32     0xff3ffdff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34:
   \   00000000   0x40012400         DC32     0x40012400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x45 0x3A          DC8 45H, 3AH, 5CH, 41H, 43H, 51H, 5CH, 50H
   \              0x5C 0x41    
   \              0x43 0x51    
   \              0x5C 0x50    
   \   00000008   0x72 0x6F          DC8 72H, 6FH, 6AH, 5FH, 76H, 65H, 72H, 30H
   \              0x6A 0x5F    
   \              0x76 0x65    
   \              0x72 0x30    
   \   00000010   0x39 0x61          DC8 39H, 61H, 5FH, 31H, 35H, 31H, 30H, 32H
   \              0x5F 0x31    
   \              0x35 0x31    
   \              0x30 0x32    
   \   00000018   0x30 0x31          DC8 30H, 31H, 35H, 5CH, 42H, 61H, 73H, 65H
   \              0x35 0x5C    
   \              0x42 0x61    
   \              0x73 0x65    
   \   00000020   0x5F 0x30          DC8 5FH, 30H, 32H, 5CH, 32H, 30H, 31H, 33H
   \              0x32 0x5C    
   \              0x32 0x30    
   \              0x31 0x33    
   \   00000028   0x5F 0x31          DC8 5FH, 31H, 31H, 5FH, 32H, 35H, 5FH, 53H
   \              0x31 0x5F    
   \              0x32 0x35    
   \              0x5F 0x53    
   \   00000030   0x70 0x69          DC8 70H, 69H, 72H, 69H, 74H, 31H, 5FH, 45H
   \              0x72 0x69    
   \              0x74 0x31    
   \              0x5F 0x45    
   \   00000038   0x6C 0x65          DC8 6CH, 65H, 6BH, 74H, 72H, 6FH, 6CH, 75H
   \              0x6B 0x74    
   \              0x72 0x6F    
   \              0x6C 0x75    
   \   00000040   0x78 0x5C          DC8 78H, 5CH, 53H, 54H, 4DH, 33H, 32H, 4CH
   \              0x53 0x54    
   \              0x4D 0x33    
   \              0x32 0x4C    
   \   00000048   0x5C 0x53          DC8 5CH, 53H, 54H, 4DH, 33H, 32H, 4CH, 31H
   \              0x54 0x4D    
   \              0x33 0x32    
   \              0x4C 0x31    
   \   00000050   0x78 0x78          DC8 78H, 78H, 5FH, 53H, 74H, 64H, 50H, 65H
   \              0x5F 0x53    
   \              0x74 0x64    
   \              0x50 0x65    
   \   00000058   0x72 0x69          DC8 72H, 69H, 70H, 68H, 5FH, 4CH, 69H, 62H
   \              0x70 0x68    
   \              0x5F 0x4C    
   \              0x69 0x62    
   \   00000060   0x5C 0x53          DC8 5CH, 53H, 6FH, 75H, 72H, 63H, 65H, 5CH
   \              0x6F 0x75    
   \              0x72 0x63    
   \              0x65 0x5C    
   \   00000068   0x53 0x54          DC8 53H, 54H, 4DH, 33H, 32H, 4CH, 31H, 78H
   \              0x4D 0x33    
   \              0x32 0x4C    
   \              0x31 0x78    
   \   00000070   0x78 0x5F          DC8 78H, 5FH, 53H, 74H, 64H, 50H, 65H, 72H
   \              0x53 0x74    
   \              0x64 0x50    
   \              0x65 0x72    
   \   00000078   0x69 0x70          DC8 69H, 70H, 68H, 5FH, 44H, 72H, 69H, 76H
   \              0x68 0x5F    
   \              0x44 0x72    
   \              0x69 0x76    
   \   00000080   0x65 0x72          DC8 65H, 72H, 5CH, 73H, 72H, 63H, 5CH, 73H
   \              0x5C 0x73    
   \              0x72 0x63    
   \              0x5C 0x73    
   \   00000088   0x74 0x6D          DC8 74H, 6DH, 33H, 32H, 6CH, 31H, 78H, 78H
   \              0x33 0x32    
   \              0x6C 0x31    
   \              0x78 0x78    
   \   00000090   0x5F 0x61          DC8 5FH, 61H, 64H, 63H, 2EH, 63H, 0
   \              0x64 0x63    
   \              0x2E 0x63    
   \              0x00         
   \   00000097   0x00               DC8 0
   1786          
   1787          /**
   1788            * @}
   1789            */
   1790          
   1791          /**
   1792            * @}
   1793            */ 
   1794          
   1795          /**
   1796            * @}
   1797            */ 
   1798          
   1799          /**
   1800            * @}
   1801            */ 
   1802          
   1803          /******************* (C) COPYRIGHT 2010 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   ADC_AnalogWatchdogCmd
        16   -> assert_failed
      16   ADC_AnalogWatchdogSingleChannelConfig
        16   -> assert_failed
      16   ADC_AnalogWatchdogThresholdsConfig
        16   -> assert_failed
      16   ADC_AutoInjectedConvCmd
        16   -> assert_failed
      16   ADC_ClearFlag
        16   -> assert_failed
      16   ADC_ClearITPendingBit
        16   -> assert_failed
      16   ADC_Cmd
        16   -> assert_failed
      16   ADC_CommonInit
        16   -> assert_failed
       0   ADC_CommonStructInit
      16   ADC_ContinuousModeCmd
        16   -> assert_failed
      16   ADC_DMACmd
        16   -> assert_failed
      16   ADC_DMARequestAfterLastTransferCmd
        16   -> assert_failed
       8   ADC_DeInit
         8   -> RCC_APB2PeriphResetCmd
         8   -> assert_failed
      16   ADC_DelaySelectionConfig
        16   -> assert_failed
      24   ADC_DiscModeChannelCountConfig
        24   -> assert_failed
      16   ADC_DiscModeCmd
        16   -> assert_failed
      16   ADC_EOCOnEachRegularChannelCmd
        16   -> assert_failed
      16   ADC_ExternalTrigInjectedConvConfig
        16   -> assert_failed
      16   ADC_ExternalTrigInjectedConvEdgeConfig
        16   -> assert_failed
       8   ADC_GetConversionValue
         8   -> assert_failed
      16   ADC_GetFlagStatus
        16   -> assert_failed
      24   ADC_GetITStatus
        24   -> assert_failed
      16   ADC_GetInjectedConversionValue
        16   -> assert_failed
      16   ADC_GetSoftwareStartConvStatus
        16   -> assert_failed
      16   ADC_GetSoftwareStartInjectedConvCmdStatus
        16   -> assert_failed
      24   ADC_ITConfig
        24   -> assert_failed
      24   ADC_Init
        24   -> assert_failed
      32   ADC_InjectedChannelConfig
        32   -> assert_failed
      16   ADC_InjectedDiscModeCmd
        16   -> assert_failed
      24   ADC_InjectedSequencerLengthConfig
        24   -> assert_failed
      16   ADC_PowerDownCmd
        16   -> assert_failed
      32   ADC_RegularChannelConfig
        32   -> assert_failed
      24   ADC_SetInjectedOffset
        24   -> assert_failed
       8   ADC_SoftwareStartConv
         8   -> assert_failed
       8   ADC_SoftwareStartInjectedConv
         8   -> assert_failed
       0   ADC_StructInit
       8   ADC_TempSensorVrefintCmd
         8   -> assert_failed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable20
       4  ??DataTable21
       4  ??DataTable24
       4  ??DataTable28
       4  ??DataTable29
       4  ??DataTable30
       4  ??DataTable30_1
       4  ??DataTable30_2
       4  ??DataTable32
       4  ??DataTable34
       4  ??DataTable34_1
     152  ?_0
     102  ADC_AnalogWatchdogCmd
     212  ADC_AnalogWatchdogSingleChannelConfig
      78  ADC_AnalogWatchdogThresholdsConfig
      70  ADC_AutoInjectedConvCmd
      54  ADC_ClearFlag
      86  ADC_ClearITPendingBit
      76  ADC_Cmd
      64  ADC_CommonInit
       6  ADC_CommonStructInit
      76  ADC_ContinuousModeCmd
      70  ADC_DMACmd
      70  ADC_DMARequestAfterLastTransferCmd
      44  ADC_DeInit
     104  ADC_DelaySelectionConfig
      74  ADC_DiscModeChannelCountConfig
      70  ADC_DiscModeCmd
      76  ADC_EOCOnEachRegularChannelCmd
     124  ADC_ExternalTrigInjectedConvConfig
      76  ADC_ExternalTrigInjectedConvEdgeConfig
      26  ADC_GetConversionValue
     116  ADC_GetFlagStatus
     126  ADC_GetITStatus
      82  ADC_GetInjectedConversionValue
      48  ADC_GetSoftwareStartConvStatus
      44  ADC_GetSoftwareStartInjectedConvCmdStatus
     130  ADC_ITConfig
     378  ADC_Init
     504  ADC_InjectedChannelConfig
      70  ADC_InjectedDiscModeCmd
      72  ADC_InjectedSequencerLengthConfig
     104  ADC_PowerDownCmd
     700  ADC_RegularChannelConfig
     108  ADC_SetInjectedOffset
      34  ADC_SoftwareStartConv
      32  ADC_SoftwareStartInjectedConv
      32  ADC_StructInit
      70  ADC_TempSensorVrefintCmd

 
   152 bytes in section .rodata
 4 252 bytes in section .text
 
 4 252 bytes of CODE  memory
   152 bytes of CONST memory

Errors: none
Warnings: none
