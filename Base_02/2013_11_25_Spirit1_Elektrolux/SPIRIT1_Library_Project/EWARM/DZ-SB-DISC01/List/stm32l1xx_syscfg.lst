###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        20/Nov/2015  05:05:51
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_syscfg.c
#    Command line =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_syscfg.c
#        -D USE_STDPERIPH_DRIVER -D VECT_TAB_FLASH -D STM32L1XX_MD -D
#        IAR_ARM_CM3 -D USE_FULL_ASSERT -D SPIRIT_USE_FULL_ASSERT -D
#        USE_SYSTICK_DELAY -D SDK -lC
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\List\
#        -o
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\.\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\examples\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\runtime\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\SDK_Eval_STM32L\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\SPIRIT1_Library\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\SDK_Eval_Util\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\SDK_Virtual_Com\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32_USB-FS-Device_Lib\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\ACQ\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\CMSIS\Include\"
#    List file    =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\List\stm32l1xx_syscfg.lst
#    Object file  =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\Obj\stm32l1xx_syscfg.o
#
###############################################################################

E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_syscfg.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_syscfg.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    31-December-2010
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the SYSCFG and RI peripherals:           
      9            *           - SYSCFG Initialization and Configuration
     10            *           - RI Initialization and Configuration
     11            *
     12            *  @verbatim
     13            *  
     14            *          ===================================================================
     15            *                                 How to use this driver
     16            *          ===================================================================
     17            *                  
     18            *          This driver provides functions for:
     19            *          
     20            *          1. Remapping the memory accessible in the code area using
     21            *             SYSCFG_MemoryRemapConfig()  
     22            *          2. Manage the EXTI lines connection to the GPIOs using
     23            *             SYSCFG_EXTILineConfig().
     24            *          3. Routing of I/Os toward the input captures of timers (TIM2, TIM3 and TIM4).
     25            *          4. Input routing of COMP1 and COMP2
     26            *          5. Routing of internal reference voltage VREFINT to PB0 and PB1.
     27            *
     28            *          6. The RI registers can be accessed only when the comparator 
     29            *             APB interface clock is enabled.
     30            *             To enable comparator clock use:
     31            *             RCC_APB1PeriphClockCmd(RCC_APB1Periph_COMP, ENABLE);
     32            *
     33            *             Following functions uses RI registers:
     34            *                   - SYSCFG_RIDeInit()
     35            *                   - SYSCFG_RITIMSelect()
     36            *                   - SYSCFG_RITIMInputCaptureConfig()
     37            *                   - SYSCFG_RIResistorConfig()
     38            *                   - SYSCFG_RIIOSwitchConfig()
     39            *                   - SYSCFG_RISwitchControlModeCmd()
     40            *                   - SYSCFG_RIHysteresisConfig()
     41            *
     42            *          7- The SYSCFG registers can be accessed only when the SYSCFG 
     43            *             interface APB clock is enabled.
     44            *             To enable SYSCFG APB clock use:
     45            *             RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
     46            *
     47            *             Following functions uses SYSCFG registers:
     48            *                   - SYSCFG_MemoryRemapConfig()
     49            *                   - SYSCFG_USBPuCmd()
     50            *                   - SYSCFG_EXTILineConfig()
     51            *                 
     52            *  @endverbatim
     53            *      
     54            ******************************************************************************
     55            * @attention
     56            *
     57            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     58            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     59            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     60            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     61            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     62            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     63            *
     64            * <h2><center>&copy; COPYRIGHT 2010 STMicroelectronics</center></h2>
     65            ******************************************************************************  
     66            */ 
     67          
     68          /* Includes ------------------------------------------------------------------*/
     69          #include "stm32l1xx_syscfg.h"
     70          #include "stm32l1xx_rcc.h"
     71          
     72          /** @addtogroup STM32L1xx_StdPeriph_Driver
     73            * @{
     74            */
     75          
     76          /** @defgroup SYSCFG 
     77            * @brief SYSCFG driver modules
     78            * @{
     79            */ 
     80          
     81          /* Private typedef -----------------------------------------------------------*/
     82          /* Private define ------------------------------------------------------------*/
     83          #define TIM_SELECT_MASK             ((uint32_t)0xFFFCFFFF) /*!< TIM select mask */
     84          #define IC_ROUTING_MASK             ((uint32_t)0x0000000F) /*!< Input Capture routing mask */
     85          
     86          /* Private macro -------------------------------------------------------------*/
     87          /* Private variables ---------------------------------------------------------*/
     88          /* Private function prototypes -----------------------------------------------*/
     89          /* Private functions ---------------------------------------------------------*/
     90          
     91          /** @defgroup SYSCFG_Private_Functions
     92            * @{
     93            */ 
     94          
     95          /** @defgroup SYSCFG_Group1 SYSCFG Initialization and Configuration functions
     96           *  @brief   SYSCFG Initialization and Configuration functions 
     97           *
     98          @verbatim   
     99           ===============================================================================
    100                       SYSCFG Initialization and Configuration functions
    101           ===============================================================================  
    102          
    103          @endverbatim
    104            * @{
    105            */
    106          
    107          /**
    108            * @brief  Deinitializes the SYSCFG registers to their default reset values.
    109            * @param  None
    110            * @retval None
    111            * @ Note: MEMRMP bits are not reset by APB2 reset.
    112            */

   \                                 In section .text, align 2, keep-with-next
    113          void SYSCFG_DeInit(void)
    114          {
   \                     SYSCFG_DeInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    115             RCC_APB2PeriphResetCmd(RCC_APB2Periph_SYSCFG, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    116             RCC_APB2PeriphResetCmd(RCC_APB2Periph_SYSCFG, DISABLE);
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    117          }
   \   00000012   0xBD01             POP      {R0,PC}          ;; return
    118          
    119          /**
    120            * @brief Deinitializes the RI registers to their default reset values.
    121            * @param  None
    122            * @retval None
    123            */

   \                                 In section .text, align 2, keep-with-next
    124          void SYSCFG_RIDeInit(void)
    125          {
    126            RI->ICR     = ((uint32_t)0x00000000);    /*!< Set RI->ICR to reset value */
   \                     SYSCFG_RIDeInit: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0x40007c04
   \   00000006   0x6008             STR      R0,[R1, #+0]
    127            RI->ASCR1   = ((uint32_t)0x00000000);    /*!< Set RI->ASCR1 to reset value */  
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable9_1  ;; 0x40007c08
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    128            RI->ASCR2   = ((uint32_t)0x00000000);    /*!< Set RI->ASCR2 to reset value */  
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x40007c0c
   \   00000016   0x6008             STR      R0,[R1, #+0]
    129            RI->HYSCR1  = ((uint32_t)0x00000000);    /*!< Set RI->HYSCR1 to reset value */
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable9_3  ;; 0x40007c10
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    130            RI->HYSCR2  = ((uint32_t)0x00000000);    /*!< Set RI->HYSCR2 to reset value */
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable9_4  ;; 0x40007c14
   \   00000026   0x6008             STR      R0,[R1, #+0]
    131            RI->HYSCR3  = ((uint32_t)0x00000000);    /*!< Set RI->HYSCR3 to reset value */
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable9_5  ;; 0x40007c18
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    132          }
   \   00000030   0x4770             BX       LR               ;; return
    133          
    134          /**
    135            * @brief  Changes the mapping of the specified memory.
    136            * @param  SYSCFG_Memory: selects the memory remapping.
    137            *   This parameter can be one of the following values:
    138            *     @arg SYSCFG_MemoryRemap_Flash:       Main Flash memory mapped at 0x00000000  
    139            *     @arg SYSCFG_MemoryRemap_SystemFlash: System Flash memory mapped at 0x00000000
    140            *     @arg SYSCFG_MemoryRemap_SRAM:        Embedded SRAM mapped at 0x00000000     
    141            * @retval None
    142            */

   \                                 In section .text, align 2, keep-with-next
    143          void SYSCFG_MemoryRemapConfig(uint8_t SYSCFG_MemoryRemap)
    144          {
   \                     SYSCFG_MemoryRemapConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    145            /* Check the parameters */
    146            assert_param(IS_SYSCFG_MEMORY_REMAP_CONFING(SYSCFG_MemoryRemap));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD00A             BEQ.N    ??SYSCFG_MemoryRemapConfig_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD007             BEQ.N    ??SYSCFG_MemoryRemapConfig_0
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C03             CMP      R4,#+3
   \   00000014   0xD004             BEQ.N    ??SYSCFG_MemoryRemapConfig_0
   \   00000016   0x2192             MOVS     R1,#+146
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable9_6
   \   0000001C   0x.... 0x....      BL       assert_failed
    147            SYSCFG->MEMRMP = SYSCFG_MemoryRemap;
   \                     ??SYSCFG_MemoryRemapConfig_0: (+1)
   \   00000020   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable9_7  ;; 0x40010000
   \   00000026   0x6004             STR      R4,[R0, #+0]
    148          }
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    149          
    150          /**
    151            * @brief  Control the internal pull-up on USB DP line.
    152            * @param  NewState: New state of the internal pull-up on USB DP line. 
    153            *   This parameter can be ENABLE: Connect internal pull-up on USB DP line.
    154            *                      or DISABLE: Disconnect internal pull-up on USB DP line.
    155            * @retval None
    156            */

   \                                 In section .text, align 2, keep-with-next
    157          void SYSCFG_USBPuCmd(FunctionalState NewState)
    158          {
   \                     SYSCFG_USBPuCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    159            /* Check the parameters */
    160            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??SYSCFG_USBPuCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD004             BEQ.N    ??SYSCFG_USBPuCmd_0
   \   00000010   0x21A0             MOVS     R1,#+160
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable9_6
   \   00000016   0x.... 0x....      BL       assert_failed
    161          
    162            if (NewState != DISABLE)
   \                     ??SYSCFG_USBPuCmd_0: (+1)
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD008             BEQ.N    ??SYSCFG_USBPuCmd_1
    163            { 
    164              /* Connect internal pull-up on USB DP line */
    165              SYSCFG->PMC |= (uint32_t) SYSCFG_PMC_USB_PU;
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable9_8  ;; 0x40010004
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable9_8  ;; 0x40010004
   \   0000002E   0x6008             STR      R0,[R1, #+0]
   \   00000030   0xE007             B.N      ??SYSCFG_USBPuCmd_2
    166            }
    167            else
    168            {
    169              /* Disconnect internal pull-up on USB DP line */
    170              SYSCFG->PMC &= (uint32_t)(~SYSCFG_PMC_USB_PU);
   \                     ??SYSCFG_USBPuCmd_1: (+1)
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable9_8  ;; 0x40010004
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x0840             LSRS     R0,R0,#+1
   \   0000003A   0x0040             LSLS     R0,R0,#+1
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable9_8  ;; 0x40010004
   \   00000040   0x6008             STR      R0,[R1, #+0]
    171            }
    172          }
   \                     ??SYSCFG_USBPuCmd_2: (+1)
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
    173          
    174          /**
    175            * @brief  Selects the GPIO pin used as EXTI Line.
    176            * @param  EXTI_PortSourceGPIOx : selects the GPIO port to be used as source 
    177            *                                for EXTI lines where x can be (A, B, C, D, E or H).
    178            * @param  EXTI_PinSourcex: specifies the EXTI line to be configured.
    179            *         This parameter can be EXTI_PinSourcex where x can be (0..15)
    180            * @retval None
    181            */

   \                                 In section .text, align 2, keep-with-next
    182          void SYSCFG_EXTILineConfig(uint8_t EXTI_PortSourceGPIOx, uint8_t EXTI_PinSourcex)
    183          {
   \                     SYSCFG_EXTILineConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    184            uint32_t tmp = 0x00;
   \   00000006   0x2600             MOVS     R6,#+0
    185          
    186            /* Check the parameters */
    187            assert_param(IS_EXTI_PORT_SOURCE(EXTI_PortSourceGPIOx));
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD013             BEQ.N    ??SYSCFG_EXTILineConfig_0
   \   0000000E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000010   0x2C01             CMP      R4,#+1
   \   00000012   0xD010             BEQ.N    ??SYSCFG_EXTILineConfig_0
   \   00000014   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000016   0x2C02             CMP      R4,#+2
   \   00000018   0xD00D             BEQ.N    ??SYSCFG_EXTILineConfig_0
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x2C03             CMP      R4,#+3
   \   0000001E   0xD00A             BEQ.N    ??SYSCFG_EXTILineConfig_0
   \   00000020   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000022   0x2C04             CMP      R4,#+4
   \   00000024   0xD007             BEQ.N    ??SYSCFG_EXTILineConfig_0
   \   00000026   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000028   0x2C05             CMP      R4,#+5
   \   0000002A   0xD004             BEQ.N    ??SYSCFG_EXTILineConfig_0
   \   0000002C   0x21BB             MOVS     R1,#+187
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable9_6
   \   00000032   0x.... 0x....      BL       assert_failed
    188            assert_param(IS_EXTI_PIN_SOURCE(EXTI_PinSourcex));
   \                     ??SYSCFG_EXTILineConfig_0: (+1)
   \   00000036   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000038   0x2D00             CMP      R5,#+0
   \   0000003A   0xD031             BEQ.N    ??SYSCFG_EXTILineConfig_1
   \   0000003C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003E   0x2D01             CMP      R5,#+1
   \   00000040   0xD02E             BEQ.N    ??SYSCFG_EXTILineConfig_1
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0x2D02             CMP      R5,#+2
   \   00000046   0xD02B             BEQ.N    ??SYSCFG_EXTILineConfig_1
   \   00000048   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004A   0x2D03             CMP      R5,#+3
   \   0000004C   0xD028             BEQ.N    ??SYSCFG_EXTILineConfig_1
   \   0000004E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000050   0x2D04             CMP      R5,#+4
   \   00000052   0xD025             BEQ.N    ??SYSCFG_EXTILineConfig_1
   \   00000054   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000056   0x2D05             CMP      R5,#+5
   \   00000058   0xD022             BEQ.N    ??SYSCFG_EXTILineConfig_1
   \   0000005A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005C   0x2D06             CMP      R5,#+6
   \   0000005E   0xD01F             BEQ.N    ??SYSCFG_EXTILineConfig_1
   \   00000060   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000062   0x2D07             CMP      R5,#+7
   \   00000064   0xD01C             BEQ.N    ??SYSCFG_EXTILineConfig_1
   \   00000066   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000068   0x2D08             CMP      R5,#+8
   \   0000006A   0xD019             BEQ.N    ??SYSCFG_EXTILineConfig_1
   \   0000006C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000006E   0x2D09             CMP      R5,#+9
   \   00000070   0xD016             BEQ.N    ??SYSCFG_EXTILineConfig_1
   \   00000072   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000074   0x2D0A             CMP      R5,#+10
   \   00000076   0xD013             BEQ.N    ??SYSCFG_EXTILineConfig_1
   \   00000078   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000007A   0x2D0B             CMP      R5,#+11
   \   0000007C   0xD010             BEQ.N    ??SYSCFG_EXTILineConfig_1
   \   0000007E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000080   0x2D0C             CMP      R5,#+12
   \   00000082   0xD00D             BEQ.N    ??SYSCFG_EXTILineConfig_1
   \   00000084   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000086   0x2D0D             CMP      R5,#+13
   \   00000088   0xD00A             BEQ.N    ??SYSCFG_EXTILineConfig_1
   \   0000008A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000008C   0x2D0E             CMP      R5,#+14
   \   0000008E   0xD007             BEQ.N    ??SYSCFG_EXTILineConfig_1
   \   00000090   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000092   0x2D0F             CMP      R5,#+15
   \   00000094   0xD004             BEQ.N    ??SYSCFG_EXTILineConfig_1
   \   00000096   0x21BC             MOVS     R1,#+188
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable9_6
   \   0000009C   0x.... 0x....      BL       assert_failed
    189            
    190            tmp = ((uint32_t)0x0F) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03));
   \                     ??SYSCFG_EXTILineConfig_1: (+1)
   \   000000A0   0x200F             MOVS     R0,#+15
   \   000000A2   0xF015 0x0103      ANDS     R1,R5,#0x3
   \   000000A6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000A8   0x0089             LSLS     R1,R1,#+2
   \   000000AA   0x4088             LSLS     R0,R0,R1
   \   000000AC   0x0006             MOVS     R6,R0
    191            SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] &= ~tmp;
   \   000000AE   0x.... 0x....      LDR.W    R0,??DataTable9_9  ;; 0x40010008
   \   000000B2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000B4   0x10A9             ASRS     R1,R5,#+2
   \   000000B6   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   000000BA   0x43B0             BICS     R0,R0,R6
   \   000000BC   0x.... 0x....      LDR.W    R1,??DataTable9_9  ;; 0x40010008
   \   000000C0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000C2   0x10AA             ASRS     R2,R5,#+2
   \   000000C4   0xF841 0x0022      STR      R0,[R1, R2, LSL #+2]
    192            SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] |= (((uint32_t)EXTI_PortSourceGPIOx) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03)));
   \   000000C8   0x.... 0x....      LDR.W    R0,??DataTable9_9  ;; 0x40010008
   \   000000CC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000CE   0x10A9             ASRS     R1,R5,#+2
   \   000000D0   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   000000D4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000D6   0xF015 0x0103      ANDS     R1,R5,#0x3
   \   000000DA   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000DC   0x0089             LSLS     R1,R1,#+2
   \   000000DE   0xFA14 0xF101      LSLS     R1,R4,R1
   \   000000E2   0x4308             ORRS     R0,R1,R0
   \   000000E4   0x.... 0x....      LDR.W    R1,??DataTable9_9  ;; 0x40010008
   \   000000E8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000EA   0x10AA             ASRS     R2,R5,#+2
   \   000000EC   0xF841 0x0022      STR      R0,[R1, R2, LSL #+2]
    193          }
   \   000000F0   0xBD70             POP      {R4-R6,PC}       ;; return
    194          
    195          /**
    196            * @}
    197            */
    198          
    199          /** @defgroup SYSCFG_Group2 RI Initialization and Configuration functions
    200           *  @brief   RI Initialization and Configuration functions
    201           *
    202          @verbatim   
    203           ===============================================================================
    204                         RI Initialization and Configuration functions
    205           ===============================================================================  
    206          
    207          @endverbatim
    208            * @{
    209            */
    210          
    211          /**
    212            * @brief  Configures the routing interface to select which Timer to be routed.
    213            * @note   Routing capability can be applied only on one of the three timers
    214            *         (TIM2, TIM3 or TIM4) at a time.
    215            * @param  TIM_Select: Timer select.
    216            *   This parameter can be one of the following values:
    217            *     @arg TIM_Select_None: No timer selected and default Timer mapping is enabled.
    218            *     @arg TIM_Select_TIM2: Timer 2 Input Captures to be routed.
    219            *     @arg TIM_Select_TIM3: Timer 3 Input Captures to be routed.
    220            *     @arg TIM_Select_TIM4: Timer 4 Input Captures to be routed.
    221            * @retval None.
    222            */

   \                                 In section .text, align 2, keep-with-next
    223          void SYSCFG_RITIMSelect(uint32_t TIM_Select)
    224          {
   \                     SYSCFG_RITIMSelect: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    225            uint32_t tmpreg = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    226          
    227            /* Check the parameters */
    228            assert_param(IS_RI_TIM(TIM_Select));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD00D             BEQ.N    ??SYSCFG_RITIMSelect_0
   \   0000000A   0xF5B4 0x3F80      CMP      R4,#+65536
   \   0000000E   0xD00A             BEQ.N    ??SYSCFG_RITIMSelect_0
   \   00000010   0xF5B4 0x3F00      CMP      R4,#+131072
   \   00000014   0xD007             BEQ.N    ??SYSCFG_RITIMSelect_0
   \   00000016   0xF5B4 0x3F40      CMP      R4,#+196608
   \   0000001A   0xD004             BEQ.N    ??SYSCFG_RITIMSelect_0
   \   0000001C   0x21E4             MOVS     R1,#+228
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable9_6
   \   00000022   0x.... 0x....      BL       assert_failed
    229          
    230            /* Get the old register value */
    231            tmpreg = RI->ICR;
   \                     ??SYSCFG_RITIMSelect_0: (+1)
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40007c04
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x0005             MOVS     R5,R0
    232          
    233            /* Clear the TIMx select bits */
    234            tmpreg &= TIM_SELECT_MASK;
   \   0000002E   0xF435 0x3540      BICS     R5,R5,#0x30000
    235          
    236            /* Select the Timer */
    237            tmpreg |= (TIM_Select);
   \   00000032   0x4325             ORRS     R5,R4,R5
    238          
    239            /* Write to RI->ICR register */
    240            RI->ICR = tmpreg;
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40007c04
   \   00000038   0x6005             STR      R5,[R0, #+0]
    241          }
   \   0000003A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    242          
    243          /**
    244            * @brief  Configures the routing interface to map Input Capture 1, 2, 3 or 4
    245            *         to a selected I/O pin.
    246            * @param  RI_InputCapture selects which input capture to be routed.
    247            *   This parameter can be one (or combination) of the following parameters:
    248            *     @arg  RI_InputCapture_IC1: Input capture 1 is selected.
    249            *     @arg  RI_InputCapture_IC2: Input capture 2 is selected.
    250            *     @arg  RI_InputCapture_IC3: Input capture 3 is selected.
    251            *     @arg  RI_InputCapture_IC4: Input capture 4 is selected.
    252            * @param  RI_InputCaptureRouting: selects which pin to be routed to Input Capture.
    253            *   This parameter can be one of the following values:
    254            *     @arg  RI_InputCaptureRouting_0 to RI_InputCaptureRouting_15
    255            *     e.g.
    256            *       SYSCFG_RITIMSelect(TIM_Select_TIM2)
    257            *       SYSCFG_RITIMInputCaptureConfig(RI_InputCapture_IC1, RI_InputCaptureRouting_1)
    258            *       allows routing of Input capture IC1 of TIM2 to PA4.
    259            *       For details about correspondence between RI_InputCaptureRouting_x 
    260            *       and I/O pins refer to the parameters' description in the header file
    261            *       or refer to the product reference manual.
    262            * @note Input capture selection bits are not reset by this function.
    263            *       To reset input capture selection bits, use SYSCFG_RIDeInit() function.
    264            * @note The I/O should be configured in alternate function mode (AF14) using
    265            *       GPIO_PinAFConfig() function.
    266            * @retval None.
    267            */

   \                                 In section .text, align 2, keep-with-next
    268          void SYSCFG_RITIMInputCaptureConfig(uint32_t RI_InputCapture, uint32_t RI_InputCaptureRouting)
    269          {
   \                     SYSCFG_RITIMInputCaptureConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    270            uint32_t tmpreg = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    271          
    272            /* Check the parameters */
    273            assert_param(IS_RI_INPUTCAPTURE(RI_InputCapture));
   \   00000008   0xF434 0x1074      BICS     R0,R4,#0x3D0000
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD101             BNE.N    ??SYSCFG_RITIMInputCaptureConfig_0
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD105             BNE.N    ??SYSCFG_RITIMInputCaptureConfig_1
   \                     ??SYSCFG_RITIMInputCaptureConfig_0: (+1)
   \   00000014   0xF240 0x1111      MOVW     R1,#+273
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable9_6
   \   0000001C   0x.... 0x....      BL       assert_failed
    274            assert_param(IS_RI_INPUTCAPTURE_ROUTING(RI_InputCaptureRouting));
   \                     ??SYSCFG_RITIMInputCaptureConfig_1: (+1)
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD023             BEQ.N    ??SYSCFG_RITIMInputCaptureConfig_2
   \   00000024   0x2D01             CMP      R5,#+1
   \   00000026   0xD021             BEQ.N    ??SYSCFG_RITIMInputCaptureConfig_2
   \   00000028   0x2D02             CMP      R5,#+2
   \   0000002A   0xD01F             BEQ.N    ??SYSCFG_RITIMInputCaptureConfig_2
   \   0000002C   0x2D03             CMP      R5,#+3
   \   0000002E   0xD01D             BEQ.N    ??SYSCFG_RITIMInputCaptureConfig_2
   \   00000030   0x2D04             CMP      R5,#+4
   \   00000032   0xD01B             BEQ.N    ??SYSCFG_RITIMInputCaptureConfig_2
   \   00000034   0x2D05             CMP      R5,#+5
   \   00000036   0xD019             BEQ.N    ??SYSCFG_RITIMInputCaptureConfig_2
   \   00000038   0x2D06             CMP      R5,#+6
   \   0000003A   0xD017             BEQ.N    ??SYSCFG_RITIMInputCaptureConfig_2
   \   0000003C   0x2D07             CMP      R5,#+7
   \   0000003E   0xD015             BEQ.N    ??SYSCFG_RITIMInputCaptureConfig_2
   \   00000040   0x2D08             CMP      R5,#+8
   \   00000042   0xD013             BEQ.N    ??SYSCFG_RITIMInputCaptureConfig_2
   \   00000044   0x2D09             CMP      R5,#+9
   \   00000046   0xD011             BEQ.N    ??SYSCFG_RITIMInputCaptureConfig_2
   \   00000048   0x2D0A             CMP      R5,#+10
   \   0000004A   0xD00F             BEQ.N    ??SYSCFG_RITIMInputCaptureConfig_2
   \   0000004C   0x2D0B             CMP      R5,#+11
   \   0000004E   0xD00D             BEQ.N    ??SYSCFG_RITIMInputCaptureConfig_2
   \   00000050   0x2D0C             CMP      R5,#+12
   \   00000052   0xD00B             BEQ.N    ??SYSCFG_RITIMInputCaptureConfig_2
   \   00000054   0x2D0D             CMP      R5,#+13
   \   00000056   0xD009             BEQ.N    ??SYSCFG_RITIMInputCaptureConfig_2
   \   00000058   0x2D0E             CMP      R5,#+14
   \   0000005A   0xD007             BEQ.N    ??SYSCFG_RITIMInputCaptureConfig_2
   \   0000005C   0x2D0F             CMP      R5,#+15
   \   0000005E   0xD005             BEQ.N    ??SYSCFG_RITIMInputCaptureConfig_2
   \   00000060   0xF44F 0x7189      MOV      R1,#+274
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable9_6
   \   00000068   0x.... 0x....      BL       assert_failed
    275          
    276            /* Get the old register value */
    277            tmpreg = RI->ICR;
   \                     ??SYSCFG_RITIMInputCaptureConfig_2: (+1)
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40007c04
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0x0006             MOVS     R6,R0
    278          
    279            /* Select input captures to be routed */
    280            tmpreg |= (RI_InputCapture);
   \   00000074   0x4326             ORRS     R6,R4,R6
    281          
    282            if((RI_InputCapture & RI_InputCapture_IC1) == RI_InputCapture_IC1)
   \   00000076   0x0360             LSLS     R0,R4,#+13
   \   00000078   0xD502             BPL.N    ??SYSCFG_RITIMInputCaptureConfig_3
    283            {
    284              /* Clear the input capture select bits */
    285              tmpreg &= (uint32_t)(~IC_ROUTING_MASK);
   \   0000007A   0x0936             LSRS     R6,R6,#+4
   \   0000007C   0x0136             LSLS     R6,R6,#+4
    286          
    287              /* Set RI_InputCaptureRouting bits  */
    288              tmpreg |= (uint32_t)( RI_InputCaptureRouting);
   \   0000007E   0x432E             ORRS     R6,R5,R6
    289            }
    290          
    291            if((RI_InputCapture & RI_InputCapture_IC2) == RI_InputCapture_IC2)
   \                     ??SYSCFG_RITIMInputCaptureConfig_3: (+1)
   \   00000080   0x0320             LSLS     R0,R4,#+12
   \   00000082   0xD503             BPL.N    ??SYSCFG_RITIMInputCaptureConfig_4
    292            {
    293              /* Clear the input capture select bits */
    294              tmpreg &= (uint32_t)(~(IC_ROUTING_MASK << 4));
   \   00000084   0xF036 0x06F0      BICS     R6,R6,#0xF0
    295          
    296              /* Set RI_InputCaptureRouting bits  */
    297              tmpreg |= (uint32_t)( (RI_InputCaptureRouting << 4)); 
   \   00000088   0xEA56 0x1605      ORRS     R6,R6,R5, LSL #+4
    298            }
    299          
    300            if((RI_InputCapture & RI_InputCapture_IC3) == RI_InputCapture_IC3)
   \                     ??SYSCFG_RITIMInputCaptureConfig_4: (+1)
   \   0000008C   0x02E0             LSLS     R0,R4,#+11
   \   0000008E   0xD503             BPL.N    ??SYSCFG_RITIMInputCaptureConfig_5
    301            {
    302              /* Clear the input capture select bits */
    303              tmpreg &= (uint32_t)(~(IC_ROUTING_MASK << 8));
   \   00000090   0xF436 0x6670      BICS     R6,R6,#0xF00
    304          
    305              /* Set RI_InputCaptureRouting bits  */
    306              tmpreg |= (uint32_t)( (RI_InputCaptureRouting << 8));  
   \   00000094   0xEA56 0x2605      ORRS     R6,R6,R5, LSL #+8
    307            }
    308          
    309            if((RI_InputCapture & RI_InputCapture_IC4) == RI_InputCapture_IC4)
   \                     ??SYSCFG_RITIMInputCaptureConfig_5: (+1)
   \   00000098   0x02A0             LSLS     R0,R4,#+10
   \   0000009A   0xD503             BPL.N    ??SYSCFG_RITIMInputCaptureConfig_6
    310            {
    311              /* Clear the input capture select bits */
    312              tmpreg &= (uint32_t)(~(IC_ROUTING_MASK << 12));
   \   0000009C   0xF436 0x4670      BICS     R6,R6,#0xF000
    313          
    314              /* Set RI_InputCaptureRouting bits  */
    315              tmpreg |= (uint32_t)( (RI_InputCaptureRouting << 12));  
   \   000000A0   0xEA56 0x3605      ORRS     R6,R6,R5, LSL #+12
    316            }
    317          
    318            /* Write to RI->ICR register */
    319            RI->ICR = tmpreg;
   \                     ??SYSCFG_RITIMInputCaptureConfig_6: (+1)
   \   000000A4   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40007c04
   \   000000A8   0x6006             STR      R6,[R0, #+0]
    320          }
   \   000000AA   0xBD70             POP      {R4-R6,PC}       ;; return
    321          /**
    322            * @brief  Configures the Pull-up and Pull-down Resistors 
    323            * @param  RI_Resistor selects the resistor to connect. 
    324            *   This parameter can be  one of the following values:
    325            *     @arg RI_Resistor_10KPU: 10K pull-up resistor
    326            *     @arg RI_Resistor_400KPU: 400K pull-up resistor 
    327            *     @arg RI_Resistor_10KPD: 10K pull-down resistor 
    328            *     @arg RI_Resistor_400KPD: 400K pull-down resistor
    329            * @param  NewState: New state of the analog switch associated to the selected 
    330            *         resistor.
    331            *   This parameter can be:
    332            *      ENABLE so the selected resistor is connected
    333            *      or DISABLE so the selected resistor is disconnected
    334            * @note To avoid extra power consumption, only one resistor should be enabled
    335            *       at a time.  
    336            * @retval None
    337            */

   \                                 In section .text, align 2, keep-with-next
    338          void SYSCFG_RIResistorConfig(uint32_t RI_Resistor, FunctionalState NewState)
    339          {
   \                     SYSCFG_RIResistorConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    340            /* Check the parameters */
    341            assert_param(IS_RI_RESISTOR(RI_Resistor));
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD00B             BEQ.N    ??SYSCFG_RIResistorConfig_0
   \   0000000A   0x2C02             CMP      R4,#+2
   \   0000000C   0xD009             BEQ.N    ??SYSCFG_RIResistorConfig_0
   \   0000000E   0x2C04             CMP      R4,#+4
   \   00000010   0xD007             BEQ.N    ??SYSCFG_RIResistorConfig_0
   \   00000012   0x2C08             CMP      R4,#+8
   \   00000014   0xD005             BEQ.N    ??SYSCFG_RIResistorConfig_0
   \   00000016   0xF240 0x1155      MOVW     R1,#+341
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable9_6
   \   0000001E   0x.... 0x....      BL       assert_failed
    342            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??SYSCFG_RIResistorConfig_0: (+1)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD007             BEQ.N    ??SYSCFG_RIResistorConfig_1
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD004             BEQ.N    ??SYSCFG_RIResistorConfig_1
   \   0000002E   0xF44F 0x71AB      MOV      R1,#+342
   \   00000032   0x....             LDR.N    R0,??DataTable9_6
   \   00000034   0x.... 0x....      BL       assert_failed
    343            
    344            if (NewState != DISABLE)
   \                     ??SYSCFG_RIResistorConfig_1: (+1)
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0xD005             BEQ.N    ??SYSCFG_RIResistorConfig_2
    345            {
    346              /* Enable the resistor */
    347              COMP->CSR |= (uint32_t) RI_Resistor;
   \   0000003E   0x....             LDR.N    R0,??DataTable9_10  ;; 0x40007c00
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x4320             ORRS     R0,R4,R0
   \   00000044   0x....             LDR.N    R1,??DataTable9_10  ;; 0x40007c00
   \   00000046   0x6008             STR      R0,[R1, #+0]
   \   00000048   0xE004             B.N      ??SYSCFG_RIResistorConfig_3
    348            }
    349            else
    350            {
    351              /* Disable the Resistor */
    352              COMP->CSR &= (uint32_t) (~RI_Resistor);
   \                     ??SYSCFG_RIResistorConfig_2: (+1)
   \   0000004A   0x....             LDR.N    R0,??DataTable9_10  ;; 0x40007c00
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x43A0             BICS     R0,R0,R4
   \   00000050   0x....             LDR.N    R1,??DataTable9_10  ;; 0x40007c00
   \   00000052   0x6008             STR      R0,[R1, #+0]
    353            }
    354          }
   \                     ??SYSCFG_RIResistorConfig_3: (+1)
   \   00000054   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    355          
    356          /**
    357            * @brief  Close or Open the routing interface Input Output switches.
    358            * @param  RI_IOSwitch: selects the I/O analog switch number.
    359            *   This parameter can be one of the following values:
    360            *     @arg RI_IOSwitch_CH0 --> RI_IOSwitch_CH15
    361            *     @arg RI_IOSwitch_CH18 --> RI_IOSwitch_CH25
    362            *     @arg RI_IOSwitch_GR10_1 --> RI_IOSwitch_GR10_4
    363            *     @arg RI_IOSwitch_GR6_1 --> RI_IOSwitch_GR6_2
    364            *     @arg RI_IOSwitch_GR5_1 --> RI_IOSwitch_GR5_3
    365            *     @arg RI_IOSwitch_GR4_1 --> RI_IOSwitch_GR4_3
    366            *     @arg RI_IOSwitch_VCOMP
    367            * @param  NewState: New state of the analog switch. 
    368            *   This parameter can be 
    369            *     ENABLE so the Input Output switch is closed
    370            *     or DISABLE so the Input Output switch is open
    371            * @retval None
    372            */

   \                                 In section .text, align 2, keep-with-next
    373          void SYSCFG_RIIOSwitchConfig(uint32_t RI_IOSwitch, FunctionalState NewState)
    374          {
   \                     SYSCFG_RIIOSwitchConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    375            uint32_t ioswitchmask = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    376            
    377            /* Check the parameters */
    378            assert_param(IS_RI_IOSWITCH(RI_IOSwitch));
   \   00000008   0x....             LDR.N    R0,??DataTable9_11  ;; 0x80000001
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD068             BEQ.N    ??SYSCFG_RIIOSwitchConfig_0
   \   0000000E   0x....             LDR.N    R0,??DataTable9_12  ;; 0x80000002
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD065             BEQ.N    ??SYSCFG_RIIOSwitchConfig_0
   \   00000014   0x....             LDR.N    R0,??DataTable9_13  ;; 0x80000004
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD062             BEQ.N    ??SYSCFG_RIIOSwitchConfig_0
   \   0000001A   0x....             LDR.N    R0,??DataTable9_14  ;; 0x80000008
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD05F             BEQ.N    ??SYSCFG_RIIOSwitchConfig_0
   \   00000020   0x....             LDR.N    R0,??DataTable9_15  ;; 0x80000010
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD05C             BEQ.N    ??SYSCFG_RIIOSwitchConfig_0
   \   00000026   0x....             LDR.N    R0,??DataTable9_16  ;; 0x80000020
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD059             BEQ.N    ??SYSCFG_RIIOSwitchConfig_0
   \   0000002C   0x....             LDR.N    R0,??DataTable9_17  ;; 0x80000040
   \   0000002E   0x4284             CMP      R4,R0
   \   00000030   0xD056             BEQ.N    ??SYSCFG_RIIOSwitchConfig_0
   \   00000032   0x....             LDR.N    R0,??DataTable9_18  ;; 0x80000080
   \   00000034   0x4284             CMP      R4,R0
   \   00000036   0xD053             BEQ.N    ??SYSCFG_RIIOSwitchConfig_0
   \   00000038   0x....             LDR.N    R0,??DataTable9_19  ;; 0x80000100
   \   0000003A   0x4284             CMP      R4,R0
   \   0000003C   0xD050             BEQ.N    ??SYSCFG_RIIOSwitchConfig_0
   \   0000003E   0x....             LDR.N    R0,??DataTable9_20  ;; 0x80000200
   \   00000040   0x4284             CMP      R4,R0
   \   00000042   0xD04D             BEQ.N    ??SYSCFG_RIIOSwitchConfig_0
   \   00000044   0x....             LDR.N    R0,??DataTable9_21  ;; 0x80000400
   \   00000046   0x4284             CMP      R4,R0
   \   00000048   0xD04A             BEQ.N    ??SYSCFG_RIIOSwitchConfig_0
   \   0000004A   0x....             LDR.N    R0,??DataTable9_22  ;; 0x80000800
   \   0000004C   0x4284             CMP      R4,R0
   \   0000004E   0xD047             BEQ.N    ??SYSCFG_RIIOSwitchConfig_0
   \   00000050   0x....             LDR.N    R0,??DataTable9_23  ;; 0x80001000
   \   00000052   0x4284             CMP      R4,R0
   \   00000054   0xD044             BEQ.N    ??SYSCFG_RIIOSwitchConfig_0
   \   00000056   0x....             LDR.N    R0,??DataTable9_24  ;; 0x80002000
   \   00000058   0x4284             CMP      R4,R0
   \   0000005A   0xD041             BEQ.N    ??SYSCFG_RIIOSwitchConfig_0
   \   0000005C   0x....             LDR.N    R0,??DataTable9_25  ;; 0x80004000
   \   0000005E   0x4284             CMP      R4,R0
   \   00000060   0xD03E             BEQ.N    ??SYSCFG_RIIOSwitchConfig_0
   \   00000062   0xF1B4 0x2F80      CMP      R4,#-2147450880
   \   00000066   0xD03B             BEQ.N    ??SYSCFG_RIIOSwitchConfig_0
   \   00000068   0x....             LDR.N    R0,??DataTable9_26  ;; 0x80040000
   \   0000006A   0x4284             CMP      R4,R0
   \   0000006C   0xD038             BEQ.N    ??SYSCFG_RIIOSwitchConfig_0
   \   0000006E   0x....             LDR.N    R0,??DataTable9_27  ;; 0x80080000
   \   00000070   0x4284             CMP      R4,R0
   \   00000072   0xD035             BEQ.N    ??SYSCFG_RIIOSwitchConfig_0
   \   00000074   0x....             LDR.N    R0,??DataTable9_28  ;; 0x80100000
   \   00000076   0x4284             CMP      R4,R0
   \   00000078   0xD032             BEQ.N    ??SYSCFG_RIIOSwitchConfig_0
   \   0000007A   0x....             LDR.N    R0,??DataTable9_29  ;; 0x80200000
   \   0000007C   0x4284             CMP      R4,R0
   \   0000007E   0xD02F             BEQ.N    ??SYSCFG_RIIOSwitchConfig_0
   \   00000080   0x....             LDR.N    R0,??DataTable9_30  ;; 0x80400000
   \   00000082   0x4284             CMP      R4,R0
   \   00000084   0xD02C             BEQ.N    ??SYSCFG_RIIOSwitchConfig_0
   \   00000086   0xF114 0x4FFF      CMN      R4,#+2139095040
   \   0000008A   0xD029             BEQ.N    ??SYSCFG_RIIOSwitchConfig_0
   \   0000008C   0xF114 0x4FFE      CMN      R4,#+2130706432
   \   00000090   0xD026             BEQ.N    ??SYSCFG_RIIOSwitchConfig_0
   \   00000092   0xF114 0x4FFC      CMN      R4,#+2113929216
   \   00000096   0xD023             BEQ.N    ??SYSCFG_RIIOSwitchConfig_0
   \   00000098   0xF114 0x4FF8      CMN      R4,#+2080374784
   \   0000009C   0xD020             BEQ.N    ??SYSCFG_RIIOSwitchConfig_0
   \   0000009E   0x2C01             CMP      R4,#+1
   \   000000A0   0xD01E             BEQ.N    ??SYSCFG_RIIOSwitchConfig_0
   \   000000A2   0x2C02             CMP      R4,#+2
   \   000000A4   0xD01C             BEQ.N    ??SYSCFG_RIIOSwitchConfig_0
   \   000000A6   0x2C04             CMP      R4,#+4
   \   000000A8   0xD01A             BEQ.N    ??SYSCFG_RIIOSwitchConfig_0
   \   000000AA   0x2C08             CMP      R4,#+8
   \   000000AC   0xD018             BEQ.N    ??SYSCFG_RIIOSwitchConfig_0
   \   000000AE   0x2C10             CMP      R4,#+16
   \   000000B0   0xD016             BEQ.N    ??SYSCFG_RIIOSwitchConfig_0
   \   000000B2   0x2C20             CMP      R4,#+32
   \   000000B4   0xD014             BEQ.N    ??SYSCFG_RIIOSwitchConfig_0
   \   000000B6   0x2C40             CMP      R4,#+64
   \   000000B8   0xD012             BEQ.N    ??SYSCFG_RIIOSwitchConfig_0
   \   000000BA   0x2C80             CMP      R4,#+128
   \   000000BC   0xD010             BEQ.N    ??SYSCFG_RIIOSwitchConfig_0
   \   000000BE   0xF5B4 0x7F80      CMP      R4,#+256
   \   000000C2   0xD00D             BEQ.N    ??SYSCFG_RIIOSwitchConfig_0
   \   000000C4   0xF5B4 0x7F00      CMP      R4,#+512
   \   000000C8   0xD00A             BEQ.N    ??SYSCFG_RIIOSwitchConfig_0
   \   000000CA   0xF5B4 0x6F80      CMP      R4,#+1024
   \   000000CE   0xD007             BEQ.N    ??SYSCFG_RIIOSwitchConfig_0
   \   000000D0   0xF5B4 0x6F00      CMP      R4,#+2048
   \   000000D4   0xD004             BEQ.N    ??SYSCFG_RIIOSwitchConfig_0
   \   000000D6   0xF44F 0x71BD      MOV      R1,#+378
   \   000000DA   0x....             LDR.N    R0,??DataTable9_6
   \   000000DC   0x.... 0x....      BL       assert_failed
    379            
    380            /* Read Analog switch register index */
    381            ioswitchmask = RI_IOSwitch >> 31;
   \                     ??SYSCFG_RIIOSwitchConfig_0: (+1)
   \   000000E0   0x0FE0             LSRS     R0,R4,#+31
   \   000000E2   0x0006             MOVS     R6,R0
    382            
    383            /* Get Bits[30:0] of the IO switch */
    384            RI_IOSwitch  &= 0x7FFFFFFF;
   \   000000E4   0x0064             LSLS     R4,R4,#+1        ;; ZeroExtS R4,R4,#+1,#+1
   \   000000E6   0x0864             LSRS     R4,R4,#+1
    385            
    386            
    387            if (NewState != DISABLE)
   \   000000E8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000EA   0x2D00             CMP      R5,#+0
   \   000000EC   0xD00D             BEQ.N    ??SYSCFG_RIIOSwitchConfig_1
    388            { 
    389              if (ioswitchmask != 0)
   \   000000EE   0x2E00             CMP      R6,#+0
   \   000000F0   0xD005             BEQ.N    ??SYSCFG_RIIOSwitchConfig_2
    390              {
    391                /* Close the analog switches */
    392                RI->ASCR1 |= RI_IOSwitch;
   \   000000F2   0x....             LDR.N    R0,??DataTable9_1  ;; 0x40007c08
   \   000000F4   0x6800             LDR      R0,[R0, #+0]
   \   000000F6   0x4320             ORRS     R0,R4,R0
   \   000000F8   0x....             LDR.N    R1,??DataTable9_1  ;; 0x40007c08
   \   000000FA   0x6008             STR      R0,[R1, #+0]
   \   000000FC   0xE012             B.N      ??SYSCFG_RIIOSwitchConfig_3
    393              }
    394              else
    395              {
    396                /* Open the analog switches */
    397                RI->ASCR2 |= RI_IOSwitch;
   \                     ??SYSCFG_RIIOSwitchConfig_2: (+1)
   \   000000FE   0x....             LDR.N    R0,??DataTable9_2  ;; 0x40007c0c
   \   00000100   0x6800             LDR      R0,[R0, #+0]
   \   00000102   0x4320             ORRS     R0,R4,R0
   \   00000104   0x....             LDR.N    R1,??DataTable9_2  ;; 0x40007c0c
   \   00000106   0x6008             STR      R0,[R1, #+0]
   \   00000108   0xE00C             B.N      ??SYSCFG_RIIOSwitchConfig_3
    398              }
    399            }
    400            else
    401            {
    402              if (ioswitchmask != 0)
   \                     ??SYSCFG_RIIOSwitchConfig_1: (+1)
   \   0000010A   0x2E00             CMP      R6,#+0
   \   0000010C   0xD005             BEQ.N    ??SYSCFG_RIIOSwitchConfig_4
    403              {
    404                /* Close the analog switches */
    405                RI->ASCR1 &= (~ (uint32_t)RI_IOSwitch);
   \   0000010E   0x....             LDR.N    R0,??DataTable9_1  ;; 0x40007c08
   \   00000110   0x6800             LDR      R0,[R0, #+0]
   \   00000112   0x43A0             BICS     R0,R0,R4
   \   00000114   0x....             LDR.N    R1,??DataTable9_1  ;; 0x40007c08
   \   00000116   0x6008             STR      R0,[R1, #+0]
   \   00000118   0xE004             B.N      ??SYSCFG_RIIOSwitchConfig_3
    406              }
    407              else
    408              {
    409                /* Open the analog switches */
    410                RI->ASCR2 &= (~ (uint32_t)RI_IOSwitch);
   \                     ??SYSCFG_RIIOSwitchConfig_4: (+1)
   \   0000011A   0x....             LDR.N    R0,??DataTable9_2  ;; 0x40007c0c
   \   0000011C   0x6800             LDR      R0,[R0, #+0]
   \   0000011E   0x43A0             BICS     R0,R0,R4
   \   00000120   0x....             LDR.N    R1,??DataTable9_2  ;; 0x40007c0c
   \   00000122   0x6008             STR      R0,[R1, #+0]
    411              }
    412            }
    413          }
   \                     ??SYSCFG_RIIOSwitchConfig_3: (+1)
   \   00000124   0xBD70             POP      {R4-R6,PC}       ;; return
    414          
    415          /**
    416            * @brief  Enable or disable the switch control mode.
    417            * @param  NewState: New state of the switch control mode. This parameter can
    418            *         be ENABLE: ADC analog switches closed if the corresponding 
    419            *                    I/O switch is also closed.
    420            *                    When using COMP1 switch control mode must be enabled.
    421            *         or DISABLE: ADC analog switches open or controlled by the ADC interface.
    422            *                    When using the ADC for acquisition switch control mode 
    423            *                    must be disabled.
    424            * @note COMP1 comparator and ADC cannot be used at the same time since 
    425            *       they share the ADC switch matrix.
    426            * @retval None
    427            */

   \                                 In section .text, align 2, keep-with-next
    428          void SYSCFG_RISwitchControlModeCmd(FunctionalState NewState)
    429          {
   \                     SYSCFG_RISwitchControlModeCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    430            /* Check the parameters */
    431            assert_param(IS_FUNCTIONAL_STATE(NewState));  
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??SYSCFG_RISwitchControlModeCmd_0
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD004             BEQ.N    ??SYSCFG_RISwitchControlModeCmd_0
   \   00000010   0xF240 0x11AF      MOVW     R1,#+431
   \   00000014   0x....             LDR.N    R0,??DataTable9_6
   \   00000016   0x.... 0x....      BL       assert_failed
    432            
    433            if (NewState != DISABLE)
   \                     ??SYSCFG_RISwitchControlModeCmd_0: (+1)
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD006             BEQ.N    ??SYSCFG_RISwitchControlModeCmd_1
    434            { 
    435              /* Enable the Switch control mode */  
    436              RI->ASCR1 |= (uint32_t) RI_ASCR1_SCM;
   \   00000020   0x....             LDR.N    R0,??DataTable9_1  ;; 0x40007c08
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xF050 0x4000      ORRS     R0,R0,#0x80000000
   \   00000028   0x....             LDR.N    R1,??DataTable9_1  ;; 0x40007c08
   \   0000002A   0x6008             STR      R0,[R1, #+0]
   \   0000002C   0xE005             B.N      ??SYSCFG_RISwitchControlModeCmd_2
    437            }
    438            else
    439            {
    440              /* Disable the Switch control mode */  
    441              RI->ASCR1 &= (uint32_t)(~RI_ASCR1_SCM);
   \                     ??SYSCFG_RISwitchControlModeCmd_1: (+1)
   \   0000002E   0x....             LDR.N    R0,??DataTable9_1  ;; 0x40007c08
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x0040             LSLS     R0,R0,#+1        ;; ZeroExtS R0,R0,#+1,#+1
   \   00000034   0x0840             LSRS     R0,R0,#+1
   \   00000036   0x....             LDR.N    R1,??DataTable9_1  ;; 0x40007c08
   \   00000038   0x6008             STR      R0,[R1, #+0]
    442            }
    443          }
   \                     ??SYSCFG_RISwitchControlModeCmd_2: (+1)
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
    444          
    445          /**
    446            * @brief  Enable or disable Hysteresis of the input schmitt triger of Ports A..E
    447            *         When the I/Os are programmed in input mode by standard I/O port 
    448            *         registers, the Schmitt trigger and the hysteresis are enabled by default. 
    449            *         When hysteresis is disabled, it is possible to read the 
    450            *         corresponding port with a trigger level of VDDIO/2.   
    451            * @param  RI_Port: selects the GPIO Port.
    452            *   This parameter can be one of the following values:
    453            *     @arg RI_PortA : Port A is selected
    454            *     @arg RI_PortB : Port B is selected
    455            *     @arg RI_PortC : Port C is selected
    456            *     @arg RI_PortD : Port D is selected
    457            *     @arg RI_PortE : Port E is selected
    458            *  @param RI_Pin : Selects the pin(s) on which to enable or disable hysteresis.
    459            *    This parameter can any value from RI_Pin_x where x can be (0..15) or RI_Pin_All.
    460            *  @param  NewState new state of the Hysteresis.
    461            *   This parameter can be:
    462            *      ENABLE so the Hysteresis is on
    463            *      or DISABLE so the Hysteresis is off
    464            * @retval None
    465            */

   \                                 In section .text, align 2, keep-with-next
    466          void SYSCFG_RIHysteresisConfig(uint8_t RI_Port, uint16_t RI_Pin,
    467                                       FunctionalState NewState)
    468          {
   \                     SYSCFG_RIHysteresisConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    469            /* Check the parameters */
    470            assert_param(IS_RI_PORT(RI_Port));
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0x2C01             CMP      R4,#+1
   \   0000000C   0xD010             BEQ.N    ??SYSCFG_RIHysteresisConfig_0
   \   0000000E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000010   0x2C02             CMP      R4,#+2
   \   00000012   0xD00D             BEQ.N    ??SYSCFG_RIHysteresisConfig_0
   \   00000014   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000016   0x2C03             CMP      R4,#+3
   \   00000018   0xD00A             BEQ.N    ??SYSCFG_RIHysteresisConfig_0
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x2C04             CMP      R4,#+4
   \   0000001E   0xD007             BEQ.N    ??SYSCFG_RIHysteresisConfig_0
   \   00000020   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000022   0x2C05             CMP      R4,#+5
   \   00000024   0xD004             BEQ.N    ??SYSCFG_RIHysteresisConfig_0
   \   00000026   0xF44F 0x71EB      MOV      R1,#+470
   \   0000002A   0x....             LDR.N    R0,??DataTable9_6
   \   0000002C   0x.... 0x....      BL       assert_failed
    471            assert_param(IS_RI_PIN(RI_Pin));
   \                     ??SYSCFG_RIHysteresisConfig_0: (+1)
   \   00000030   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD104             BNE.N    ??SYSCFG_RIHysteresisConfig_1
   \   00000036   0xF240 0x11D7      MOVW     R1,#+471
   \   0000003A   0x....             LDR.N    R0,??DataTable9_6
   \   0000003C   0x.... 0x....      BL       assert_failed
    472            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??SYSCFG_RIHysteresisConfig_1: (+1)
   \   00000040   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000042   0x2E00             CMP      R6,#+0
   \   00000044   0xD007             BEQ.N    ??SYSCFG_RIHysteresisConfig_2
   \   00000046   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000048   0x2E01             CMP      R6,#+1
   \   0000004A   0xD004             BEQ.N    ??SYSCFG_RIHysteresisConfig_2
   \   0000004C   0xF44F 0x71EC      MOV      R1,#+472
   \   00000050   0x....             LDR.N    R0,??DataTable9_6
   \   00000052   0x.... 0x....      BL       assert_failed
    473            
    474            if(RI_Port == RI_PortA)
   \                     ??SYSCFG_RIHysteresisConfig_2: (+1)
   \   00000056   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000058   0x2C01             CMP      R4,#+1
   \   0000005A   0xD110             BNE.N    ??SYSCFG_RIHysteresisConfig_3
    475            {  
    476              if (NewState != DISABLE)
   \   0000005C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000005E   0x2E00             CMP      R6,#+0
   \   00000060   0xD006             BEQ.N    ??SYSCFG_RIHysteresisConfig_4
    477              {
    478                /* Hysteresis on */
    479                RI->HYSCR1 &= (uint32_t)~((uint32_t)RI_Pin);
   \   00000062   0x....             LDR.N    R0,??DataTable9_3  ;; 0x40007c10
   \   00000064   0x6800             LDR      R0,[R0, #+0]
   \   00000066   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000068   0x43A8             BICS     R0,R0,R5
   \   0000006A   0x....             LDR.N    R1,??DataTable9_3  ;; 0x40007c10
   \   0000006C   0x6008             STR      R0,[R1, #+0]
   \   0000006E   0xE058             B.N      ??SYSCFG_RIHysteresisConfig_5
    480              }
    481              else
    482              {
    483                /* Hysteresis off */
    484                RI->HYSCR1 |= (uint32_t) RI_Pin;
   \                     ??SYSCFG_RIHysteresisConfig_4: (+1)
   \   00000070   0x....             LDR.N    R0,??DataTable9_3  ;; 0x40007c10
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000076   0x4328             ORRS     R0,R5,R0
   \   00000078   0x....             LDR.N    R1,??DataTable9_3  ;; 0x40007c10
   \   0000007A   0x6008             STR      R0,[R1, #+0]
   \   0000007C   0xE051             B.N      ??SYSCFG_RIHysteresisConfig_5
    485              }
    486            }
    487            
    488            else if(RI_Port == RI_PortB)
   \                     ??SYSCFG_RIHysteresisConfig_3: (+1)
   \   0000007E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000080   0x2C02             CMP      R4,#+2
   \   00000082   0xD113             BNE.N    ??SYSCFG_RIHysteresisConfig_6
    489            {
    490            
    491              if (NewState != DISABLE)
   \   00000084   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000086   0x2E00             CMP      R6,#+0
   \   00000088   0xD008             BEQ.N    ??SYSCFG_RIHysteresisConfig_7
    492              {
    493                /* Hysteresis on */
    494                RI->HYSCR1 &= (uint32_t) (~((uint32_t)RI_Pin) << 16);
   \   0000008A   0x....             LDR.N    R0,??DataTable9_3  ;; 0x40007c10
   \   0000008C   0x6800             LDR      R0,[R0, #+0]
   \   0000008E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000090   0x43E9             MVNS     R1,R5
   \   00000092   0xEA10 0x4001      ANDS     R0,R0,R1, LSL #+16
   \   00000096   0x....             LDR.N    R1,??DataTable9_3  ;; 0x40007c10
   \   00000098   0x6008             STR      R0,[R1, #+0]
   \   0000009A   0xE042             B.N      ??SYSCFG_RIHysteresisConfig_5
    495              }
    496              else
    497              {
    498                /* Hysteresis off */
    499                RI->HYSCR1 |= (uint32_t) ((uint32_t)(RI_Pin) << 16);
   \                     ??SYSCFG_RIHysteresisConfig_7: (+1)
   \   0000009C   0x....             LDR.N    R0,??DataTable9_3  ;; 0x40007c10
   \   0000009E   0x6800             LDR      R0,[R0, #+0]
   \   000000A0   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000A2   0xEA50 0x4005      ORRS     R0,R0,R5, LSL #+16
   \   000000A6   0x....             LDR.N    R1,??DataTable9_3  ;; 0x40007c10
   \   000000A8   0x6008             STR      R0,[R1, #+0]
   \   000000AA   0xE03A             B.N      ??SYSCFG_RIHysteresisConfig_5
    500              }
    501            }  
    502           
    503            else if(RI_Port == RI_PortC)
   \                     ??SYSCFG_RIHysteresisConfig_6: (+1)
   \   000000AC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000AE   0x2C03             CMP      R4,#+3
   \   000000B0   0xD110             BNE.N    ??SYSCFG_RIHysteresisConfig_8
    504            {
    505            
    506              if (NewState != DISABLE)
   \   000000B2   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000B4   0x2E00             CMP      R6,#+0
   \   000000B6   0xD006             BEQ.N    ??SYSCFG_RIHysteresisConfig_9
    507              {
    508                /* Hysteresis on */
    509                RI->HYSCR2 &= (uint32_t) (~((uint32_t)RI_Pin));
   \   000000B8   0x....             LDR.N    R0,??DataTable9_4  ;; 0x40007c14
   \   000000BA   0x6800             LDR      R0,[R0, #+0]
   \   000000BC   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000BE   0x43A8             BICS     R0,R0,R5
   \   000000C0   0x....             LDR.N    R1,??DataTable9_4  ;; 0x40007c14
   \   000000C2   0x6008             STR      R0,[R1, #+0]
   \   000000C4   0xE02D             B.N      ??SYSCFG_RIHysteresisConfig_5
    510              }
    511              else
    512              {
    513                /* Hysteresis off */
    514                RI->HYSCR2 |= (uint32_t) (RI_Pin );
   \                     ??SYSCFG_RIHysteresisConfig_9: (+1)
   \   000000C6   0x....             LDR.N    R0,??DataTable9_4  ;; 0x40007c14
   \   000000C8   0x6800             LDR      R0,[R0, #+0]
   \   000000CA   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000CC   0x4328             ORRS     R0,R5,R0
   \   000000CE   0x....             LDR.N    R1,??DataTable9_4  ;; 0x40007c14
   \   000000D0   0x6008             STR      R0,[R1, #+0]
   \   000000D2   0xE026             B.N      ??SYSCFG_RIHysteresisConfig_5
    515              }
    516            } 
    517            else if(RI_Port == RI_PortD)
   \                     ??SYSCFG_RIHysteresisConfig_8: (+1)
   \   000000D4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000D6   0x2C04             CMP      R4,#+4
   \   000000D8   0xD113             BNE.N    ??SYSCFG_RIHysteresisConfig_10
    518            {
    519              if (NewState != DISABLE)
   \   000000DA   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000DC   0x2E00             CMP      R6,#+0
   \   000000DE   0xD008             BEQ.N    ??SYSCFG_RIHysteresisConfig_11
    520              {
    521                /* Hysteresis on */
    522                RI->HYSCR2 &= (uint32_t) (~((uint32_t)RI_Pin) << 16);
   \   000000E0   0x....             LDR.N    R0,??DataTable9_4  ;; 0x40007c14
   \   000000E2   0x6800             LDR      R0,[R0, #+0]
   \   000000E4   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000E6   0x43E9             MVNS     R1,R5
   \   000000E8   0xEA10 0x4001      ANDS     R0,R0,R1, LSL #+16
   \   000000EC   0x....             LDR.N    R1,??DataTable9_4  ;; 0x40007c14
   \   000000EE   0x6008             STR      R0,[R1, #+0]
   \   000000F0   0xE017             B.N      ??SYSCFG_RIHysteresisConfig_5
    523              }
    524              else
    525              {
    526                /* Hysteresis off */
    527                RI->HYSCR2 |= (uint32_t) ((uint32_t)(RI_Pin) << 16);
   \                     ??SYSCFG_RIHysteresisConfig_11: (+1)
   \   000000F2   0x....             LDR.N    R0,??DataTable9_4  ;; 0x40007c14
   \   000000F4   0x6800             LDR      R0,[R0, #+0]
   \   000000F6   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000F8   0xEA50 0x4005      ORRS     R0,R0,R5, LSL #+16
   \   000000FC   0x....             LDR.N    R1,??DataTable9_4  ;; 0x40007c14
   \   000000FE   0x6008             STR      R0,[R1, #+0]
   \   00000100   0xE00F             B.N      ??SYSCFG_RIHysteresisConfig_5
    528          
    529              }
    530            }   
    531            else /* RI_Port == RI_PortE */
    532            {
    533              if (NewState != DISABLE)
   \                     ??SYSCFG_RIHysteresisConfig_10: (+1)
   \   00000102   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000104   0x2E00             CMP      R6,#+0
   \   00000106   0xD006             BEQ.N    ??SYSCFG_RIHysteresisConfig_12
    534              {
    535                /* Hysteresis on */
    536                RI->HYSCR3 &= (uint32_t) (~((uint32_t)RI_Pin));
   \   00000108   0x....             LDR.N    R0,??DataTable9_5  ;; 0x40007c18
   \   0000010A   0x6800             LDR      R0,[R0, #+0]
   \   0000010C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000010E   0x43A8             BICS     R0,R0,R5
   \   00000110   0x....             LDR.N    R1,??DataTable9_5  ;; 0x40007c18
   \   00000112   0x6008             STR      R0,[R1, #+0]
   \   00000114   0xE005             B.N      ??SYSCFG_RIHysteresisConfig_5
    537              }
    538              else
    539              {
    540                /* Hysteresis off */
    541                RI->HYSCR3 |= (uint32_t) (RI_Pin );
   \                     ??SYSCFG_RIHysteresisConfig_12: (+1)
   \   00000116   0x....             LDR.N    R0,??DataTable9_5  ;; 0x40007c18
   \   00000118   0x6800             LDR      R0,[R0, #+0]
   \   0000011A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000011C   0x4328             ORRS     R0,R5,R0
   \   0000011E   0x....             LDR.N    R1,??DataTable9_5  ;; 0x40007c18
   \   00000120   0x6008             STR      R0,[R1, #+0]
    542              }
    543            }   
    544          }
   \                     ??SYSCFG_RIHysteresisConfig_5: (+1)
   \   00000122   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x40007C04         DC32     0x40007c04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x40007C08         DC32     0x40007c08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x40007C0C         DC32     0x40007c0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x40007C10         DC32     0x40007c10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x40007C14         DC32     0x40007c14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x40007C18         DC32     0x40007c18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x40010000         DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x40010004         DC32     0x40010004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   0x40010008         DC32     0x40010008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_10:
   \   00000000   0x40007C00         DC32     0x40007c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_11:
   \   00000000   0x80000001         DC32     0x80000001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_12:
   \   00000000   0x80000002         DC32     0x80000002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_13:
   \   00000000   0x80000004         DC32     0x80000004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_14:
   \   00000000   0x80000008         DC32     0x80000008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_15:
   \   00000000   0x80000010         DC32     0x80000010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_16:
   \   00000000   0x80000020         DC32     0x80000020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_17:
   \   00000000   0x80000040         DC32     0x80000040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_18:
   \   00000000   0x80000080         DC32     0x80000080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_19:
   \   00000000   0x80000100         DC32     0x80000100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_20:
   \   00000000   0x80000200         DC32     0x80000200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_21:
   \   00000000   0x80000400         DC32     0x80000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_22:
   \   00000000   0x80000800         DC32     0x80000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_23:
   \   00000000   0x80001000         DC32     0x80001000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_24:
   \   00000000   0x80002000         DC32     0x80002000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_25:
   \   00000000   0x80004000         DC32     0x80004000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_26:
   \   00000000   0x80040000         DC32     0x80040000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_27:
   \   00000000   0x80080000         DC32     0x80080000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_28:
   \   00000000   0x80100000         DC32     0x80100000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_29:
   \   00000000   0x80200000         DC32     0x80200000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_30:
   \   00000000   0x80400000         DC32     0x80400000

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x45 0x3A          DC8 45H, 3AH, 5CH, 41H, 43H, 51H, 5CH, 50H
   \              0x5C 0x41    
   \              0x43 0x51    
   \              0x5C 0x50    
   \   00000008   0x72 0x6F          DC8 72H, 6FH, 6AH, 5FH, 76H, 65H, 72H, 30H
   \              0x6A 0x5F    
   \              0x76 0x65    
   \              0x72 0x30    
   \   00000010   0x39 0x61          DC8 39H, 61H, 5FH, 31H, 35H, 31H, 30H, 32H
   \              0x5F 0x31    
   \              0x35 0x31    
   \              0x30 0x32    
   \   00000018   0x30 0x31          DC8 30H, 31H, 35H, 5CH, 42H, 61H, 73H, 65H
   \              0x35 0x5C    
   \              0x42 0x61    
   \              0x73 0x65    
   \   00000020   0x5F 0x30          DC8 5FH, 30H, 32H, 5CH, 32H, 30H, 31H, 33H
   \              0x32 0x5C    
   \              0x32 0x30    
   \              0x31 0x33    
   \   00000028   0x5F 0x31          DC8 5FH, 31H, 31H, 5FH, 32H, 35H, 5FH, 53H
   \              0x31 0x5F    
   \              0x32 0x35    
   \              0x5F 0x53    
   \   00000030   0x70 0x69          DC8 70H, 69H, 72H, 69H, 74H, 31H, 5FH, 45H
   \              0x72 0x69    
   \              0x74 0x31    
   \              0x5F 0x45    
   \   00000038   0x6C 0x65          DC8 6CH, 65H, 6BH, 74H, 72H, 6FH, 6CH, 75H
   \              0x6B 0x74    
   \              0x72 0x6F    
   \              0x6C 0x75    
   \   00000040   0x78 0x5C          DC8 78H, 5CH, 53H, 54H, 4DH, 33H, 32H, 4CH
   \              0x53 0x54    
   \              0x4D 0x33    
   \              0x32 0x4C    
   \   00000048   0x5C 0x53          DC8 5CH, 53H, 54H, 4DH, 33H, 32H, 4CH, 31H
   \              0x54 0x4D    
   \              0x33 0x32    
   \              0x4C 0x31    
   \   00000050   0x78 0x78          DC8 78H, 78H, 5FH, 53H, 74H, 64H, 50H, 65H
   \              0x5F 0x53    
   \              0x74 0x64    
   \              0x50 0x65    
   \   00000058   0x72 0x69          DC8 72H, 69H, 70H, 68H, 5FH, 4CH, 69H, 62H
   \              0x70 0x68    
   \              0x5F 0x4C    
   \              0x69 0x62    
   \   00000060   0x5C 0x53          DC8 5CH, 53H, 6FH, 75H, 72H, 63H, 65H, 5CH
   \              0x6F 0x75    
   \              0x72 0x63    
   \              0x65 0x5C    
   \   00000068   0x53 0x54          DC8 53H, 54H, 4DH, 33H, 32H, 4CH, 31H, 78H
   \              0x4D 0x33    
   \              0x32 0x4C    
   \              0x31 0x78    
   \   00000070   0x78 0x5F          DC8 78H, 5FH, 53H, 74H, 64H, 50H, 65H, 72H
   \              0x53 0x74    
   \              0x64 0x50    
   \              0x65 0x72    
   \   00000078   0x69 0x70          DC8 69H, 70H, 68H, 5FH, 44H, 72H, 69H, 76H
   \              0x68 0x5F    
   \              0x44 0x72    
   \              0x69 0x76    
   \   00000080   0x65 0x72          DC8 65H, 72H, 5CH, 73H, 72H, 63H, 5CH, 73H
   \              0x5C 0x73    
   \              0x72 0x63    
   \              0x5C 0x73    
   \   00000088   0x74 0x6D          DC8 74H, 6DH, 33H, 32H, 6CH, 31H, 78H, 78H
   \              0x33 0x32    
   \              0x6C 0x31    
   \              0x78 0x78    
   \   00000090   0x5F 0x73          DC8 5FH, 73H, 79H, 73H, 63H, 66H, 67H, 2EH
   \              0x79 0x73    
   \              0x63 0x66    
   \              0x67 0x2E    
   \   00000098   0x63 0x00          DC8 63H, 0
   \   0000009A   0x00 0x00          DC8 0, 0
    545          
    546          /**
    547            * @}
    548            */
    549          
    550          /**
    551            * @}
    552            */ 
    553          
    554          /**
    555            * @}
    556            */ 
    557          
    558          /**
    559            * @}
    560            */ 
    561          /******************* (C) COPYRIGHT 2010 STMicroelectronics *****END OF FILE****/   

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   SYSCFG_DeInit
         8   -> RCC_APB2PeriphResetCmd
      16   SYSCFG_EXTILineConfig
        16   -> assert_failed
       8   SYSCFG_MemoryRemapConfig
         8   -> assert_failed
       0   SYSCFG_RIDeInit
      16   SYSCFG_RIHysteresisConfig
        16   -> assert_failed
      16   SYSCFG_RIIOSwitchConfig
        16   -> assert_failed
      16   SYSCFG_RIResistorConfig
        16   -> assert_failed
       8   SYSCFG_RISwitchControlModeCmd
         8   -> assert_failed
      16   SYSCFG_RITIMInputCaptureConfig
        16   -> assert_failed
      16   SYSCFG_RITIMSelect
        16   -> assert_failed
       8   SYSCFG_USBPuCmd
         8   -> assert_failed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_12
       4  ??DataTable9_13
       4  ??DataTable9_14
       4  ??DataTable9_15
       4  ??DataTable9_16
       4  ??DataTable9_17
       4  ??DataTable9_18
       4  ??DataTable9_19
       4  ??DataTable9_2
       4  ??DataTable9_20
       4  ??DataTable9_21
       4  ??DataTable9_22
       4  ??DataTable9_23
       4  ??DataTable9_24
       4  ??DataTable9_25
       4  ??DataTable9_26
       4  ??DataTable9_27
       4  ??DataTable9_28
       4  ??DataTable9_29
       4  ??DataTable9_3
       4  ??DataTable9_30
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
     156  ?_0
      20  SYSCFG_DeInit
     242  SYSCFG_EXTILineConfig
      42  SYSCFG_MemoryRemapConfig
      50  SYSCFG_RIDeInit
     292  SYSCFG_RIHysteresisConfig
     294  SYSCFG_RIIOSwitchConfig
      86  SYSCFG_RIResistorConfig
      60  SYSCFG_RISwitchControlModeCmd
     172  SYSCFG_RITIMInputCaptureConfig
      60  SYSCFG_RITIMSelect
      68  SYSCFG_USBPuCmd

 
   156 bytes in section .rodata
 1 510 bytes in section .text
 
 1 510 bytes of CODE  memory
   156 bytes of CONST memory

Errors: none
Warnings: none
