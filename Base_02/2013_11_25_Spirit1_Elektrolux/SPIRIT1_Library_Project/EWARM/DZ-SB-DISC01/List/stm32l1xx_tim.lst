###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        20/Nov/2015  05:05:52
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_tim.c
#    Command line =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_tim.c
#        -D USE_STDPERIPH_DRIVER -D VECT_TAB_FLASH -D STM32L1XX_MD -D
#        IAR_ARM_CM3 -D USE_FULL_ASSERT -D SPIRIT_USE_FULL_ASSERT -D
#        USE_SYSTICK_DELAY -D SDK -lC
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\List\
#        -o
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\.\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\examples\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\Application\runtime\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\SDK_Eval_STM32L\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\SPIRIT1_Library\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\SDK_Eval_Util\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\SDK_Virtual_Com\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\..\STM32L\STM32_USB-FS-Device_Lib\Source\inc\
#        -I
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\..\ACQ\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\CMSIS\Include\"
#    List file    =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\List\stm32l1xx_tim.lst
#    Object file  =  
#        E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\SPIRIT1_Library_Project\EWARM\DZ-SB-DISC01\Obj\stm32l1xx_tim.o
#
###############################################################################

E:\ACQ\Proj_ver09a_15102015\Base_02\2013_11_25_Spirit1_Elektrolux\STM32L\STM32L1xx_StdPeriph_Lib\Source\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_tim.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l1xx_tim.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    31-December-2010
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the TIM peripheral:
      9            *            - TimeBase management
     10            *            - Output Compare management
     11            *            - Input Capture management
     12            *            - Interrupts, DMA and flags management
     13            *            - Clocks management
     14            *            - Synchronization management
     15            *            - Specific interface management
     16            *            - Specific remapping management      
     17            *              
     18            *  @verbatim
     19            *  
     20            *          ===================================================================
     21            *                                 How to use this driver
     22            *          ===================================================================
     23            *          This driver provides functions to configure and program the TIM 
     24            *          of all STM32L1xx devices
     25            *          These functions are split in 8 groups: 
     26            *   
     27            *          1. TIM TimeBase management: this group includes all needed functions 
     28            *             to configure the TM Timebase unit:
     29            *                   - Set/Get Prescaler
     30            *                   - Set/Get Autoreload  
     31            *                   - Counter modes configuration
     32            *                   - Set Clock division  
     33            *                   - Select the One Pulse mode
     34            *                   - Update Request Configuration
     35            *                   - Update Disable Configuration
     36            *                   - Auto-Preload Configuration 
     37            *                   - Enable/Disable the counter     
     38            *                 
     39            *          2. TIM Output Compare management: this group includes all needed 
     40            *             functions to configure the Capture/Compare unit used in Output 
     41            *             compare mode: 
     42            *                   - Configure each channel, independently, in Output Compare mode
     43            *                   - Select the output compare modes
     44            *                   - Select the Polarities of each channel
     45            *                   - Set/Get the Capture/Compare register values
     46            *                   - Select the Output Compare Fast mode 
     47            *                   - Select the Output Compare Forced mode  
     48            *                   - Output Compare-Preload Configuration 
     49            *                   - Clear Output Compare Reference
     50            *                   - Select the OCREF Clear signal
     51            *                   - Enable/Disable the Capture/Compare Channels    
     52            *                   
     53            *          3. TIM Input Capture management: this group includes all needed 
     54            *             functions to configure the Capture/Compare unit used in 
     55            *             Input Capture mode:
     56            *                   - Configure each channel in input capture mode
     57            *                   - Configure Channel1/2 in PWM Input mode
     58            *                   - Set the Input Capture Prescaler
     59            *                   - Get the Capture/Compare values      
     60            *        
     61            *          4. TIM interrupts, DMA and flags management
     62            *                   - Enable/Disable interrupt sources
     63            *                   - Get flags status
     64            *                   - Clear flags/ Pending bits
     65            *                   - Enable/Disable DMA requests 
     66            *                   - Configure DMA burst mode
     67            *                   - Select CaptureCompare DMA request  
     68            *              
     69            *          5. TIM clocks management: this group includes all needed functions 
     70            *             to configure the clock controller unit:
     71            *                   - Select internal/External clock
     72            *                   - Select the external clock mode: ETR(Mode1/Mode2), TIx or ITRx
     73            *         
     74            *          6. TIM synchronization management: this group includes all needed 
     75            *             functions to configure the Synchronization unit:
     76            *                   - Select Input Trigger  
     77            *                   - Select Output Trigger  
     78            *                   - Select Master Slave Mode 
     79            *                   - ETR Configuration when used as external trigger   
     80            *     
     81            *          7. TIM specific interface management, this group includes all 
     82            *             needed functions to use the specific TIM interface:
     83            *                   - Encoder Interface Configuration
     84            *                   - Select Hall Sensor   
     85            *         
     86            *          8. TIM specific remapping management includes the Remapping 
     87            *             configuration of specific timers               
     88            *   
     89            *  @endverbatim
     90            *    
     91            ******************************************************************************
     92            * @attention
     93            *
     94            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     95            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     96            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     97            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     98            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     99            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
    100            *
    101            * <h2><center>&copy; COPYRIGHT 2010 STMicroelectronics</center></h2>
    102            ******************************************************************************  
    103            */ 
    104          
    105          /* Includes ------------------------------------------------------------------*/
    106          #include "stm32l1xx_tim.h"
    107          #include "stm32l1xx_rcc.h"
    108          
    109          /** @addtogroup STM32L1xx_StdPeriph_Driver
    110            * @{
    111            */
    112          
    113          /** @defgroup TIM 
    114            * @brief TIM driver modules
    115            * @{
    116            */
    117          
    118          /* Private typedef -----------------------------------------------------------*/
    119          /* Private define ------------------------------------------------------------*/
    120          
    121          /* ---------------------- TIM registers bit mask ------------------------ */
    122          #define SMCR_ETR_MASK               ((uint16_t)0x00FF) 
    123          #define CCMR_OFFSET                 ((uint16_t)0x0018)
    124          #define CCER_CCE_SET                ((uint16_t)0x0001)  
    125            
    126          /* Private macro -------------------------------------------------------------*/
    127          /* Private variables ---------------------------------------------------------*/
    128          /* Private function prototypes -----------------------------------------------*/
    129          
    130          static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
    131                                 uint16_t TIM_ICFilter);
    132          static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
    133                                 uint16_t TIM_ICFilter);
    134          static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
    135                                 uint16_t TIM_ICFilter);
    136          static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
    137                                 uint16_t TIM_ICFilter);
    138          /* Private functions ---------------------------------------------------------*/
    139          
    140          /** @defgroup TIM_Private_Functions
    141            * @{
    142            */
    143          
    144          /** @defgroup TIM_Group1 TimeBase management functions
    145           *  @brief   TimeBase management functions 
    146           *
    147          @verbatim   
    148           ===============================================================================
    149                                 TimeBase management functions
    150           ===============================================================================  
    151            
    152                 ===================================================================      
    153                        TIM Driver: how to use it in Timing(Time base) Mode
    154                 =================================================================== 
    155                 To use the Timer in Timing(Time base) mode, the following steps are mandatory:
    156                 
    157                 1. Enable TIM clock using RCC_APBxPeriphClockCmd(RCC_APBxPeriph_TIMx, ENABLE) function
    158                              
    159                 2. Fill the TIM_TimeBaseInitStruct with the desired parameters.
    160                 
    161                 3. Call TIM_TimeBaseInit(TIMx, &TIM_TimeBaseInitStruct) to configure the Time Base unit
    162                    with the corresponding configuration
    163                    
    164                 4. Enable the NVIC if you need to generate the update interrupt. 
    165                    
    166                 5. Enable the corresponding interrupt using the function TIM_ITConfig(TIMx, TIM_IT_Update) 
    167                 
    168                 6. Call the TIM_Cmd(ENABLE) function to enable the TIM counter.
    169                       
    170                 Note1: All other functions can be used seperatly to modify, if needed,
    171                    a specific feature of the Timer. 
    172          
    173          @endverbatim
    174            * @{
    175            */
    176          
    177          /**
    178            * @brief  Deinitializes the TIMx peripheral registers to their default reset values.
    179            * @param  TIMx: where x can be 2 to 11 to select the TIM peripheral.
    180            * @retval None
    181            *   
    182            */

   \                                 In section .text, align 2, keep-with-next
    183          void TIM_DeInit(TIM_TypeDef* TIMx)
    184          {
   \                     TIM_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    185            /* Check the parameters */
    186            assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
   \   00000004   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   00000008   0xD020             BEQ.N    ??TIM_DeInit_0
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40000400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD01C             BEQ.N    ??TIM_DeInit_0
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x40000800
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD018             BEQ.N    ??TIM_DeInit_0
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable16_2  ;; 0x40001000
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD014             BEQ.N    ??TIM_DeInit_0
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable16_3  ;; 0x40001400
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD010             BEQ.N    ??TIM_DeInit_0
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable16_4  ;; 0x40010800
   \   0000002E   0x4284             CMP      R4,R0
   \   00000030   0xD00C             BEQ.N    ??TIM_DeInit_0
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable16_5  ;; 0x40010c00
   \   00000036   0x4284             CMP      R4,R0
   \   00000038   0xD008             BEQ.N    ??TIM_DeInit_0
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x40011000
   \   0000003E   0x4284             CMP      R4,R0
   \   00000040   0xD004             BEQ.N    ??TIM_DeInit_0
   \   00000042   0x21BA             MOVS     R1,#+186
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   00000048   0x.... 0x....      BL       assert_failed
    187             
    188            if (TIMx == TIM2)
   \                     ??TIM_DeInit_0: (+1)
   \   0000004C   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   00000050   0xD108             BNE.N    ??TIM_DeInit_1
    189            {
    190              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
   \   00000052   0x2101             MOVS     R1,#+1
   \   00000054   0x2001             MOVS     R0,#+1
   \   00000056   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    191              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
   \   0000005A   0x2100             MOVS     R1,#+0
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
   \   00000062   0xE059             B.N      ??TIM_DeInit_2
    192            }
    193            else if (TIMx == TIM3)
   \                     ??TIM_DeInit_1: (+1)
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40000400
   \   00000068   0x4284             CMP      R4,R0
   \   0000006A   0xD108             BNE.N    ??TIM_DeInit_3
    194            {
    195              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
   \   0000006C   0x2101             MOVS     R1,#+1
   \   0000006E   0x2002             MOVS     R0,#+2
   \   00000070   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    196              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
   \   00000074   0x2100             MOVS     R1,#+0
   \   00000076   0x2002             MOVS     R0,#+2
   \   00000078   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
   \   0000007C   0xE04C             B.N      ??TIM_DeInit_2
    197            }
    198            else if (TIMx == TIM4)
   \                     ??TIM_DeInit_3: (+1)
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x40000800
   \   00000082   0x4284             CMP      R4,R0
   \   00000084   0xD108             BNE.N    ??TIM_DeInit_4
    199            {
    200              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
   \   00000086   0x2101             MOVS     R1,#+1
   \   00000088   0x2004             MOVS     R0,#+4
   \   0000008A   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    201              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
   \   0000008E   0x2100             MOVS     R1,#+0
   \   00000090   0x2004             MOVS     R0,#+4
   \   00000092   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
   \   00000096   0xE03F             B.N      ??TIM_DeInit_2
    202            } 
    203          
    204            else if (TIMx == TIM6)
   \                     ??TIM_DeInit_4: (+1)
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable16_2  ;; 0x40001000
   \   0000009C   0x4284             CMP      R4,R0
   \   0000009E   0xD108             BNE.N    ??TIM_DeInit_5
    205            {
    206              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
   \   000000A0   0x2101             MOVS     R1,#+1
   \   000000A2   0x2010             MOVS     R0,#+16
   \   000000A4   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    207              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
   \   000000A8   0x2100             MOVS     R1,#+0
   \   000000AA   0x2010             MOVS     R0,#+16
   \   000000AC   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
   \   000000B0   0xE032             B.N      ??TIM_DeInit_2
    208            } 
    209            else if (TIMx == TIM7)
   \                     ??TIM_DeInit_5: (+1)
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable16_3  ;; 0x40001400
   \   000000B6   0x4284             CMP      R4,R0
   \   000000B8   0xD108             BNE.N    ??TIM_DeInit_6
    210            {
    211              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
   \   000000BA   0x2101             MOVS     R1,#+1
   \   000000BC   0x2020             MOVS     R0,#+32
   \   000000BE   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    212              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
   \   000000C2   0x2100             MOVS     R1,#+0
   \   000000C4   0x2020             MOVS     R0,#+32
   \   000000C6   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
   \   000000CA   0xE025             B.N      ??TIM_DeInit_2
    213            } 
    214          
    215            else if (TIMx == TIM9)
   \                     ??TIM_DeInit_6: (+1)
   \   000000CC   0x.... 0x....      LDR.W    R0,??DataTable16_4  ;; 0x40010800
   \   000000D0   0x4284             CMP      R4,R0
   \   000000D2   0xD108             BNE.N    ??TIM_DeInit_7
    216            {
    217              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);
   \   000000D4   0x2101             MOVS     R1,#+1
   \   000000D6   0x2004             MOVS     R0,#+4
   \   000000D8   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    218              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);
   \   000000DC   0x2100             MOVS     R1,#+0
   \   000000DE   0x2004             MOVS     R0,#+4
   \   000000E0   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
   \   000000E4   0xE018             B.N      ??TIM_DeInit_2
    219            } 
    220            else if (TIMx == TIM10)
   \                     ??TIM_DeInit_7: (+1)
   \   000000E6   0x.... 0x....      LDR.W    R0,??DataTable16_5  ;; 0x40010c00
   \   000000EA   0x4284             CMP      R4,R0
   \   000000EC   0xD108             BNE.N    ??TIM_DeInit_8
    221            {
    222              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);
   \   000000EE   0x2101             MOVS     R1,#+1
   \   000000F0   0x2008             MOVS     R0,#+8
   \   000000F2   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    223              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);
   \   000000F6   0x2100             MOVS     R1,#+0
   \   000000F8   0x2008             MOVS     R0,#+8
   \   000000FA   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
   \   000000FE   0xE00B             B.N      ??TIM_DeInit_2
    224            } 
    225            else
    226            {
    227              if (TIMx == TIM11)
   \                     ??TIM_DeInit_8: (+1)
   \   00000100   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x40011000
   \   00000104   0x4284             CMP      R4,R0
   \   00000106   0xD107             BNE.N    ??TIM_DeInit_2
    228              {
    229                RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);
   \   00000108   0x2101             MOVS     R1,#+1
   \   0000010A   0x2010             MOVS     R0,#+16
   \   0000010C   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    230                RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE); 
   \   00000110   0x2100             MOVS     R1,#+0
   \   00000112   0x2010             MOVS     R0,#+16
   \   00000114   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    231              }  
    232            }
    233               
    234          }
   \                     ??TIM_DeInit_2: (+1)
   \   00000118   0xBD10             POP      {R4,PC}          ;; return
    235          
    236          /**
    237            * @brief  Initializes the TIMx Time Base Unit peripheral according to 
    238            *         the specified parameters in the TIM_TimeBaseInitStruct.
    239            * @param  TIMx: where x can be 2 to 11 to select the TIM peripheral.
    240            * @param  TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef
    241            *         structure that contains the configuration information for
    242            *         the specified TIM peripheral.
    243            * @retval None
    244            */

   \                                 In section .text, align 2, keep-with-next
    245          void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
    246          {
   \                     TIM_TimeBaseInit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    247            uint16_t tmpcr1 = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    248          
    249            /* Check the parameters */
    250            assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
   \   00000008   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000C   0xD020             BEQ.N    ??TIM_TimeBaseInit_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40000400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD01C             BEQ.N    ??TIM_TimeBaseInit_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x40000800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD018             BEQ.N    ??TIM_TimeBaseInit_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable16_2  ;; 0x40001000
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD014             BEQ.N    ??TIM_TimeBaseInit_0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable16_3  ;; 0x40001400
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD010             BEQ.N    ??TIM_TimeBaseInit_0
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable16_4  ;; 0x40010800
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD00C             BEQ.N    ??TIM_TimeBaseInit_0
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable16_5  ;; 0x40010c00
   \   0000003A   0x4284             CMP      R4,R0
   \   0000003C   0xD008             BEQ.N    ??TIM_TimeBaseInit_0
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x40011000
   \   00000042   0x4284             CMP      R4,R0
   \   00000044   0xD004             BEQ.N    ??TIM_TimeBaseInit_0
   \   00000046   0x21FA             MOVS     R1,#+250
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   0000004C   0x.... 0x....      BL       assert_failed
    251            assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
   \                     ??TIM_TimeBaseInit_0: (+1)
   \   00000050   0x8868             LDRH     R0,[R5, #+2]
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD010             BEQ.N    ??TIM_TimeBaseInit_1
   \   00000056   0x8868             LDRH     R0,[R5, #+2]
   \   00000058   0x2810             CMP      R0,#+16
   \   0000005A   0xD00D             BEQ.N    ??TIM_TimeBaseInit_1
   \   0000005C   0x8868             LDRH     R0,[R5, #+2]
   \   0000005E   0x2820             CMP      R0,#+32
   \   00000060   0xD00A             BEQ.N    ??TIM_TimeBaseInit_1
   \   00000062   0x8868             LDRH     R0,[R5, #+2]
   \   00000064   0x2840             CMP      R0,#+64
   \   00000066   0xD007             BEQ.N    ??TIM_TimeBaseInit_1
   \   00000068   0x8868             LDRH     R0,[R5, #+2]
   \   0000006A   0x2860             CMP      R0,#+96
   \   0000006C   0xD004             BEQ.N    ??TIM_TimeBaseInit_1
   \   0000006E   0x21FB             MOVS     R1,#+251
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   00000074   0x.... 0x....      BL       assert_failed
    252            assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
   \                     ??TIM_TimeBaseInit_1: (+1)
   \   00000078   0x88E8             LDRH     R0,[R5, #+6]
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD00C             BEQ.N    ??TIM_TimeBaseInit_2
   \   0000007E   0x88E8             LDRH     R0,[R5, #+6]
   \   00000080   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000084   0xD008             BEQ.N    ??TIM_TimeBaseInit_2
   \   00000086   0x88E8             LDRH     R0,[R5, #+6]
   \   00000088   0xF5B0 0x7F00      CMP      R0,#+512
   \   0000008C   0xD004             BEQ.N    ??TIM_TimeBaseInit_2
   \   0000008E   0x21FC             MOVS     R1,#+252
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   00000094   0x.... 0x....      BL       assert_failed
    253          
    254            tmpcr1 = TIMx->CR1;  
   \                     ??TIM_TimeBaseInit_2: (+1)
   \   00000098   0x8820             LDRH     R0,[R4, #+0]
   \   0000009A   0x0006             MOVS     R6,R0
    255          
    256            if(((TIMx) == TIM2) || ((TIMx) == TIM3) || ((TIMx) == TIM4))
   \   0000009C   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   000000A0   0xD007             BEQ.N    ??TIM_TimeBaseInit_3
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40000400
   \   000000A6   0x4284             CMP      R4,R0
   \   000000A8   0xD003             BEQ.N    ??TIM_TimeBaseInit_3
   \   000000AA   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x40000800
   \   000000AE   0x4284             CMP      R4,R0
   \   000000B0   0xD104             BNE.N    ??TIM_TimeBaseInit_4
    257            {											
    258              /* Select the Counter Mode */
    259              tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
   \                     ??TIM_TimeBaseInit_3: (+1)
   \   000000B2   0xF64F 0x708F      MOVW     R0,#+65423
   \   000000B6   0x4006             ANDS     R6,R0,R6
    260              tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
   \   000000B8   0x8868             LDRH     R0,[R5, #+2]
   \   000000BA   0x4306             ORRS     R6,R0,R6
    261            }
    262           
    263            if(((TIMx) != TIM6) && ((TIMx) != TIM7))
   \                     ??TIM_TimeBaseInit_4: (+1)
   \   000000BC   0x.... 0x....      LDR.W    R0,??DataTable16_2  ;; 0x40001000
   \   000000C0   0x4284             CMP      R4,R0
   \   000000C2   0xD008             BEQ.N    ??TIM_TimeBaseInit_5
   \   000000C4   0x.... 0x....      LDR.W    R0,??DataTable16_3  ;; 0x40001400
   \   000000C8   0x4284             CMP      R4,R0
   \   000000CA   0xD004             BEQ.N    ??TIM_TimeBaseInit_5
    264            {
    265              /* Set the clock division */
    266              tmpcr1 &= (uint16_t)(~((uint16_t)TIM_CR1_CKD));
   \   000000CC   0xF64F 0x40FF      MOVW     R0,#+64767
   \   000000D0   0x4006             ANDS     R6,R0,R6
    267              tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
   \   000000D2   0x88E8             LDRH     R0,[R5, #+6]
   \   000000D4   0x4306             ORRS     R6,R0,R6
    268            }
    269          
    270            TIMx->CR1 = tmpcr1;
   \                     ??TIM_TimeBaseInit_5: (+1)
   \   000000D6   0x8026             STRH     R6,[R4, #+0]
    271          
    272            /* Set the Autoreload value */
    273            TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
   \   000000D8   0x88A8             LDRH     R0,[R5, #+4]
   \   000000DA   0x85A0             STRH     R0,[R4, #+44]
    274           
    275            /* Set the Prescaler value */
    276            TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
   \   000000DC   0x8828             LDRH     R0,[R5, #+0]
   \   000000DE   0x8520             STRH     R0,[R4, #+40]
    277              
    278            /* Generate an update event to reload the Prescaler value immediatly */
    279            TIMx->EGR = TIM_PSCReloadMode_Immediate;          
   \   000000E0   0x2001             MOVS     R0,#+1
   \   000000E2   0x82A0             STRH     R0,[R4, #+20]
    280          }
   \   000000E4   0xBD70             POP      {R4-R6,PC}       ;; return
    281          
    282          /**
    283            * @brief  Fills each TIM_TimeBaseInitStruct member with its default value.
    284            * @param  TIM_TimeBaseInitStruct : pointer to a TIM_TimeBaseInitTypeDef
    285            *         structure which will be initialized.
    286            * @retval None
    287            */

   \                                 In section .text, align 2, keep-with-next
    288          void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
    289          {
    290            /* Set the default configuration */
    291            TIM_TimeBaseInitStruct->TIM_Period = 0xFFFF;
   \                     TIM_TimeBaseStructInit: (+1)
   \   00000000   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000004   0x8081             STRH     R1,[R0, #+4]
    292            TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x8001             STRH     R1,[R0, #+0]
    293            TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x80C1             STRH     R1,[R0, #+6]
    294            TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x8041             STRH     R1,[R0, #+2]
    295          }
   \   00000012   0x4770             BX       LR               ;; return
    296          
    297          /**
    298            * @brief  Configures the TIMx Prescaler.
    299            * @param  TIMx: where x can be 2 to 11 to select the TIM peripheral.
    300            * @param  Prescaler: specifies the Prescaler Register value
    301            * @param  TIM_PSCReloadMode: specifies the TIM Prescaler Reload mode
    302            *   This parameter can be one of the following values:
    303            *     @arg TIM_PSCReloadMode_Update: The Prescaler is loaded at the update event.
    304            *     @arg TIM_PSCReloadMode_Immediate: The Prescaler is loaded immediatly.
    305            * @retval None
    306            */

   \                                 In section .text, align 2, keep-with-next
    307          void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
    308          {
   \                     TIM_PrescalerConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    309            /* Check the parameters */
    310            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   \   00000008   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000C   0xD021             BEQ.N    ??TIM_PrescalerConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40000400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD01D             BEQ.N    ??TIM_PrescalerConfig_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x40000800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD019             BEQ.N    ??TIM_PrescalerConfig_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable16_2  ;; 0x40001000
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD015             BEQ.N    ??TIM_PrescalerConfig_0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable16_3  ;; 0x40001400
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD011             BEQ.N    ??TIM_PrescalerConfig_0
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable16_4  ;; 0x40010800
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD00D             BEQ.N    ??TIM_PrescalerConfig_0
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable16_5  ;; 0x40010c00
   \   0000003A   0x4284             CMP      R4,R0
   \   0000003C   0xD009             BEQ.N    ??TIM_PrescalerConfig_0
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x40011000
   \   00000042   0x4284             CMP      R4,R0
   \   00000044   0xD005             BEQ.N    ??TIM_PrescalerConfig_0
   \   00000046   0xF44F 0x719B      MOV      R1,#+310
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   0000004E   0x.... 0x....      BL       assert_failed
    311            assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
   \                     ??TIM_PrescalerConfig_0: (+1)
   \   00000052   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000054   0x2E00             CMP      R6,#+0
   \   00000056   0xD008             BEQ.N    ??TIM_PrescalerConfig_1
   \   00000058   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000005A   0x2E01             CMP      R6,#+1
   \   0000005C   0xD005             BEQ.N    ??TIM_PrescalerConfig_1
   \   0000005E   0xF240 0x1137      MOVW     R1,#+311
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   00000066   0x.... 0x....      BL       assert_failed
    312            
    313            /* Set the Prescaler value */
    314            TIMx->PSC = Prescaler;
   \                     ??TIM_PrescalerConfig_1: (+1)
   \   0000006A   0x8525             STRH     R5,[R4, #+40]
    315            /* Set or reset the UG Bit */
    316            TIMx->EGR = TIM_PSCReloadMode;
   \   0000006C   0x82A6             STRH     R6,[R4, #+20]
    317          }
   \   0000006E   0xBD70             POP      {R4-R6,PC}       ;; return
    318          
    319          /**
    320            * @brief  Specifies the TIMx Counter Mode to be used.
    321            * @param  TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    322            * @param  TIM_CounterMode: specifies the Counter Mode to be used
    323            *   This parameter can be one of the following values:
    324            *     @arg TIM_CounterMode_Up: TIM Up Counting Mode
    325            *     @arg TIM_CounterMode_Down: TIM Down Counting Mode
    326            *     @arg TIM_CounterMode_CenterAligned1: TIM Center Aligned Mode1
    327            *     @arg TIM_CounterMode_CenterAligned2: TIM Center Aligned Mode2
    328            *     @arg TIM_CounterMode_CenterAligned3: TIM Center Aligned Mode3
    329            * @retval None
    330            */

   \                                 In section .text, align 2, keep-with-next
    331          void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
    332          {
   \                     TIM_CounterModeConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    333            uint16_t tmpcr1 = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    334            
    335            /* Check the parameters */
    336            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   \   00000008   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000C   0xD00D             BEQ.N    ??TIM_CounterModeConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40000400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??TIM_CounterModeConfig_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x40000800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??TIM_CounterModeConfig_0
   \   0000001E   0xF44F 0x71A8      MOV      R1,#+336
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   00000026   0x.... 0x....      BL       assert_failed
    337            assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
   \                     ??TIM_CounterModeConfig_0: (+1)
   \   0000002A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002C   0x2D00             CMP      R5,#+0
   \   0000002E   0xD011             BEQ.N    ??TIM_CounterModeConfig_1
   \   00000030   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000032   0x2D10             CMP      R5,#+16
   \   00000034   0xD00E             BEQ.N    ??TIM_CounterModeConfig_1
   \   00000036   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000038   0x2D20             CMP      R5,#+32
   \   0000003A   0xD00B             BEQ.N    ??TIM_CounterModeConfig_1
   \   0000003C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000003E   0x2D40             CMP      R5,#+64
   \   00000040   0xD008             BEQ.N    ??TIM_CounterModeConfig_1
   \   00000042   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000044   0x2D60             CMP      R5,#+96
   \   00000046   0xD005             BEQ.N    ??TIM_CounterModeConfig_1
   \   00000048   0xF240 0x1151      MOVW     R1,#+337
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   00000050   0x.... 0x....      BL       assert_failed
    338            
    339            tmpcr1 = TIMx->CR1;
   \                     ??TIM_CounterModeConfig_1: (+1)
   \   00000054   0x8820             LDRH     R0,[R4, #+0]
   \   00000056   0x0006             MOVS     R6,R0
    340            /* Reset the CMS and DIR Bits */
    341            tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
   \   00000058   0xF64F 0x708F      MOVW     R0,#+65423
   \   0000005C   0x4006             ANDS     R6,R0,R6
    342            /* Set the Counter Mode */
    343            tmpcr1 |= TIM_CounterMode;
   \   0000005E   0x432E             ORRS     R6,R5,R6
    344            /* Write to TIMx CR1 register */
    345            TIMx->CR1 = tmpcr1;
   \   00000060   0x8026             STRH     R6,[R4, #+0]
    346          }
   \   00000062   0xBD70             POP      {R4-R6,PC}       ;; return
    347          
    348          /**
    349            * @brief  Sets the TIMx Counter Register value
    350            * @param  TIMx: where x can be 2 to 11 to select the TIM peripheral.
    351            * @param  Counter: specifies the Counter register new value.
    352            * @retval None
    353            */

   \                                 In section .text, align 2, keep-with-next
    354          void TIM_SetCounter(TIM_TypeDef* TIMx, uint32_t Counter)
    355          {
   \                     TIM_SetCounter: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    356            /* Check the parameters */
    357             assert_param(IS_TIM_ALL_PERIPH(TIMx));
   \   00000006   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000A   0xD021             BEQ.N    ??TIM_SetCounter_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40000400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD01D             BEQ.N    ??TIM_SetCounter_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x40000800
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD019             BEQ.N    ??TIM_SetCounter_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable16_2  ;; 0x40001000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD015             BEQ.N    ??TIM_SetCounter_0
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable16_3  ;; 0x40001400
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD011             BEQ.N    ??TIM_SetCounter_0
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable16_4  ;; 0x40010800
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD00D             BEQ.N    ??TIM_SetCounter_0
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable16_5  ;; 0x40010c00
   \   00000038   0x4284             CMP      R4,R0
   \   0000003A   0xD009             BEQ.N    ??TIM_SetCounter_0
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x40011000
   \   00000040   0x4284             CMP      R4,R0
   \   00000042   0xD005             BEQ.N    ??TIM_SetCounter_0
   \   00000044   0xF240 0x1165      MOVW     R1,#+357
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   0000004C   0x.... 0x....      BL       assert_failed
    358             
    359            /* Set the Counter Register value */
    360            TIMx->CNT = Counter;
   \                     ??TIM_SetCounter_0: (+1)
   \   00000050   0x84A5             STRH     R5,[R4, #+36]
    361          }
   \   00000052   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    362          
    363          /**
    364            * @brief  Sets the TIMx Autoreload Register value
    365            * @param  TIMx: where x can be 2 to 11 to select the TIM peripheral.
    366            * @param  Autoreload: specifies the Autoreload register new value.
    367            * @retval None
    368            */

   \                                 In section .text, align 2, keep-with-next
    369          void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint32_t Autoreload)
    370          {
   \                     TIM_SetAutoreload: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    371            /* Check the parameters */
    372            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   \   00000006   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000A   0xD021             BEQ.N    ??TIM_SetAutoreload_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40000400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD01D             BEQ.N    ??TIM_SetAutoreload_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x40000800
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD019             BEQ.N    ??TIM_SetAutoreload_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable16_2  ;; 0x40001000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD015             BEQ.N    ??TIM_SetAutoreload_0
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable16_3  ;; 0x40001400
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD011             BEQ.N    ??TIM_SetAutoreload_0
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable16_4  ;; 0x40010800
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD00D             BEQ.N    ??TIM_SetAutoreload_0
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable16_5  ;; 0x40010c00
   \   00000038   0x4284             CMP      R4,R0
   \   0000003A   0xD009             BEQ.N    ??TIM_SetAutoreload_0
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x40011000
   \   00000040   0x4284             CMP      R4,R0
   \   00000042   0xD005             BEQ.N    ??TIM_SetAutoreload_0
   \   00000044   0xF44F 0x71BA      MOV      R1,#+372
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   0000004C   0x.... 0x....      BL       assert_failed
    373            
    374            /* Set the Autoreload Register value */
    375            TIMx->ARR = Autoreload;
   \                     ??TIM_SetAutoreload_0: (+1)
   \   00000050   0x85A5             STRH     R5,[R4, #+44]
    376          }
   \   00000052   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    377          
    378          /**
    379            * @brief  Gets the TIMx Counter value.
    380            * @param  TIMx: where x can be 2 to 11 to select the TIM peripheral.
    381            * @retval Counter Register value.
    382            */

   \                                 In section .text, align 2, keep-with-next
    383          uint32_t TIM_GetCounter(TIM_TypeDef* TIMx)
    384          {
   \                     TIM_GetCounter: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    385            /* Check the parameters */
    386            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   \   00000004   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   00000008   0xD021             BEQ.N    ??TIM_GetCounter_0
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40000400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD01D             BEQ.N    ??TIM_GetCounter_0
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x40000800
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD019             BEQ.N    ??TIM_GetCounter_0
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable16_2  ;; 0x40001000
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD015             BEQ.N    ??TIM_GetCounter_0
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable16_3  ;; 0x40001400
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD011             BEQ.N    ??TIM_GetCounter_0
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable16_4  ;; 0x40010800
   \   0000002E   0x4284             CMP      R4,R0
   \   00000030   0xD00D             BEQ.N    ??TIM_GetCounter_0
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable16_5  ;; 0x40010c00
   \   00000036   0x4284             CMP      R4,R0
   \   00000038   0xD009             BEQ.N    ??TIM_GetCounter_0
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x40011000
   \   0000003E   0x4284             CMP      R4,R0
   \   00000040   0xD005             BEQ.N    ??TIM_GetCounter_0
   \   00000042   0xF44F 0x71C1      MOV      R1,#+386
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   0000004A   0x.... 0x....      BL       assert_failed
    387            
    388            /* Get the Counter Register value */
    389            return TIMx->CNT;
   \                     ??TIM_GetCounter_0: (+1)
   \   0000004E   0x8CA0             LDRH     R0,[R4, #+36]
   \   00000050   0xBD10             POP      {R4,PC}          ;; return
    390          }
    391          
    392          /**
    393            * @brief  Gets the TIMx Prescaler value.
    394            * @param  TIMx: where x can be 2 to 11 to select the TIM peripheral.
    395            * @retval Prescaler Register value.
    396            */

   \                                 In section .text, align 2, keep-with-next
    397          uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
    398          {
   \                     TIM_GetPrescaler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    399            /* Check the parameters */
    400            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   \   00000004   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   00000008   0xD021             BEQ.N    ??TIM_GetPrescaler_0
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40000400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD01D             BEQ.N    ??TIM_GetPrescaler_0
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x40000800
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD019             BEQ.N    ??TIM_GetPrescaler_0
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable16_2  ;; 0x40001000
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD015             BEQ.N    ??TIM_GetPrescaler_0
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable16_3  ;; 0x40001400
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD011             BEQ.N    ??TIM_GetPrescaler_0
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable16_4  ;; 0x40010800
   \   0000002E   0x4284             CMP      R4,R0
   \   00000030   0xD00D             BEQ.N    ??TIM_GetPrescaler_0
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable16_5  ;; 0x40010c00
   \   00000036   0x4284             CMP      R4,R0
   \   00000038   0xD009             BEQ.N    ??TIM_GetPrescaler_0
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x40011000
   \   0000003E   0x4284             CMP      R4,R0
   \   00000040   0xD005             BEQ.N    ??TIM_GetPrescaler_0
   \   00000042   0xF44F 0x71C8      MOV      R1,#+400
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   0000004A   0x.... 0x....      BL       assert_failed
    401            
    402            /* Get the Prescaler Register value */
    403            return TIMx->PSC;
   \                     ??TIM_GetPrescaler_0: (+1)
   \   0000004E   0x8D20             LDRH     R0,[R4, #+40]
   \   00000050   0xBD10             POP      {R4,PC}          ;; return
    404          }
    405          
    406          /**
    407            * @brief  Enables or Disables the TIMx Update event.
    408            * @param  TIMx: where x can be 2 to 11 to select the TIM peripheral.
    409            * @param  NewState: new state of the TIMx UDIS bit
    410            *   This parameter can be: ENABLE or DISABLE.
    411            * @retval None
    412            */

   \                                 In section .text, align 2, keep-with-next
    413          void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
    414          {
   \                     TIM_UpdateDisableConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    415            /* Check the parameters */
    416            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   \   00000006   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000A   0xD021             BEQ.N    ??TIM_UpdateDisableConfig_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40000400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD01D             BEQ.N    ??TIM_UpdateDisableConfig_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x40000800
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD019             BEQ.N    ??TIM_UpdateDisableConfig_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable16_2  ;; 0x40001000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD015             BEQ.N    ??TIM_UpdateDisableConfig_0
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable16_3  ;; 0x40001400
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD011             BEQ.N    ??TIM_UpdateDisableConfig_0
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable16_4  ;; 0x40010800
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD00D             BEQ.N    ??TIM_UpdateDisableConfig_0
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable16_5  ;; 0x40010c00
   \   00000038   0x4284             CMP      R4,R0
   \   0000003A   0xD009             BEQ.N    ??TIM_UpdateDisableConfig_0
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x40011000
   \   00000040   0x4284             CMP      R4,R0
   \   00000042   0xD005             BEQ.N    ??TIM_UpdateDisableConfig_0
   \   00000044   0xF44F 0x71D0      MOV      R1,#+416
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   0000004C   0x.... 0x....      BL       assert_failed
    417            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??TIM_UpdateDisableConfig_0: (+1)
   \   00000050   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000052   0x2D00             CMP      R5,#+0
   \   00000054   0xD008             BEQ.N    ??TIM_UpdateDisableConfig_1
   \   00000056   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000058   0x2D01             CMP      R5,#+1
   \   0000005A   0xD005             BEQ.N    ??TIM_UpdateDisableConfig_1
   \   0000005C   0xF240 0x11A1      MOVW     R1,#+417
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   00000064   0x.... 0x....      BL       assert_failed
    418            
    419            if (NewState != DISABLE)
   \                     ??TIM_UpdateDisableConfig_1: (+1)
   \   00000068   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000006A   0x2D00             CMP      R5,#+0
   \   0000006C   0xD004             BEQ.N    ??TIM_UpdateDisableConfig_2
    420            {
    421              /* Set the Update Disable Bit */
    422              TIMx->CR1 |= TIM_CR1_UDIS;
   \   0000006E   0x8820             LDRH     R0,[R4, #+0]
   \   00000070   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000074   0x8020             STRH     R0,[R4, #+0]
   \   00000076   0xE004             B.N      ??TIM_UpdateDisableConfig_3
    423            }
    424            else
    425            {
    426              /* Reset the Update Disable Bit */
    427              TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_UDIS);
   \                     ??TIM_UpdateDisableConfig_2: (+1)
   \   00000078   0x8820             LDRH     R0,[R4, #+0]
   \   0000007A   0xF64F 0x71FD      MOVW     R1,#+65533
   \   0000007E   0x4008             ANDS     R0,R1,R0
   \   00000080   0x8020             STRH     R0,[R4, #+0]
    428            }
    429          }
   \                     ??TIM_UpdateDisableConfig_3: (+1)
   \   00000082   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    430          
    431          /**
    432            * @brief  Configures the TIMx Update Request Interrupt source.
    433            * @param  TIMx: where x can be 2 to 11 to select the TIM peripheral.
    434            * @param  TIM_UpdateSource: specifies the Update source.
    435            *   This parameter can be one of the following values:
    436            *     @arg TIM_UpdateSource_Regular: Source of update is the counter overflow/underflow
    437                                                 or the setting of UG bit, or an update generation
    438                                                 through the slave mode controller.
    439            *     @arg TIM_UpdateSource_Global: Source of update is counter overflow/underflow.
    440            * @retval None
    441            */

   \                                 In section .text, align 2, keep-with-next
    442          void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
    443          {
   \                     TIM_UpdateRequestConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    444            /* Check the parameters */
    445            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   \   00000006   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000A   0xD021             BEQ.N    ??TIM_UpdateRequestConfig_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40000400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD01D             BEQ.N    ??TIM_UpdateRequestConfig_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x40000800
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD019             BEQ.N    ??TIM_UpdateRequestConfig_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable16_2  ;; 0x40001000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD015             BEQ.N    ??TIM_UpdateRequestConfig_0
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable16_3  ;; 0x40001400
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD011             BEQ.N    ??TIM_UpdateRequestConfig_0
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable16_4  ;; 0x40010800
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD00D             BEQ.N    ??TIM_UpdateRequestConfig_0
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable16_5  ;; 0x40010c00
   \   00000038   0x4284             CMP      R4,R0
   \   0000003A   0xD009             BEQ.N    ??TIM_UpdateRequestConfig_0
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x40011000
   \   00000040   0x4284             CMP      R4,R0
   \   00000042   0xD005             BEQ.N    ??TIM_UpdateRequestConfig_0
   \   00000044   0xF240 0x11BD      MOVW     R1,#+445
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   0000004C   0x.... 0x....      BL       assert_failed
    446            assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
   \                     ??TIM_UpdateRequestConfig_0: (+1)
   \   00000050   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000052   0x2D00             CMP      R5,#+0
   \   00000054   0xD008             BEQ.N    ??TIM_UpdateRequestConfig_1
   \   00000056   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000058   0x2D01             CMP      R5,#+1
   \   0000005A   0xD005             BEQ.N    ??TIM_UpdateRequestConfig_1
   \   0000005C   0xF44F 0x71DF      MOV      R1,#+446
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   00000064   0x.... 0x....      BL       assert_failed
    447            
    448            if (TIM_UpdateSource != TIM_UpdateSource_Global)
   \                     ??TIM_UpdateRequestConfig_1: (+1)
   \   00000068   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000006A   0x2D00             CMP      R5,#+0
   \   0000006C   0xD004             BEQ.N    ??TIM_UpdateRequestConfig_2
    449            {
    450              /* Set the URS Bit */
    451              TIMx->CR1 |= TIM_CR1_URS;
   \   0000006E   0x8820             LDRH     R0,[R4, #+0]
   \   00000070   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000074   0x8020             STRH     R0,[R4, #+0]
   \   00000076   0xE004             B.N      ??TIM_UpdateRequestConfig_3
    452            }
    453            else
    454            {
    455              /* Reset the URS Bit */
    456              TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_URS);
   \                     ??TIM_UpdateRequestConfig_2: (+1)
   \   00000078   0x8820             LDRH     R0,[R4, #+0]
   \   0000007A   0xF64F 0x71FB      MOVW     R1,#+65531
   \   0000007E   0x4008             ANDS     R0,R1,R0
   \   00000080   0x8020             STRH     R0,[R4, #+0]
    457            }
    458          }
   \                     ??TIM_UpdateRequestConfig_3: (+1)
   \   00000082   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    459          
    460          /**
    461            * @brief  Enables or disables TIMx peripheral Preload register on ARR.
    462            * @param  TIMx: where x can be  2 to 11 to select the TIM peripheral.
    463            * @param  NewState: new state of the TIMx peripheral Preload register
    464            *   This parameter can be: ENABLE or DISABLE.
    465            * @retval None
    466            */

   \                                 In section .text, align 2, keep-with-next
    467          void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
    468          {
   \                     TIM_ARRPreloadConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    469            /* Check the parameters */
    470            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   \   00000006   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000A   0xD021             BEQ.N    ??TIM_ARRPreloadConfig_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40000400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD01D             BEQ.N    ??TIM_ARRPreloadConfig_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x40000800
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD019             BEQ.N    ??TIM_ARRPreloadConfig_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable16_2  ;; 0x40001000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD015             BEQ.N    ??TIM_ARRPreloadConfig_0
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable16_3  ;; 0x40001400
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD011             BEQ.N    ??TIM_ARRPreloadConfig_0
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable16_4  ;; 0x40010800
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD00D             BEQ.N    ??TIM_ARRPreloadConfig_0
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable16_5  ;; 0x40010c00
   \   00000038   0x4284             CMP      R4,R0
   \   0000003A   0xD009             BEQ.N    ??TIM_ARRPreloadConfig_0
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x40011000
   \   00000040   0x4284             CMP      R4,R0
   \   00000042   0xD005             BEQ.N    ??TIM_ARRPreloadConfig_0
   \   00000044   0xF44F 0x71EB      MOV      R1,#+470
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   0000004C   0x.... 0x....      BL       assert_failed
    471            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??TIM_ARRPreloadConfig_0: (+1)
   \   00000050   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000052   0x2D00             CMP      R5,#+0
   \   00000054   0xD008             BEQ.N    ??TIM_ARRPreloadConfig_1
   \   00000056   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000058   0x2D01             CMP      R5,#+1
   \   0000005A   0xD005             BEQ.N    ??TIM_ARRPreloadConfig_1
   \   0000005C   0xF240 0x11D7      MOVW     R1,#+471
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   00000064   0x.... 0x....      BL       assert_failed
    472            
    473            if (NewState != DISABLE)
   \                     ??TIM_ARRPreloadConfig_1: (+1)
   \   00000068   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000006A   0x2D00             CMP      R5,#+0
   \   0000006C   0xD004             BEQ.N    ??TIM_ARRPreloadConfig_2
    474            {
    475              /* Set the ARR Preload Bit */
    476              TIMx->CR1 |= TIM_CR1_ARPE;
   \   0000006E   0x8820             LDRH     R0,[R4, #+0]
   \   00000070   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000074   0x8020             STRH     R0,[R4, #+0]
   \   00000076   0xE004             B.N      ??TIM_ARRPreloadConfig_3
    477            }
    478            else
    479            {
    480              /* Reset the ARR Preload Bit */
    481              TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_ARPE);
   \                     ??TIM_ARRPreloadConfig_2: (+1)
   \   00000078   0x8820             LDRH     R0,[R4, #+0]
   \   0000007A   0xF64F 0x717F      MOVW     R1,#+65407
   \   0000007E   0x4008             ANDS     R0,R1,R0
   \   00000080   0x8020             STRH     R0,[R4, #+0]
    482            }
    483          }
   \                     ??TIM_ARRPreloadConfig_3: (+1)
   \   00000082   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    484          
    485          /**
    486            * @brief  Selects the TIMxs One Pulse Mode.
    487            * @param  TIMx: where x can be 2 to 11 to select the TIM peripheral.
    488            * @param  TIM_OPMode: specifies the OPM Mode to be used.
    489            *   This parameter can be one of the following values:
    490            *     @arg TIM_OPMode_Single
    491            *     @arg TIM_OPMode_Repetitive
    492            * @retval None
    493            */

   \                                 In section .text, align 2, keep-with-next
    494          void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
    495          {
   \                     TIM_SelectOnePulseMode: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    496            /* Check the parameters */
    497            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   \   00000006   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000A   0xD021             BEQ.N    ??TIM_SelectOnePulseMode_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40000400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD01D             BEQ.N    ??TIM_SelectOnePulseMode_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x40000800
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD019             BEQ.N    ??TIM_SelectOnePulseMode_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable16_2  ;; 0x40001000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD015             BEQ.N    ??TIM_SelectOnePulseMode_0
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable16_3  ;; 0x40001400
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD011             BEQ.N    ??TIM_SelectOnePulseMode_0
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable16_4  ;; 0x40010800
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD00D             BEQ.N    ??TIM_SelectOnePulseMode_0
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable16_5  ;; 0x40010c00
   \   00000038   0x4284             CMP      R4,R0
   \   0000003A   0xD009             BEQ.N    ??TIM_SelectOnePulseMode_0
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x40011000
   \   00000040   0x4284             CMP      R4,R0
   \   00000042   0xD005             BEQ.N    ??TIM_SelectOnePulseMode_0
   \   00000044   0xF240 0x11F1      MOVW     R1,#+497
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   0000004C   0x.... 0x....      BL       assert_failed
    498            assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
   \                     ??TIM_SelectOnePulseMode_0: (+1)
   \   00000050   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000052   0x2D08             CMP      R5,#+8
   \   00000054   0xD008             BEQ.N    ??TIM_SelectOnePulseMode_1
   \   00000056   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000058   0x2D00             CMP      R5,#+0
   \   0000005A   0xD005             BEQ.N    ??TIM_SelectOnePulseMode_1
   \   0000005C   0xF44F 0x71F9      MOV      R1,#+498
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   00000064   0x.... 0x....      BL       assert_failed
    499            
    500            /* Reset the OPM Bit */
    501            TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_OPM);
   \                     ??TIM_SelectOnePulseMode_1: (+1)
   \   00000068   0x8820             LDRH     R0,[R4, #+0]
   \   0000006A   0xF64F 0x71F7      MOVW     R1,#+65527
   \   0000006E   0x4008             ANDS     R0,R1,R0
   \   00000070   0x8020             STRH     R0,[R4, #+0]
    502            /* Configure the OPM Mode */
    503            TIMx->CR1 |= TIM_OPMode;
   \   00000072   0x8820             LDRH     R0,[R4, #+0]
   \   00000074   0x4328             ORRS     R0,R5,R0
   \   00000076   0x8020             STRH     R0,[R4, #+0]
    504          }
   \   00000078   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    505          
    506          /**
    507            * @brief  Sets the TIMx Clock Division value.
    508            * @param  TIMx: where x can be  2, 3, 4, 9, 10 or 11 to select the TIM peripheral.
    509            * @param  TIM_CKD: specifies the clock division value.
    510            *   This parameter can be one of the following value:
    511            *     @arg TIM_CKD_DIV1: TDTS = Tck_tim
    512            *     @arg TIM_CKD_DIV2: TDTS = 2*Tck_tim
    513            *     @arg TIM_CKD_DIV4: TDTS = 4*Tck_tim
    514            * @retval None
    515            */

   \                                 In section .text, align 2, keep-with-next
    516          void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
    517          {
   \                     TIM_SetClockDivision: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    518            /* Check the parameters */
    519            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   \   00000006   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000A   0xD014             BEQ.N    ??TIM_SetClockDivision_0
   \   0000000C   0x....             LDR.N    R0,??DataTable16  ;; 0x40000400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD011             BEQ.N    ??TIM_SetClockDivision_0
   \   00000012   0x....             LDR.N    R0,??DataTable16_1  ;; 0x40000800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD00E             BEQ.N    ??TIM_SetClockDivision_0
   \   00000018   0x....             LDR.N    R0,??DataTable16_4  ;; 0x40010800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD00B             BEQ.N    ??TIM_SetClockDivision_0
   \   0000001E   0x....             LDR.N    R0,??DataTable16_5  ;; 0x40010c00
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD008             BEQ.N    ??TIM_SetClockDivision_0
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x40011000
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD004             BEQ.N    ??TIM_SetClockDivision_0
   \   0000002C   0xF240 0x2107      MOVW     R1,#+519
   \   00000030   0x....             LDR.N    R0,??DataTable16_6
   \   00000032   0x.... 0x....      BL       assert_failed
    520            assert_param(IS_TIM_CKD_DIV(TIM_CKD));
   \                     ??TIM_SetClockDivision_0: (+1)
   \   00000036   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000038   0x2D00             CMP      R5,#+0
   \   0000003A   0xD00C             BEQ.N    ??TIM_SetClockDivision_1
   \   0000003C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000003E   0xF5B5 0x7F80      CMP      R5,#+256
   \   00000042   0xD008             BEQ.N    ??TIM_SetClockDivision_1
   \   00000044   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000046   0xF5B5 0x7F00      CMP      R5,#+512
   \   0000004A   0xD004             BEQ.N    ??TIM_SetClockDivision_1
   \   0000004C   0xF44F 0x7102      MOV      R1,#+520
   \   00000050   0x....             LDR.N    R0,??DataTable16_6
   \   00000052   0x.... 0x....      BL       assert_failed
    521            
    522            /* Reset the CKD Bits */
    523            TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_CKD);
   \                     ??TIM_SetClockDivision_1: (+1)
   \   00000056   0x8820             LDRH     R0,[R4, #+0]
   \   00000058   0xF64F 0x41FF      MOVW     R1,#+64767
   \   0000005C   0x4008             ANDS     R0,R1,R0
   \   0000005E   0x8020             STRH     R0,[R4, #+0]
    524            /* Set the CKD value */
    525            TIMx->CR1 |= TIM_CKD;
   \   00000060   0x8820             LDRH     R0,[R4, #+0]
   \   00000062   0x4328             ORRS     R0,R5,R0
   \   00000064   0x8020             STRH     R0,[R4, #+0]
    526          }
   \   00000066   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    527          
    528          /**
    529            * @brief  Enables or disables the specified TIM peripheral.
    530            * @param  TIMx: where x can be 2 to 11 to select the TIMx peripheral.
    531            * @param  NewState: new state of the TIMx peripheral.
    532            *         This parameter can be: ENABLE or DISABLE.
    533            * @retval None
    534            */

   \                                 In section .text, align 2, keep-with-next
    535          void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
    536          {
   \                     TIM_Cmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    537            /* Check the parameters */
    538            assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
   \   00000006   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000A   0xD01A             BEQ.N    ??TIM_Cmd_0
   \   0000000C   0x....             LDR.N    R0,??DataTable16  ;; 0x40000400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD017             BEQ.N    ??TIM_Cmd_0
   \   00000012   0x....             LDR.N    R0,??DataTable16_1  ;; 0x40000800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD014             BEQ.N    ??TIM_Cmd_0
   \   00000018   0x....             LDR.N    R0,??DataTable16_2  ;; 0x40001000
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD011             BEQ.N    ??TIM_Cmd_0
   \   0000001E   0x....             LDR.N    R0,??DataTable16_3  ;; 0x40001400
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD00E             BEQ.N    ??TIM_Cmd_0
   \   00000024   0x....             LDR.N    R0,??DataTable16_4  ;; 0x40010800
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD00B             BEQ.N    ??TIM_Cmd_0
   \   0000002A   0x....             LDR.N    R0,??DataTable16_5  ;; 0x40010c00
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD008             BEQ.N    ??TIM_Cmd_0
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x40011000
   \   00000034   0x4284             CMP      R4,R0
   \   00000036   0xD004             BEQ.N    ??TIM_Cmd_0
   \   00000038   0xF240 0x211A      MOVW     R1,#+538
   \   0000003C   0x....             LDR.N    R0,??DataTable16_6
   \   0000003E   0x.... 0x....      BL       assert_failed
    539            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??TIM_Cmd_0: (+1)
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0x2D00             CMP      R5,#+0
   \   00000046   0xD007             BEQ.N    ??TIM_Cmd_1
   \   00000048   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004A   0x2D01             CMP      R5,#+1
   \   0000004C   0xD004             BEQ.N    ??TIM_Cmd_1
   \   0000004E   0xF240 0x211B      MOVW     R1,#+539
   \   00000052   0x....             LDR.N    R0,??DataTable16_6
   \   00000054   0x.... 0x....      BL       assert_failed
    540            
    541            if (NewState != DISABLE)
   \                     ??TIM_Cmd_1: (+1)
   \   00000058   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005A   0x2D00             CMP      R5,#+0
   \   0000005C   0xD004             BEQ.N    ??TIM_Cmd_2
    542            {
    543              /* Enable the TIM Counter */
    544              TIMx->CR1 |= TIM_CR1_CEN;
   \   0000005E   0x8820             LDRH     R0,[R4, #+0]
   \   00000060   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000064   0x8020             STRH     R0,[R4, #+0]
   \   00000066   0xE004             B.N      ??TIM_Cmd_3
    545            }
    546            else
    547            {
    548              /* Disable the TIM Counter */
    549              TIMx->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN));
   \                     ??TIM_Cmd_2: (+1)
   \   00000068   0x8820             LDRH     R0,[R4, #+0]
   \   0000006A   0xF64F 0x71FE      MOVW     R1,#+65534
   \   0000006E   0x4008             ANDS     R0,R1,R0
   \   00000070   0x8020             STRH     R0,[R4, #+0]
    550            }
    551          }
   \                     ??TIM_Cmd_3: (+1)
   \   00000072   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    552          
    553          /**
    554            * @}
    555            */
    556          
    557          /** @defgroup TIM_Group2 Output Compare management functions
    558           *  @brief    Output Compare management functions 
    559           *
    560          @verbatim   
    561           ===============================================================================
    562                                  Output Compare management functions
    563           ===============================================================================  
    564             
    565                 ===================================================================      
    566                        TIM Driver: how to use it in Output Compare Mode
    567                 =================================================================== 
    568                 To use the Timer in Output Compare mode, the following steps are mandatory:
    569                 
    570                 1. Enable TIM clock using RCC_APBxPeriphClockCmd(RCC_APBxPeriph_TIMx, ENABLE) function
    571                 
    572                 2. Configure the TIM pins by configuring the corresponding GPIO pins
    573                 
    574                 2. Configure the Time base unit as described in the first part of this driver, if needed,
    575                    else the Timer will run with the default configuration:
    576                    - Autoreload value = 0xFFFF
    577                    - Prescaler value = 0x0000
    578                    - Counter mode = Up counting
    579                    - Clock Division = TIM_CKD_DIV1
    580                    
    581                 3. Fill the TIM_OCInitStruct with the desired parameters including:
    582                    - The TIM Output Compare mode: TIM_OCMode
    583                    - TIM Output State: TIM_OutputState
    584                    - TIM Pulse value: TIM_Pulse
    585                    - TIM Output Compare Polarity : TIM_OCPolarity
    586                 
    587                 4. Call TIM_OCxInit(TIMx, &TIM_OCInitStruct) to configure the desired channel with the 
    588                    corresponding configuration
    589                 
    590                 5. Call the TIM_Cmd(ENABLE) function to enable the TIM counter.
    591                 
    592                 Note1: All other functions can be used separately to modify, if needed,
    593                    a specific feature of the Timer. 
    594                    
    595                 Note2: In case of PWM mode, this function is mandatory:
    596                        TIM_OCxPreloadConfig(TIMx, TIM_OCPreload_ENABLE); 
    597                        
    598                 Note3: If the corresponding interrupt or DMA request are needed, the user should:
    599                        1. Enable the NVIC (or the DMA) to use the TIM interrupts (or DMA requests). 
    600                        2. Enable the corresponding interrupt (or DMA request) using the function 
    601                        TIM_ITConfig(TIMx, TIM_IT_CCx) (or TIM_DMA_Cmd(TIMx, TIM_DMA_CCx))   
    602          
    603          @endverbatim
    604            * @{
    605            */
    606          
    607          /**
    608            * @brief  Initializes the TIMx Channel1 according to the specified
    609            *         parameters in the TIM_OCInitStruct.
    610            * @param  TIMx: where x can be 2, 3, 4, 9, 10 or 11 to select the TIM peripheral.
    611            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    612            *         that contains the configuration information for the specified TIM 
    613            *         peripheral.
    614            * @retval None
    615            */

   \                                 In section .text, align 2, keep-with-next
    616          void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    617          {
   \                     TIM_OC1Init: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    618            uint16_t tmpccmrx = 0, tmpccer = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0x2700             MOVS     R7,#+0
    619             
    620            /* Check the parameters */
    621            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   \   0000000A   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000E   0xD013             BEQ.N    ??TIM_OC1Init_0
   \   00000010   0x....             LDR.N    R0,??DataTable16  ;; 0x40000400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD010             BEQ.N    ??TIM_OC1Init_0
   \   00000016   0x....             LDR.N    R0,??DataTable16_1  ;; 0x40000800
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD00D             BEQ.N    ??TIM_OC1Init_0
   \   0000001C   0x....             LDR.N    R0,??DataTable16_4  ;; 0x40010800
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD00A             BEQ.N    ??TIM_OC1Init_0
   \   00000022   0x....             LDR.N    R0,??DataTable16_5  ;; 0x40010c00
   \   00000024   0x4284             CMP      R4,R0
   \   00000026   0xD007             BEQ.N    ??TIM_OC1Init_0
   \   00000028   0x....             LDR.N    R0,??DataTable17  ;; 0x40011000
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD004             BEQ.N    ??TIM_OC1Init_0
   \   0000002E   0xF240 0x216D      MOVW     R1,#+621
   \   00000032   0x....             LDR.N    R0,??DataTable16_6
   \   00000034   0x.... 0x....      BL       assert_failed
    622            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
   \                     ??TIM_OC1Init_0: (+1)
   \   00000038   0x8828             LDRH     R0,[R5, #+0]
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD013             BEQ.N    ??TIM_OC1Init_1
   \   0000003E   0x8828             LDRH     R0,[R5, #+0]
   \   00000040   0x2810             CMP      R0,#+16
   \   00000042   0xD010             BEQ.N    ??TIM_OC1Init_1
   \   00000044   0x8828             LDRH     R0,[R5, #+0]
   \   00000046   0x2820             CMP      R0,#+32
   \   00000048   0xD00D             BEQ.N    ??TIM_OC1Init_1
   \   0000004A   0x8828             LDRH     R0,[R5, #+0]
   \   0000004C   0x2830             CMP      R0,#+48
   \   0000004E   0xD00A             BEQ.N    ??TIM_OC1Init_1
   \   00000050   0x8828             LDRH     R0,[R5, #+0]
   \   00000052   0x2860             CMP      R0,#+96
   \   00000054   0xD007             BEQ.N    ??TIM_OC1Init_1
   \   00000056   0x8828             LDRH     R0,[R5, #+0]
   \   00000058   0x2870             CMP      R0,#+112
   \   0000005A   0xD004             BEQ.N    ??TIM_OC1Init_1
   \   0000005C   0xF240 0x216E      MOVW     R1,#+622
   \   00000060   0x....             LDR.N    R0,??DataTable16_6
   \   00000062   0x.... 0x....      BL       assert_failed
    623            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
   \                     ??TIM_OC1Init_1: (+1)
   \   00000066   0x8868             LDRH     R0,[R5, #+2]
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD007             BEQ.N    ??TIM_OC1Init_2
   \   0000006C   0x8868             LDRH     R0,[R5, #+2]
   \   0000006E   0x2801             CMP      R0,#+1
   \   00000070   0xD004             BEQ.N    ??TIM_OC1Init_2
   \   00000072   0xF240 0x216F      MOVW     R1,#+623
   \   00000076   0x....             LDR.N    R0,??DataTable16_6
   \   00000078   0x.... 0x....      BL       assert_failed
    624            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
   \                     ??TIM_OC1Init_2: (+1)
   \   0000007C   0x88E8             LDRH     R0,[R5, #+6]
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD007             BEQ.N    ??TIM_OC1Init_3
   \   00000082   0x88E8             LDRH     R0,[R5, #+6]
   \   00000084   0x2802             CMP      R0,#+2
   \   00000086   0xD004             BEQ.N    ??TIM_OC1Init_3
   \   00000088   0xF44F 0x711C      MOV      R1,#+624
   \   0000008C   0x....             LDR.N    R0,??DataTable16_6
   \   0000008E   0x.... 0x....      BL       assert_failed
    625            /* Disable the Channel 1: Reset the CC1E Bit */
    626            TIMx->CCER &= (uint16_t)(~(uint16_t)TIM_CCER_CC1E);
   \                     ??TIM_OC1Init_3: (+1)
   \   00000092   0x8C20             LDRH     R0,[R4, #+32]
   \   00000094   0xF64F 0x71FE      MOVW     R1,#+65534
   \   00000098   0x4008             ANDS     R0,R1,R0
   \   0000009A   0x8420             STRH     R0,[R4, #+32]
    627            
    628            /* Get the TIMx CCER register value */
    629            tmpccer = TIMx->CCER;
   \   0000009C   0x8C20             LDRH     R0,[R4, #+32]
   \   0000009E   0x0007             MOVS     R7,R0
    630            
    631            /* Get the TIMx CCMR1 register value */
    632            tmpccmrx = TIMx->CCMR1;
   \   000000A0   0x8B20             LDRH     R0,[R4, #+24]
   \   000000A2   0x0006             MOVS     R6,R0
    633              
    634            /* Reset the Output Compare Mode Bits */
    635            tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC1M));
   \   000000A4   0xF64F 0x708F      MOVW     R0,#+65423
   \   000000A8   0x4006             ANDS     R6,R0,R6
    636            tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC1S));
   \   000000AA   0xF64F 0x70FC      MOVW     R0,#+65532
   \   000000AE   0x4006             ANDS     R6,R0,R6
    637            
    638            /* Select the Output Compare Mode */
    639            tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
   \   000000B0   0x8828             LDRH     R0,[R5, #+0]
   \   000000B2   0x4306             ORRS     R6,R0,R6
    640            
    641            /* Reset the Output Polarity level */
    642            tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1P));
   \   000000B4   0xF64F 0x70FD      MOVW     R0,#+65533
   \   000000B8   0x4007             ANDS     R7,R0,R7
    643            /* Set the Output Compare Polarity */
    644            tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
   \   000000BA   0x88E8             LDRH     R0,[R5, #+6]
   \   000000BC   0x4307             ORRS     R7,R0,R7
    645            
    646            /* Set the Output State */
    647            tmpccer |= TIM_OCInitStruct->TIM_OutputState;
   \   000000BE   0x8868             LDRH     R0,[R5, #+2]
   \   000000C0   0x4307             ORRS     R7,R0,R7
    648            
    649            /* Set the Capture Compare Register value */
    650            TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
   \   000000C2   0x88A8             LDRH     R0,[R5, #+4]
   \   000000C4   0x86A0             STRH     R0,[R4, #+52]
    651            
    652            /* Write to TIMx CCMR1 */
    653            TIMx->CCMR1 = tmpccmrx;
   \   000000C6   0x8326             STRH     R6,[R4, #+24]
    654            
    655            /* Write to TIMx CCER */
    656            TIMx->CCER = tmpccer;
   \   000000C8   0x8427             STRH     R7,[R4, #+32]
    657          }
   \   000000CA   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    658          
    659          /**
    660            * @brief  Initializes the TIMx Channel2 according to the specified
    661            *         parameters in the TIM_OCInitStruct.
    662            * @param  TIMx: where x can be 2, 3, 4 or 9 to select the TIM peripheral.
    663            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    664            *         that contains the configuration information for the specified TIM 
    665            *         peripheral.
    666            * @retval None
    667            */

   \                                 In section .text, align 2, keep-with-next
    668          void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    669          {
   \                     TIM_OC2Init: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    670            uint16_t tmpccmrx = 0, tmpccer = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0x2700             MOVS     R7,#+0
    671             
    672            /* Check the parameters */
    673            assert_param(IS_TIM_LIST2_PERIPH(TIMx)); 
   \   0000000A   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000E   0xD00D             BEQ.N    ??TIM_OC2Init_0
   \   00000010   0x....             LDR.N    R0,??DataTable16  ;; 0x40000400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD00A             BEQ.N    ??TIM_OC2Init_0
   \   00000016   0x....             LDR.N    R0,??DataTable16_1  ;; 0x40000800
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD007             BEQ.N    ??TIM_OC2Init_0
   \   0000001C   0x....             LDR.N    R0,??DataTable16_4  ;; 0x40010800
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD004             BEQ.N    ??TIM_OC2Init_0
   \   00000022   0xF240 0x21A1      MOVW     R1,#+673
   \   00000026   0x....             LDR.N    R0,??DataTable16_6
   \   00000028   0x.... 0x....      BL       assert_failed
    674            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
   \                     ??TIM_OC2Init_0: (+1)
   \   0000002C   0x8828             LDRH     R0,[R5, #+0]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD013             BEQ.N    ??TIM_OC2Init_1
   \   00000032   0x8828             LDRH     R0,[R5, #+0]
   \   00000034   0x2810             CMP      R0,#+16
   \   00000036   0xD010             BEQ.N    ??TIM_OC2Init_1
   \   00000038   0x8828             LDRH     R0,[R5, #+0]
   \   0000003A   0x2820             CMP      R0,#+32
   \   0000003C   0xD00D             BEQ.N    ??TIM_OC2Init_1
   \   0000003E   0x8828             LDRH     R0,[R5, #+0]
   \   00000040   0x2830             CMP      R0,#+48
   \   00000042   0xD00A             BEQ.N    ??TIM_OC2Init_1
   \   00000044   0x8828             LDRH     R0,[R5, #+0]
   \   00000046   0x2860             CMP      R0,#+96
   \   00000048   0xD007             BEQ.N    ??TIM_OC2Init_1
   \   0000004A   0x8828             LDRH     R0,[R5, #+0]
   \   0000004C   0x2870             CMP      R0,#+112
   \   0000004E   0xD004             BEQ.N    ??TIM_OC2Init_1
   \   00000050   0xF240 0x21A2      MOVW     R1,#+674
   \   00000054   0x....             LDR.N    R0,??DataTable16_6
   \   00000056   0x.... 0x....      BL       assert_failed
    675            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
   \                     ??TIM_OC2Init_1: (+1)
   \   0000005A   0x8868             LDRH     R0,[R5, #+2]
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD007             BEQ.N    ??TIM_OC2Init_2
   \   00000060   0x8868             LDRH     R0,[R5, #+2]
   \   00000062   0x2801             CMP      R0,#+1
   \   00000064   0xD004             BEQ.N    ??TIM_OC2Init_2
   \   00000066   0xF240 0x21A3      MOVW     R1,#+675
   \   0000006A   0x....             LDR.N    R0,??DataTable16_6
   \   0000006C   0x.... 0x....      BL       assert_failed
    676            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
   \                     ??TIM_OC2Init_2: (+1)
   \   00000070   0x88E8             LDRH     R0,[R5, #+6]
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD007             BEQ.N    ??TIM_OC2Init_3
   \   00000076   0x88E8             LDRH     R0,[R5, #+6]
   \   00000078   0x2802             CMP      R0,#+2
   \   0000007A   0xD004             BEQ.N    ??TIM_OC2Init_3
   \   0000007C   0xF44F 0x7129      MOV      R1,#+676
   \   00000080   0x....             LDR.N    R0,??DataTable16_6
   \   00000082   0x.... 0x....      BL       assert_failed
    677            /* Disable the Channel 2: Reset the CC2E Bit */
    678            TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC2E));
   \                     ??TIM_OC2Init_3: (+1)
   \   00000086   0x8C20             LDRH     R0,[R4, #+32]
   \   00000088   0xF64F 0x71EF      MOVW     R1,#+65519
   \   0000008C   0x4008             ANDS     R0,R1,R0
   \   0000008E   0x8420             STRH     R0,[R4, #+32]
    679            
    680            /* Get the TIMx CCER register value */  
    681            tmpccer = TIMx->CCER;
   \   00000090   0x8C20             LDRH     R0,[R4, #+32]
   \   00000092   0x0007             MOVS     R7,R0
    682            
    683            /* Get the TIMx CCMR1 register value */
    684            tmpccmrx = TIMx->CCMR1;
   \   00000094   0x8B20             LDRH     R0,[R4, #+24]
   \   00000096   0x0006             MOVS     R6,R0
    685              
    686            /* Reset the Output Compare Mode Bits */
    687            tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC2M));
   \   00000098   0xF648 0x70FF      MOVW     R0,#+36863
   \   0000009C   0x4006             ANDS     R6,R0,R6
    688            
    689            /* Select the Output Compare Mode */
    690            tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
   \   0000009E   0x8828             LDRH     R0,[R5, #+0]
   \   000000A0   0xEA56 0x2600      ORRS     R6,R6,R0, LSL #+8
    691            
    692            /* Reset the Output Polarity level */
    693            tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2P));
   \   000000A4   0xF64F 0x70DF      MOVW     R0,#+65503
   \   000000A8   0x4007             ANDS     R7,R0,R7
    694            /* Set the Output Compare Polarity */
    695            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
   \   000000AA   0x88E8             LDRH     R0,[R5, #+6]
   \   000000AC   0xEA57 0x1700      ORRS     R7,R7,R0, LSL #+4
    696            
    697            /* Set the Output State */
    698            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
   \   000000B0   0x8868             LDRH     R0,[R5, #+2]
   \   000000B2   0xEA57 0x1700      ORRS     R7,R7,R0, LSL #+4
    699            
    700            /* Set the Capture Compare Register value */
    701            TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
   \   000000B6   0x88A8             LDRH     R0,[R5, #+4]
   \   000000B8   0x8720             STRH     R0,[R4, #+56]
    702              
    703            /* Write to TIMx CCMR1 */
    704            TIMx->CCMR1 = tmpccmrx;
   \   000000BA   0x8326             STRH     R6,[R4, #+24]
    705            
    706            /* Write to TIMx CCER */
    707            TIMx->CCER = tmpccer;
   \   000000BC   0x8427             STRH     R7,[R4, #+32]
    708          }
   \   000000BE   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    709          
    710          /**
    711            * @brief  Initializes the TIMx Channel3 according to the specified
    712            *         parameters in the TIM_OCInitStruct.
    713            * @param  TIMx: where x can be  2, 3 or 4 to select the TIM peripheral.
    714            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    715            *         that contains the configuration information for the specified TIM 
    716            *         peripheral.
    717            * @retval None
    718            */

   \                                 In section .text, align 2, keep-with-next
    719          void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    720          {
   \                     TIM_OC3Init: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    721            uint16_t tmpccmrx = 0, tmpccer = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0x2700             MOVS     R7,#+0
    722             
    723            /* Check the parameters */
    724            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   \   0000000A   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000E   0xD00A             BEQ.N    ??TIM_OC3Init_0
   \   00000010   0x....             LDR.N    R0,??DataTable16  ;; 0x40000400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD007             BEQ.N    ??TIM_OC3Init_0
   \   00000016   0x....             LDR.N    R0,??DataTable16_1  ;; 0x40000800
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD004             BEQ.N    ??TIM_OC3Init_0
   \   0000001C   0xF44F 0x7135      MOV      R1,#+724
   \   00000020   0x....             LDR.N    R0,??DataTable16_6
   \   00000022   0x.... 0x....      BL       assert_failed
    725            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
   \                     ??TIM_OC3Init_0: (+1)
   \   00000026   0x8828             LDRH     R0,[R5, #+0]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD013             BEQ.N    ??TIM_OC3Init_1
   \   0000002C   0x8828             LDRH     R0,[R5, #+0]
   \   0000002E   0x2810             CMP      R0,#+16
   \   00000030   0xD010             BEQ.N    ??TIM_OC3Init_1
   \   00000032   0x8828             LDRH     R0,[R5, #+0]
   \   00000034   0x2820             CMP      R0,#+32
   \   00000036   0xD00D             BEQ.N    ??TIM_OC3Init_1
   \   00000038   0x8828             LDRH     R0,[R5, #+0]
   \   0000003A   0x2830             CMP      R0,#+48
   \   0000003C   0xD00A             BEQ.N    ??TIM_OC3Init_1
   \   0000003E   0x8828             LDRH     R0,[R5, #+0]
   \   00000040   0x2860             CMP      R0,#+96
   \   00000042   0xD007             BEQ.N    ??TIM_OC3Init_1
   \   00000044   0x8828             LDRH     R0,[R5, #+0]
   \   00000046   0x2870             CMP      R0,#+112
   \   00000048   0xD004             BEQ.N    ??TIM_OC3Init_1
   \   0000004A   0xF240 0x21D5      MOVW     R1,#+725
   \   0000004E   0x....             LDR.N    R0,??DataTable16_6
   \   00000050   0x.... 0x....      BL       assert_failed
    726            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
   \                     ??TIM_OC3Init_1: (+1)
   \   00000054   0x8868             LDRH     R0,[R5, #+2]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD007             BEQ.N    ??TIM_OC3Init_2
   \   0000005A   0x8868             LDRH     R0,[R5, #+2]
   \   0000005C   0x2801             CMP      R0,#+1
   \   0000005E   0xD004             BEQ.N    ??TIM_OC3Init_2
   \   00000060   0xF240 0x21D6      MOVW     R1,#+726
   \   00000064   0x....             LDR.N    R0,??DataTable16_6
   \   00000066   0x.... 0x....      BL       assert_failed
    727            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
   \                     ??TIM_OC3Init_2: (+1)
   \   0000006A   0x88E8             LDRH     R0,[R5, #+6]
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD007             BEQ.N    ??TIM_OC3Init_3
   \   00000070   0x88E8             LDRH     R0,[R5, #+6]
   \   00000072   0x2802             CMP      R0,#+2
   \   00000074   0xD004             BEQ.N    ??TIM_OC3Init_3
   \   00000076   0xF240 0x21D7      MOVW     R1,#+727
   \   0000007A   0x....             LDR.N    R0,??DataTable16_6
   \   0000007C   0x.... 0x....      BL       assert_failed
    728          
    729            /* Disable the Channel 2: Reset the CC2E Bit */
    730            TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC3E));
   \                     ??TIM_OC3Init_3: (+1)
   \   00000080   0x8C20             LDRH     R0,[R4, #+32]
   \   00000082   0xF64F 0x61FF      MOVW     R1,#+65279
   \   00000086   0x4008             ANDS     R0,R1,R0
   \   00000088   0x8420             STRH     R0,[R4, #+32]
    731            
    732            /* Get the TIMx CCER register value */
    733            tmpccer = TIMx->CCER;
   \   0000008A   0x8C20             LDRH     R0,[R4, #+32]
   \   0000008C   0x0007             MOVS     R7,R0
    734            
    735            /* Get the TIMx CCMR2 register value */
    736            tmpccmrx = TIMx->CCMR2;
   \   0000008E   0x8BA0             LDRH     R0,[R4, #+28]
   \   00000090   0x0006             MOVS     R6,R0
    737              
    738            /* Reset the Output Compare Mode Bits */
    739            tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC3M));
   \   00000092   0xF64F 0x708F      MOVW     R0,#+65423
   \   00000096   0x4006             ANDS     R6,R0,R6
    740            
    741            /* Select the Output Compare Mode */
    742            tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
   \   00000098   0x8828             LDRH     R0,[R5, #+0]
   \   0000009A   0x4306             ORRS     R6,R0,R6
    743            
    744            /* Reset the Output Polarity level */
    745            tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3P));
   \   0000009C   0xF64F 0x50FF      MOVW     R0,#+65023
   \   000000A0   0x4007             ANDS     R7,R0,R7
    746            /* Set the Output Compare Polarity */
    747            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
   \   000000A2   0x88E8             LDRH     R0,[R5, #+6]
   \   000000A4   0xEA57 0x2700      ORRS     R7,R7,R0, LSL #+8
    748            
    749            /* Set the Output State */
    750            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
   \   000000A8   0x8868             LDRH     R0,[R5, #+2]
   \   000000AA   0xEA57 0x2700      ORRS     R7,R7,R0, LSL #+8
    751            
    752            /* Set the Capture Compare Register value */
    753            TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
   \   000000AE   0x88A8             LDRH     R0,[R5, #+4]
   \   000000B0   0x87A0             STRH     R0,[R4, #+60]
    754            
    755            /* Write to TIMx CCMR2 */
    756            TIMx->CCMR2 = tmpccmrx;
   \   000000B2   0x83A6             STRH     R6,[R4, #+28]
    757            
    758            /* Write to TIMx CCER */
    759            TIMx->CCER = tmpccer;
   \   000000B4   0x8427             STRH     R7,[R4, #+32]
    760          }
   \   000000B6   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    761          
    762          /**
    763            * @brief  Initializes the TIMx Channel4 according to the specified
    764            *         parameters in the TIM_OCInitStruct.
    765            * @param  TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    766            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    767            *         that contains the configuration information for the specified TIM 
    768            *         peripheral.
    769            * @retval None
    770            */

   \                                 In section .text, align 2, keep-with-next
    771          void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    772          {
   \                     TIM_OC4Init: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    773            uint16_t tmpccmrx = 0, tmpccer = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0x2700             MOVS     R7,#+0
    774             
    775            /* Check the parameters */
    776            assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
   \   0000000A   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000E   0xD00D             BEQ.N    ??TIM_OC4Init_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable43  ;; 0x40000400
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD009             BEQ.N    ??TIM_OC4Init_0
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable43_1  ;; 0x40000800
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD005             BEQ.N    ??TIM_OC4Init_0
   \   00000020   0xF44F 0x7142      MOV      R1,#+776
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable49
   \   00000028   0x.... 0x....      BL       assert_failed
    777            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
   \                     ??TIM_OC4Init_0: (+1)
   \   0000002C   0x8828             LDRH     R0,[R5, #+0]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD014             BEQ.N    ??TIM_OC4Init_1
   \   00000032   0x8828             LDRH     R0,[R5, #+0]
   \   00000034   0x2810             CMP      R0,#+16
   \   00000036   0xD011             BEQ.N    ??TIM_OC4Init_1
   \   00000038   0x8828             LDRH     R0,[R5, #+0]
   \   0000003A   0x2820             CMP      R0,#+32
   \   0000003C   0xD00E             BEQ.N    ??TIM_OC4Init_1
   \   0000003E   0x8828             LDRH     R0,[R5, #+0]
   \   00000040   0x2830             CMP      R0,#+48
   \   00000042   0xD00B             BEQ.N    ??TIM_OC4Init_1
   \   00000044   0x8828             LDRH     R0,[R5, #+0]
   \   00000046   0x2860             CMP      R0,#+96
   \   00000048   0xD008             BEQ.N    ??TIM_OC4Init_1
   \   0000004A   0x8828             LDRH     R0,[R5, #+0]
   \   0000004C   0x2870             CMP      R0,#+112
   \   0000004E   0xD005             BEQ.N    ??TIM_OC4Init_1
   \   00000050   0xF240 0x3109      MOVW     R1,#+777
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable49
   \   00000058   0x.... 0x....      BL       assert_failed
    778            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
   \                     ??TIM_OC4Init_1: (+1)
   \   0000005C   0x8868             LDRH     R0,[R5, #+2]
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD008             BEQ.N    ??TIM_OC4Init_2
   \   00000062   0x8868             LDRH     R0,[R5, #+2]
   \   00000064   0x2801             CMP      R0,#+1
   \   00000066   0xD005             BEQ.N    ??TIM_OC4Init_2
   \   00000068   0xF240 0x310A      MOVW     R1,#+778
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable49
   \   00000070   0x.... 0x....      BL       assert_failed
    779            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
   \                     ??TIM_OC4Init_2: (+1)
   \   00000074   0x88E8             LDRH     R0,[R5, #+6]
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD008             BEQ.N    ??TIM_OC4Init_3
   \   0000007A   0x88E8             LDRH     R0,[R5, #+6]
   \   0000007C   0x2802             CMP      R0,#+2
   \   0000007E   0xD005             BEQ.N    ??TIM_OC4Init_3
   \   00000080   0xF240 0x310B      MOVW     R1,#+779
   \   00000084   0x.... 0x....      LDR.W    R0,??DataTable49
   \   00000088   0x.... 0x....      BL       assert_failed
    780          
    781            /* Disable the Channel 2: Reset the CC4E Bit */
    782            TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC4E));
   \                     ??TIM_OC4Init_3: (+1)
   \   0000008C   0x8C20             LDRH     R0,[R4, #+32]
   \   0000008E   0xF64E 0x71FF      MOVW     R1,#+61439
   \   00000092   0x4008             ANDS     R0,R1,R0
   \   00000094   0x8420             STRH     R0,[R4, #+32]
    783            
    784            /* Get the TIMx CCER register value */
    785            tmpccer = TIMx->CCER;
   \   00000096   0x8C20             LDRH     R0,[R4, #+32]
   \   00000098   0x0007             MOVS     R7,R0
    786            
    787            /* Get the TIMx CCMR2 register value */
    788            tmpccmrx = TIMx->CCMR2;
   \   0000009A   0x8BA0             LDRH     R0,[R4, #+28]
   \   0000009C   0x0006             MOVS     R6,R0
    789              
    790            /* Reset the Output Compare Mode Bits */
    791            tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC4M));
   \   0000009E   0xF648 0x70FF      MOVW     R0,#+36863
   \   000000A2   0x4006             ANDS     R6,R0,R6
    792            
    793            /* Select the Output Compare Mode */
    794            tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
   \   000000A4   0x8828             LDRH     R0,[R5, #+0]
   \   000000A6   0xEA56 0x2600      ORRS     R6,R6,R0, LSL #+8
    795            
    796            /* Reset the Output Polarity level */
    797            tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC4P));
   \   000000AA   0xF64D 0x70FF      MOVW     R0,#+57343
   \   000000AE   0x4007             ANDS     R7,R0,R7
    798            /* Set the Output Compare Polarity */
    799            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
   \   000000B0   0x88E8             LDRH     R0,[R5, #+6]
   \   000000B2   0xEA57 0x3700      ORRS     R7,R7,R0, LSL #+12
    800            
    801            /* Set the Output State */
    802            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
   \   000000B6   0x8868             LDRH     R0,[R5, #+2]
   \   000000B8   0xEA57 0x3700      ORRS     R7,R7,R0, LSL #+12
    803            
    804            /* Set the Capture Compare Register value */
    805            TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
   \   000000BC   0x88A8             LDRH     R0,[R5, #+4]
   \   000000BE   0xF8A4 0x0040      STRH     R0,[R4, #+64]
    806            
    807            /* Write to TIMx CCMR2 */  
    808            TIMx->CCMR2 = tmpccmrx;
   \   000000C2   0x83A6             STRH     R6,[R4, #+28]
    809            
    810            /* Write to TIMx CCER */
    811            TIMx->CCER = tmpccer;
   \   000000C4   0x8427             STRH     R7,[R4, #+32]
    812          }
   \   000000C6   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    813          
    814          /**
    815            * @brief  Fills each TIM_OCInitStruct member with its default value.
    816            * @param  TIM_OCInitStruct : pointer to a TIM_OCInitTypeDef structure which will
    817            *         be initialized.
    818            * @retval None
    819            */

   \                                 In section .text, align 2, keep-with-next
    820          void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
    821          {
    822            /* Set the default configuration */
    823            TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
   \                     TIM_OCStructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x8001             STRH     R1,[R0, #+0]
    824            TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x8041             STRH     R1,[R0, #+2]
    825            TIM_OCInitStruct->TIM_Pulse = 0x0000;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x8081             STRH     R1,[R0, #+4]
    826            TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x80C1             STRH     R1,[R0, #+6]
    827          }
   \   00000010   0x4770             BX       LR               ;; return
    828          
    829          /**
    830            * @brief  Selects the TIM Output Compare Mode.
    831            * @note   This function disables the selected channel before changing the Output
    832            *         Compare Mode.
    833            *         User has to enable this channel using TIM_CCxCmd and TIM_CCxNCmd functions.
    834            * @param  TIMx: where x can be 2, 3, 4, 9, 10 or 11 to select the TIM peripheral.
    835            * @param  TIM_Channel: specifies the TIM Channel
    836            *   This parameter can be one of the following values:
    837            *     @arg TIM_Channel_1: TIM Channel 1
    838            *     @arg TIM_Channel_2: TIM Channel 2
    839            *     @arg TIM_Channel_3: TIM Channel 3
    840            *     @arg TIM_Channel_4: TIM Channel 4
    841            * @param  TIM_OCMode: specifies the TIM Output Compare Mode.
    842            *   This parameter can be one of the following values:
    843            *     @arg TIM_OCMode_Timing
    844            *     @arg TIM_OCMode_Active
    845            *     @arg TIM_OCMode_Toggle
    846            *     @arg TIM_OCMode_PWM1
    847            *     @arg TIM_OCMode_PWM2
    848            *     @arg TIM_ForcedAction_Active
    849            *     @arg TIM_ForcedAction_InActive
    850            * @retval None
    851            */

   \                                 In section .text, align 2, keep-with-next
    852          void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
    853          {
   \                     TIM_SelectOCxM: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    854            uint32_t tmp = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
    855            uint16_t tmp1 = 0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
    856          
    857            /* Check the parameters */
    858            assert_param(IS_TIM_LIST1_PERIPH(TIMx));  
   \   00000010   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   00000014   0xD019             BEQ.N    ??TIM_SelectOCxM_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable43  ;; 0x40000400
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD015             BEQ.N    ??TIM_SelectOCxM_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable43_1  ;; 0x40000800
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD011             BEQ.N    ??TIM_SelectOCxM_0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable44  ;; 0x40010800
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD00D             BEQ.N    ??TIM_SelectOCxM_0
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable44_1  ;; 0x40010c00
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD009             BEQ.N    ??TIM_SelectOCxM_0
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable44_2  ;; 0x40011000
   \   0000003A   0x4284             CMP      R4,R0
   \   0000003C   0xD005             BEQ.N    ??TIM_SelectOCxM_0
   \   0000003E   0xF240 0x315A      MOVW     R1,#+858
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable49
   \   00000046   0x.... 0x....      BL       assert_failed
    859            assert_param(IS_TIM_OCM(TIM_OCMode));
   \                     ??TIM_SelectOCxM_0: (+1)
   \   0000004A   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000004C   0x2E00             CMP      R6,#+0
   \   0000004E   0xD01A             BEQ.N    ??TIM_SelectOCxM_1
   \   00000050   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000052   0x2E10             CMP      R6,#+16
   \   00000054   0xD017             BEQ.N    ??TIM_SelectOCxM_1
   \   00000056   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000058   0x2E20             CMP      R6,#+32
   \   0000005A   0xD014             BEQ.N    ??TIM_SelectOCxM_1
   \   0000005C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000005E   0x2E30             CMP      R6,#+48
   \   00000060   0xD011             BEQ.N    ??TIM_SelectOCxM_1
   \   00000062   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000064   0x2E60             CMP      R6,#+96
   \   00000066   0xD00E             BEQ.N    ??TIM_SelectOCxM_1
   \   00000068   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000006A   0x2E70             CMP      R6,#+112
   \   0000006C   0xD00B             BEQ.N    ??TIM_SelectOCxM_1
   \   0000006E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000070   0x2E50             CMP      R6,#+80
   \   00000072   0xD008             BEQ.N    ??TIM_SelectOCxM_1
   \   00000074   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000076   0x2E40             CMP      R6,#+64
   \   00000078   0xD005             BEQ.N    ??TIM_SelectOCxM_1
   \   0000007A   0xF240 0x315B      MOVW     R1,#+859
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable49
   \   00000082   0x.... 0x....      BL       assert_failed
    860            
    861            tmp = (uint32_t) TIMx;
   \                     ??TIM_SelectOCxM_1: (+1)
   \   00000086   0x0027             MOVS     R7,R4
    862            tmp += CCMR_OFFSET;
   \   00000088   0x3718             ADDS     R7,R7,#+24
    863          
    864            tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0x40A8             LSLS     R0,R0,R5
   \   0000008E   0x4680             MOV      R8,R0
    865          
    866            /* Disable the Channel: Reset the CCxE Bit */
    867            TIMx->CCER &= (uint16_t) ~tmp1;
   \   00000090   0x8C20             LDRH     R0,[R4, #+32]
   \   00000092   0xEA30 0x0008      BICS     R0,R0,R8
   \   00000096   0x8420             STRH     R0,[R4, #+32]
    868          
    869            if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
   \   00000098   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000009A   0x2D00             CMP      R5,#+0
   \   0000009C   0xD002             BEQ.N    ??TIM_SelectOCxM_2
   \   0000009E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000A0   0x2D08             CMP      R5,#+8
   \   000000A2   0xD10C             BNE.N    ??TIM_SelectOCxM_3
    870            {
    871              tmp += (TIM_Channel>>1);
   \                     ??TIM_SelectOCxM_2: (+1)
   \   000000A4   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000A6   0x0868             LSRS     R0,R5,#+1
   \   000000A8   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000AA   0x19C7             ADDS     R7,R0,R7
    872          
    873              /* Reset the OCxM bits in the CCMRx register */
    874              *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC1M);
   \   000000AC   0x6838             LDR      R0,[R7, #+0]
   \   000000AE   0xF030 0x0070      BICS     R0,R0,#0x70
   \   000000B2   0x6038             STR      R0,[R7, #+0]
    875             
    876              /* Configure the OCxM bits in the CCMRx register */
    877              *(__IO uint32_t *) tmp |= TIM_OCMode;
   \   000000B4   0x6838             LDR      R0,[R7, #+0]
   \   000000B6   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000B8   0x4330             ORRS     R0,R6,R0
   \   000000BA   0x6038             STR      R0,[R7, #+0]
   \   000000BC   0xE00D             B.N      ??TIM_SelectOCxM_4
    878            }
    879            else
    880            {
    881              tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
   \                     ??TIM_SelectOCxM_3: (+1)
   \   000000BE   0x1F28             SUBS     R0,R5,#+4
   \   000000C0   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000C2   0x0840             LSRS     R0,R0,#+1
   \   000000C4   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000C6   0x19C7             ADDS     R7,R0,R7
    882          
    883              /* Reset the OCxM bits in the CCMRx register */
    884              *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC2M);
   \   000000C8   0x6838             LDR      R0,[R7, #+0]
   \   000000CA   0xF430 0x40E0      BICS     R0,R0,#0x7000
   \   000000CE   0x6038             STR      R0,[R7, #+0]
    885              
    886              /* Configure the OCxM bits in the CCMRx register */
    887              *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
   \   000000D0   0x6838             LDR      R0,[R7, #+0]
   \   000000D2   0x0231             LSLS     R1,R6,#+8
   \   000000D4   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000D6   0x4308             ORRS     R0,R1,R0
   \   000000D8   0x6038             STR      R0,[R7, #+0]
    888            }
    889          }
   \                     ??TIM_SelectOCxM_4: (+1)
   \   000000DA   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    890          
    891          /**
    892            * @brief  Sets the TIMx Capture Compare1 Register value
    893            * @param  TIMx: where x can be 2, 3, 4, 9, 10 or 11 to select the TIM peripheral.
    894            * @param  Compare1: specifies the Capture Compare1 register new value.
    895            * @retval None
    896          
    897            */

   \                                 In section .text, align 2, keep-with-next
    898          void TIM_SetCompare1(TIM_TypeDef* TIMx, uint32_t Compare1)
    899          {
   \                     TIM_SetCompare1: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    900            /* Check the parameters */
    901            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   \   00000006   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000A   0xD019             BEQ.N    ??TIM_SetCompare1_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable43  ;; 0x40000400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD015             BEQ.N    ??TIM_SetCompare1_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable43_1  ;; 0x40000800
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD011             BEQ.N    ??TIM_SetCompare1_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable44  ;; 0x40010800
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD00D             BEQ.N    ??TIM_SetCompare1_0
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable44_1  ;; 0x40010c00
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD009             BEQ.N    ??TIM_SetCompare1_0
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable44_2  ;; 0x40011000
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD005             BEQ.N    ??TIM_SetCompare1_0
   \   00000034   0xF240 0x3185      MOVW     R1,#+901
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable49
   \   0000003C   0x.... 0x....      BL       assert_failed
    902            
    903            /* Set the Capture Compare1 Register value */
    904            TIMx->CCR1 = Compare1;
   \                     ??TIM_SetCompare1_0: (+1)
   \   00000040   0x86A5             STRH     R5,[R4, #+52]
    905          }
   \   00000042   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    906          
    907          /**
    908            * @brief  Sets the TIMx Capture Compare2 Register value
    909            * @param  TIMx: where x can be 2, 3, 4 or 9 to select the TIM peripheral.
    910            * @param  Compare2: specifies the Capture Compare2 register new value.
    911            * @retval None
    912          
    913            */

   \                                 In section .text, align 2, keep-with-next
    914          void TIM_SetCompare2(TIM_TypeDef* TIMx, uint32_t Compare2)
    915          {
   \                     TIM_SetCompare2: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    916            /* Check the parameters */
    917            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   \   00000006   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000A   0xD011             BEQ.N    ??TIM_SetCompare2_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable43  ;; 0x40000400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD00D             BEQ.N    ??TIM_SetCompare2_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable43_1  ;; 0x40000800
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD009             BEQ.N    ??TIM_SetCompare2_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable44  ;; 0x40010800
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD005             BEQ.N    ??TIM_SetCompare2_0
   \   00000024   0xF240 0x3195      MOVW     R1,#+917
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable49
   \   0000002C   0x.... 0x....      BL       assert_failed
    918            
    919            /* Set the Capture Compare2 Register value */
    920            TIMx->CCR2 = Compare2;
   \                     ??TIM_SetCompare2_0: (+1)
   \   00000030   0x8725             STRH     R5,[R4, #+56]
    921          }
   \   00000032   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    922          
    923          /**
    924            * @brief  Sets the TIMx Capture Compare3 Register value
    925            * @param  TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    926            * @param  Compare3: specifies the Capture Compare3 register new value.
    927            * @retval None
    928          
    929            */

   \                                 In section .text, align 2, keep-with-next
    930          void TIM_SetCompare3(TIM_TypeDef* TIMx, uint32_t Compare3)
    931          {
   \                     TIM_SetCompare3: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    932            /* Check the parameters */
    933            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   \   00000006   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000A   0xD00D             BEQ.N    ??TIM_SetCompare3_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable43  ;; 0x40000400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD009             BEQ.N    ??TIM_SetCompare3_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable43_1  ;; 0x40000800
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD005             BEQ.N    ??TIM_SetCompare3_0
   \   0000001C   0xF240 0x31A5      MOVW     R1,#+933
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable49
   \   00000024   0x.... 0x....      BL       assert_failed
    934            
    935            /* Set the Capture Compare3 Register value */
    936            TIMx->CCR3 = Compare3;
   \                     ??TIM_SetCompare3_0: (+1)
   \   00000028   0x87A5             STRH     R5,[R4, #+60]
    937          }
   \   0000002A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    938          
    939          /**
    940            * @brief  Sets the TIMx Capture Compare4 Register value
    941            * @param  TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    942            * @param  Compare4: specifies the Capture Compare4 register new value.
    943            * @retval None
    944          
    945            */

   \                                 In section .text, align 2, keep-with-next
    946          void TIM_SetCompare4(TIM_TypeDef* TIMx, uint32_t Compare4)
    947          {
   \                     TIM_SetCompare4: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    948            /* Check the parameters */
    949            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   \   00000006   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000A   0xD00D             BEQ.N    ??TIM_SetCompare4_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable43  ;; 0x40000400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD009             BEQ.N    ??TIM_SetCompare4_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable43_1  ;; 0x40000800
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD005             BEQ.N    ??TIM_SetCompare4_0
   \   0000001C   0xF240 0x31B5      MOVW     R1,#+949
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable49
   \   00000024   0x.... 0x....      BL       assert_failed
    950            
    951            /* Set the Capture Compare4 Register value */
    952            TIMx->CCR4 = Compare4;
   \                     ??TIM_SetCompare4_0: (+1)
   \   00000028   0xF8A4 0x5040      STRH     R5,[R4, #+64]
    953          }
   \   0000002C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    954          
    955          /**
    956            * @brief  Forces the TIMx output 1 waveform to active or inactive level.
    957            * @param  TIMx: where x can be 2, 3, 4, 9, 10 or 11 to select the TIM peripheral.
    958            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
    959            *   This parameter can be one of the following values:
    960            *     @arg TIM_ForcedAction_Active: Force active level on OC1REF
    961            *     @arg TIM_ForcedAction_InActive: Force inactive level on OC1REF.
    962            * @retval None
    963            */

   \                                 In section .text, align 2, keep-with-next
    964          void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
    965          {
   \                     TIM_ForcedOC1Config: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    966            uint16_t tmpccmr1 = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    967            /* Check the parameters */
    968            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   \   00000008   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000C   0xD019             BEQ.N    ??TIM_ForcedOC1Config_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable43  ;; 0x40000400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD015             BEQ.N    ??TIM_ForcedOC1Config_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable43_1  ;; 0x40000800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD011             BEQ.N    ??TIM_ForcedOC1Config_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable44  ;; 0x40010800
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD00D             BEQ.N    ??TIM_ForcedOC1Config_0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable44_1  ;; 0x40010c00
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD009             BEQ.N    ??TIM_ForcedOC1Config_0
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable44_2  ;; 0x40011000
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD005             BEQ.N    ??TIM_ForcedOC1Config_0
   \   00000036   0xF44F 0x7172      MOV      R1,#+968
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable49
   \   0000003E   0x.... 0x....      BL       assert_failed
    969            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   \                     ??TIM_ForcedOC1Config_0: (+1)
   \   00000042   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000044   0x2D50             CMP      R5,#+80
   \   00000046   0xD008             BEQ.N    ??TIM_ForcedOC1Config_1
   \   00000048   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004A   0x2D40             CMP      R5,#+64
   \   0000004C   0xD005             BEQ.N    ??TIM_ForcedOC1Config_1
   \   0000004E   0xF240 0x31C9      MOVW     R1,#+969
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable49
   \   00000056   0x.... 0x....      BL       assert_failed
    970            tmpccmr1 = TIMx->CCMR1;
   \                     ??TIM_ForcedOC1Config_1: (+1)
   \   0000005A   0x8B20             LDRH     R0,[R4, #+24]
   \   0000005C   0x0006             MOVS     R6,R0
    971            /* Reset the OC1M Bits */
    972            tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1M);
   \   0000005E   0xF64F 0x708F      MOVW     R0,#+65423
   \   00000062   0x4006             ANDS     R6,R0,R6
    973            /* Configure The Forced output Mode */
    974            tmpccmr1 |= TIM_ForcedAction;
   \   00000064   0x432E             ORRS     R6,R5,R6
    975            /* Write to TIMx CCMR1 register */
    976            TIMx->CCMR1 = tmpccmr1;
   \   00000066   0x8326             STRH     R6,[R4, #+24]
    977          }
   \   00000068   0xBD70             POP      {R4-R6,PC}       ;; return
    978           
    979          /**
    980            * @brief  Forces the TIMx output 2 waveform to active or inactive level.
    981            * @param  TIMx: where x can be 2, 3, 4 or 9 to select the TIM 
    982            *   peripheral.
    983            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
    984            *   This parameter can be one of the following values:
    985            *     @arg TIM_ForcedAction_Active: Force active level on OC2REF
    986            *     @arg TIM_ForcedAction_InActive: Force inactive level on OC2REF.
    987            * @retval None
    988            */

   \                                 In section .text, align 2, keep-with-next
    989          void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
    990          {
   \                     TIM_ForcedOC2Config: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    991            uint16_t tmpccmr1 = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    992            
    993            /* Check the parameters */
    994            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   \   00000008   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000C   0xD011             BEQ.N    ??TIM_ForcedOC2Config_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable43  ;; 0x40000400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD00D             BEQ.N    ??TIM_ForcedOC2Config_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable43_1  ;; 0x40000800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD009             BEQ.N    ??TIM_ForcedOC2Config_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable44  ;; 0x40010800
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD005             BEQ.N    ??TIM_ForcedOC2Config_0
   \   00000026   0xF240 0x31E2      MOVW     R1,#+994
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable49
   \   0000002E   0x.... 0x....      BL       assert_failed
    995            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   \                     ??TIM_ForcedOC2Config_0: (+1)
   \   00000032   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000034   0x2D50             CMP      R5,#+80
   \   00000036   0xD008             BEQ.N    ??TIM_ForcedOC2Config_1
   \   00000038   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000003A   0x2D40             CMP      R5,#+64
   \   0000003C   0xD005             BEQ.N    ??TIM_ForcedOC2Config_1
   \   0000003E   0xF240 0x31E3      MOVW     R1,#+995
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable49
   \   00000046   0x.... 0x....      BL       assert_failed
    996            
    997            tmpccmr1 = TIMx->CCMR1;
   \                     ??TIM_ForcedOC2Config_1: (+1)
   \   0000004A   0x8B20             LDRH     R0,[R4, #+24]
   \   0000004C   0x0006             MOVS     R6,R0
    998            /* Reset the OC2M Bits */
    999            tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2M);
   \   0000004E   0xF648 0x70FF      MOVW     R0,#+36863
   \   00000052   0x4006             ANDS     R6,R0,R6
   1000            /* Configure The Forced output Mode */
   1001            tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
   \   00000054   0xEA56 0x2605      ORRS     R6,R6,R5, LSL #+8
   1002            /* Write to TIMx CCMR1 register */
   1003            TIMx->CCMR1 = tmpccmr1;
   \   00000058   0x8326             STRH     R6,[R4, #+24]
   1004          }
   \   0000005A   0xBD70             POP      {R4-R6,PC}       ;; return
   1005          
   1006          /**
   1007            * @brief  Forces the TIMx output 3 waveform to active or inactive level.
   1008            * @param  TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1009            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1010            *   This parameter can be one of the following values:
   1011            *     @arg TIM_ForcedAction_Active: Force active level on OC3REF
   1012            *     @arg TIM_ForcedAction_InActive: Force inactive level on OC3REF.
   1013            * @retval None
   1014            */

   \                                 In section .text, align 2, keep-with-next
   1015          void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
   1016          {
   \                     TIM_ForcedOC3Config: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1017            uint16_t tmpccmr2 = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1018            
   1019            /* Check the parameters */
   1020            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   \   00000008   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000C   0xD00D             BEQ.N    ??TIM_ForcedOC3Config_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable43  ;; 0x40000400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??TIM_ForcedOC3Config_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable43_1  ;; 0x40000800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??TIM_ForcedOC3Config_0
   \   0000001E   0xF44F 0x717F      MOV      R1,#+1020
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable49
   \   00000026   0x.... 0x....      BL       assert_failed
   1021            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   \                     ??TIM_ForcedOC3Config_0: (+1)
   \   0000002A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002C   0x2D50             CMP      R5,#+80
   \   0000002E   0xD008             BEQ.N    ??TIM_ForcedOC3Config_1
   \   00000030   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000032   0x2D40             CMP      R5,#+64
   \   00000034   0xD005             BEQ.N    ??TIM_ForcedOC3Config_1
   \   00000036   0xF240 0x31FD      MOVW     R1,#+1021
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable49
   \   0000003E   0x.... 0x....      BL       assert_failed
   1022            
   1023            tmpccmr2 = TIMx->CCMR2;
   \                     ??TIM_ForcedOC3Config_1: (+1)
   \   00000042   0x8BA0             LDRH     R0,[R4, #+28]
   \   00000044   0x0006             MOVS     R6,R0
   1024            /* Reset the OC1M Bits */
   1025            tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3M);
   \   00000046   0xF64F 0x708F      MOVW     R0,#+65423
   \   0000004A   0x4006             ANDS     R6,R0,R6
   1026            /* Configure The Forced output Mode */
   1027            tmpccmr2 |= TIM_ForcedAction;
   \   0000004C   0x432E             ORRS     R6,R5,R6
   1028            /* Write to TIMx CCMR2 register */
   1029            TIMx->CCMR2 = tmpccmr2;
   \   0000004E   0x83A6             STRH     R6,[R4, #+28]
   1030          }
   \   00000050   0xBD70             POP      {R4-R6,PC}       ;; return
   1031          
   1032          /**
   1033            * @brief  Forces the TIMx output 4 waveform to active or inactive level.
   1034            * @param  TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1035            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1036            *   This parameter can be one of the following values:
   1037            *     @arg TIM_ForcedAction_Active: Force active level on OC4REF
   1038            *     @arg TIM_ForcedAction_InActive: Force inactive level on OC4REF.
   1039            * @retval None
   1040            */

   \                                 In section .text, align 2, keep-with-next
   1041          void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
   1042          {
   \                     TIM_ForcedOC4Config: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1043            uint16_t tmpccmr2 = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1044            /* Check the parameters */
   1045            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   \   00000008   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000C   0xD00D             BEQ.N    ??TIM_ForcedOC4Config_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable43  ;; 0x40000400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??TIM_ForcedOC4Config_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable43_1  ;; 0x40000800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??TIM_ForcedOC4Config_0
   \   0000001E   0xF240 0x4115      MOVW     R1,#+1045
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable49
   \   00000026   0x.... 0x....      BL       assert_failed
   1046            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   \                     ??TIM_ForcedOC4Config_0: (+1)
   \   0000002A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002C   0x2D50             CMP      R5,#+80
   \   0000002E   0xD008             BEQ.N    ??TIM_ForcedOC4Config_1
   \   00000030   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000032   0x2D40             CMP      R5,#+64
   \   00000034   0xD005             BEQ.N    ??TIM_ForcedOC4Config_1
   \   00000036   0xF240 0x4116      MOVW     R1,#+1046
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable49
   \   0000003E   0x.... 0x....      BL       assert_failed
   1047            
   1048            tmpccmr2 = TIMx->CCMR2;
   \                     ??TIM_ForcedOC4Config_1: (+1)
   \   00000042   0x8BA0             LDRH     R0,[R4, #+28]
   \   00000044   0x0006             MOVS     R6,R0
   1049            /* Reset the OC2M Bits */
   1050            tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4M);
   \   00000046   0xF648 0x70FF      MOVW     R0,#+36863
   \   0000004A   0x4006             ANDS     R6,R0,R6
   1051            /* Configure The Forced output Mode */
   1052            tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
   \   0000004C   0xEA56 0x2605      ORRS     R6,R6,R5, LSL #+8
   1053            /* Write to TIMx CCMR2 register */
   1054            TIMx->CCMR2 = tmpccmr2;
   \   00000050   0x83A6             STRH     R6,[R4, #+28]
   1055          }
   \   00000052   0xBD70             POP      {R4-R6,PC}       ;; return
   1056          
   1057          /**
   1058            * @brief  Enables or disables the TIMx peripheral Preload register on CCR1.
   1059            * @param  TIMx: where x can be 2, 3, 4, 9, 10 or 11 to select the TIM peripheral.
   1060            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1061            *   This parameter can be one of the following values:
   1062            *     @arg TIM_OCPreload_Enable
   1063            *     @arg TIM_OCPreload_Disable
   1064            * @retval None
   1065            */

   \                                 In section .text, align 2, keep-with-next
   1066          void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1067          {
   \                     TIM_OC1PreloadConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1068            uint16_t tmpccmr1 = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1069            /* Check the parameters */
   1070            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   \   00000008   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000C   0xD019             BEQ.N    ??TIM_OC1PreloadConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable43  ;; 0x40000400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD015             BEQ.N    ??TIM_OC1PreloadConfig_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable43_1  ;; 0x40000800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD011             BEQ.N    ??TIM_OC1PreloadConfig_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable44  ;; 0x40010800
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD00D             BEQ.N    ??TIM_OC1PreloadConfig_0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable44_1  ;; 0x40010c00
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD009             BEQ.N    ??TIM_OC1PreloadConfig_0
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable44_2  ;; 0x40011000
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD005             BEQ.N    ??TIM_OC1PreloadConfig_0
   \   00000036   0xF240 0x412E      MOVW     R1,#+1070
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable49
   \   0000003E   0x.... 0x....      BL       assert_failed
   1071            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   \                     ??TIM_OC1PreloadConfig_0: (+1)
   \   00000042   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000044   0x2D08             CMP      R5,#+8
   \   00000046   0xD008             BEQ.N    ??TIM_OC1PreloadConfig_1
   \   00000048   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004A   0x2D00             CMP      R5,#+0
   \   0000004C   0xD005             BEQ.N    ??TIM_OC1PreloadConfig_1
   \   0000004E   0xF240 0x412F      MOVW     R1,#+1071
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable49
   \   00000056   0x.... 0x....      BL       assert_failed
   1072            
   1073            tmpccmr1 = TIMx->CCMR1;
   \                     ??TIM_OC1PreloadConfig_1: (+1)
   \   0000005A   0x8B20             LDRH     R0,[R4, #+24]
   \   0000005C   0x0006             MOVS     R6,R0
   1074            /* Reset the OC1PE Bit */
   1075            tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1PE);
   \   0000005E   0xF64F 0x70F7      MOVW     R0,#+65527
   \   00000062   0x4006             ANDS     R6,R0,R6
   1076            /* Enable or Disable the Output Compare Preload feature */
   1077            tmpccmr1 |= TIM_OCPreload;
   \   00000064   0x432E             ORRS     R6,R5,R6
   1078            /* Write to TIMx CCMR1 register */
   1079            TIMx->CCMR1 = tmpccmr1;
   \   00000066   0x8326             STRH     R6,[R4, #+24]
   1080          }
   \   00000068   0xBD70             POP      {R4-R6,PC}       ;; return
   1081          
   1082          /**
   1083            * @brief  Enables or disables the TIMx peripheral Preload register on CCR2.
   1084            * @param  TIMx: where x can be 2, 3, 4 or 9 to select the TIM peripheral.
   1085            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1086            *   This parameter can be one of the following values:
   1087            *     @arg TIM_OCPreload_Enable
   1088            *     @arg TIM_OCPreload_Disable
   1089            * @retval None
   1090            */

   \                                 In section .text, align 2, keep-with-next
   1091          void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1092          {
   \                     TIM_OC2PreloadConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1093            uint16_t tmpccmr1 = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1094            /* Check the parameters */
   1095            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   \   00000008   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000C   0xD011             BEQ.N    ??TIM_OC2PreloadConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable43  ;; 0x40000400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD00D             BEQ.N    ??TIM_OC2PreloadConfig_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable43_1  ;; 0x40000800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD009             BEQ.N    ??TIM_OC2PreloadConfig_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable44  ;; 0x40010800
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD005             BEQ.N    ??TIM_OC2PreloadConfig_0
   \   00000026   0xF240 0x4147      MOVW     R1,#+1095
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable49
   \   0000002E   0x.... 0x....      BL       assert_failed
   1096            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   \                     ??TIM_OC2PreloadConfig_0: (+1)
   \   00000032   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000034   0x2D08             CMP      R5,#+8
   \   00000036   0xD008             BEQ.N    ??TIM_OC2PreloadConfig_1
   \   00000038   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0xD005             BEQ.N    ??TIM_OC2PreloadConfig_1
   \   0000003E   0xF44F 0x6189      MOV      R1,#+1096
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable49
   \   00000046   0x.... 0x....      BL       assert_failed
   1097            
   1098            tmpccmr1 = TIMx->CCMR1;
   \                     ??TIM_OC2PreloadConfig_1: (+1)
   \   0000004A   0x8B20             LDRH     R0,[R4, #+24]
   \   0000004C   0x0006             MOVS     R6,R0
   1099            /* Reset the OC2PE Bit */
   1100            tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2PE);
   \   0000004E   0xF24F 0x70FF      MOVW     R0,#+63487
   \   00000052   0x4006             ANDS     R6,R0,R6
   1101            /* Enable or Disable the Output Compare Preload feature */
   1102            tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
   \   00000054   0xEA56 0x2605      ORRS     R6,R6,R5, LSL #+8
   1103            /* Write to TIMx CCMR1 register */
   1104            TIMx->CCMR1 = tmpccmr1;
   \   00000058   0x8326             STRH     R6,[R4, #+24]
   1105          }
   \   0000005A   0xBD70             POP      {R4-R6,PC}       ;; return
   1106          
   1107          /**
   1108            * @brief  Enables or disables the TIMx peripheral Preload register on CCR3.
   1109            * @param  TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1110            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1111            *   This parameter can be one of the following values:
   1112            *     @arg TIM_OCPreload_Enable
   1113            *     @arg TIM_OCPreload_Disable
   1114            * @retval None
   1115            */

   \                                 In section .text, align 2, keep-with-next
   1116          void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1117          {
   \                     TIM_OC3PreloadConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1118            uint16_t tmpccmr2 = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1119            
   1120            /* Check the parameters */
   1121            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   \   00000008   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000C   0xD00D             BEQ.N    ??TIM_OC3PreloadConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable43  ;; 0x40000400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??TIM_OC3PreloadConfig_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable43_1  ;; 0x40000800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??TIM_OC3PreloadConfig_0
   \   0000001E   0xF240 0x4161      MOVW     R1,#+1121
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable49
   \   00000026   0x.... 0x....      BL       assert_failed
   1122            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   \                     ??TIM_OC3PreloadConfig_0: (+1)
   \   0000002A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002C   0x2D08             CMP      R5,#+8
   \   0000002E   0xD008             BEQ.N    ??TIM_OC3PreloadConfig_1
   \   00000030   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD005             BEQ.N    ??TIM_OC3PreloadConfig_1
   \   00000036   0xF240 0x4162      MOVW     R1,#+1122
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable49
   \   0000003E   0x.... 0x....      BL       assert_failed
   1123            
   1124            tmpccmr2 = TIMx->CCMR2;
   \                     ??TIM_OC3PreloadConfig_1: (+1)
   \   00000042   0x8BA0             LDRH     R0,[R4, #+28]
   \   00000044   0x0006             MOVS     R6,R0
   1125            /* Reset the OC3PE Bit */
   1126            tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3PE);
   \   00000046   0xF64F 0x70F7      MOVW     R0,#+65527
   \   0000004A   0x4006             ANDS     R6,R0,R6
   1127            /* Enable or Disable the Output Compare Preload feature */
   1128            tmpccmr2 |= TIM_OCPreload;
   \   0000004C   0x432E             ORRS     R6,R5,R6
   1129            /* Write to TIMx CCMR2 register */
   1130            TIMx->CCMR2 = tmpccmr2;
   \   0000004E   0x83A6             STRH     R6,[R4, #+28]
   1131          }
   \   00000050   0xBD70             POP      {R4-R6,PC}       ;; return
   1132          
   1133          /**
   1134            * @brief  Enables or disables the TIMx peripheral Preload register on CCR4.
   1135            * @param  TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1136            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1137            *   This parameter can be one of the following values:
   1138            *     @arg TIM_OCPreload_Enable
   1139            *     @arg TIM_OCPreload_Disable
   1140            * @retval None
   1141            */

   \                                 In section .text, align 2, keep-with-next
   1142          void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1143          {
   \                     TIM_OC4PreloadConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1144            uint16_t tmpccmr2 = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1145            
   1146            /* Check the parameters */
   1147            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   \   00000008   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000C   0xD00D             BEQ.N    ??TIM_OC4PreloadConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable43  ;; 0x40000400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??TIM_OC4PreloadConfig_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable43_1  ;; 0x40000800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??TIM_OC4PreloadConfig_0
   \   0000001E   0xF240 0x417B      MOVW     R1,#+1147
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable49
   \   00000026   0x.... 0x....      BL       assert_failed
   1148            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   \                     ??TIM_OC4PreloadConfig_0: (+1)
   \   0000002A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002C   0x2D08             CMP      R5,#+8
   \   0000002E   0xD008             BEQ.N    ??TIM_OC4PreloadConfig_1
   \   00000030   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD005             BEQ.N    ??TIM_OC4PreloadConfig_1
   \   00000036   0xF240 0x417C      MOVW     R1,#+1148
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable49
   \   0000003E   0x.... 0x....      BL       assert_failed
   1149            
   1150            tmpccmr2 = TIMx->CCMR2;
   \                     ??TIM_OC4PreloadConfig_1: (+1)
   \   00000042   0x8BA0             LDRH     R0,[R4, #+28]
   \   00000044   0x0006             MOVS     R6,R0
   1151            /* Reset the OC4PE Bit */
   1152            tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4PE);
   \   00000046   0xF24F 0x70FF      MOVW     R0,#+63487
   \   0000004A   0x4006             ANDS     R6,R0,R6
   1153            /* Enable or Disable the Output Compare Preload feature */
   1154            tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
   \   0000004C   0xEA56 0x2605      ORRS     R6,R6,R5, LSL #+8
   1155            /* Write to TIMx CCMR2 register */
   1156            TIMx->CCMR2 = tmpccmr2;
   \   00000050   0x83A6             STRH     R6,[R4, #+28]
   1157          }
   \   00000052   0xBD70             POP      {R4-R6,PC}       ;; return
   1158          
   1159          /**
   1160            * @brief  Configures the TIMx Output Compare 1 Fast feature.
   1161            * @param  TIMx: where x can be 2, 3, 4, 9, 10 or 11 to select the TIM peripheral.
   1162            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1163            *   This parameter can be one of the following values:
   1164            *     @arg TIM_OCFast_Enable: TIM output compare fast enable
   1165            *     @arg TIM_OCFast_Disable: TIM output compare fast disable
   1166            * @retval None
   1167            */

   \                                 In section .text, align 2, keep-with-next
   1168          void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1169          {
   \                     TIM_OC1FastConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1170            uint16_t tmpccmr1 = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1171            
   1172            /* Check the parameters */
   1173            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   \   00000008   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000C   0xD019             BEQ.N    ??TIM_OC1FastConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable43  ;; 0x40000400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD015             BEQ.N    ??TIM_OC1FastConfig_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable43_1  ;; 0x40000800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD011             BEQ.N    ??TIM_OC1FastConfig_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable44  ;; 0x40010800
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD00D             BEQ.N    ??TIM_OC1FastConfig_0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable44_1  ;; 0x40010c00
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD009             BEQ.N    ??TIM_OC1FastConfig_0
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable44_2  ;; 0x40011000
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD005             BEQ.N    ??TIM_OC1FastConfig_0
   \   00000036   0xF240 0x4195      MOVW     R1,#+1173
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable49
   \   0000003E   0x.... 0x....      BL       assert_failed
   1174            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   \                     ??TIM_OC1FastConfig_0: (+1)
   \   00000042   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000044   0x2D04             CMP      R5,#+4
   \   00000046   0xD008             BEQ.N    ??TIM_OC1FastConfig_1
   \   00000048   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004A   0x2D00             CMP      R5,#+0
   \   0000004C   0xD005             BEQ.N    ??TIM_OC1FastConfig_1
   \   0000004E   0xF240 0x4196      MOVW     R1,#+1174
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable49
   \   00000056   0x.... 0x....      BL       assert_failed
   1175            
   1176            /* Get the TIMx CCMR1 register value */
   1177            tmpccmr1 = TIMx->CCMR1;
   \                     ??TIM_OC1FastConfig_1: (+1)
   \   0000005A   0x8B20             LDRH     R0,[R4, #+24]
   \   0000005C   0x0006             MOVS     R6,R0
   1178            /* Reset the OC1FE Bit */
   1179            tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1FE);
   \   0000005E   0xF64F 0x70FB      MOVW     R0,#+65531
   \   00000062   0x4006             ANDS     R6,R0,R6
   1180            /* Enable or Disable the Output Compare Fast Bit */
   1181            tmpccmr1 |= TIM_OCFast;
   \   00000064   0x432E             ORRS     R6,R5,R6
   1182            /* Write to TIMx CCMR1 */
   1183            TIMx->CCMR1 = tmpccmr1;
   \   00000066   0x8326             STRH     R6,[R4, #+24]
   1184          }
   \   00000068   0xBD70             POP      {R4-R6,PC}       ;; return
   1185          
   1186          /**
   1187            * @brief  Configures the TIMx Output Compare 2 Fast feature.
   1188            * @param  TIMx: where x can be 2, 3, 4 or 9 to select the TIM peripheral.
   1189            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1190            *   This parameter can be one of the following values:
   1191            *     @arg TIM_OCFast_Enable: TIM output compare fast enable
   1192            *     @arg TIM_OCFast_Disable: TIM output compare fast disable
   1193            * @retval None
   1194            */

   \                                 In section .text, align 2, keep-with-next
   1195          void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1196          {
   \                     TIM_OC2FastConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1197            uint16_t tmpccmr1 = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1198            
   1199            /* Check the parameters */
   1200            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   \   00000008   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000C   0xD011             BEQ.N    ??TIM_OC2FastConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable43  ;; 0x40000400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD00D             BEQ.N    ??TIM_OC2FastConfig_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable43_1  ;; 0x40000800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD009             BEQ.N    ??TIM_OC2FastConfig_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable44  ;; 0x40010800
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD005             BEQ.N    ??TIM_OC2FastConfig_0
   \   00000026   0xF44F 0x6196      MOV      R1,#+1200
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable49
   \   0000002E   0x.... 0x....      BL       assert_failed
   1201            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   \                     ??TIM_OC2FastConfig_0: (+1)
   \   00000032   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000034   0x2D04             CMP      R5,#+4
   \   00000036   0xD008             BEQ.N    ??TIM_OC2FastConfig_1
   \   00000038   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0xD005             BEQ.N    ??TIM_OC2FastConfig_1
   \   0000003E   0xF240 0x41B1      MOVW     R1,#+1201
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable49
   \   00000046   0x.... 0x....      BL       assert_failed
   1202            
   1203            /* Get the TIMx CCMR1 register value */
   1204            tmpccmr1 = TIMx->CCMR1;
   \                     ??TIM_OC2FastConfig_1: (+1)
   \   0000004A   0x8B20             LDRH     R0,[R4, #+24]
   \   0000004C   0x0006             MOVS     R6,R0
   1205            /* Reset the OC2FE Bit */
   1206            tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2FE);
   \   0000004E   0xF64F 0x30FF      MOVW     R0,#+64511
   \   00000052   0x4006             ANDS     R6,R0,R6
   1207            /* Enable or Disable the Output Compare Fast Bit */
   1208            tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
   \   00000054   0xEA56 0x2605      ORRS     R6,R6,R5, LSL #+8
   1209            /* Write to TIMx CCMR1 */
   1210            TIMx->CCMR1 = tmpccmr1;
   \   00000058   0x8326             STRH     R6,[R4, #+24]
   1211          }
   \   0000005A   0xBD70             POP      {R4-R6,PC}       ;; return
   1212          
   1213          /**
   1214            * @brief  Configures the TIMx Output Compare 3 Fast feature.
   1215            * @param  TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1216            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1217            *   This parameter can be one of the following values:
   1218            *     @arg TIM_OCFast_Enable: TIM output compare fast enable
   1219            *     @arg TIM_OCFast_Disable: TIM output compare fast disable
   1220            * @retval None
   1221            */

   \                                 In section .text, align 2, keep-with-next
   1222          void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1223          {
   \                     TIM_OC3FastConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1224            uint16_t tmpccmr2 = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1225            
   1226            /* Check the parameters */
   1227            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   \   00000008   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000C   0xD00D             BEQ.N    ??TIM_OC3FastConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable43  ;; 0x40000400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??TIM_OC3FastConfig_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable43_1  ;; 0x40000800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??TIM_OC3FastConfig_0
   \   0000001E   0xF240 0x41CB      MOVW     R1,#+1227
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable49
   \   00000026   0x.... 0x....      BL       assert_failed
   1228            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   \                     ??TIM_OC3FastConfig_0: (+1)
   \   0000002A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002C   0x2D04             CMP      R5,#+4
   \   0000002E   0xD008             BEQ.N    ??TIM_OC3FastConfig_1
   \   00000030   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD005             BEQ.N    ??TIM_OC3FastConfig_1
   \   00000036   0xF240 0x41CC      MOVW     R1,#+1228
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable49
   \   0000003E   0x.... 0x....      BL       assert_failed
   1229            
   1230            /* Get the TIMx CCMR2 register value */
   1231            tmpccmr2 = TIMx->CCMR2;
   \                     ??TIM_OC3FastConfig_1: (+1)
   \   00000042   0x8BA0             LDRH     R0,[R4, #+28]
   \   00000044   0x0006             MOVS     R6,R0
   1232            /* Reset the OC3FE Bit */
   1233            tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3FE);
   \   00000046   0xF64F 0x70FB      MOVW     R0,#+65531
   \   0000004A   0x4006             ANDS     R6,R0,R6
   1234            /* Enable or Disable the Output Compare Fast Bit */
   1235            tmpccmr2 |= TIM_OCFast;
   \   0000004C   0x432E             ORRS     R6,R5,R6
   1236            /* Write to TIMx CCMR2 */
   1237            TIMx->CCMR2 = tmpccmr2;
   \   0000004E   0x83A6             STRH     R6,[R4, #+28]
   1238          }
   \   00000050   0xBD70             POP      {R4-R6,PC}       ;; return
   1239          
   1240          /**
   1241            * @brief  Configures the TIMx Output Compare 4 Fast feature.
   1242            * @param  TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1243            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1244            *   This parameter can be one of the following values:
   1245            *     @arg TIM_OCFast_Enable: TIM output compare fast enable
   1246            *     @arg TIM_OCFast_Disable: TIM output compare fast disable
   1247            * @retval None
   1248            */

   \                                 In section .text, align 2, keep-with-next
   1249          void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1250          {
   \                     TIM_OC4FastConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1251            uint16_t tmpccmr2 = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1252            
   1253            /* Check the parameters */
   1254            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   \   00000008   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000C   0xD00B             BEQ.N    ??TIM_OC4FastConfig_0
   \   0000000E   0x....             LDR.N    R0,??DataTable43  ;; 0x40000400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD008             BEQ.N    ??TIM_OC4FastConfig_0
   \   00000014   0x....             LDR.N    R0,??DataTable43_1  ;; 0x40000800
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD005             BEQ.N    ??TIM_OC4FastConfig_0
   \   0000001A   0xF240 0x41E6      MOVW     R1,#+1254
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable49
   \   00000022   0x.... 0x....      BL       assert_failed
   1255            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   \                     ??TIM_OC4FastConfig_0: (+1)
   \   00000026   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000028   0x2D04             CMP      R5,#+4
   \   0000002A   0xD008             BEQ.N    ??TIM_OC4FastConfig_1
   \   0000002C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002E   0x2D00             CMP      R5,#+0
   \   00000030   0xD005             BEQ.N    ??TIM_OC4FastConfig_1
   \   00000032   0xF240 0x41E7      MOVW     R1,#+1255
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable49
   \   0000003A   0x.... 0x....      BL       assert_failed
   1256            
   1257            /* Get the TIMx CCMR2 register value */
   1258            tmpccmr2 = TIMx->CCMR2;
   \                     ??TIM_OC4FastConfig_1: (+1)
   \   0000003E   0x8BA0             LDRH     R0,[R4, #+28]
   \   00000040   0x0006             MOVS     R6,R0
   1259            /* Reset the OC4FE Bit */
   1260            tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4FE);
   \   00000042   0xF64F 0x30FF      MOVW     R0,#+64511
   \   00000046   0x4006             ANDS     R6,R0,R6
   1261            /* Enable or Disable the Output Compare Fast Bit */
   1262            tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
   \   00000048   0xEA56 0x2605      ORRS     R6,R6,R5, LSL #+8
   1263            /* Write to TIMx CCMR2 */
   1264            TIMx->CCMR2 = tmpccmr2;
   \   0000004C   0x83A6             STRH     R6,[R4, #+28]
   1265          }
   \   0000004E   0xBD70             POP      {R4-R6,PC}       ;; return
   1266          
   1267          /**
   1268            * @brief  Clears or safeguards the OCREF1 signal on an external event
   1269            * @param  TIMx: where x can be 2, 3, 4, 9, 10 or 11 to select the TIM peripheral.
   1270            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1271            *   This parameter can be one of the following values:
   1272            *     @arg TIM_OCClear_Enable: TIM Output clear enable
   1273            *     @arg TIM_OCClear_Disable: TIM Output clear disable
   1274            * @retval None
   1275            */

   \                                 In section .text, align 2, keep-with-next
   1276          void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1277          {
   \                     TIM_ClearOC1Ref: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1278            uint16_t tmpccmr1 = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1279            
   1280            /* Check the parameters */
   1281            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   \   00000008   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000C   0xD017             BEQ.N    ??TIM_ClearOC1Ref_0
   \   0000000E   0x....             LDR.N    R0,??DataTable43  ;; 0x40000400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD014             BEQ.N    ??TIM_ClearOC1Ref_0
   \   00000014   0x....             LDR.N    R0,??DataTable43_1  ;; 0x40000800
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD011             BEQ.N    ??TIM_ClearOC1Ref_0
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable44  ;; 0x40010800
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD00D             BEQ.N    ??TIM_ClearOC1Ref_0
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable44_1  ;; 0x40010c00
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD009             BEQ.N    ??TIM_ClearOC1Ref_0
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable44_2  ;; 0x40011000
   \   0000002E   0x4284             CMP      R4,R0
   \   00000030   0xD005             BEQ.N    ??TIM_ClearOC1Ref_0
   \   00000032   0xF240 0x5101      MOVW     R1,#+1281
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable49
   \   0000003A   0x.... 0x....      BL       assert_failed
   1282            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   \                     ??TIM_ClearOC1Ref_0: (+1)
   \   0000003E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000040   0x2D80             CMP      R5,#+128
   \   00000042   0xD008             BEQ.N    ??TIM_ClearOC1Ref_1
   \   00000044   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000046   0x2D00             CMP      R5,#+0
   \   00000048   0xD005             BEQ.N    ??TIM_ClearOC1Ref_1
   \   0000004A   0xF240 0x5102      MOVW     R1,#+1282
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable49
   \   00000052   0x.... 0x....      BL       assert_failed
   1283            
   1284            tmpccmr1 = TIMx->CCMR1;
   \                     ??TIM_ClearOC1Ref_1: (+1)
   \   00000056   0x8B20             LDRH     R0,[R4, #+24]
   \   00000058   0x0006             MOVS     R6,R0
   1285            /* Reset the OC1CE Bit */
   1286            tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1CE);
   \   0000005A   0xF64F 0x707F      MOVW     R0,#+65407
   \   0000005E   0x4006             ANDS     R6,R0,R6
   1287            /* Enable or Disable the Output Compare Clear Bit */
   1288            tmpccmr1 |= TIM_OCClear;
   \   00000060   0x432E             ORRS     R6,R5,R6
   1289            /* Write to TIMx CCMR1 register */
   1290            TIMx->CCMR1 = tmpccmr1;
   \   00000062   0x8326             STRH     R6,[R4, #+24]
   1291          }
   \   00000064   0xBD70             POP      {R4-R6,PC}       ;; return
   1292          
   1293          /**
   1294            * @brief  Clears or safeguards the OCREF2 signal on an external event
   1295            * @param  TIMx: where x can be 2, 3, 4 or 9 to select the TIM peripheral.
   1296            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1297          
   1298            *   This parameter can be one of the following values:
   1299            *     @arg TIM_OCClear_Enable: TIM Output clear enable
   1300            *     @arg TIM_OCClear_Disable: TIM Output clear disable
   1301            * @retval None
   1302            */

   \                                 In section .text, align 2, keep-with-next
   1303          void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1304          {
   \                     TIM_ClearOC2Ref: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1305            uint16_t tmpccmr1 = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1306            
   1307            /* Check the parameters */
   1308            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   \   00000008   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000C   0xD00E             BEQ.N    ??TIM_ClearOC2Ref_0
   \   0000000E   0x....             LDR.N    R0,??DataTable43  ;; 0x40000400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD00B             BEQ.N    ??TIM_ClearOC2Ref_0
   \   00000014   0x....             LDR.N    R0,??DataTable43_1  ;; 0x40000800
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD008             BEQ.N    ??TIM_ClearOC2Ref_0
   \   0000001A   0x....             LDR.N    R0,??DataTable44  ;; 0x40010800
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD005             BEQ.N    ??TIM_ClearOC2Ref_0
   \   00000020   0xF240 0x511C      MOVW     R1,#+1308
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable49
   \   00000028   0x.... 0x....      BL       assert_failed
   1309            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   \                     ??TIM_ClearOC2Ref_0: (+1)
   \   0000002C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002E   0x2D80             CMP      R5,#+128
   \   00000030   0xD008             BEQ.N    ??TIM_ClearOC2Ref_1
   \   00000032   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD005             BEQ.N    ??TIM_ClearOC2Ref_1
   \   00000038   0xF240 0x511D      MOVW     R1,#+1309
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable49
   \   00000040   0x.... 0x....      BL       assert_failed
   1310            
   1311            tmpccmr1 = TIMx->CCMR1;
   \                     ??TIM_ClearOC2Ref_1: (+1)
   \   00000044   0x8B20             LDRH     R0,[R4, #+24]
   \   00000046   0x0006             MOVS     R6,R0
   1312            /* Reset the OC2CE Bit */
   1313            tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2CE);
   \   00000048   0x0476             LSLS     R6,R6,#+17       ;; ZeroExtS R6,R6,#+17,#+17
   \   0000004A   0x0C76             LSRS     R6,R6,#+17
   1314            /* Enable or Disable the Output Compare Clear Bit */
   1315            tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
   \   0000004C   0xEA56 0x2605      ORRS     R6,R6,R5, LSL #+8
   1316            /* Write to TIMx CCMR1 register */
   1317            TIMx->CCMR1 = tmpccmr1;
   \   00000050   0x8326             STRH     R6,[R4, #+24]
   1318          }
   \   00000052   0xBD70             POP      {R4-R6,PC}       ;; return
   1319          
   1320          /**
   1321            * @brief  Clears or safeguards the OCREF3 signal on an external event
   1322            * @param  TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1323            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1324            *   This parameter can be one of the following values:
   1325            *     @arg TIM_OCClear_Enable: TIM Output clear enable
   1326            *     @arg TIM_OCClear_Disable: TIM Output clear disable
   1327            * @retval None
   1328            */

   \                                 In section .text, align 2, keep-with-next
   1329          void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1330          {
   \                     TIM_ClearOC3Ref: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1331            uint16_t tmpccmr2 = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1332            
   1333            /* Check the parameters */
   1334            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   \   00000008   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000C   0xD00B             BEQ.N    ??TIM_ClearOC3Ref_0
   \   0000000E   0x....             LDR.N    R0,??DataTable43  ;; 0x40000400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD008             BEQ.N    ??TIM_ClearOC3Ref_0
   \   00000014   0x....             LDR.N    R0,??DataTable43_1  ;; 0x40000800
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD005             BEQ.N    ??TIM_ClearOC3Ref_0
   \   0000001A   0xF240 0x5136      MOVW     R1,#+1334
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable49
   \   00000022   0x.... 0x....      BL       assert_failed
   1335            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   \                     ??TIM_ClearOC3Ref_0: (+1)
   \   00000026   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000028   0x2D80             CMP      R5,#+128
   \   0000002A   0xD008             BEQ.N    ??TIM_ClearOC3Ref_1
   \   0000002C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002E   0x2D00             CMP      R5,#+0
   \   00000030   0xD005             BEQ.N    ??TIM_ClearOC3Ref_1
   \   00000032   0xF240 0x5137      MOVW     R1,#+1335
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable49
   \   0000003A   0x.... 0x....      BL       assert_failed
   1336            
   1337            tmpccmr2 = TIMx->CCMR2;
   \                     ??TIM_ClearOC3Ref_1: (+1)
   \   0000003E   0x8BA0             LDRH     R0,[R4, #+28]
   \   00000040   0x0006             MOVS     R6,R0
   1338            /* Reset the OC3CE Bit */
   1339            tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3CE);
   \   00000042   0xF64F 0x707F      MOVW     R0,#+65407
   \   00000046   0x4006             ANDS     R6,R0,R6
   1340            /* Enable or Disable the Output Compare Clear Bit */
   1341            tmpccmr2 |= TIM_OCClear;
   \   00000048   0x432E             ORRS     R6,R5,R6
   1342            /* Write to TIMx CCMR2 register */
   1343            TIMx->CCMR2 = tmpccmr2;
   \   0000004A   0x83A6             STRH     R6,[R4, #+28]
   1344          }
   \   0000004C   0xBD70             POP      {R4-R6,PC}       ;; return
   1345          
   1346          /**
   1347            * @brief  Clears or safeguards the OCREF4 signal on an external event
   1348            * @param  TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1349            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1350            *   This parameter can be one of the following values:
   1351            *     @arg TIM_OCClear_Enable: TIM Output clear enable
   1352            *     @arg TIM_OCClear_Disable: TIM Output clear disable
   1353            * @retval None
   1354            */

   \                                 In section .text, align 2, keep-with-next
   1355          void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1356          {
   \                     TIM_ClearOC4Ref: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1357            uint16_t tmpccmr2 = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1358            
   1359            /* Check the parameters */
   1360            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   \   00000008   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000C   0xD00B             BEQ.N    ??TIM_ClearOC4Ref_0
   \   0000000E   0x....             LDR.N    R0,??DataTable43  ;; 0x40000400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD008             BEQ.N    ??TIM_ClearOC4Ref_0
   \   00000014   0x....             LDR.N    R0,??DataTable43_1  ;; 0x40000800
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD005             BEQ.N    ??TIM_ClearOC4Ref_0
   \   0000001A   0xF44F 0x61AA      MOV      R1,#+1360
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable49
   \   00000022   0x.... 0x....      BL       assert_failed
   1361            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   \                     ??TIM_ClearOC4Ref_0: (+1)
   \   00000026   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000028   0x2D80             CMP      R5,#+128
   \   0000002A   0xD008             BEQ.N    ??TIM_ClearOC4Ref_1
   \   0000002C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002E   0x2D00             CMP      R5,#+0
   \   00000030   0xD005             BEQ.N    ??TIM_ClearOC4Ref_1
   \   00000032   0xF240 0x5151      MOVW     R1,#+1361
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable49
   \   0000003A   0x.... 0x....      BL       assert_failed
   1362            
   1363            tmpccmr2 = TIMx->CCMR2;
   \                     ??TIM_ClearOC4Ref_1: (+1)
   \   0000003E   0x8BA0             LDRH     R0,[R4, #+28]
   \   00000040   0x0006             MOVS     R6,R0
   1364            /* Reset the OC4CE Bit */
   1365            tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4CE);
   \   00000042   0x0476             LSLS     R6,R6,#+17       ;; ZeroExtS R6,R6,#+17,#+17
   \   00000044   0x0C76             LSRS     R6,R6,#+17
   1366            /* Enable or Disable the Output Compare Clear Bit */
   1367            tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
   \   00000046   0xEA56 0x2605      ORRS     R6,R6,R5, LSL #+8
   1368            /* Write to TIMx CCMR2 register */
   1369            TIMx->CCMR2 = tmpccmr2;
   \   0000004A   0x83A6             STRH     R6,[R4, #+28]
   1370          }
   \   0000004C   0xBD70             POP      {R4-R6,PC}       ;; return
   1371          
   1372          /**
   1373            * @brief  Configures the TIMx channel 1 polarity.
   1374            * @param  TIMx: where x can be 2, 3, 4, 9, 10 or 11 to select the TIM peripheral.
   1375            * @param  TIM_OCPolarity: specifies the OC1 Polarity
   1376            *   This parmeter can be one of the following values:
   1377            *     @arg TIM_OCPolarity_High: Output Compare active high
   1378            *     @arg TIM_OCPolarity_Low: Output Compare active low
   1379            * @retval None
   1380            */

   \                                 In section .text, align 2, keep-with-next
   1381          void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1382          {
   \                     TIM_OC1PolarityConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1383            uint16_t tmpccer = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1384            
   1385            /* Check the parameters */
   1386            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   \   00000008   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000C   0xD014             BEQ.N    ??TIM_OC1PolarityConfig_0
   \   0000000E   0x....             LDR.N    R0,??DataTable43  ;; 0x40000400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD011             BEQ.N    ??TIM_OC1PolarityConfig_0
   \   00000014   0x....             LDR.N    R0,??DataTable43_1  ;; 0x40000800
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD00E             BEQ.N    ??TIM_OC1PolarityConfig_0
   \   0000001A   0x....             LDR.N    R0,??DataTable44  ;; 0x40010800
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD00B             BEQ.N    ??TIM_OC1PolarityConfig_0
   \   00000020   0x....             LDR.N    R0,??DataTable44_1  ;; 0x40010c00
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD008             BEQ.N    ??TIM_OC1PolarityConfig_0
   \   00000026   0x....             LDR.N    R0,??DataTable44_2  ;; 0x40011000
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD005             BEQ.N    ??TIM_OC1PolarityConfig_0
   \   0000002C   0xF240 0x516A      MOVW     R1,#+1386
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable49
   \   00000034   0x.... 0x....      BL       assert_failed
   1387            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   \                     ??TIM_OC1PolarityConfig_0: (+1)
   \   00000038   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0xD008             BEQ.N    ??TIM_OC1PolarityConfig_1
   \   0000003E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000040   0x2D02             CMP      R5,#+2
   \   00000042   0xD005             BEQ.N    ??TIM_OC1PolarityConfig_1
   \   00000044   0xF240 0x516B      MOVW     R1,#+1387
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable49
   \   0000004C   0x.... 0x....      BL       assert_failed
   1388            
   1389            tmpccer = TIMx->CCER;
   \                     ??TIM_OC1PolarityConfig_1: (+1)
   \   00000050   0x8C20             LDRH     R0,[R4, #+32]
   \   00000052   0x0006             MOVS     R6,R0
   1390            /* Set or Reset the CC1P Bit */
   1391            tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1P);
   \   00000054   0xF64F 0x70FD      MOVW     R0,#+65533
   \   00000058   0x4006             ANDS     R6,R0,R6
   1392            tmpccer |= TIM_OCPolarity;
   \   0000005A   0x432E             ORRS     R6,R5,R6
   1393            /* Write to TIMx CCER register */
   1394            TIMx->CCER = tmpccer;
   \   0000005C   0x8426             STRH     R6,[R4, #+32]
   1395          }
   \   0000005E   0xBD70             POP      {R4-R6,PC}       ;; return
   1396          
   1397          /**
   1398            * @brief  Configures the TIMx channel 2 polarity.
   1399            * @param  TIMx: where x can be 2, 3, 4 or 9 to select the TIM peripheral.
   1400            * @param  TIM_OCPolarity: specifies the OC2 Polarity
   1401            *   This parmeter can be one of the following values:
   1402            *     @arg TIM_OCPolarity_High: Output Compare active high
   1403            *     @arg TIM_OCPolarity_Low: Output Compare active low
   1404            * @retval None
   1405            */

   \                                 In section .text, align 2, keep-with-next
   1406          void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1407          {
   \                     TIM_OC2PolarityConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1408            uint16_t tmpccer = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1409            
   1410            /* Check the parameters */
   1411            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   \   00000008   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000C   0xD00E             BEQ.N    ??TIM_OC2PolarityConfig_0
   \   0000000E   0x....             LDR.N    R0,??DataTable43  ;; 0x40000400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD00B             BEQ.N    ??TIM_OC2PolarityConfig_0
   \   00000014   0x....             LDR.N    R0,??DataTable43_1  ;; 0x40000800
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD008             BEQ.N    ??TIM_OC2PolarityConfig_0
   \   0000001A   0x....             LDR.N    R0,??DataTable44  ;; 0x40010800
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD005             BEQ.N    ??TIM_OC2PolarityConfig_0
   \   00000020   0xF240 0x5183      MOVW     R1,#+1411
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable49
   \   00000028   0x.... 0x....      BL       assert_failed
   1412            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   \                     ??TIM_OC2PolarityConfig_0: (+1)
   \   0000002C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002E   0x2D00             CMP      R5,#+0
   \   00000030   0xD008             BEQ.N    ??TIM_OC2PolarityConfig_1
   \   00000032   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000034   0x2D02             CMP      R5,#+2
   \   00000036   0xD005             BEQ.N    ??TIM_OC2PolarityConfig_1
   \   00000038   0xF240 0x5184      MOVW     R1,#+1412
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable49
   \   00000040   0x.... 0x....      BL       assert_failed
   1413            
   1414            tmpccer = TIMx->CCER;
   \                     ??TIM_OC2PolarityConfig_1: (+1)
   \   00000044   0x8C20             LDRH     R0,[R4, #+32]
   \   00000046   0x0006             MOVS     R6,R0
   1415            /* Set or Reset the CC2P Bit */
   1416            tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2P);
   \   00000048   0xF64F 0x70DF      MOVW     R0,#+65503
   \   0000004C   0x4006             ANDS     R6,R0,R6
   1417            tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
   \   0000004E   0xEA56 0x1605      ORRS     R6,R6,R5, LSL #+4
   1418            /* Write to TIMx CCER register */
   1419            TIMx->CCER = tmpccer;
   \   00000052   0x8426             STRH     R6,[R4, #+32]
   1420          }
   \   00000054   0xBD70             POP      {R4-R6,PC}       ;; return
   1421          
   1422          /**
   1423            * @brief  Configures the TIMx channel 3 polarity.
   1424            * @param  TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1425            * @param  TIM_OCPolarity: specifies the OC3 Polarity
   1426            *   This parmeter can be one of the following values:
   1427            *     @arg TIM_OCPolarity_High: Output Compare active high
   1428            *     @arg TIM_OCPolarity_Low: Output Compare active low
   1429            * @retval None
   1430            */

   \                                 In section .text, align 2, keep-with-next
   1431          void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1432          {
   \                     TIM_OC3PolarityConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1433            uint16_t tmpccer = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1434            
   1435            /* Check the parameters */
   1436            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   \   00000008   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000C   0xD00B             BEQ.N    ??TIM_OC3PolarityConfig_0
   \   0000000E   0x....             LDR.N    R0,??DataTable43  ;; 0x40000400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD008             BEQ.N    ??TIM_OC3PolarityConfig_0
   \   00000014   0x....             LDR.N    R0,??DataTable43_1  ;; 0x40000800
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD005             BEQ.N    ??TIM_OC3PolarityConfig_0
   \   0000001A   0xF240 0x519C      MOVW     R1,#+1436
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable49
   \   00000022   0x.... 0x....      BL       assert_failed
   1437            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   \                     ??TIM_OC3PolarityConfig_0: (+1)
   \   00000026   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000028   0x2D00             CMP      R5,#+0
   \   0000002A   0xD008             BEQ.N    ??TIM_OC3PolarityConfig_1
   \   0000002C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002E   0x2D02             CMP      R5,#+2
   \   00000030   0xD005             BEQ.N    ??TIM_OC3PolarityConfig_1
   \   00000032   0xF240 0x519D      MOVW     R1,#+1437
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable49
   \   0000003A   0x.... 0x....      BL       assert_failed
   1438            
   1439            tmpccer = TIMx->CCER;
   \                     ??TIM_OC3PolarityConfig_1: (+1)
   \   0000003E   0x8C20             LDRH     R0,[R4, #+32]
   \   00000040   0x0006             MOVS     R6,R0
   1440            /* Set or Reset the CC3P Bit */
   1441            tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3P);
   \   00000042   0xF64F 0x50FF      MOVW     R0,#+65023
   \   00000046   0x4006             ANDS     R6,R0,R6
   1442            tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
   \   00000048   0xEA56 0x2605      ORRS     R6,R6,R5, LSL #+8
   1443            /* Write to TIMx CCER register */
   1444            TIMx->CCER = tmpccer;
   \   0000004C   0x8426             STRH     R6,[R4, #+32]
   1445          }
   \   0000004E   0xBD70             POP      {R4-R6,PC}       ;; return
   1446          
   1447          /**
   1448            * @brief  Configures the TIMx channel 4 polarity.
   1449            * @param  TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1450            * @param  TIM_OCPolarity: specifies the OC4 Polarity
   1451            *   This parmeter can be one of the following values:
   1452            *     @arg TIM_OCPolarity_High: Output Compare active high
   1453            *     @arg TIM_OCPolarity_Low: Output Compare active low
   1454            * @retval None
   1455            */

   \                                 In section .text, align 2, keep-with-next
   1456          void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1457          {
   \                     TIM_OC4PolarityConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1458            uint16_t tmpccer = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1459            
   1460            /* Check the parameters */
   1461            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   \   00000008   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000C   0xD00B             BEQ.N    ??TIM_OC4PolarityConfig_0
   \   0000000E   0x....             LDR.N    R0,??DataTable43  ;; 0x40000400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD008             BEQ.N    ??TIM_OC4PolarityConfig_0
   \   00000014   0x....             LDR.N    R0,??DataTable43_1  ;; 0x40000800
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD005             BEQ.N    ??TIM_OC4PolarityConfig_0
   \   0000001A   0xF240 0x51B5      MOVW     R1,#+1461
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable49
   \   00000022   0x.... 0x....      BL       assert_failed
   1462            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   \                     ??TIM_OC4PolarityConfig_0: (+1)
   \   00000026   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000028   0x2D00             CMP      R5,#+0
   \   0000002A   0xD008             BEQ.N    ??TIM_OC4PolarityConfig_1
   \   0000002C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002E   0x2D02             CMP      R5,#+2
   \   00000030   0xD005             BEQ.N    ??TIM_OC4PolarityConfig_1
   \   00000032   0xF240 0x51B6      MOVW     R1,#+1462
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable49
   \   0000003A   0x.... 0x....      BL       assert_failed
   1463            
   1464            tmpccer = TIMx->CCER;
   \                     ??TIM_OC4PolarityConfig_1: (+1)
   \   0000003E   0x8C20             LDRH     R0,[R4, #+32]
   \   00000040   0x0006             MOVS     R6,R0
   1465            /* Set or Reset the CC4P Bit */
   1466            tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC4P);
   \   00000042   0xF64D 0x70FF      MOVW     R0,#+57343
   \   00000046   0x4006             ANDS     R6,R0,R6
   1467            tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
   \   00000048   0xEA56 0x3605      ORRS     R6,R6,R5, LSL #+12
   1468            /* Write to TIMx CCER register */
   1469            TIMx->CCER = tmpccer;
   \   0000004C   0x8426             STRH     R6,[R4, #+32]
   1470          }
   \   0000004E   0xBD70             POP      {R4-R6,PC}       ;; return
   1471          
   1472          /**
   1473            * @brief  Selects the OCReference Clear source.
   1474            * @param  TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1475            * @param  TIM_OCReferenceClear: specifies the OCReference Clear source.
   1476            *   This parameter can be one of the following values:
   1477            *     @arg TIM_OCReferenceClear_ETRF: The internal OCreference clear input is connected to ETRF.
   1478            *     @arg TIM_OCReferenceClear_OCREFCLR: The internal OCreference clear input is connected to OCREF_CLR input.  
   1479            * @retval None
   1480            */

   \                                 In section .text, align 2, keep-with-next
   1481          void TIM_SelectOCREFClear(TIM_TypeDef* TIMx, uint16_t TIM_OCReferenceClear)
   1482          {
   \                     TIM_SelectOCREFClear: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1483            /* Check the parameters */
   1484            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   \   00000006   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000A   0xD00A             BEQ.N    ??TIM_SelectOCREFClear_0
   \   0000000C   0x....             LDR.N    R0,??DataTable43  ;; 0x40000400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD007             BEQ.N    ??TIM_SelectOCREFClear_0
   \   00000012   0x....             LDR.N    R0,??DataTable43_1  ;; 0x40000800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD004             BEQ.N    ??TIM_SelectOCREFClear_0
   \   00000018   0xF240 0x51CC      MOVW     R1,#+1484
   \   0000001C   0x....             LDR.N    R0,??DataTable49
   \   0000001E   0x.... 0x....      BL       assert_failed
   1485            assert_param(TIM_OCREFERENCECECLEAR_SOURCE(TIM_OCReferenceClear));
   \                     ??TIM_SelectOCREFClear_0: (+1)
   \   00000022   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000024   0x2D08             CMP      R5,#+8
   \   00000026   0xD007             BEQ.N    ??TIM_SelectOCREFClear_1
   \   00000028   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD004             BEQ.N    ??TIM_SelectOCREFClear_1
   \   0000002E   0xF240 0x51CD      MOVW     R1,#+1485
   \   00000032   0x....             LDR.N    R0,??DataTable49
   \   00000034   0x.... 0x....      BL       assert_failed
   1486          
   1487            /* Set the TIM_OCReferenceClear source */
   1488            TIMx->SMCR &=  (uint16_t)~((uint16_t)TIM_SMCR_OCCS);
   \                     ??TIM_SelectOCREFClear_1: (+1)
   \   00000038   0x8920             LDRH     R0,[R4, #+8]
   \   0000003A   0xF64F 0x71F7      MOVW     R1,#+65527
   \   0000003E   0x4008             ANDS     R0,R1,R0
   \   00000040   0x8120             STRH     R0,[R4, #+8]
   1489            TIMx->SMCR |=  TIM_OCReferenceClear;
   \   00000042   0x8920             LDRH     R0,[R4, #+8]
   \   00000044   0x4328             ORRS     R0,R5,R0
   \   00000046   0x8120             STRH     R0,[R4, #+8]
   1490          }
   \   00000048   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1491          
   1492          /**
   1493            * @brief  Enables or disables the TIM Capture Compare Channel x.
   1494            * @param  TIMx: where x can be 2, 3, 4, 9, 10 or 11 to select the TIM peripheral.
   1495            * @param  TIM_Channel: specifies the TIM Channel
   1496            *   This parameter can be one of the following values:
   1497            *     @arg TIM_Channel_1: TIM Channel 1
   1498            *     @arg TIM_Channel_2: TIM Channel 2
   1499            *     @arg TIM_Channel_3: TIM Channel 3
   1500            *     @arg TIM_Channel_4: TIM Channel 4
   1501            * @param  TIM_CCx: specifies the TIM Channel CCxE bit new state.
   1502            *   This parameter can be: TIM_CCx_Enable or TIM_CCx_Disable. 
   1503            * @retval None
   1504            */

   \                                 In section .text, align 2, keep-with-next
   1505          void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
   1506          {
   \                     TIM_CCxCmd: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1507            uint16_t tmp = 0;
   \   00000008   0x2700             MOVS     R7,#+0
   1508          
   1509            /* Check the parameters */
   1510            assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
   \   0000000A   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000E   0xD015             BEQ.N    ??TIM_CCxCmd_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable62  ;; 0x40000400
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD011             BEQ.N    ??TIM_CCxCmd_0
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable63  ;; 0x40000800
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD00D             BEQ.N    ??TIM_CCxCmd_0
   \   00000020   0x....             LDR.N    R0,??DataTable44  ;; 0x40010800
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD00A             BEQ.N    ??TIM_CCxCmd_0
   \   00000026   0x....             LDR.N    R0,??DataTable44_1  ;; 0x40010c00
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD007             BEQ.N    ??TIM_CCxCmd_0
   \   0000002C   0x....             LDR.N    R0,??DataTable44_2  ;; 0x40011000
   \   0000002E   0x4284             CMP      R4,R0
   \   00000030   0xD004             BEQ.N    ??TIM_CCxCmd_0
   \   00000032   0xF240 0x51E6      MOVW     R1,#+1510
   \   00000036   0x....             LDR.N    R0,??DataTable49
   \   00000038   0x.... 0x....      BL       assert_failed
   1511            assert_param(IS_TIM_CCX(TIM_CCx));
   \                     ??TIM_CCxCmd_0: (+1)
   \   0000003C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000003E   0x2E01             CMP      R6,#+1
   \   00000040   0xD007             BEQ.N    ??TIM_CCxCmd_1
   \   00000042   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000044   0x2E00             CMP      R6,#+0
   \   00000046   0xD004             BEQ.N    ??TIM_CCxCmd_1
   \   00000048   0xF240 0x51E7      MOVW     R1,#+1511
   \   0000004C   0x....             LDR.N    R0,??DataTable49
   \   0000004E   0x.... 0x....      BL       assert_failed
   1512          
   1513            tmp = CCER_CCE_SET << TIM_Channel;
   \                     ??TIM_CCxCmd_1: (+1)
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0x40A8             LSLS     R0,R0,R5
   \   00000056   0x0007             MOVS     R7,R0
   1514          
   1515            /* Reset the CCxE Bit */
   1516            TIMx->CCER &= (uint16_t)~ tmp;
   \   00000058   0x8C20             LDRH     R0,[R4, #+32]
   \   0000005A   0x43B8             BICS     R0,R0,R7
   \   0000005C   0x8420             STRH     R0,[R4, #+32]
   1517          
   1518            /* Set or reset the CCxE Bit */ 
   1519            TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
   \   0000005E   0x8C20             LDRH     R0,[R4, #+32]
   \   00000060   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000062   0xFA16 0xF105      LSLS     R1,R6,R5
   \   00000066   0x4308             ORRS     R0,R1,R0
   \   00000068   0x8420             STRH     R0,[R4, #+32]
   1520          }
   \   0000006A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1521          
   1522          /**
   1523            * @}
   1524            */
   1525          
   1526          /** @defgroup TIM_Group3 Input Capture management functions
   1527           *  @brief    Input Capture management functions 
   1528           *
   1529          @verbatim   
   1530           ===============================================================================
   1531                                Input Capture management functions
   1532           ===============================================================================  
   1533             
   1534                 ===================================================================      
   1535                        TIM Driver: how to use it in Input Capture Mode
   1536                 =================================================================== 
   1537                 To use the Timer in Input Capture mode, the following steps are mandatory:
   1538                 
   1539                 1. Enable TIM clock using RCC_APBxPeriphClockCmd(RCC_APBxPeriph_TIMx, ENABLE) function
   1540                 
   1541                 2. Configure the TIM pins by configuring the corresponding GPIO pins
   1542                 
   1543                 2. Configure the Time base unit as described in the first part of this driver, if needed,
   1544                    else the Timer will run with the default configuration:
   1545                    - Autoreload value = 0xFFFF
   1546                    - Prescaler value = 0x0000
   1547                    - Counter mode = Up counting
   1548                    - Clock Division = TIM_CKD_DIV1
   1549                    
   1550                 3. Fill the TIM_ICInitStruct with the desired parameters including:
   1551                    - TIM Channel: TIM_Channel
   1552                    - TIM Input Capture polarity: TIM_ICPolarity
   1553                    - TIM Input Capture selection: TIM_ICSelection
   1554                    - TIM Input Capture Prescaler: TIM_ICPrescaler
   1555                    - TIM Input CApture filter value: TIM_ICFilter
   1556                 
   1557                 4. Call TIM_ICInit(TIMx, &TIM_ICInitStruct) to configure the desired channel with the 
   1558                    corresponding configuration and to measure only frequency or duty cycle of the input signal,
   1559                    or,
   1560                    Call TIM_PWMIConfig(TIMx, &TIM_ICInitStruct) to configure the desired channels with the 
   1561                    corresponding configuration and to measure the frequency and the duty cycle of the input signal
   1562                    
   1563                 5. Enable the NVIC or the DMA to read the measured frequency. 
   1564                    
   1565                 6. Enable the corresponding interrupt (or DMA request) to read the Captured value,
   1566                    using the function TIM_ITConfig(TIMx, TIM_IT_CCx) (or TIM_DMA_Cmd(TIMx, TIM_DMA_CCx)) 
   1567                 
   1568                 7. Call the TIM_Cmd(ENABLE) function to enable the TIM counter.
   1569                 
   1570                 8. Use TIM_GetCapturex(TIMx); to read the captured value.
   1571                 
   1572                 Note1: All other functions can be used seperatly to modify, if needed,
   1573                    a specific feature of the Timer. 
   1574          
   1575          @endverbatim
   1576            * @{
   1577            */
   1578          
   1579          /**
   1580            * @brief  Initializes the TIM peripheral according to the specified
   1581            *         parameters in the TIM_ICInitStruct.
   1582            * @param  TIMx: where x can be 2, 3, 4, 9, 10 or 11 to select the TIM peripheral.
   1583            * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
   1584            *         that contains the configuration information for the specified TIM 
   1585            *         peripheral.
   1586            * @retval None
   1587            */

   \                                 In section .text, align 2, keep-with-next
   1588          void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
   1589          {
   \                     TIM_ICInit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1590            /* Check the parameters */
   1591            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   \   00000006   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000A   0xD018             BEQ.N    ??TIM_ICInit_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable62  ;; 0x40000400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD014             BEQ.N    ??TIM_ICInit_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable63  ;; 0x40000800
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD010             BEQ.N    ??TIM_ICInit_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable65  ;; 0x40010800
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD00C             BEQ.N    ??TIM_ICInit_0
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable65_1  ;; 0x40010c00
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD008             BEQ.N    ??TIM_ICInit_0
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable65_2  ;; 0x40011000
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD004             BEQ.N    ??TIM_ICInit_0
   \   00000034   0xF240 0x6137      MOVW     R1,#+1591
   \   00000038   0x....             LDR.N    R0,??DataTable49
   \   0000003A   0x.... 0x....      BL       assert_failed
   1592            assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
   \                     ??TIM_ICInit_0: (+1)
   \   0000003E   0x8868             LDRH     R0,[R5, #+2]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD00A             BEQ.N    ??TIM_ICInit_1
   \   00000044   0x8868             LDRH     R0,[R5, #+2]
   \   00000046   0x2802             CMP      R0,#+2
   \   00000048   0xD007             BEQ.N    ??TIM_ICInit_1
   \   0000004A   0x8868             LDRH     R0,[R5, #+2]
   \   0000004C   0x280A             CMP      R0,#+10
   \   0000004E   0xD004             BEQ.N    ??TIM_ICInit_1
   \   00000050   0xF44F 0x61C7      MOV      R1,#+1592
   \   00000054   0x....             LDR.N    R0,??DataTable49
   \   00000056   0x.... 0x....      BL       assert_failed
   1593            assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
   \                     ??TIM_ICInit_1: (+1)
   \   0000005A   0x88A8             LDRH     R0,[R5, #+4]
   \   0000005C   0x2801             CMP      R0,#+1
   \   0000005E   0xD00A             BEQ.N    ??TIM_ICInit_2
   \   00000060   0x88A8             LDRH     R0,[R5, #+4]
   \   00000062   0x2802             CMP      R0,#+2
   \   00000064   0xD007             BEQ.N    ??TIM_ICInit_2
   \   00000066   0x88A8             LDRH     R0,[R5, #+4]
   \   00000068   0x2803             CMP      R0,#+3
   \   0000006A   0xD004             BEQ.N    ??TIM_ICInit_2
   \   0000006C   0xF240 0x6139      MOVW     R1,#+1593
   \   00000070   0x....             LDR.N    R0,??DataTable49
   \   00000072   0x.... 0x....      BL       assert_failed
   1594            assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
   \                     ??TIM_ICInit_2: (+1)
   \   00000076   0x88E8             LDRH     R0,[R5, #+6]
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD00D             BEQ.N    ??TIM_ICInit_3
   \   0000007C   0x88E8             LDRH     R0,[R5, #+6]
   \   0000007E   0x2804             CMP      R0,#+4
   \   00000080   0xD00A             BEQ.N    ??TIM_ICInit_3
   \   00000082   0x88E8             LDRH     R0,[R5, #+6]
   \   00000084   0x2808             CMP      R0,#+8
   \   00000086   0xD007             BEQ.N    ??TIM_ICInit_3
   \   00000088   0x88E8             LDRH     R0,[R5, #+6]
   \   0000008A   0x280C             CMP      R0,#+12
   \   0000008C   0xD004             BEQ.N    ??TIM_ICInit_3
   \   0000008E   0xF240 0x613A      MOVW     R1,#+1594
   \   00000092   0x....             LDR.N    R0,??DataTable49
   \   00000094   0x.... 0x....      BL       assert_failed
   1595            assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
   \                     ??TIM_ICInit_3: (+1)
   \   00000098   0x8928             LDRH     R0,[R5, #+8]
   \   0000009A   0x2810             CMP      R0,#+16
   \   0000009C   0xDB04             BLT.N    ??TIM_ICInit_4
   \   0000009E   0xF240 0x613B      MOVW     R1,#+1595
   \   000000A2   0x....             LDR.N    R0,??DataTable49
   \   000000A4   0x.... 0x....      BL       assert_failed
   1596            
   1597            if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
   \                     ??TIM_ICInit_4: (+1)
   \   000000A8   0x8828             LDRH     R0,[R5, #+0]
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xD10A             BNE.N    ??TIM_ICInit_5
   1598            {
   1599              /* TI1 Configuration */
   1600              TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
   1601                         TIM_ICInitStruct->TIM_ICSelection,
   1602                         TIM_ICInitStruct->TIM_ICFilter);
   \   000000AE   0x892B             LDRH     R3,[R5, #+8]
   \   000000B0   0x88AA             LDRH     R2,[R5, #+4]
   \   000000B2   0x8869             LDRH     R1,[R5, #+2]
   \   000000B4   0x0020             MOVS     R0,R4
   \   000000B6   0x.... 0x....      BL       TI1_Config
   1603              /* Set the Input Capture Prescaler value */
   1604              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   000000BA   0x88E9             LDRH     R1,[R5, #+6]
   \   000000BC   0x0020             MOVS     R0,R4
   \   000000BE   0x.... 0x....      BL       TIM_SetIC1Prescaler
   \   000000C2   0xE025             B.N      ??TIM_ICInit_6
   1605            }
   1606            else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
   \                     ??TIM_ICInit_5: (+1)
   \   000000C4   0x8828             LDRH     R0,[R5, #+0]
   \   000000C6   0x2804             CMP      R0,#+4
   \   000000C8   0xD10A             BNE.N    ??TIM_ICInit_7
   1607            {
   1608              /* TI2 Configuration */
   1609              TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
   1610                         TIM_ICInitStruct->TIM_ICSelection,
   1611                         TIM_ICInitStruct->TIM_ICFilter);
   \   000000CA   0x892B             LDRH     R3,[R5, #+8]
   \   000000CC   0x88AA             LDRH     R2,[R5, #+4]
   \   000000CE   0x8869             LDRH     R1,[R5, #+2]
   \   000000D0   0x0020             MOVS     R0,R4
   \   000000D2   0x.... 0x....      BL       TI2_Config
   1612              /* Set the Input Capture Prescaler value */
   1613              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   000000D6   0x88E9             LDRH     R1,[R5, #+6]
   \   000000D8   0x0020             MOVS     R0,R4
   \   000000DA   0x.... 0x....      BL       TIM_SetIC2Prescaler
   \   000000DE   0xE017             B.N      ??TIM_ICInit_6
   1614            }
   1615            else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
   \                     ??TIM_ICInit_7: (+1)
   \   000000E0   0x8828             LDRH     R0,[R5, #+0]
   \   000000E2   0x2808             CMP      R0,#+8
   \   000000E4   0xD10A             BNE.N    ??TIM_ICInit_8
   1616            {
   1617              /* TI3 Configuration */
   1618              TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
   1619                         TIM_ICInitStruct->TIM_ICSelection,
   1620                         TIM_ICInitStruct->TIM_ICFilter);
   \   000000E6   0x892B             LDRH     R3,[R5, #+8]
   \   000000E8   0x88AA             LDRH     R2,[R5, #+4]
   \   000000EA   0x8869             LDRH     R1,[R5, #+2]
   \   000000EC   0x0020             MOVS     R0,R4
   \   000000EE   0x.... 0x....      BL       TI3_Config
   1621              /* Set the Input Capture Prescaler value */
   1622              TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   000000F2   0x88E9             LDRH     R1,[R5, #+6]
   \   000000F4   0x0020             MOVS     R0,R4
   \   000000F6   0x.... 0x....      BL       TIM_SetIC3Prescaler
   \   000000FA   0xE009             B.N      ??TIM_ICInit_6
   1623            }
   1624            else
   1625            {
   1626              /* TI4 Configuration */
   1627              TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
   1628                         TIM_ICInitStruct->TIM_ICSelection,
   1629                         TIM_ICInitStruct->TIM_ICFilter);
   \                     ??TIM_ICInit_8: (+1)
   \   000000FC   0x892B             LDRH     R3,[R5, #+8]
   \   000000FE   0x88AA             LDRH     R2,[R5, #+4]
   \   00000100   0x8869             LDRH     R1,[R5, #+2]
   \   00000102   0x0020             MOVS     R0,R4
   \   00000104   0x.... 0x....      BL       TI4_Config
   1630              /* Set the Input Capture Prescaler value */
   1631              TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   00000108   0x88E9             LDRH     R1,[R5, #+6]
   \   0000010A   0x0020             MOVS     R0,R4
   \   0000010C   0x.... 0x....      BL       TIM_SetIC4Prescaler
   1632            }
   1633          }
   \                     ??TIM_ICInit_6: (+1)
   \   00000110   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1634          
   1635          /**
   1636            * @brief  Fills each TIM_ICInitStruct member with its default value.
   1637            * @param  TIM_ICInitStruct : pointer to a TIM_ICInitTypeDef structure which will
   1638            *         be initialized.
   1639            * @retval None
   1640            */

   \                                 In section .text, align 2, keep-with-next
   1641          void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
   1642          {
   1643            /* Set the default configuration */
   1644            TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
   \                     TIM_ICStructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x8001             STRH     R1,[R0, #+0]
   1645            TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x8041             STRH     R1,[R0, #+2]
   1646            TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0x8081             STRH     R1,[R0, #+4]
   1647            TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x80C1             STRH     R1,[R0, #+6]
   1648            TIM_ICInitStruct->TIM_ICFilter = 0x00;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x8101             STRH     R1,[R0, #+8]
   1649          }
   \   00000014   0x4770             BX       LR               ;; return
   1650          
   1651          /**
   1652            * @brief  Configures the TIM peripheral according to the specified
   1653            *         parameters in the TIM_ICInitStruct to measure an external PWM signal.
   1654            * @param  TIMx: where x can be 2, 3, 4 or 9 to select the TIM peripheral.
   1655            * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
   1656            *         that contains the configuration information for the specified TIM 
   1657            *         peripheral.
   1658            * @retval None
   1659            */

   \                                 In section .text, align 2, keep-with-next
   1660          void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
   1661          {
   \                     TIM_PWMIConfig: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1662            uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
   \   00000006   0x2600             MOVS     R6,#+0
   1663            uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
   \   00000008   0x2701             MOVS     R7,#+1
   1664            /* Check the parameters */
   1665            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   \   0000000A   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000E   0xD010             BEQ.N    ??TIM_PWMIConfig_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable62  ;; 0x40000400
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD00C             BEQ.N    ??TIM_PWMIConfig_0
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable63  ;; 0x40000800
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD008             BEQ.N    ??TIM_PWMIConfig_0
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable65  ;; 0x40010800
   \   00000024   0x4284             CMP      R4,R0
   \   00000026   0xD004             BEQ.N    ??TIM_PWMIConfig_0
   \   00000028   0xF240 0x6181      MOVW     R1,#+1665
   \   0000002C   0x....             LDR.N    R0,??DataTable49
   \   0000002E   0x.... 0x....      BL       assert_failed
   1666            /* Select the Opposite Input Polarity */
   1667            if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
   \                     ??TIM_PWMIConfig_0: (+1)
   \   00000032   0x8868             LDRH     R0,[R5, #+2]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD102             BNE.N    ??TIM_PWMIConfig_1
   1668            {
   1669              icoppositepolarity = TIM_ICPolarity_Falling;
   \   00000038   0x2002             MOVS     R0,#+2
   \   0000003A   0x0006             MOVS     R6,R0
   \   0000003C   0xE001             B.N      ??TIM_PWMIConfig_2
   1670            }
   1671            else
   1672            {
   1673              icoppositepolarity = TIM_ICPolarity_Rising;
   \                     ??TIM_PWMIConfig_1: (+1)
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x0006             MOVS     R6,R0
   1674            }
   1675            /* Select the Opposite Input */
   1676            if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
   \                     ??TIM_PWMIConfig_2: (+1)
   \   00000042   0x88A8             LDRH     R0,[R5, #+4]
   \   00000044   0x2801             CMP      R0,#+1
   \   00000046   0xD102             BNE.N    ??TIM_PWMIConfig_3
   1677            {
   1678              icoppositeselection = TIM_ICSelection_IndirectTI;
   \   00000048   0x2002             MOVS     R0,#+2
   \   0000004A   0x0007             MOVS     R7,R0
   \   0000004C   0xE001             B.N      ??TIM_PWMIConfig_4
   1679            }
   1680            else
   1681            {
   1682              icoppositeselection = TIM_ICSelection_DirectTI;
   \                     ??TIM_PWMIConfig_3: (+1)
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0x0007             MOVS     R7,R0
   1683            }
   1684            if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
   \                     ??TIM_PWMIConfig_4: (+1)
   \   00000052   0x8828             LDRH     R0,[R5, #+0]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD116             BNE.N    ??TIM_PWMIConfig_5
   1685            {
   1686              /* TI1 Configuration */
   1687              TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
   1688                         TIM_ICInitStruct->TIM_ICFilter);
   \   00000058   0x892B             LDRH     R3,[R5, #+8]
   \   0000005A   0x88AA             LDRH     R2,[R5, #+4]
   \   0000005C   0x8869             LDRH     R1,[R5, #+2]
   \   0000005E   0x0020             MOVS     R0,R4
   \   00000060   0x.... 0x....      BL       TI1_Config
   1689              /* Set the Input Capture Prescaler value */
   1690              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   00000064   0x88E9             LDRH     R1,[R5, #+6]
   \   00000066   0x0020             MOVS     R0,R4
   \   00000068   0x.... 0x....      BL       TIM_SetIC1Prescaler
   1691              /* TI2 Configuration */
   1692              TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
   \   0000006C   0x892B             LDRH     R3,[R5, #+8]
   \   0000006E   0x003A             MOVS     R2,R7
   \   00000070   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000072   0x0031             MOVS     R1,R6
   \   00000074   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000076   0x0020             MOVS     R0,R4
   \   00000078   0x.... 0x....      BL       TI2_Config
   1693              /* Set the Input Capture Prescaler value */
   1694              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   0000007C   0x88E9             LDRH     R1,[R5, #+6]
   \   0000007E   0x0020             MOVS     R0,R4
   \   00000080   0x.... 0x....      BL       TIM_SetIC2Prescaler
   \   00000084   0xE015             B.N      ??TIM_PWMIConfig_6
   1695            }
   1696            else
   1697            { 
   1698              /* TI2 Configuration */
   1699              TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
   1700                         TIM_ICInitStruct->TIM_ICFilter);
   \                     ??TIM_PWMIConfig_5: (+1)
   \   00000086   0x892B             LDRH     R3,[R5, #+8]
   \   00000088   0x88AA             LDRH     R2,[R5, #+4]
   \   0000008A   0x8869             LDRH     R1,[R5, #+2]
   \   0000008C   0x0020             MOVS     R0,R4
   \   0000008E   0x.... 0x....      BL       TI2_Config
   1701              /* Set the Input Capture Prescaler value */
   1702              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   00000092   0x88E9             LDRH     R1,[R5, #+6]
   \   00000094   0x0020             MOVS     R0,R4
   \   00000096   0x.... 0x....      BL       TIM_SetIC2Prescaler
   1703              /* TI1 Configuration */
   1704              TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
   \   0000009A   0x892B             LDRH     R3,[R5, #+8]
   \   0000009C   0x003A             MOVS     R2,R7
   \   0000009E   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000A0   0x0031             MOVS     R1,R6
   \   000000A2   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000A4   0x0020             MOVS     R0,R4
   \   000000A6   0x.... 0x....      BL       TI1_Config
   1705              /* Set the Input Capture Prescaler value */
   1706              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   000000AA   0x88E9             LDRH     R1,[R5, #+6]
   \   000000AC   0x0020             MOVS     R0,R4
   \   000000AE   0x.... 0x....      BL       TIM_SetIC1Prescaler
   1707            }
   1708          }
   \                     ??TIM_PWMIConfig_6: (+1)
   \   000000B2   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1709          
   1710          /**
   1711            * @brief  Gets the TIMx Input Capture 1 value.
   1712            * @param  TIMx: where x can be 2, 3, 4, 9, 10 or 11 to select the TIM peripheral.
   1713            * @retval Capture Compare 1 Register value.
   1714          
   1715            */

   \                                 In section .text, align 2, keep-with-next
   1716          uint32_t TIM_GetCapture1(TIM_TypeDef* TIMx)
   1717          {
   \                     TIM_GetCapture1: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1718            /* Check the parameters */
   1719            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   \   00000004   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   00000008   0xD018             BEQ.N    ??TIM_GetCapture1_0
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable62  ;; 0x40000400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD014             BEQ.N    ??TIM_GetCapture1_0
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable63  ;; 0x40000800
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD010             BEQ.N    ??TIM_GetCapture1_0
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable65  ;; 0x40010800
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD00C             BEQ.N    ??TIM_GetCapture1_0
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable65_1  ;; 0x40010c00
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD008             BEQ.N    ??TIM_GetCapture1_0
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable65_2  ;; 0x40011000
   \   0000002E   0x4284             CMP      R4,R0
   \   00000030   0xD004             BEQ.N    ??TIM_GetCapture1_0
   \   00000032   0xF240 0x61B7      MOVW     R1,#+1719
   \   00000036   0x....             LDR.N    R0,??DataTable49
   \   00000038   0x.... 0x....      BL       assert_failed
   1720            
   1721            /* Get the Capture 1 Register value */
   1722            return TIMx->CCR1;
   \                     ??TIM_GetCapture1_0: (+1)
   \   0000003C   0x8EA0             LDRH     R0,[R4, #+52]
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
   1723          }
   1724          
   1725          /**
   1726            * @brief  Gets the TIMx Input Capture 2 value.
   1727            * @param  TIMx: where x can be 2, 3, 4 or 9 to select the TIM peripheral.
   1728            * @retval Capture Compare 2 Register value.
   1729          
   1730            */

   \                                 In section .text, align 2, keep-with-next
   1731          uint32_t TIM_GetCapture2(TIM_TypeDef* TIMx)
   1732          {
   \                     TIM_GetCapture2: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1733            /* Check the parameters */
   1734            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   \   00000004   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   00000008   0xD010             BEQ.N    ??TIM_GetCapture2_0
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable62  ;; 0x40000400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD00C             BEQ.N    ??TIM_GetCapture2_0
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable63  ;; 0x40000800
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD008             BEQ.N    ??TIM_GetCapture2_0
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable65  ;; 0x40010800
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD004             BEQ.N    ??TIM_GetCapture2_0
   \   00000022   0xF240 0x61C6      MOVW     R1,#+1734
   \   00000026   0x....             LDR.N    R0,??DataTable49
   \   00000028   0x.... 0x....      BL       assert_failed
   1735            
   1736            /* Get the Capture 2 Register value */
   1737            return TIMx->CCR2;
   \                     ??TIM_GetCapture2_0: (+1)
   \   0000002C   0x8F20             LDRH     R0,[R4, #+56]
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
   1738          }
   1739          
   1740          /**
   1741            * @brief  Gets the TIMx Input Capture 3 value.
   1742            * @param  TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1743            * @retval Capture Compare 3 Register value.
   1744            */

   \                                 In section .text, align 2, keep-with-next
   1745          uint32_t TIM_GetCapture3(TIM_TypeDef* TIMx)
   1746          {
   \                     TIM_GetCapture3: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1747            /* Check the parameters */
   1748            assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
   \   00000004   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   00000008   0xD00C             BEQ.N    ??TIM_GetCapture3_0
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable62  ;; 0x40000400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD008             BEQ.N    ??TIM_GetCapture3_0
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable63  ;; 0x40000800
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD004             BEQ.N    ??TIM_GetCapture3_0
   \   0000001A   0xF240 0x61D4      MOVW     R1,#+1748
   \   0000001E   0x....             LDR.N    R0,??DataTable49
   \   00000020   0x.... 0x....      BL       assert_failed
   1749            
   1750            /* Get the Capture 3 Register value */
   1751            return TIMx->CCR3;
   \                     ??TIM_GetCapture3_0: (+1)
   \   00000024   0x8FA0             LDRH     R0,[R4, #+60]
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
   1752          }
   1753          
   1754          /**
   1755            * @brief  Gets the TIMx Input Capture 4 value.
   1756            * @param  TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1757            * @retval Capture Compare 4 Register value.
   1758            */

   \                                 In section .text, align 2, keep-with-next
   1759          uint32_t TIM_GetCapture4(TIM_TypeDef* TIMx)
   1760          {
   \                     TIM_GetCapture4: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1761            /* Check the parameters */
   1762            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   \   00000004   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   00000008   0xD00D             BEQ.N    ??TIM_GetCapture4_0
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable62  ;; 0x40000400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD009             BEQ.N    ??TIM_GetCapture4_0
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable63  ;; 0x40000800
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD005             BEQ.N    ??TIM_GetCapture4_0
   \   0000001A   0xF240 0x61E2      MOVW     R1,#+1762
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable73
   \   00000022   0x.... 0x....      BL       assert_failed
   1763            
   1764            /* Get the Capture 4 Register value */
   1765            return TIMx->CCR4;
   \                     ??TIM_GetCapture4_0: (+1)
   \   00000026   0xF8B4 0x0040      LDRH     R0,[R4, #+64]
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
   1766          }
   1767          
   1768          /**
   1769            * @brief  Sets the TIMx Input Capture 1 prescaler.
   1770            * @param  TIMx: where x can be 2, 3, 4, 9, 10 or 11 to select the TIM peripheral.
   1771            * @param  TIM_ICPSC: specifies the Input Capture1 prescaler new value.
   1772            *   This parameter can be one of the following values:
   1773            *     @arg TIM_ICPSC_DIV1: no prescaler
   1774            *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   1775            *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   1776            *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   1777            * @retval None
   1778            */

   \                                 In section .text, align 2, keep-with-next
   1779          void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   1780          {
   \                     TIM_SetIC1Prescaler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1781            /* Check the parameters */
   1782            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   \   00000006   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000A   0xD019             BEQ.N    ??TIM_SetIC1Prescaler_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable62  ;; 0x40000400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD015             BEQ.N    ??TIM_SetIC1Prescaler_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable63  ;; 0x40000800
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD011             BEQ.N    ??TIM_SetIC1Prescaler_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable65  ;; 0x40010800
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD00D             BEQ.N    ??TIM_SetIC1Prescaler_0
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable65_1  ;; 0x40010c00
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD009             BEQ.N    ??TIM_SetIC1Prescaler_0
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable65_2  ;; 0x40011000
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD005             BEQ.N    ??TIM_SetIC1Prescaler_0
   \   00000034   0xF240 0x61F6      MOVW     R1,#+1782
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable73
   \   0000003C   0x.... 0x....      BL       assert_failed
   1783            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   \                     ??TIM_SetIC1Prescaler_0: (+1)
   \   00000040   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000042   0x2D00             CMP      R5,#+0
   \   00000044   0xD00E             BEQ.N    ??TIM_SetIC1Prescaler_1
   \   00000046   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000048   0x2D04             CMP      R5,#+4
   \   0000004A   0xD00B             BEQ.N    ??TIM_SetIC1Prescaler_1
   \   0000004C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004E   0x2D08             CMP      R5,#+8
   \   00000050   0xD008             BEQ.N    ??TIM_SetIC1Prescaler_1
   \   00000052   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000054   0x2D0C             CMP      R5,#+12
   \   00000056   0xD005             BEQ.N    ??TIM_SetIC1Prescaler_1
   \   00000058   0xF240 0x61F7      MOVW     R1,#+1783
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable73
   \   00000060   0x.... 0x....      BL       assert_failed
   1784            
   1785            /* Reset the IC1PSC Bits */
   1786            TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC1PSC);
   \                     ??TIM_SetIC1Prescaler_1: (+1)
   \   00000064   0x8B20             LDRH     R0,[R4, #+24]
   \   00000066   0xF64F 0x71F3      MOVW     R1,#+65523
   \   0000006A   0x4008             ANDS     R0,R1,R0
   \   0000006C   0x8320             STRH     R0,[R4, #+24]
   1787            /* Set the IC1PSC value */
   1788            TIMx->CCMR1 |= TIM_ICPSC;
   \   0000006E   0x8B20             LDRH     R0,[R4, #+24]
   \   00000070   0x4328             ORRS     R0,R5,R0
   \   00000072   0x8320             STRH     R0,[R4, #+24]
   1789          }
   \   00000074   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1790          
   1791          /**
   1792            * @brief  Sets the TIMx Input Capture 2 prescaler.
   1793            * @param  TIMx: where x can be 2, 3, 4 or 9 to select the TIM peripheral.
   1794            * @param  TIM_ICPSC: specifies the Input Capture2 prescaler new value.
   1795            *   This parameter can be one of the following values:
   1796            *     @arg TIM_ICPSC_DIV1: no prescaler
   1797            *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   1798            *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   1799            *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   1800            * @retval None
   1801            */

   \                                 In section .text, align 2, keep-with-next
   1802          void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   1803          {
   \                     TIM_SetIC2Prescaler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1804            /* Check the parameters */
   1805            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   \   00000006   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000A   0xD011             BEQ.N    ??TIM_SetIC2Prescaler_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable62  ;; 0x40000400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD00D             BEQ.N    ??TIM_SetIC2Prescaler_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable63  ;; 0x40000800
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD009             BEQ.N    ??TIM_SetIC2Prescaler_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable65  ;; 0x40010800
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD005             BEQ.N    ??TIM_SetIC2Prescaler_0
   \   00000024   0xF240 0x710D      MOVW     R1,#+1805
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable73
   \   0000002C   0x.... 0x....      BL       assert_failed
   1806            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   \                     ??TIM_SetIC2Prescaler_0: (+1)
   \   00000030   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD00E             BEQ.N    ??TIM_SetIC2Prescaler_1
   \   00000036   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000038   0x2D04             CMP      R5,#+4
   \   0000003A   0xD00B             BEQ.N    ??TIM_SetIC2Prescaler_1
   \   0000003C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000003E   0x2D08             CMP      R5,#+8
   \   00000040   0xD008             BEQ.N    ??TIM_SetIC2Prescaler_1
   \   00000042   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000044   0x2D0C             CMP      R5,#+12
   \   00000046   0xD005             BEQ.N    ??TIM_SetIC2Prescaler_1
   \   00000048   0xF240 0x710E      MOVW     R1,#+1806
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable73
   \   00000050   0x.... 0x....      BL       assert_failed
   1807            
   1808            /* Reset the IC2PSC Bits */
   1809            TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC2PSC);
   \                     ??TIM_SetIC2Prescaler_1: (+1)
   \   00000054   0x8B20             LDRH     R0,[R4, #+24]
   \   00000056   0xF24F 0x31FF      MOVW     R1,#+62463
   \   0000005A   0x4008             ANDS     R0,R1,R0
   \   0000005C   0x8320             STRH     R0,[R4, #+24]
   1810            /* Set the IC2PSC value */
   1811            TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
   \   0000005E   0x8B20             LDRH     R0,[R4, #+24]
   \   00000060   0xEA50 0x2005      ORRS     R0,R0,R5, LSL #+8
   \   00000064   0x8320             STRH     R0,[R4, #+24]
   1812          }
   \   00000066   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1813          
   1814          /**
   1815            * @brief  Sets the TIMx Input Capture 3 prescaler.
   1816            * @param  TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1817            * @param  TIM_ICPSC: specifies the Input Capture3 prescaler new value.
   1818            *   This parameter can be one of the following values:
   1819            *     @arg TIM_ICPSC_DIV1: no prescaler
   1820            *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   1821            *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   1822            *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   1823            * @retval None
   1824            */

   \                                 In section .text, align 2, keep-with-next
   1825          void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   1826          {
   \                     TIM_SetIC3Prescaler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1827            /* Check the parameters */
   1828            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   \   00000006   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000A   0xD00D             BEQ.N    ??TIM_SetIC3Prescaler_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable62  ;; 0x40000400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD009             BEQ.N    ??TIM_SetIC3Prescaler_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable63  ;; 0x40000800
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD005             BEQ.N    ??TIM_SetIC3Prescaler_0
   \   0000001C   0xF240 0x7124      MOVW     R1,#+1828
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable73
   \   00000024   0x.... 0x....      BL       assert_failed
   1829            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   \                     ??TIM_SetIC3Prescaler_0: (+1)
   \   00000028   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD00E             BEQ.N    ??TIM_SetIC3Prescaler_1
   \   0000002E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000030   0x2D04             CMP      R5,#+4
   \   00000032   0xD00B             BEQ.N    ??TIM_SetIC3Prescaler_1
   \   00000034   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000036   0x2D08             CMP      R5,#+8
   \   00000038   0xD008             BEQ.N    ??TIM_SetIC3Prescaler_1
   \   0000003A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000003C   0x2D0C             CMP      R5,#+12
   \   0000003E   0xD005             BEQ.N    ??TIM_SetIC3Prescaler_1
   \   00000040   0xF240 0x7125      MOVW     R1,#+1829
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable73
   \   00000048   0x.... 0x....      BL       assert_failed
   1830            
   1831            /* Reset the IC3PSC Bits */
   1832            TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC3PSC);
   \                     ??TIM_SetIC3Prescaler_1: (+1)
   \   0000004C   0x8BA0             LDRH     R0,[R4, #+28]
   \   0000004E   0xF64F 0x71F3      MOVW     R1,#+65523
   \   00000052   0x4008             ANDS     R0,R1,R0
   \   00000054   0x83A0             STRH     R0,[R4, #+28]
   1833            /* Set the IC3PSC value */
   1834            TIMx->CCMR2 |= TIM_ICPSC;
   \   00000056   0x8BA0             LDRH     R0,[R4, #+28]
   \   00000058   0x4328             ORRS     R0,R5,R0
   \   0000005A   0x83A0             STRH     R0,[R4, #+28]
   1835          }
   \   0000005C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1836          
   1837          /**
   1838            * @brief  Sets the TIMx Input Capture 4 prescaler.
   1839            * @param  TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1840            * @param  TIM_ICPSC: specifies the Input Capture4 prescaler new value.
   1841            *   This parameter can be one of the following values:
   1842            *     @arg TIM_ICPSC_DIV1: no prescaler
   1843            *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   1844            *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   1845            *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   1846            * @retval None
   1847            */

   \                                 In section .text, align 2, keep-with-next
   1848          void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   1849          {  
   \                     TIM_SetIC4Prescaler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1850            /* Check the parameters */
   1851            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   \   00000006   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000A   0xD00D             BEQ.N    ??TIM_SetIC4Prescaler_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable62  ;; 0x40000400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD009             BEQ.N    ??TIM_SetIC4Prescaler_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable63  ;; 0x40000800
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD005             BEQ.N    ??TIM_SetIC4Prescaler_0
   \   0000001C   0xF240 0x713B      MOVW     R1,#+1851
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable73
   \   00000024   0x.... 0x....      BL       assert_failed
   1852            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   \                     ??TIM_SetIC4Prescaler_0: (+1)
   \   00000028   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD00E             BEQ.N    ??TIM_SetIC4Prescaler_1
   \   0000002E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000030   0x2D04             CMP      R5,#+4
   \   00000032   0xD00B             BEQ.N    ??TIM_SetIC4Prescaler_1
   \   00000034   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000036   0x2D08             CMP      R5,#+8
   \   00000038   0xD008             BEQ.N    ??TIM_SetIC4Prescaler_1
   \   0000003A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000003C   0x2D0C             CMP      R5,#+12
   \   0000003E   0xD005             BEQ.N    ??TIM_SetIC4Prescaler_1
   \   00000040   0xF240 0x713C      MOVW     R1,#+1852
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable73
   \   00000048   0x.... 0x....      BL       assert_failed
   1853            
   1854            /* Reset the IC4PSC Bits */
   1855            TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC4PSC);
   \                     ??TIM_SetIC4Prescaler_1: (+1)
   \   0000004C   0x8BA0             LDRH     R0,[R4, #+28]
   \   0000004E   0xF24F 0x31FF      MOVW     R1,#+62463
   \   00000052   0x4008             ANDS     R0,R1,R0
   \   00000054   0x83A0             STRH     R0,[R4, #+28]
   1856            /* Set the IC4PSC value */
   1857            TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
   \   00000056   0x8BA0             LDRH     R0,[R4, #+28]
   \   00000058   0xEA50 0x2005      ORRS     R0,R0,R5, LSL #+8
   \   0000005C   0x83A0             STRH     R0,[R4, #+28]
   1858          }
   \   0000005E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1859          
   1860          /**
   1861            * @}
   1862            */
   1863          
   1864          /** @defgroup TIM_Group4 Interrupts DMA and flags management functions
   1865           *  @brief    Interrupts, DMA and flags management functions 
   1866           *
   1867          @verbatim   
   1868           ===============================================================================
   1869                           Interrupts, DMA and flags management functions
   1870           ===============================================================================  
   1871          
   1872          @endverbatim
   1873            * @{
   1874            */
   1875          
   1876          /**
   1877            * @brief  Enables or disables the specified TIM interrupts.
   1878            * @param  TIMx: where x can be 2 to 11 to select the TIMx peripheral.
   1879            * @param  TIM_IT: specifies the TIM interrupts sources to be enabled or disabled.
   1880            *   This parameter can be any combination of the following values:
   1881            *     @arg TIM_IT_Update: TIM update Interrupt source
   1882            *     @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
   1883            *     @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
   1884            *     @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
   1885            *     @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
   1886            *     @arg TIM_IT_Trigger: TIM Trigger Interrupt source
   1887            * @note 
   1888            *   - TIM6 and TIM7 can only generate an update interrupt.  
   1889            *   - TIM_IT_CC2, TIM_IT_CC3, TIM_IT_CC4 and TIM_IT_Trigger can not be used with TIM10 and TIM11
   1890            *   - TIM_IT_CC3, TIM_IT_CC4 can not be used with TIM9.   
   1891            * @param  NewState: new state of the TIM interrupts.
   1892            *         This parameter can be: ENABLE or DISABLE.
   1893            * @retval None
   1894            */

   \                                 In section .text, align 2, keep-with-next
   1895          void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
   1896          {  
   \                     TIM_ITConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1897            /* Check the parameters */
   1898            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   \   00000008   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000C   0xD021             BEQ.N    ??TIM_ITConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable62  ;; 0x40000400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD01D             BEQ.N    ??TIM_ITConfig_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable63  ;; 0x40000800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD019             BEQ.N    ??TIM_ITConfig_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable72  ;; 0x40001000
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD015             BEQ.N    ??TIM_ITConfig_0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable72_1  ;; 0x40001400
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD011             BEQ.N    ??TIM_ITConfig_0
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable67  ;; 0x40010800
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD00D             BEQ.N    ??TIM_ITConfig_0
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable67_1  ;; 0x40010c00
   \   0000003A   0x4284             CMP      R4,R0
   \   0000003C   0xD009             BEQ.N    ??TIM_ITConfig_0
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable67_2  ;; 0x40011000
   \   00000042   0x4284             CMP      R4,R0
   \   00000044   0xD005             BEQ.N    ??TIM_ITConfig_0
   \   00000046   0xF240 0x716A      MOVW     R1,#+1898
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable73
   \   0000004E   0x.... 0x....      BL       assert_failed
   1899            assert_param(IS_TIM_IT(TIM_IT));
   \                     ??TIM_ITConfig_0: (+1)
   \   00000052   0xF64F 0x70A0      MOVW     R0,#+65440
   \   00000056   0x4205             TST      R5,R0
   \   00000058   0xD102             BNE.N    ??TIM_ITConfig_1
   \   0000005A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000005C   0x2D00             CMP      R5,#+0
   \   0000005E   0xD105             BNE.N    ??TIM_ITConfig_2
   \                     ??TIM_ITConfig_1: (+1)
   \   00000060   0xF240 0x716B      MOVW     R1,#+1899
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable73
   \   00000068   0x.... 0x....      BL       assert_failed
   1900            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??TIM_ITConfig_2: (+1)
   \   0000006C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000006E   0x2E00             CMP      R6,#+0
   \   00000070   0xD008             BEQ.N    ??TIM_ITConfig_3
   \   00000072   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000074   0x2E01             CMP      R6,#+1
   \   00000076   0xD005             BEQ.N    ??TIM_ITConfig_3
   \   00000078   0xF240 0x716C      MOVW     R1,#+1900
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable73
   \   00000080   0x.... 0x....      BL       assert_failed
   1901            
   1902            if (NewState != DISABLE)
   \                     ??TIM_ITConfig_3: (+1)
   \   00000084   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000086   0x2E00             CMP      R6,#+0
   \   00000088   0xD003             BEQ.N    ??TIM_ITConfig_4
   1903            {
   1904              /* Enable the Interrupt sources */
   1905              TIMx->DIER |= TIM_IT;
   \   0000008A   0x89A0             LDRH     R0,[R4, #+12]
   \   0000008C   0x4328             ORRS     R0,R5,R0
   \   0000008E   0x81A0             STRH     R0,[R4, #+12]
   \   00000090   0xE002             B.N      ??TIM_ITConfig_5
   1906            }
   1907            else
   1908            {
   1909              /* Disable the Interrupt sources */
   1910              TIMx->DIER &= (uint16_t)~TIM_IT;
   \                     ??TIM_ITConfig_4: (+1)
   \   00000092   0x89A0             LDRH     R0,[R4, #+12]
   \   00000094   0x43A8             BICS     R0,R0,R5
   \   00000096   0x81A0             STRH     R0,[R4, #+12]
   1911            }
   1912          }
   \                     ??TIM_ITConfig_5: (+1)
   \   00000098   0xBD70             POP      {R4-R6,PC}       ;; return
   1913          
   1914          /**
   1915            * @brief  Configures the TIMx event to be generate by software.
   1916            * @param  TIMx: where x can be 2 to 11 to select the TIM peripheral.
   1917            * @param  TIM_EventSource: specifies the event source.
   1918            *   This parameter can be one or more of the following values:	   
   1919            *     @arg TIM_EventSource_Update: Timer update Event source
   1920            *     @arg TIM_EventSource_CC1: Timer Capture Compare 1 Event source
   1921            *     @arg TIM_EventSource_CC2: Timer Capture Compare 2 Event source
   1922            *     @arg TIM_EventSource_CC3: Timer Capture Compare 3 Event source
   1923            *     @arg TIM_EventSource_CC4: Timer Capture Compare 4 Event source 
   1924            *     @arg TIM_EventSource_Trigger: Timer Trigger Event source
   1925            * @note 
   1926            *   - TIM6 and TIM7 can only generate an update event. 
   1927            *   - TIM9 can only generate an update event, Capture Compare 1 event, 
   1928            *     Capture Compare 2 event and TIM_EventSource_Trigger.  
   1929            *   - TIM10 and TIM11 can only generate an update event and Capture Compare 1 event.            
   1930            * @retval None
   1931            */

   \                                 In section .text, align 2, keep-with-next
   1932          void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
   1933          { 
   \                     TIM_GenerateEvent: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1934            /* Check the parameters */
   1935            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   \   00000006   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000A   0xD021             BEQ.N    ??TIM_GenerateEvent_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable62  ;; 0x40000400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD01D             BEQ.N    ??TIM_GenerateEvent_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable63  ;; 0x40000800
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD019             BEQ.N    ??TIM_GenerateEvent_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable72  ;; 0x40001000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD015             BEQ.N    ??TIM_GenerateEvent_0
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable72_1  ;; 0x40001400
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD011             BEQ.N    ??TIM_GenerateEvent_0
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable67  ;; 0x40010800
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD00D             BEQ.N    ??TIM_GenerateEvent_0
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable67_1  ;; 0x40010c00
   \   00000038   0x4284             CMP      R4,R0
   \   0000003A   0xD009             BEQ.N    ??TIM_GenerateEvent_0
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable67_2  ;; 0x40011000
   \   00000040   0x4284             CMP      R4,R0
   \   00000042   0xD005             BEQ.N    ??TIM_GenerateEvent_0
   \   00000044   0xF240 0x718F      MOVW     R1,#+1935
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable73
   \   0000004C   0x.... 0x....      BL       assert_failed
   1936            assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource)); 
   \                     ??TIM_GenerateEvent_0: (+1)
   \   00000050   0xF64F 0x70A0      MOVW     R0,#+65440
   \   00000054   0x4205             TST      R5,R0
   \   00000056   0xD102             BNE.N    ??TIM_GenerateEvent_1
   \   00000058   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000005A   0x2D00             CMP      R5,#+0
   \   0000005C   0xD105             BNE.N    ??TIM_GenerateEvent_2
   \                     ??TIM_GenerateEvent_1: (+1)
   \   0000005E   0xF44F 0x61F2      MOV      R1,#+1936
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable73
   \   00000066   0x.... 0x....      BL       assert_failed
   1937            /* Set the event sources */
   1938            TIMx->EGR = TIM_EventSource;
   \                     ??TIM_GenerateEvent_2: (+1)
   \   0000006A   0x82A5             STRH     R5,[R4, #+20]
   1939          }
   \   0000006C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1940          
   1941          /**
   1942            * @brief  Checks whether the specified TIM flag is set or not.
   1943            * @param  TIMx: where x can be 2 to 11 to select the TIM peripheral.
   1944            * @param  TIM_FLAG: specifies the flag to check.
   1945            *   This parameter can be one of the following values:
   1946            *     @arg TIM_FLAG_Update: TIM update Flag
   1947            *     @arg TIM_FLAG_CC1: TIM Capture Compare 1 Flag
   1948            *     @arg TIM_FLAG_CC2: TIM Capture Compare 2 Flag
   1949            *     @arg TIM_FLAG_CC3: TIM Capture Compare 3 Flag
   1950            *     @arg TIM_FLAG_CC4: TIM Capture Compare 4 Flag
   1951            *     @arg TIM_FLAG_Trigger: TIM Trigger Flag
   1952            *     @arg TIM_FLAG_CC1OF: TIM Capture Compare 1 overcapture Flag
   1953            *     @arg TIM_FLAG_CC2OF: TIM Capture Compare 2 overcapture Flag
   1954            *     @arg TIM_FLAG_CC3OF: TIM Capture Compare 3 overcapture Flag
   1955            *     @arg TIM_FLAG_CC4OF: TIM Capture Compare 4 overcapture Flag
   1956            * @note
   1957            *   - TIM6 and TIM7 can have only one update flag.
   1958            *   - TIM9 can have only update flag, TIM_FLAG_CC1, TIM_FLAG_CC2 and TIM_FLAG_Trigger,
   1959            *     TIM_FLAG_CC1OF or TIM_FLAG_CC2OF flags  
   1960            *   - TIM10 and TIM11 can have only update flag, TIM_FLAG_CC1 or TIM_FLAG_CC1OF flags         
   1961            * @retval The new state of TIM_FLAG (SET or RESET).
   1962            */

   \                                 In section .text, align 2, keep-with-next
   1963          FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
   1964          { 
   \                     TIM_GetFlagStatus: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1965            ITStatus bitstatus = RESET; 
   \   00000006   0x2600             MOVS     R6,#+0
   1966             
   1967            /* Check the parameters */
   1968            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   \   00000008   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000C   0xD021             BEQ.N    ??TIM_GetFlagStatus_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable62  ;; 0x40000400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD01D             BEQ.N    ??TIM_GetFlagStatus_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable63  ;; 0x40000800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD019             BEQ.N    ??TIM_GetFlagStatus_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable72  ;; 0x40001000
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD015             BEQ.N    ??TIM_GetFlagStatus_0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable72_1  ;; 0x40001400
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD011             BEQ.N    ??TIM_GetFlagStatus_0
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable67  ;; 0x40010800
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD00D             BEQ.N    ??TIM_GetFlagStatus_0
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable67_1  ;; 0x40010c00
   \   0000003A   0x4284             CMP      R4,R0
   \   0000003C   0xD009             BEQ.N    ??TIM_GetFlagStatus_0
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable67_2  ;; 0x40011000
   \   00000042   0x4284             CMP      R4,R0
   \   00000044   0xD005             BEQ.N    ??TIM_GetFlagStatus_0
   \   00000046   0xF44F 0x61F6      MOV      R1,#+1968
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable73
   \   0000004E   0x.... 0x....      BL       assert_failed
   1969            assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
   \                     ??TIM_GetFlagStatus_0: (+1)
   \   00000052   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000054   0x2D01             CMP      R5,#+1
   \   00000056   0xD024             BEQ.N    ??TIM_GetFlagStatus_1
   \   00000058   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000005A   0x2D02             CMP      R5,#+2
   \   0000005C   0xD021             BEQ.N    ??TIM_GetFlagStatus_1
   \   0000005E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000060   0x2D04             CMP      R5,#+4
   \   00000062   0xD01E             BEQ.N    ??TIM_GetFlagStatus_1
   \   00000064   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000066   0x2D08             CMP      R5,#+8
   \   00000068   0xD01B             BEQ.N    ??TIM_GetFlagStatus_1
   \   0000006A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000006C   0x2D10             CMP      R5,#+16
   \   0000006E   0xD018             BEQ.N    ??TIM_GetFlagStatus_1
   \   00000070   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000072   0x2D40             CMP      R5,#+64
   \   00000074   0xD015             BEQ.N    ??TIM_GetFlagStatus_1
   \   00000076   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000078   0xF5B5 0x7F00      CMP      R5,#+512
   \   0000007C   0xD011             BEQ.N    ??TIM_GetFlagStatus_1
   \   0000007E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000080   0xF5B5 0x6F80      CMP      R5,#+1024
   \   00000084   0xD00D             BEQ.N    ??TIM_GetFlagStatus_1
   \   00000086   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000088   0xF5B5 0x6F00      CMP      R5,#+2048
   \   0000008C   0xD009             BEQ.N    ??TIM_GetFlagStatus_1
   \   0000008E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000090   0xF5B5 0x5F80      CMP      R5,#+4096
   \   00000094   0xD005             BEQ.N    ??TIM_GetFlagStatus_1
   \   00000096   0xF240 0x71B1      MOVW     R1,#+1969
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable73
   \   0000009E   0x.... 0x....      BL       assert_failed
   1970            
   1971            if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
   \                     ??TIM_GetFlagStatus_1: (+1)
   \   000000A2   0x8A20             LDRH     R0,[R4, #+16]
   \   000000A4   0x4228             TST      R0,R5
   \   000000A6   0xD002             BEQ.N    ??TIM_GetFlagStatus_2
   1972            {
   1973              bitstatus = SET;
   \   000000A8   0x2001             MOVS     R0,#+1
   \   000000AA   0x0006             MOVS     R6,R0
   \   000000AC   0xE001             B.N      ??TIM_GetFlagStatus_3
   1974            }
   1975            else
   1976            {
   1977              bitstatus = RESET;
   \                     ??TIM_GetFlagStatus_2: (+1)
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0x0006             MOVS     R6,R0
   1978            }
   1979            return bitstatus;
   \                     ??TIM_GetFlagStatus_3: (+1)
   \   000000B2   0x0030             MOVS     R0,R6
   \   000000B4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B6   0xBD70             POP      {R4-R6,PC}       ;; return
   1980          }
   1981          
   1982          /**
   1983            * @brief  Clears the TIMx's pending flags.
   1984            * @param  TIMx: where x can be 2 to 11 to select the TIM peripheral.
   1985            * @param  TIM_FLAG: specifies the flag bit to clear.
   1986            *   This parameter can be any combination of the following values:
   1987            *     @arg TIM_FLAG_Update: TIM update Flag
   1988            *     @arg TIM_FLAG_CC1: TIM Capture Compare 1 Flag
   1989            *     @arg TIM_FLAG_CC2: TIM Capture Compare 2 Flag
   1990            *     @arg TIM_FLAG_CC3: TIM Capture Compare 3 Flag
   1991            *     @arg TIM_FLAG_CC4: TIM Capture Compare 4 Flag
   1992            *     @arg TIM_FLAG_Trigger: TIM Trigger Flag
   1993            *     @arg TIM_FLAG_CC1OF: TIM Capture Compare 1 overcapture Flag
   1994            *     @arg TIM_FLAG_CC2OF: TIM Capture Compare 2 overcapture Flag
   1995            *     @arg TIM_FLAG_CC3OF: TIM Capture Compare 3 overcapture Flag
   1996            *     @arg TIM_FLAG_CC4OF: TIM Capture Compare 4 overcapture Flag
   1997            * @note
   1998            *   - TIM6 and TIM7 can have only one update flag. 
   1999            *   - TIM9 can have only update flag, TIM_FLAG_CC1, TIM_FLAG_CC2 and TIM_FLAG_Trigger flags
   2000            *     TIM_FLAG_CC1OF or TIM_FLAG_CC2OF flags  
   2001            *   - TIM10 and TIM11 can have only update flag, TIM_FLAG_CC1
   2002            *     or TIM_FLAG_CC1OF flags      
   2003            * @retval None
   2004            */

   \                                 In section .text, align 2, keep-with-next
   2005          void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
   2006          {  
   \                     TIM_ClearFlag: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2007            /* Check the parameters */
   2008            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   \   00000006   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000A   0xD021             BEQ.N    ??TIM_ClearFlag_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable62  ;; 0x40000400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD01D             BEQ.N    ??TIM_ClearFlag_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable63  ;; 0x40000800
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD019             BEQ.N    ??TIM_ClearFlag_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable72  ;; 0x40001000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD015             BEQ.N    ??TIM_ClearFlag_0
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable72_1  ;; 0x40001400
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD011             BEQ.N    ??TIM_ClearFlag_0
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable67  ;; 0x40010800
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD00D             BEQ.N    ??TIM_ClearFlag_0
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable67_1  ;; 0x40010c00
   \   00000038   0x4284             CMP      R4,R0
   \   0000003A   0xD009             BEQ.N    ??TIM_ClearFlag_0
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable67_2  ;; 0x40011000
   \   00000040   0x4284             CMP      R4,R0
   \   00000042   0xD005             BEQ.N    ??TIM_ClearFlag_0
   \   00000044   0xF44F 0x61FB      MOV      R1,#+2008
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable73
   \   0000004C   0x.... 0x....      BL       assert_failed
   2009            assert_param(IS_TIM_CLEAR_FLAG(TIM_FLAG));
   \                     ??TIM_ClearFlag_0: (+1)
   \   00000050   0xF24E 0x10A0      MOVW     R0,#+57760
   \   00000054   0x4205             TST      R5,R0
   \   00000056   0xD102             BNE.N    ??TIM_ClearFlag_1
   \   00000058   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000005A   0x2D00             CMP      R5,#+0
   \   0000005C   0xD105             BNE.N    ??TIM_ClearFlag_2
   \                     ??TIM_ClearFlag_1: (+1)
   \   0000005E   0xF240 0x71D9      MOVW     R1,#+2009
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable73
   \   00000066   0x.... 0x....      BL       assert_failed
   2010             
   2011            /* Clear the flags */
   2012            TIMx->SR = (uint16_t)~TIM_FLAG;
   \                     ??TIM_ClearFlag_2: (+1)
   \   0000006A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000006C   0x43E8             MVNS     R0,R5
   \   0000006E   0x8220             STRH     R0,[R4, #+16]
   2013          }
   \   00000070   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2014          
   2015          /**
   2016            * @brief  Checks whether the TIM interrupt has occurred or not.
   2017            * @param  TIMx: where x can be 2 to 11 to select the TIM peripheral.
   2018            * @param  TIM_IT: specifies the TIM interrupt source to check.
   2019            *   This parameter can be one of the following values:
   2020            *     @arg TIM_IT_Update: TIM update Interrupt source
   2021            *     @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
   2022            *     @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
   2023            *     @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
   2024            *     @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
   2025            *     @arg TIM_IT_Trigger: TIM Trigger Interrupt source
   2026            * @note
   2027            *   - TIM6 and TIM7 can generate only an update interrupt.
   2028            *   - TIM9 can have only update interrupt, TIM_FLAG_CC1 or TIM_FLAG_CC2,
   2029            *     interrupt and TIM_IT_Trigger interrupt.
   2030            *   - TIM10 and TIM11 can have only update interrupt or TIM_FLAG_CC1
   2031            *     interrupt      
   2032            * @retval The new state of the TIM_IT(SET or RESET).
   2033            */

   \                                 In section .text, align 2, keep-with-next
   2034          ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
   2035          {
   \                     TIM_GetITStatus: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   2036            ITStatus bitstatus = RESET;  
   \   00000008   0x2600             MOVS     R6,#+0
   2037            uint16_t itstatus = 0x0, itenable = 0x0;
   \   0000000A   0x2700             MOVS     R7,#+0
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   2038            
   2039            /* Check the parameters */
   2040            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   \   00000010   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   00000014   0xD01F             BEQ.N    ??TIM_GetITStatus_0
   \   00000016   0x....             LDR.N    R0,??DataTable62  ;; 0x40000400
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD01C             BEQ.N    ??TIM_GetITStatus_0
   \   0000001C   0x....             LDR.N    R0,??DataTable63  ;; 0x40000800
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD019             BEQ.N    ??TIM_GetITStatus_0
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable72  ;; 0x40001000
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD015             BEQ.N    ??TIM_GetITStatus_0
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable72_1  ;; 0x40001400
   \   0000002E   0x4284             CMP      R4,R0
   \   00000030   0xD011             BEQ.N    ??TIM_GetITStatus_0
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable67  ;; 0x40010800
   \   00000036   0x4284             CMP      R4,R0
   \   00000038   0xD00D             BEQ.N    ??TIM_GetITStatus_0
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable67_1  ;; 0x40010c00
   \   0000003E   0x4284             CMP      R4,R0
   \   00000040   0xD009             BEQ.N    ??TIM_GetITStatus_0
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable67_2  ;; 0x40011000
   \   00000046   0x4284             CMP      R4,R0
   \   00000048   0xD005             BEQ.N    ??TIM_GetITStatus_0
   \   0000004A   0xF44F 0x61FF      MOV      R1,#+2040
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable73
   \   00000052   0x.... 0x....      BL       assert_failed
   2041            assert_param(IS_TIM_GET_IT(TIM_IT));
   \                     ??TIM_GetITStatus_0: (+1)
   \   00000056   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000058   0x2D01             CMP      R5,#+1
   \   0000005A   0xD014             BEQ.N    ??TIM_GetITStatus_1
   \   0000005C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000005E   0x2D02             CMP      R5,#+2
   \   00000060   0xD011             BEQ.N    ??TIM_GetITStatus_1
   \   00000062   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000064   0x2D04             CMP      R5,#+4
   \   00000066   0xD00E             BEQ.N    ??TIM_GetITStatus_1
   \   00000068   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000006A   0x2D08             CMP      R5,#+8
   \   0000006C   0xD00B             BEQ.N    ??TIM_GetITStatus_1
   \   0000006E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000070   0x2D10             CMP      R5,#+16
   \   00000072   0xD008             BEQ.N    ??TIM_GetITStatus_1
   \   00000074   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000076   0x2D40             CMP      R5,#+64
   \   00000078   0xD005             BEQ.N    ??TIM_GetITStatus_1
   \   0000007A   0xF240 0x71F9      MOVW     R1,#+2041
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable73
   \   00000082   0x.... 0x....      BL       assert_failed
   2042             
   2043            itstatus = TIMx->SR & TIM_IT;
   \                     ??TIM_GetITStatus_1: (+1)
   \   00000086   0x8A20             LDRH     R0,[R4, #+16]
   \   00000088   0x4028             ANDS     R0,R5,R0
   \   0000008A   0x0007             MOVS     R7,R0
   2044            
   2045            itenable = TIMx->DIER & TIM_IT;
   \   0000008C   0x89A0             LDRH     R0,[R4, #+12]
   \   0000008E   0x4028             ANDS     R0,R5,R0
   \   00000090   0x4680             MOV      R8,R0
   2046            if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
   \   00000092   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000094   0x2F00             CMP      R7,#+0
   \   00000096   0xD007             BEQ.N    ??TIM_GetITStatus_2
   \   00000098   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   0000009C   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000A0   0xD002             BEQ.N    ??TIM_GetITStatus_2
   2047            {
   2048              bitstatus = SET;
   \   000000A2   0x2001             MOVS     R0,#+1
   \   000000A4   0x0006             MOVS     R6,R0
   \   000000A6   0xE001             B.N      ??TIM_GetITStatus_3
   2049            }
   2050            else
   2051            {
   2052              bitstatus = RESET;
   \                     ??TIM_GetITStatus_2: (+1)
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x0006             MOVS     R6,R0
   2053            }
   2054            return bitstatus;
   \                     ??TIM_GetITStatus_3: (+1)
   \   000000AC   0x0030             MOVS     R0,R6
   \   000000AE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B0   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2055          }
   2056          
   2057          /**
   2058            * @brief  Clears the TIMx's interrupt pending bits.
   2059            * @param  TIMx: where x can be 2 to 11 to select the TIM peripheral.
   2060            * @param  TIM_IT: specifies the pending bit to clear.
   2061            *   This parameter can be any combination of the following values:
   2062            *     @arg TIM_IT_Update: TIM update Interrupt source
   2063            *     @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
   2064            *     @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
   2065            *     @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
   2066            *     @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
   2067            *     @arg TIM_IT_Trigger: TIM Trigger Interrupt source
   2068            * @note
   2069            *   - TIM6 and TIM7 can generate only an update interrupt.
   2070            *   - TIM9 can have only update interrupt, TIM_IT_CC1 or TIM_IT_CC2,
   2071            *     and TIM_IT_Trigger interrupt.  
   2072            *   - TIM10 and TIM11 can have only update interrupt or TIM_IT_CC1
   2073            *     interrupt        
   2074            * @retval None
   2075            */

   \                                 In section .text, align 2, keep-with-next
   2076          void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
   2077          {
   \                     TIM_ClearITPendingBit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2078            /* Check the parameters */
   2079            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   \   00000006   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000A   0xD01F             BEQ.N    ??TIM_ClearITPendingBit_0
   \   0000000C   0x....             LDR.N    R0,??DataTable62  ;; 0x40000400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD01C             BEQ.N    ??TIM_ClearITPendingBit_0
   \   00000012   0x....             LDR.N    R0,??DataTable63  ;; 0x40000800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD019             BEQ.N    ??TIM_ClearITPendingBit_0
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable72  ;; 0x40001000
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD015             BEQ.N    ??TIM_ClearITPendingBit_0
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable72_1  ;; 0x40001400
   \   00000024   0x4284             CMP      R4,R0
   \   00000026   0xD011             BEQ.N    ??TIM_ClearITPendingBit_0
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable67  ;; 0x40010800
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD00D             BEQ.N    ??TIM_ClearITPendingBit_0
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable67_1  ;; 0x40010c00
   \   00000034   0x4284             CMP      R4,R0
   \   00000036   0xD009             BEQ.N    ??TIM_ClearITPendingBit_0
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable67_2  ;; 0x40011000
   \   0000003C   0x4284             CMP      R4,R0
   \   0000003E   0xD005             BEQ.N    ??TIM_ClearITPendingBit_0
   \   00000040   0xF640 0x011F      MOVW     R1,#+2079
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable73
   \   00000048   0x.... 0x....      BL       assert_failed
   2080            assert_param(IS_TIM_IT(TIM_IT));
   \                     ??TIM_ClearITPendingBit_0: (+1)
   \   0000004C   0xF64F 0x70A0      MOVW     R0,#+65440
   \   00000050   0x4205             TST      R5,R0
   \   00000052   0xD102             BNE.N    ??TIM_ClearITPendingBit_1
   \   00000054   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000056   0x2D00             CMP      R5,#+0
   \   00000058   0xD105             BNE.N    ??TIM_ClearITPendingBit_2
   \                     ??TIM_ClearITPendingBit_1: (+1)
   \   0000005A   0xF44F 0x6102      MOV      R1,#+2080
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable73
   \   00000062   0x.... 0x....      BL       assert_failed
   2081             
   2082            /* Clear the IT pending Bit */
   2083            TIMx->SR = (uint16_t)~TIM_IT;
   \                     ??TIM_ClearITPendingBit_2: (+1)
   \   00000066   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000068   0x43E8             MVNS     R0,R5
   \   0000006A   0x8220             STRH     R0,[R4, #+16]
   2084          }
   \   0000006C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2085          
   2086          /**
   2087            * @brief  Configures the TIMxs DMA interface.
   2088            * @param  TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2089            * @param  TIM_DMABase: DMA Base address.
   2090            *   This parameter can be one of the following values:
   2091            *     @arg TIM_DMABase_CR, TIM_DMABase_CR2, TIM_DMABase_SMCR,
   2092            *          TIM_DMABase_DIER, TIM_DMABase_SR, TIM_DMABase_EGR,
   2093            *          TIM_DMABase_CCMR1, TIM_DMABase_CCMR2, TIM_DMABase_CCER,
   2094            *          TIM_DMABase_CNT, TIM_DMABase_PSC, TIM_DMABase_ARR,
   2095            *          TIM_DMABase_CCR1, TIM_DMABase_CCR2, TIM_DMABase_CCR3, 
   2096            *          TIM_DMABase_CCR4, TIM_DMABase_DCR.
   2097            * @param  TIM_DMABurstLength: DMA Burst length.
   2098            *   This parameter can be one value between:
   2099            *   TIM_DMABurstLength_1Byte and TIM_DMABurstLength_18Bytes.
   2100            * @retval None
   2101            */

   \                                 In section .text, align 2, keep-with-next
   2102          void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
   2103          {
   \                     TIM_DMAConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   2104            /* Check the parameters */
   2105            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   \   00000008   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000C   0xD00B             BEQ.N    ??TIM_DMAConfig_0
   \   0000000E   0x....             LDR.N    R0,??DataTable62  ;; 0x40000400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD008             BEQ.N    ??TIM_DMAConfig_0
   \   00000014   0x....             LDR.N    R0,??DataTable63  ;; 0x40000800
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD005             BEQ.N    ??TIM_DMAConfig_0
   \   0000001A   0xF640 0x0139      MOVW     R1,#+2105
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable73
   \   00000022   0x.... 0x....      BL       assert_failed
   2106            assert_param(IS_TIM_DMA_BASE(TIM_DMABase)); 
   \                     ??TIM_DMAConfig_0: (+1)
   \   00000026   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000028   0x2D00             CMP      R5,#+0
   \   0000002A   0xD035             BEQ.N    ??TIM_DMAConfig_1
   \   0000002C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002E   0x2D01             CMP      R5,#+1
   \   00000030   0xD032             BEQ.N    ??TIM_DMAConfig_1
   \   00000032   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000034   0x2D02             CMP      R5,#+2
   \   00000036   0xD02F             BEQ.N    ??TIM_DMAConfig_1
   \   00000038   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000003A   0x2D03             CMP      R5,#+3
   \   0000003C   0xD02C             BEQ.N    ??TIM_DMAConfig_1
   \   0000003E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000040   0x2D04             CMP      R5,#+4
   \   00000042   0xD029             BEQ.N    ??TIM_DMAConfig_1
   \   00000044   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000046   0x2D05             CMP      R5,#+5
   \   00000048   0xD026             BEQ.N    ??TIM_DMAConfig_1
   \   0000004A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004C   0x2D06             CMP      R5,#+6
   \   0000004E   0xD023             BEQ.N    ??TIM_DMAConfig_1
   \   00000050   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000052   0x2D07             CMP      R5,#+7
   \   00000054   0xD020             BEQ.N    ??TIM_DMAConfig_1
   \   00000056   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000058   0x2D08             CMP      R5,#+8
   \   0000005A   0xD01D             BEQ.N    ??TIM_DMAConfig_1
   \   0000005C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000005E   0x2D09             CMP      R5,#+9
   \   00000060   0xD01A             BEQ.N    ??TIM_DMAConfig_1
   \   00000062   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000064   0x2D0A             CMP      R5,#+10
   \   00000066   0xD017             BEQ.N    ??TIM_DMAConfig_1
   \   00000068   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000006A   0x2D0B             CMP      R5,#+11
   \   0000006C   0xD014             BEQ.N    ??TIM_DMAConfig_1
   \   0000006E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000070   0x2D0D             CMP      R5,#+13
   \   00000072   0xD011             BEQ.N    ??TIM_DMAConfig_1
   \   00000074   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000076   0x2D0E             CMP      R5,#+14
   \   00000078   0xD00E             BEQ.N    ??TIM_DMAConfig_1
   \   0000007A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000007C   0x2D0F             CMP      R5,#+15
   \   0000007E   0xD00B             BEQ.N    ??TIM_DMAConfig_1
   \   00000080   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000082   0x2D10             CMP      R5,#+16
   \   00000084   0xD008             BEQ.N    ??TIM_DMAConfig_1
   \   00000086   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000088   0x2D12             CMP      R5,#+18
   \   0000008A   0xD005             BEQ.N    ??TIM_DMAConfig_1
   \   0000008C   0xF640 0x013A      MOVW     R1,#+2106
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable73
   \   00000094   0x.... 0x....      BL       assert_failed
   2107            assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
   \                     ??TIM_DMAConfig_1: (+1)
   \   00000098   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000009A   0x2E00             CMP      R6,#+0
   \   0000009C   0xD049             BEQ.N    ??TIM_DMAConfig_2
   \   0000009E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000A0   0xF5B6 0x7F80      CMP      R6,#+256
   \   000000A4   0xD045             BEQ.N    ??TIM_DMAConfig_2
   \   000000A6   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000A8   0xF5B6 0x7F00      CMP      R6,#+512
   \   000000AC   0xD041             BEQ.N    ??TIM_DMAConfig_2
   \   000000AE   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000B0   0xF5B6 0x7F40      CMP      R6,#+768
   \   000000B4   0xD03D             BEQ.N    ??TIM_DMAConfig_2
   \   000000B6   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000B8   0xF5B6 0x6F80      CMP      R6,#+1024
   \   000000BC   0xD039             BEQ.N    ??TIM_DMAConfig_2
   \   000000BE   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000C0   0xF5B6 0x6FA0      CMP      R6,#+1280
   \   000000C4   0xD035             BEQ.N    ??TIM_DMAConfig_2
   \   000000C6   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000C8   0xF5B6 0x6FC0      CMP      R6,#+1536
   \   000000CC   0xD031             BEQ.N    ??TIM_DMAConfig_2
   \   000000CE   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000D0   0xF5B6 0x6FE0      CMP      R6,#+1792
   \   000000D4   0xD02D             BEQ.N    ??TIM_DMAConfig_2
   \   000000D6   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000D8   0xF5B6 0x6F00      CMP      R6,#+2048
   \   000000DC   0xD029             BEQ.N    ??TIM_DMAConfig_2
   \   000000DE   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000E0   0xF5B6 0x6F10      CMP      R6,#+2304
   \   000000E4   0xD025             BEQ.N    ??TIM_DMAConfig_2
   \   000000E6   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000E8   0xF5B6 0x6F20      CMP      R6,#+2560
   \   000000EC   0xD021             BEQ.N    ??TIM_DMAConfig_2
   \   000000EE   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000F0   0xF5B6 0x6F30      CMP      R6,#+2816
   \   000000F4   0xD01D             BEQ.N    ??TIM_DMAConfig_2
   \   000000F6   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000F8   0xF5B6 0x6F40      CMP      R6,#+3072
   \   000000FC   0xD019             BEQ.N    ??TIM_DMAConfig_2
   \   000000FE   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000100   0xF5B6 0x6F50      CMP      R6,#+3328
   \   00000104   0xD015             BEQ.N    ??TIM_DMAConfig_2
   \   00000106   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000108   0xF5B6 0x6F60      CMP      R6,#+3584
   \   0000010C   0xD011             BEQ.N    ??TIM_DMAConfig_2
   \   0000010E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000110   0xF5B6 0x6F70      CMP      R6,#+3840
   \   00000114   0xD00D             BEQ.N    ??TIM_DMAConfig_2
   \   00000116   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000118   0xF5B6 0x5F80      CMP      R6,#+4096
   \   0000011C   0xD009             BEQ.N    ??TIM_DMAConfig_2
   \   0000011E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000120   0xF5B6 0x5F88      CMP      R6,#+4352
   \   00000124   0xD005             BEQ.N    ??TIM_DMAConfig_2
   \   00000126   0xF640 0x013B      MOVW     R1,#+2107
   \   0000012A   0x.... 0x....      LDR.W    R0,??DataTable73
   \   0000012E   0x.... 0x....      BL       assert_failed
   2108            /* Set the DMA Base and the DMA Burst Length */
   2109            TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
   \                     ??TIM_DMAConfig_2: (+1)
   \   00000132   0xEA56 0x0005      ORRS     R0,R6,R5
   \   00000136   0xF8A4 0x0048      STRH     R0,[R4, #+72]
   2110          }
   \   0000013A   0xBD70             POP      {R4-R6,PC}       ;; return
   2111          
   2112          /**
   2113            * @brief  Enables or disables the TIMxs DMA Requests.
   2114            * @param  TIMx: where x can be 2, 3, 4, 6 or 7 to select the TIM peripheral. 
   2115            * @param  TIM_DMASource: specifies the DMA Request sources.
   2116            *   This parameter can be any combination of the following values:
   2117            *     @arg TIM_DMA_Update: TIM update Interrupt source
   2118            *     @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   2119            *     @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   2120            *     @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   2121            *     @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   2122            *     @arg TIM_DMA_Trigger: TIM Trigger DMA source
   2123            * @param  NewState: new state of the DMA Request sources.
   2124            *   This parameter can be: ENABLE or DISABLE.
   2125            * @retval None
   2126            */

   \                                 In section .text, align 2, keep-with-next
   2127          void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
   2128          { 
   \                     TIM_DMACmd: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   2129            /* Check the parameters */
   2130            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   \   00000008   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000C   0xD013             BEQ.N    ??TIM_DMACmd_0
   \   0000000E   0x....             LDR.N    R0,??DataTable62  ;; 0x40000400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD010             BEQ.N    ??TIM_DMACmd_0
   \   00000014   0x....             LDR.N    R0,??DataTable63  ;; 0x40000800
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD00D             BEQ.N    ??TIM_DMACmd_0
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable72  ;; 0x40001000
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD009             BEQ.N    ??TIM_DMACmd_0
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable72_1  ;; 0x40001400
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD005             BEQ.N    ??TIM_DMACmd_0
   \   0000002A   0xF640 0x0152      MOVW     R1,#+2130
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable73
   \   00000032   0x.... 0x....      BL       assert_failed
   2131            assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
   \                     ??TIM_DMACmd_0: (+1)
   \   00000036   0xF24A 0x00FF      MOVW     R0,#+41215
   \   0000003A   0x4205             TST      R5,R0
   \   0000003C   0xD102             BNE.N    ??TIM_DMACmd_1
   \   0000003E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000040   0x2D00             CMP      R5,#+0
   \   00000042   0xD105             BNE.N    ??TIM_DMACmd_2
   \                     ??TIM_DMACmd_1: (+1)
   \   00000044   0xF640 0x0153      MOVW     R1,#+2131
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable73
   \   0000004C   0x.... 0x....      BL       assert_failed
   2132            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??TIM_DMACmd_2: (+1)
   \   00000050   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000052   0x2E00             CMP      R6,#+0
   \   00000054   0xD008             BEQ.N    ??TIM_DMACmd_3
   \   00000056   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000058   0x2E01             CMP      R6,#+1
   \   0000005A   0xD005             BEQ.N    ??TIM_DMACmd_3
   \   0000005C   0xF640 0x0154      MOVW     R1,#+2132
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable73
   \   00000064   0x.... 0x....      BL       assert_failed
   2133            
   2134            if (NewState != DISABLE)
   \                     ??TIM_DMACmd_3: (+1)
   \   00000068   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000006A   0x2E00             CMP      R6,#+0
   \   0000006C   0xD003             BEQ.N    ??TIM_DMACmd_4
   2135            {
   2136              /* Enable the DMA sources */
   2137              TIMx->DIER |= TIM_DMASource; 
   \   0000006E   0x89A0             LDRH     R0,[R4, #+12]
   \   00000070   0x4328             ORRS     R0,R5,R0
   \   00000072   0x81A0             STRH     R0,[R4, #+12]
   \   00000074   0xE002             B.N      ??TIM_DMACmd_5
   2138            }
   2139            else
   2140            {
   2141              /* Disable the DMA sources */
   2142              TIMx->DIER &= (uint16_t)~TIM_DMASource;
   \                     ??TIM_DMACmd_4: (+1)
   \   00000076   0x89A0             LDRH     R0,[R4, #+12]
   \   00000078   0x43A8             BICS     R0,R0,R5
   \   0000007A   0x81A0             STRH     R0,[R4, #+12]
   2143            }
   2144          }
   \                     ??TIM_DMACmd_5: (+1)
   \   0000007C   0xBD70             POP      {R4-R6,PC}       ;; return
   2145          
   2146          /**
   2147            * @brief  Selects the TIMx peripheral Capture Compare DMA source.
   2148            * @param  TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2149            * @param  NewState: new state of the Capture Compare DMA source
   2150            *   This parameter can be: ENABLE or DISABLE.
   2151            * @retval None
   2152            */

   \                                 In section .text, align 2, keep-with-next
   2153          void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
   2154          {
   \                     TIM_SelectCCDMA: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2155            /* Check the parameters */
   2156            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   \   00000006   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000A   0xD00C             BEQ.N    ??TIM_SelectCCDMA_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable76  ;; 0x40000400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD008             BEQ.N    ??TIM_SelectCCDMA_0
   \   00000014   0x....             LDR.N    R0,??DataTable63  ;; 0x40000800
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD005             BEQ.N    ??TIM_SelectCCDMA_0
   \   0000001A   0xF640 0x016C      MOVW     R1,#+2156
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable73
   \   00000022   0x.... 0x....      BL       assert_failed
   2157            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??TIM_SelectCCDMA_0: (+1)
   \   00000026   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000028   0x2D00             CMP      R5,#+0
   \   0000002A   0xD008             BEQ.N    ??TIM_SelectCCDMA_1
   \   0000002C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002E   0x2D01             CMP      R5,#+1
   \   00000030   0xD005             BEQ.N    ??TIM_SelectCCDMA_1
   \   00000032   0xF640 0x016D      MOVW     R1,#+2157
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable73
   \   0000003A   0x.... 0x....      BL       assert_failed
   2158            
   2159            if (NewState != DISABLE)
   \                     ??TIM_SelectCCDMA_1: (+1)
   \   0000003E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000040   0x2D00             CMP      R5,#+0
   \   00000042   0xD004             BEQ.N    ??TIM_SelectCCDMA_2
   2160            {
   2161              /* Set the CCDS Bit */
   2162              TIMx->CR2 |= TIM_CR2_CCDS;
   \   00000044   0x88A0             LDRH     R0,[R4, #+4]
   \   00000046   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000004A   0x80A0             STRH     R0,[R4, #+4]
   \   0000004C   0xE004             B.N      ??TIM_SelectCCDMA_3
   2163            }
   2164            else
   2165            {
   2166              /* Reset the CCDS Bit */
   2167              TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCDS);
   \                     ??TIM_SelectCCDMA_2: (+1)
   \   0000004E   0x88A0             LDRH     R0,[R4, #+4]
   \   00000050   0xF64F 0x71F7      MOVW     R1,#+65527
   \   00000054   0x4008             ANDS     R0,R1,R0
   \   00000056   0x80A0             STRH     R0,[R4, #+4]
   2168            }
   2169          }
   \                     ??TIM_SelectCCDMA_3: (+1)
   \   00000058   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2170          
   2171          /**
   2172            * @}
   2173            */
   2174          
   2175          /** @defgroup TIM_Group5 Clocks management functions
   2176           *  @brief    Clocks management functions
   2177           *
   2178          @verbatim   
   2179           ===============================================================================
   2180                                   Clocks management functions
   2181           ===============================================================================  
   2182          
   2183          @endverbatim
   2184            * @{
   2185            */
   2186          
   2187          /**
   2188            * @brief  Configures the TIMx internal Clock
   2189            * @param  TIMx: where x can be 2, 3, 4 or 9 to select the TIM peripheral.
   2190            * @retval None
   2191            */

   \                                 In section .text, align 2, keep-with-next
   2192          void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
   2193          {
   \                     TIM_InternalClockConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2194            /* Check the parameters */
   2195            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   \   00000004   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   00000008   0xD010             BEQ.N    ??TIM_InternalClockConfig_0
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable76  ;; 0x40000400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD00C             BEQ.N    ??TIM_InternalClockConfig_0
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable76_1  ;; 0x40000800
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD008             BEQ.N    ??TIM_InternalClockConfig_0
   \   0000001A   0x....             LDR.N    R0,??DataTable67  ;; 0x40010800
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD005             BEQ.N    ??TIM_InternalClockConfig_0
   \   00000020   0xF640 0x0193      MOVW     R1,#+2195
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable73
   \   00000028   0x.... 0x....      BL       assert_failed
   2196            /* Disable slave mode to clock the prescaler directly with the internal clock */
   2197            TIMx->SMCR &=  (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
   \                     ??TIM_InternalClockConfig_0: (+1)
   \   0000002C   0x8920             LDRH     R0,[R4, #+8]
   \   0000002E   0xF64F 0x71F8      MOVW     R1,#+65528
   \   00000032   0x4008             ANDS     R0,R1,R0
   \   00000034   0x8120             STRH     R0,[R4, #+8]
   2198          }
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
   2199          
   2200          /**
   2201            * @brief  Configures the TIMx Internal Trigger as External Clock
   2202            * @param  TIMx: where x can be 2, 3, 4 or 9 to select the TIM peripheral.
   2203            * @param  TIM_ITRSource: Trigger source.
   2204            *   This parameter can be one of the following values:
   2205            * @param  TIM_TS_ITR0: Internal Trigger 0
   2206            * @param  TIM_TS_ITR1: Internal Trigger 1
   2207            * @param  TIM_TS_ITR2: Internal Trigger 2
   2208            * @param  TIM_TS_ITR3: Internal Trigger 3
   2209            * @retval None
   2210            */

   \                                 In section .text, align 2, keep-with-next
   2211          void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
   2212          {
   \                     TIM_ITRxExternalClockConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2213            /* Check the parameters */
   2214            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   \   00000006   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000A   0xD010             BEQ.N    ??TIM_ITRxExternalClockConfig_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable76  ;; 0x40000400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD00C             BEQ.N    ??TIM_ITRxExternalClockConfig_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable76_1  ;; 0x40000800
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD008             BEQ.N    ??TIM_ITRxExternalClockConfig_0
   \   0000001C   0x....             LDR.N    R0,??DataTable65  ;; 0x40010800
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD005             BEQ.N    ??TIM_ITRxExternalClockConfig_0
   \   00000022   0xF640 0x01A6      MOVW     R1,#+2214
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable73
   \   0000002A   0x.... 0x....      BL       assert_failed
   2215            assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
   \                     ??TIM_ITRxExternalClockConfig_0: (+1)
   \   0000002E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000030   0x2D00             CMP      R5,#+0
   \   00000032   0xD00E             BEQ.N    ??TIM_ITRxExternalClockConfig_1
   \   00000034   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000036   0x2D10             CMP      R5,#+16
   \   00000038   0xD00B             BEQ.N    ??TIM_ITRxExternalClockConfig_1
   \   0000003A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000003C   0x2D20             CMP      R5,#+32
   \   0000003E   0xD008             BEQ.N    ??TIM_ITRxExternalClockConfig_1
   \   00000040   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000042   0x2D30             CMP      R5,#+48
   \   00000044   0xD005             BEQ.N    ??TIM_ITRxExternalClockConfig_1
   \   00000046   0xF640 0x01A7      MOVW     R1,#+2215
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable73
   \   0000004E   0x.... 0x....      BL       assert_failed
   2216            /* Select the Internal Trigger */
   2217            TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
   \                     ??TIM_ITRxExternalClockConfig_1: (+1)
   \   00000052   0x0029             MOVS     R1,R5
   \   00000054   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000056   0x0020             MOVS     R0,R4
   \   00000058   0x.... 0x....      BL       TIM_SelectInputTrigger
   2218            /* Select the External clock mode1 */
   2219            TIMx->SMCR |= TIM_SlaveMode_External1;
   \   0000005C   0x8920             LDRH     R0,[R4, #+8]
   \   0000005E   0xF050 0x0007      ORRS     R0,R0,#0x7
   \   00000062   0x8120             STRH     R0,[R4, #+8]
   2220          }
   \   00000064   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2221          
   2222          /**
   2223            * @brief  Configures the TIMx Trigger as External Clock
   2224            * @param  TIMx: where x can be 2, 3, 4 or 9 to select the TIM peripheral.
   2225            * @param  TIM_TIxExternalCLKSource: Trigger source.
   2226            *   This parameter can be one of the following values:
   2227            *     @arg TIM_TIxExternalCLK1Source_TI1ED: TI1 Edge Detector
   2228            *     @arg TIM_TIxExternalCLK1Source_TI1: Filtered Timer Input 1
   2229            *     @arg TIM_TIxExternalCLK1Source_TI2: Filtered Timer Input 2
   2230            * @param  TIM_ICPolarity: specifies the TIx Polarity.
   2231            *   This parameter can be one of the following values:
   2232            *     @arg TIM_ICPolarity_Rising
   2233            *     @arg TIM_ICPolarity_Falling
   2234            * @param  ICFilter : specifies the filter value.
   2235            *   This parameter must be a value between 0x0 and 0xF.
   2236            * @retval None
   2237            */

   \                                 In section .text, align 2, keep-with-next
   2238          void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
   2239                                          uint16_t TIM_ICPolarity, uint16_t ICFilter)
   2240          {
   \                     TIM_TIxExternalClockConfig: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
   2241            /* Check the parameters */
   2242            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   \   0000000A   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000E   0xD010             BEQ.N    ??TIM_TIxExternalClockConfig_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable76  ;; 0x40000400
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD00C             BEQ.N    ??TIM_TIxExternalClockConfig_0
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable76_1  ;; 0x40000800
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD008             BEQ.N    ??TIM_TIxExternalClockConfig_0
   \   00000020   0x....             LDR.N    R0,??DataTable67  ;; 0x40010800
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD005             BEQ.N    ??TIM_TIxExternalClockConfig_0
   \   00000026   0xF640 0x01C2      MOVW     R1,#+2242
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable73
   \   0000002E   0x.... 0x....      BL       assert_failed
   2243            assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
   \                     ??TIM_TIxExternalClockConfig_0: (+1)
   \   00000032   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000034   0x2E00             CMP      R6,#+0
   \   00000036   0xD00B             BEQ.N    ??TIM_TIxExternalClockConfig_1
   \   00000038   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000003A   0x2E02             CMP      R6,#+2
   \   0000003C   0xD008             BEQ.N    ??TIM_TIxExternalClockConfig_1
   \   0000003E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000040   0x2E0A             CMP      R6,#+10
   \   00000042   0xD005             BEQ.N    ??TIM_TIxExternalClockConfig_1
   \   00000044   0xF640 0x01C3      MOVW     R1,#+2243
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable73
   \   0000004C   0x.... 0x....      BL       assert_failed
   2244            assert_param(IS_TIM_IC_FILTER(ICFilter));
   \                     ??TIM_TIxExternalClockConfig_1: (+1)
   \   00000050   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000052   0x2F10             CMP      R7,#+16
   \   00000054   0xDB05             BLT.N    ??TIM_TIxExternalClockConfig_2
   \   00000056   0xF640 0x01C4      MOVW     R1,#+2244
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable73
   \   0000005E   0x.... 0x....      BL       assert_failed
   2245            
   2246            /* Configure the Timer Input Clock Source */
   2247            if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
   \                     ??TIM_TIxExternalClockConfig_2: (+1)
   \   00000062   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000064   0x2D60             CMP      R5,#+96
   \   00000066   0xD108             BNE.N    ??TIM_TIxExternalClockConfig_3
   2248            {
   2249              TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
   \   00000068   0x003B             MOVS     R3,R7
   \   0000006A   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000006C   0x2201             MOVS     R2,#+1
   \   0000006E   0x0031             MOVS     R1,R6
   \   00000070   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000072   0x0020             MOVS     R0,R4
   \   00000074   0x.... 0x....      BL       TI2_Config
   \   00000078   0xE007             B.N      ??TIM_TIxExternalClockConfig_4
   2250            }
   2251            else
   2252            {
   2253              TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
   \                     ??TIM_TIxExternalClockConfig_3: (+1)
   \   0000007A   0x003B             MOVS     R3,R7
   \   0000007C   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000007E   0x2201             MOVS     R2,#+1
   \   00000080   0x0031             MOVS     R1,R6
   \   00000082   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000084   0x0020             MOVS     R0,R4
   \   00000086   0x.... 0x....      BL       TI1_Config
   2254            }
   2255            /* Select the Trigger source */
   2256            TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
   \                     ??TIM_TIxExternalClockConfig_4: (+1)
   \   0000008A   0x0029             MOVS     R1,R5
   \   0000008C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000008E   0x0020             MOVS     R0,R4
   \   00000090   0x.... 0x....      BL       TIM_SelectInputTrigger
   2257            /* Select the External clock mode1 */
   2258            TIMx->SMCR |= TIM_SlaveMode_External1;
   \   00000094   0x8920             LDRH     R0,[R4, #+8]
   \   00000096   0xF050 0x0007      ORRS     R0,R0,#0x7
   \   0000009A   0x8120             STRH     R0,[R4, #+8]
   2259          }
   \   0000009C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   2260          
   2261          /**
   2262            * @brief  Configures the External clock Mode1
   2263            * @param  TIMx: where x can be 2, 3, 4 or 9 to select the TIM peripheral.
   2264            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   2265            *   This parameter can be one of the following values:
   2266            *     @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
   2267            *     @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   2268            *     @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   2269            *     @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   2270            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   2271            *   This parameter can be one of the following values:
   2272            *     @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   2273            *     @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   2274            * @param  ExtTRGFilter: External Trigger Filter.
   2275            *   This parameter must be a value between 0x00 and 0x0F
   2276            * @retval None
   2277            */

   \                                 In section .text, align 2, keep-with-next
   2278          void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
   2279                                       uint16_t ExtTRGFilter)
   2280          {
   \                     TIM_ETRClockMode1Config: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   2281            uint16_t tmpsmcr = 0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   2282            
   2283            /* Check the parameters */
   2284            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   \   00000010   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   00000014   0xD010             BEQ.N    ??TIM_ETRClockMode1Config_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable76  ;; 0x40000400
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD00C             BEQ.N    ??TIM_ETRClockMode1Config_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable76_1  ;; 0x40000800
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD008             BEQ.N    ??TIM_ETRClockMode1Config_0
   \   00000026   0x....             LDR.N    R0,??DataTable67  ;; 0x40010800
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD005             BEQ.N    ??TIM_ETRClockMode1Config_0
   \   0000002C   0xF640 0x01EC      MOVW     R1,#+2284
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable73
   \   00000034   0x.... 0x....      BL       assert_failed
   2285            assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   \                     ??TIM_ETRClockMode1Config_0: (+1)
   \   00000038   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0xD011             BEQ.N    ??TIM_ETRClockMode1Config_1
   \   0000003E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000040   0xF5B5 0x5F80      CMP      R5,#+4096
   \   00000044   0xD00D             BEQ.N    ??TIM_ETRClockMode1Config_1
   \   00000046   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000048   0xF5B5 0x5F00      CMP      R5,#+8192
   \   0000004C   0xD009             BEQ.N    ??TIM_ETRClockMode1Config_1
   \   0000004E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000050   0xF5B5 0x5F40      CMP      R5,#+12288
   \   00000054   0xD005             BEQ.N    ??TIM_ETRClockMode1Config_1
   \   00000056   0xF640 0x01ED      MOVW     R1,#+2285
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable73
   \   0000005E   0x.... 0x....      BL       assert_failed
   2286            assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   \                     ??TIM_ETRClockMode1Config_1: (+1)
   \   00000062   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000064   0xF5B6 0x4F00      CMP      R6,#+32768
   \   00000068   0xD008             BEQ.N    ??TIM_ETRClockMode1Config_2
   \   0000006A   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000006C   0x2E00             CMP      R6,#+0
   \   0000006E   0xD005             BEQ.N    ??TIM_ETRClockMode1Config_2
   \   00000070   0xF640 0x01EE      MOVW     R1,#+2286
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable73
   \   00000078   0x.... 0x....      BL       assert_failed
   2287            assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   \                     ??TIM_ETRClockMode1Config_2: (+1)
   \   0000007C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000007E   0x2F10             CMP      R7,#+16
   \   00000080   0xDB05             BLT.N    ??TIM_ETRClockMode1Config_3
   \   00000082   0xF640 0x01EF      MOVW     R1,#+2287
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable73
   \   0000008A   0x.... 0x....      BL       assert_failed
   2288            
   2289            /* Configure the ETR Clock source */
   2290            TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
   \                     ??TIM_ETRClockMode1Config_3: (+1)
   \   0000008E   0x003B             MOVS     R3,R7
   \   00000090   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000092   0x0032             MOVS     R2,R6
   \   00000094   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000096   0x0029             MOVS     R1,R5
   \   00000098   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000009A   0x0020             MOVS     R0,R4
   \   0000009C   0x.... 0x....      BL       TIM_ETRConfig
   2291            
   2292            /* Get the TIMx SMCR register value */
   2293            tmpsmcr = TIMx->SMCR;
   \   000000A0   0x8920             LDRH     R0,[R4, #+8]
   \   000000A2   0x4680             MOV      R8,R0
   2294            /* Reset the SMS Bits */
   2295            tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
   \   000000A4   0xF64F 0x70F8      MOVW     R0,#+65528
   \   000000A8   0xEA10 0x0808      ANDS     R8,R0,R8
   2296            /* Select the External clock mode1 */
   2297            tmpsmcr |= TIM_SlaveMode_External1;
   \   000000AC   0xF058 0x0807      ORRS     R8,R8,#0x7
   2298            /* Select the Trigger selection : ETRF */
   2299            tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
   \   000000B0   0xF64F 0x708F      MOVW     R0,#+65423
   \   000000B4   0xEA10 0x0808      ANDS     R8,R0,R8
   2300            tmpsmcr |= TIM_TS_ETRF;
   \   000000B8   0xF058 0x0870      ORRS     R8,R8,#0x70
   2301            /* Write to TIMx SMCR */
   2302            TIMx->SMCR = tmpsmcr;
   \   000000BC   0xF8A4 0x8008      STRH     R8,[R4, #+8]
   2303          }
   \   000000C0   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2304          
   2305          /**
   2306            * @brief  Configures the External clock Mode2
   2307            * @param  TIMx: where x can be 2, 3, 4, 9, 10 or 11 to select the TIM peripheral.
   2308            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   2309            *   This parameter can be one of the following values:
   2310            *     @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
   2311            *     @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   2312            *     @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   2313            *     @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   2314            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   2315            *   This parameter can be one of the following values:
   2316            *     @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   2317            *     @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   2318            * @param  ExtTRGFilter: External Trigger Filter.
   2319            *   This parameter must be a value between 0x00 and 0x0F
   2320            * @retval None
   2321            */

   \                                 In section .text, align 2, keep-with-next
   2322          void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
   2323                                       uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
   2324          {
   \                     TIM_ETRClockMode2Config: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
   2325            /* Check the parameters */
   2326            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   \   0000000A   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000E   0xD018             BEQ.N    ??TIM_ETRClockMode2Config_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable76  ;; 0x40000400
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD014             BEQ.N    ??TIM_ETRClockMode2Config_0
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable76_1  ;; 0x40000800
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD010             BEQ.N    ??TIM_ETRClockMode2Config_0
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable76_2  ;; 0x40010800
   \   00000024   0x4284             CMP      R4,R0
   \   00000026   0xD00C             BEQ.N    ??TIM_ETRClockMode2Config_0
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable76_3  ;; 0x40010c00
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD008             BEQ.N    ??TIM_ETRClockMode2Config_0
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable76_4  ;; 0x40011000
   \   00000034   0x4284             CMP      R4,R0
   \   00000036   0xD004             BEQ.N    ??TIM_ETRClockMode2Config_0
   \   00000038   0xF640 0x1116      MOVW     R1,#+2326
   \   0000003C   0x....             LDR.N    R0,??DataTable73
   \   0000003E   0x.... 0x....      BL       assert_failed
   2327            assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   \                     ??TIM_ETRClockMode2Config_0: (+1)
   \   00000042   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000044   0x2D00             CMP      R5,#+0
   \   00000046   0xD010             BEQ.N    ??TIM_ETRClockMode2Config_1
   \   00000048   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004A   0xF5B5 0x5F80      CMP      R5,#+4096
   \   0000004E   0xD00C             BEQ.N    ??TIM_ETRClockMode2Config_1
   \   00000050   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000052   0xF5B5 0x5F00      CMP      R5,#+8192
   \   00000056   0xD008             BEQ.N    ??TIM_ETRClockMode2Config_1
   \   00000058   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000005A   0xF5B5 0x5F40      CMP      R5,#+12288
   \   0000005E   0xD004             BEQ.N    ??TIM_ETRClockMode2Config_1
   \   00000060   0xF640 0x1117      MOVW     R1,#+2327
   \   00000064   0x....             LDR.N    R0,??DataTable73
   \   00000066   0x.... 0x....      BL       assert_failed
   2328            assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   \                     ??TIM_ETRClockMode2Config_1: (+1)
   \   0000006A   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000006C   0xF5B6 0x4F00      CMP      R6,#+32768
   \   00000070   0xD007             BEQ.N    ??TIM_ETRClockMode2Config_2
   \   00000072   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000074   0x2E00             CMP      R6,#+0
   \   00000076   0xD004             BEQ.N    ??TIM_ETRClockMode2Config_2
   \   00000078   0xF640 0x1118      MOVW     R1,#+2328
   \   0000007C   0x....             LDR.N    R0,??DataTable73
   \   0000007E   0x.... 0x....      BL       assert_failed
   2329            assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   \                     ??TIM_ETRClockMode2Config_2: (+1)
   \   00000082   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000084   0x2F10             CMP      R7,#+16
   \   00000086   0xDB04             BLT.N    ??TIM_ETRClockMode2Config_3
   \   00000088   0xF640 0x1119      MOVW     R1,#+2329
   \   0000008C   0x....             LDR.N    R0,??DataTable73
   \   0000008E   0x.... 0x....      BL       assert_failed
   2330            
   2331            /* Configure the ETR Clock source */
   2332            TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
   \                     ??TIM_ETRClockMode2Config_3: (+1)
   \   00000092   0x003B             MOVS     R3,R7
   \   00000094   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000096   0x0032             MOVS     R2,R6
   \   00000098   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000009A   0x0029             MOVS     R1,R5
   \   0000009C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000009E   0x0020             MOVS     R0,R4
   \   000000A0   0x.... 0x....      BL       TIM_ETRConfig
   2333            /* Enable the External clock mode2 */
   2334            TIMx->SMCR |= TIM_SMCR_ECE;
   \   000000A4   0x8920             LDRH     R0,[R4, #+8]
   \   000000A6   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \   000000AA   0x8120             STRH     R0,[R4, #+8]
   2335          }
   \   000000AC   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   2336          
   2337          /**
   2338            * @}
   2339            */
   2340          
   2341          /** @defgroup TIM_Group6 Synchronization management functions
   2342           *  @brief    Synchronization management functions 
   2343           *
   2344          @verbatim   
   2345           ===============================================================================
   2346                                 Synchronization management functions
   2347           ===============================================================================  
   2348                             
   2349                 ===================================================================      
   2350                        TIM Driver: how to use it in synchronization Mode
   2351                 =================================================================== 
   2352                 Case of two/several Timers
   2353                 **************************
   2354                 1. Configure the Master Timers using the following functions:
   2355                    - void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource); 
   2356                    - void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode);  
   2357                 2. Configure the Slave Timers using the following functions: 
   2358                    - void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);  
   2359                    - void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode); 
   2360                    
   2361                 Case of Timers and external trigger(ETR pin)
   2362                 ********************************************       
   2363                 1. Configure the Etrenal trigger using this function:
   2364                    - void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
   2365                             uint16_t ExtTRGFilter);
   2366                 2. Configure the Slave Timers using the following functions: 
   2367                    - void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);  
   2368                    - void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode); 
   2369          
   2370          @endverbatim
   2371            * @{
   2372            */
   2373          
   2374          /**
   2375            * @brief  Selects the Input Trigger source
   2376            * @param  TIMx: where x can be 2, 3, 4 or 9 to select the TIM peripheral.
   2377            * @param  TIM_InputTriggerSource: The Input Trigger source.
   2378            *   This parameter can be one of the following values:
   2379            *     @arg TIM_TS_ITR0: Internal Trigger 0
   2380            *     @arg TIM_TS_ITR1: Internal Trigger 1
   2381            *     @arg TIM_TS_ITR2: Internal Trigger 2
   2382            *     @arg TIM_TS_ITR3: Internal Trigger 3
   2383            *     @arg TIM_TS_TI1F_ED: TI1 Edge Detector
   2384            *     @arg TIM_TS_TI1FP1: Filtered Timer Input 1
   2385            *     @arg TIM_TS_TI2FP2: Filtered Timer Input 2
   2386            *     @arg TIM_TS_ETRF: External Trigger input
   2387            * @retval None
   2388            */

   \                                 In section .text, align 2, keep-with-next
   2389          void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
   2390          {
   \                     TIM_SelectInputTrigger: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2391            uint16_t tmpsmcr = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   2392          
   2393            /* Check the parameters */
   2394            assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
   \   00000008   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000C   0xD018             BEQ.N    ??TIM_SelectInputTrigger_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable76  ;; 0x40000400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD014             BEQ.N    ??TIM_SelectInputTrigger_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable76_1  ;; 0x40000800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD010             BEQ.N    ??TIM_SelectInputTrigger_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable76_2  ;; 0x40010800
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD00C             BEQ.N    ??TIM_SelectInputTrigger_0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable76_3  ;; 0x40010c00
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD008             BEQ.N    ??TIM_SelectInputTrigger_0
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable76_4  ;; 0x40011000
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD004             BEQ.N    ??TIM_SelectInputTrigger_0
   \   00000036   0xF640 0x115A      MOVW     R1,#+2394
   \   0000003A   0x....             LDR.N    R0,??DataTable73
   \   0000003C   0x.... 0x....      BL       assert_failed
   2395            assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
   \                     ??TIM_SelectInputTrigger_0: (+1)
   \   00000040   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000042   0x2D00             CMP      R5,#+0
   \   00000044   0xD019             BEQ.N    ??TIM_SelectInputTrigger_1
   \   00000046   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000048   0x2D10             CMP      R5,#+16
   \   0000004A   0xD016             BEQ.N    ??TIM_SelectInputTrigger_1
   \   0000004C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004E   0x2D20             CMP      R5,#+32
   \   00000050   0xD013             BEQ.N    ??TIM_SelectInputTrigger_1
   \   00000052   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000054   0x2D30             CMP      R5,#+48
   \   00000056   0xD010             BEQ.N    ??TIM_SelectInputTrigger_1
   \   00000058   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000005A   0x2D40             CMP      R5,#+64
   \   0000005C   0xD00D             BEQ.N    ??TIM_SelectInputTrigger_1
   \   0000005E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000060   0x2D50             CMP      R5,#+80
   \   00000062   0xD00A             BEQ.N    ??TIM_SelectInputTrigger_1
   \   00000064   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000066   0x2D60             CMP      R5,#+96
   \   00000068   0xD007             BEQ.N    ??TIM_SelectInputTrigger_1
   \   0000006A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000006C   0x2D70             CMP      R5,#+112
   \   0000006E   0xD004             BEQ.N    ??TIM_SelectInputTrigger_1
   \   00000070   0xF640 0x115B      MOVW     R1,#+2395
   \   00000074   0x....             LDR.N    R0,??DataTable73
   \   00000076   0x.... 0x....      BL       assert_failed
   2396          
   2397            /* Get the TIMx SMCR register value */
   2398            tmpsmcr = TIMx->SMCR;
   \                     ??TIM_SelectInputTrigger_1: (+1)
   \   0000007A   0x8920             LDRH     R0,[R4, #+8]
   \   0000007C   0x0006             MOVS     R6,R0
   2399            /* Reset the TS Bits */
   2400            tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
   \   0000007E   0xF64F 0x708F      MOVW     R0,#+65423
   \   00000082   0x4006             ANDS     R6,R0,R6
   2401            /* Set the Input Trigger source */
   2402            tmpsmcr |= TIM_InputTriggerSource;
   \   00000084   0x432E             ORRS     R6,R5,R6
   2403            /* Write to TIMx SMCR */
   2404            TIMx->SMCR = tmpsmcr;
   \   00000086   0x8126             STRH     R6,[R4, #+8]
   2405          }
   \   00000088   0xBD70             POP      {R4-R6,PC}       ;; return
   2406          
   2407          /**
   2408            * @brief  Selects the TIMx Trigger Output Mode.
   2409            * @param  TIMx: where x can be 2, 3, 4, 6, 7 or 9 to select the TIM peripheral.
   2410            * @param  TIM_TRGOSource: specifies the Trigger Output source.
   2411            *   This paramter can be one of the following values:
   2412            *
   2413            *  - For all TIMx
   2414            *     @arg TIM_TRGOSource_Reset:  The UG bit in the TIM_EGR register is used as the trigger output (TRGO).
   2415            *     @arg TIM_TRGOSource_Enable: The Counter Enable CEN is used as the trigger output (TRGO).
   2416            *     @arg TIM_TRGOSource_Update: The update event is selected as the trigger output (TRGO).
   2417            *
   2418            *  - For all TIMx except TIM6 and TIM7
   2419            *     @arg TIM_TRGOSource_OC1: The trigger output sends a positive pulse when the CC1IF flag
   2420            *                              is to be set, as soon as a capture or compare match occurs (TRGO).
   2421            *     @arg TIM_TRGOSource_OC1Ref: OC1REF signal is used as the trigger output (TRGO).
   2422          
   2423            *  - For all TIMx except TIM6, TIM7, TIM10 and TIM11
   2424            *     @arg TIM_TRGOSource_OC2Ref: OC2REF signal is used as the trigger output (TRGO).
   2425          
   2426            *  - For TIM2, TIM3 and TIM4
   2427            *     @arg TIM_TRGOSource_OC3Ref: OC3REF signal is used as the trigger output (TRGO).
   2428            *     @arg TIM_TRGOSource_OC4Ref: OC4REF signal is used as the trigger output (TRGO).
   2429            *
   2430            * @retval None
   2431            */

   \                                 In section .text, align 2, keep-with-next
   2432          void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
   2433          {
   \                     TIM_SelectOutputTrigger: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2434            /* Check the parameters */
   2435            assert_param(IS_TIM_LIST5_PERIPH(TIMx));
   \   00000006   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000A   0xD016             BEQ.N    ??TIM_SelectOutputTrigger_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable76  ;; 0x40000400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD012             BEQ.N    ??TIM_SelectOutputTrigger_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable76_1  ;; 0x40000800
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD00E             BEQ.N    ??TIM_SelectOutputTrigger_0
   \   0000001C   0x....             LDR.N    R0,??DataTable72  ;; 0x40001000
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD00B             BEQ.N    ??TIM_SelectOutputTrigger_0
   \   00000022   0x....             LDR.N    R0,??DataTable72_1  ;; 0x40001400
   \   00000024   0x4284             CMP      R4,R0
   \   00000026   0xD008             BEQ.N    ??TIM_SelectOutputTrigger_0
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable76_2  ;; 0x40010800
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD004             BEQ.N    ??TIM_SelectOutputTrigger_0
   \   00000030   0xF640 0x1183      MOVW     R1,#+2435
   \   00000034   0x....             LDR.N    R0,??DataTable73
   \   00000036   0x.... 0x....      BL       assert_failed
   2436            assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
   \                     ??TIM_SelectOutputTrigger_0: (+1)
   \   0000003A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000003C   0x2D00             CMP      R5,#+0
   \   0000003E   0xD019             BEQ.N    ??TIM_SelectOutputTrigger_1
   \   00000040   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000042   0x2D10             CMP      R5,#+16
   \   00000044   0xD016             BEQ.N    ??TIM_SelectOutputTrigger_1
   \   00000046   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000048   0x2D20             CMP      R5,#+32
   \   0000004A   0xD013             BEQ.N    ??TIM_SelectOutputTrigger_1
   \   0000004C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004E   0x2D30             CMP      R5,#+48
   \   00000050   0xD010             BEQ.N    ??TIM_SelectOutputTrigger_1
   \   00000052   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000054   0x2D40             CMP      R5,#+64
   \   00000056   0xD00D             BEQ.N    ??TIM_SelectOutputTrigger_1
   \   00000058   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000005A   0x2D50             CMP      R5,#+80
   \   0000005C   0xD00A             BEQ.N    ??TIM_SelectOutputTrigger_1
   \   0000005E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000060   0x2D60             CMP      R5,#+96
   \   00000062   0xD007             BEQ.N    ??TIM_SelectOutputTrigger_1
   \   00000064   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000066   0x2D70             CMP      R5,#+112
   \   00000068   0xD004             BEQ.N    ??TIM_SelectOutputTrigger_1
   \   0000006A   0xF640 0x1184      MOVW     R1,#+2436
   \   0000006E   0x....             LDR.N    R0,??DataTable73
   \   00000070   0x.... 0x....      BL       assert_failed
   2437          
   2438            /* Reset the MMS Bits */
   2439            TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_MMS);
   \                     ??TIM_SelectOutputTrigger_1: (+1)
   \   00000074   0x88A0             LDRH     R0,[R4, #+4]
   \   00000076   0xF64F 0x718F      MOVW     R1,#+65423
   \   0000007A   0x4008             ANDS     R0,R1,R0
   \   0000007C   0x80A0             STRH     R0,[R4, #+4]
   2440            /* Select the TRGO source */
   2441            TIMx->CR2 |=  TIM_TRGOSource;
   \   0000007E   0x88A0             LDRH     R0,[R4, #+4]
   \   00000080   0x4328             ORRS     R0,R5,R0
   \   00000082   0x80A0             STRH     R0,[R4, #+4]
   2442          }
   \   00000084   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2443          
   2444          /**
   2445            * @brief  Selects the TIMx Slave Mode.
   2446            * @param  TIMx: where x can be 2, 3, 4 or 9 to select the TIM peripheral.
   2447            * @param  TIM_SlaveMode: specifies the Timer Slave Mode.
   2448            *   This paramter can be one of the following values:
   2449            *     @arg TIM_SlaveMode_Reset: Rising edge of the selected trigger signal (TRGI) re-initializes
   2450            *                               the counter and triggers an update of the registers.
   2451            *     @arg TIM_SlaveMode_Gated:     The counter clock is enabled when the trigger signal (TRGI) is high.
   2452            *     @arg TIM_SlaveMode_Trigger:   The counter starts at a rising edge of the trigger TRGI.
   2453            *     @arg TIM_SlaveMode_External1: Rising edges of the selected trigger (TRGI) clock the counter.
   2454            * @retval None
   2455            */

   \                                 In section .text, align 2, keep-with-next
   2456          void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
   2457          {
   \                     TIM_SelectSlaveMode: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2458            /* Check the parameters */
   2459            assert_param(IS_TIM_LIST2_PERIPH(TIMx)); 
   \   00000006   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000A   0xD00D             BEQ.N    ??TIM_SelectSlaveMode_0
   \   0000000C   0x....             LDR.N    R0,??DataTable76  ;; 0x40000400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD00A             BEQ.N    ??TIM_SelectSlaveMode_0
   \   00000012   0x....             LDR.N    R0,??DataTable76_1  ;; 0x40000800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD007             BEQ.N    ??TIM_SelectSlaveMode_0
   \   00000018   0x....             LDR.N    R0,??DataTable76_2  ;; 0x40010800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD004             BEQ.N    ??TIM_SelectSlaveMode_0
   \   0000001E   0xF640 0x119B      MOVW     R1,#+2459
   \   00000022   0x....             LDR.N    R0,??DataTable73
   \   00000024   0x.... 0x....      BL       assert_failed
   2460            assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
   \                     ??TIM_SelectSlaveMode_0: (+1)
   \   00000028   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002A   0x2D04             CMP      R5,#+4
   \   0000002C   0xD00D             BEQ.N    ??TIM_SelectSlaveMode_1
   \   0000002E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000030   0x2D05             CMP      R5,#+5
   \   00000032   0xD00A             BEQ.N    ??TIM_SelectSlaveMode_1
   \   00000034   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000036   0x2D06             CMP      R5,#+6
   \   00000038   0xD007             BEQ.N    ??TIM_SelectSlaveMode_1
   \   0000003A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000003C   0x2D07             CMP      R5,#+7
   \   0000003E   0xD004             BEQ.N    ??TIM_SelectSlaveMode_1
   \   00000040   0xF640 0x119C      MOVW     R1,#+2460
   \   00000044   0x....             LDR.N    R0,??DataTable73
   \   00000046   0x.... 0x....      BL       assert_failed
   2461            
   2462            /* Reset the SMS Bits */
   2463            TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_SMS);
   \                     ??TIM_SelectSlaveMode_1: (+1)
   \   0000004A   0x8920             LDRH     R0,[R4, #+8]
   \   0000004C   0xF64F 0x71F8      MOVW     R1,#+65528
   \   00000050   0x4008             ANDS     R0,R1,R0
   \   00000052   0x8120             STRH     R0,[R4, #+8]
   2464            /* Select the Slave Mode */
   2465            TIMx->SMCR |= TIM_SlaveMode;
   \   00000054   0x8920             LDRH     R0,[R4, #+8]
   \   00000056   0x4328             ORRS     R0,R5,R0
   \   00000058   0x8120             STRH     R0,[R4, #+8]
   2466          }
   \   0000005A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2467          
   2468          /**
   2469            * @brief  Sets or Resets the TIMx Master/Slave Mode.
   2470            * @param  TIMx: where x can be 2, 3, 4 or 9 to select the TIM peripheral.
   2471            * @param  TIM_MasterSlaveMode: specifies the Timer Master Slave Mode.
   2472            *   This paramter can be one of the following values:
   2473            *     @arg TIM_MasterSlaveMode_Enable: synchronization between the current timer
   2474            *                                      and its slaves (through TRGO).
   2475            *     @arg TIM_MasterSlaveMode_Disable: No action
   2476            * @retval None
   2477            */

   \                                 In section .text, align 2, keep-with-next
   2478          void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
   2479          {
   \                     TIM_SelectMasterSlaveMode: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2480            /* Check the parameters */
   2481            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   \   00000006   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000A   0xD00D             BEQ.N    ??TIM_SelectMasterSlaveMode_0
   \   0000000C   0x....             LDR.N    R0,??DataTable76  ;; 0x40000400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD00A             BEQ.N    ??TIM_SelectMasterSlaveMode_0
   \   00000012   0x....             LDR.N    R0,??DataTable76_1  ;; 0x40000800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD007             BEQ.N    ??TIM_SelectMasterSlaveMode_0
   \   00000018   0x....             LDR.N    R0,??DataTable76_2  ;; 0x40010800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD004             BEQ.N    ??TIM_SelectMasterSlaveMode_0
   \   0000001E   0xF640 0x11B1      MOVW     R1,#+2481
   \   00000022   0x....             LDR.N    R0,??DataTable73
   \   00000024   0x.... 0x....      BL       assert_failed
   2482            assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
   \                     ??TIM_SelectMasterSlaveMode_0: (+1)
   \   00000028   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002A   0x2D80             CMP      R5,#+128
   \   0000002C   0xD007             BEQ.N    ??TIM_SelectMasterSlaveMode_1
   \   0000002E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000030   0x2D00             CMP      R5,#+0
   \   00000032   0xD004             BEQ.N    ??TIM_SelectMasterSlaveMode_1
   \   00000034   0xF640 0x11B2      MOVW     R1,#+2482
   \   00000038   0x....             LDR.N    R0,??DataTable73
   \   0000003A   0x.... 0x....      BL       assert_failed
   2483            
   2484            /* Reset the MSM Bit */
   2485            TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_MSM);
   \                     ??TIM_SelectMasterSlaveMode_1: (+1)
   \   0000003E   0x8920             LDRH     R0,[R4, #+8]
   \   00000040   0xF64F 0x717F      MOVW     R1,#+65407
   \   00000044   0x4008             ANDS     R0,R1,R0
   \   00000046   0x8120             STRH     R0,[R4, #+8]
   2486            
   2487            /* Set or Reset the MSM Bit */
   2488            TIMx->SMCR |= TIM_MasterSlaveMode;
   \   00000048   0x8920             LDRH     R0,[R4, #+8]
   \   0000004A   0x4328             ORRS     R0,R5,R0
   \   0000004C   0x8120             STRH     R0,[R4, #+8]
   2489          }
   \   0000004E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2490          
   2491          /**
   2492            * @brief  Configures the TIMx External Trigger (ETR).
   2493            * @param  TIMx: where x can be 2, 3, 4, 9, 10 or 11 to select the TIM peripheral.
   2494            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   2495            *   This parameter can be one of the following values:
   2496            *     @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
   2497            *     @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   2498            *     @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   2499            *     @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   2500            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   2501            *   This parameter can be one of the following values:
   2502            *     @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   2503            *     @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   2504            * @param  ExtTRGFilter: External Trigger Filter.
   2505            *   This parameter must be a value between 0x00 and 0x0F
   2506            * @retval None
   2507            */

   \                                 In section .text, align 2, keep-with-next
   2508          void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
   2509                             uint16_t ExtTRGFilter)
   2510          {
   \                     TIM_ETRConfig: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   2511            uint16_t tmpsmcr = 0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   2512            
   2513            /* Check the parameters */
   2514            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   \   00000010   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   00000014   0xD013             BEQ.N    ??TIM_ETRConfig_0
   \   00000016   0x....             LDR.N    R0,??DataTable76  ;; 0x40000400
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD010             BEQ.N    ??TIM_ETRConfig_0
   \   0000001C   0x....             LDR.N    R0,??DataTable76_1  ;; 0x40000800
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD00D             BEQ.N    ??TIM_ETRConfig_0
   \   00000022   0x....             LDR.N    R0,??DataTable76_2  ;; 0x40010800
   \   00000024   0x4284             CMP      R4,R0
   \   00000026   0xD00A             BEQ.N    ??TIM_ETRConfig_0
   \   00000028   0x....             LDR.N    R0,??DataTable76_3  ;; 0x40010c00
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD007             BEQ.N    ??TIM_ETRConfig_0
   \   0000002E   0x....             LDR.N    R0,??DataTable76_4  ;; 0x40011000
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD004             BEQ.N    ??TIM_ETRConfig_0
   \   00000034   0xF640 0x11D2      MOVW     R1,#+2514
   \   00000038   0x....             LDR.N    R0,??DataTable73
   \   0000003A   0x.... 0x....      BL       assert_failed
   2515            assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   \                     ??TIM_ETRConfig_0: (+1)
   \   0000003E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000040   0x2D00             CMP      R5,#+0
   \   00000042   0xD010             BEQ.N    ??TIM_ETRConfig_1
   \   00000044   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000046   0xF5B5 0x5F80      CMP      R5,#+4096
   \   0000004A   0xD00C             BEQ.N    ??TIM_ETRConfig_1
   \   0000004C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004E   0xF5B5 0x5F00      CMP      R5,#+8192
   \   00000052   0xD008             BEQ.N    ??TIM_ETRConfig_1
   \   00000054   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000056   0xF5B5 0x5F40      CMP      R5,#+12288
   \   0000005A   0xD004             BEQ.N    ??TIM_ETRConfig_1
   \   0000005C   0xF640 0x11D3      MOVW     R1,#+2515
   \   00000060   0x....             LDR.N    R0,??DataTable73
   \   00000062   0x.... 0x....      BL       assert_failed
   2516            assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   \                     ??TIM_ETRConfig_1: (+1)
   \   00000066   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000068   0xF5B6 0x4F00      CMP      R6,#+32768
   \   0000006C   0xD007             BEQ.N    ??TIM_ETRConfig_2
   \   0000006E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000070   0x2E00             CMP      R6,#+0
   \   00000072   0xD004             BEQ.N    ??TIM_ETRConfig_2
   \   00000074   0xF640 0x11D4      MOVW     R1,#+2516
   \   00000078   0x....             LDR.N    R0,??DataTable73
   \   0000007A   0x.... 0x....      BL       assert_failed
   2517            assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   \                     ??TIM_ETRConfig_2: (+1)
   \   0000007E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000080   0x2F10             CMP      R7,#+16
   \   00000082   0xDB04             BLT.N    ??TIM_ETRConfig_3
   \   00000084   0xF640 0x11D5      MOVW     R1,#+2517
   \   00000088   0x....             LDR.N    R0,??DataTable73
   \   0000008A   0x.... 0x....      BL       assert_failed
   2518            
   2519            tmpsmcr = TIMx->SMCR;
   \                     ??TIM_ETRConfig_3: (+1)
   \   0000008E   0x8920             LDRH     R0,[R4, #+8]
   \   00000090   0x4680             MOV      R8,R0
   2520            /* Reset the ETR Bits */
   2521            tmpsmcr &= SMCR_ETR_MASK;
   \   00000092   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   2522            /* Set the Prescaler, the Filter value and the Polarity */
   2523            tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
   \   00000096   0xEA56 0x2007      ORRS     R0,R6,R7, LSL #+8
   \   0000009A   0x4328             ORRS     R0,R0,R5
   \   0000009C   0xEA50 0x0808      ORRS     R8,R0,R8
   2524            /* Write to TIMx SMCR */
   2525            TIMx->SMCR = tmpsmcr;
   \   000000A0   0xF8A4 0x8008      STRH     R8,[R4, #+8]
   2526          }
   \   000000A4   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2527          
   2528          /**
   2529            * @}
   2530            */
   2531          
   2532          /** @defgroup TIM_Group7 Specific interface management functions
   2533           *  @brief    Specific interface management functions 
   2534           *
   2535          @verbatim   
   2536           ===============================================================================
   2537                              Specific interface management functions
   2538           ===============================================================================  
   2539          
   2540          @endverbatim
   2541            * @{
   2542            */
   2543          
   2544          /**
   2545            * @brief  Configures the TIMx Encoder Interface.
   2546            * @param  TIMx: where x can be  2, 3 or 4 to select the TIM peripheral.
   2547            * @param  TIM_EncoderMode: specifies the TIMx Encoder Mode.
   2548            *   This parameter can be one of the following values:
   2549            *     @arg TIM_EncoderMode_TI1: Counter counts on TI1FP1 edge depending on TI2FP2 level.
   2550            *     @arg TIM_EncoderMode_TI2: Counter counts on TI2FP2 edge depending on TI1FP1 level.
   2551            *     @arg TIM_EncoderMode_TI12: Counter counts on both TI1FP1 and TI2FP2 edges depending
   2552            *                                on the level of the other input.
   2553            * @param  TIM_IC1Polarity: specifies the IC1 Polarity
   2554            *   This parmeter can be one of the following values:
   2555            *     @arg TIM_ICPolarity_Falling: IC Falling edge.
   2556            *     @arg TIM_ICPolarity_Rising: IC Rising edge.
   2557            * @param  TIM_IC2Polarity: specifies the IC2 Polarity
   2558            *   This parmeter can be one of the following values:
   2559            *     @arg TIM_ICPolarity_Falling: IC Falling edge.
   2560            *     @arg TIM_ICPolarity_Rising: IC Rising edge.
   2561            * @retval None
   2562            */

   \                                 In section .text, align 2, keep-with-next
   2563          void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
   2564                                          uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
   2565          {
   \                     TIM_EncoderInterfaceConfig: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   2566            uint16_t tmpsmcr = 0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   2567            uint16_t tmpccmr1 = 0;
   \   00000010   0xF05F 0x0900      MOVS     R9,#+0
   2568            uint16_t tmpccer = 0;
   \   00000014   0xF05F 0x0A00      MOVS     R10,#+0
   2569              
   2570            /* Check the parameters */
   2571            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   \   00000018   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000001C   0xD00A             BEQ.N    ??TIM_EncoderInterfaceConfig_0
   \   0000001E   0x....             LDR.N    R0,??DataTable76  ;; 0x40000400
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD007             BEQ.N    ??TIM_EncoderInterfaceConfig_0
   \   00000024   0x....             LDR.N    R0,??DataTable76_1  ;; 0x40000800
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD004             BEQ.N    ??TIM_EncoderInterfaceConfig_0
   \   0000002A   0xF640 0x210B      MOVW     R1,#+2571
   \   0000002E   0x....             LDR.N    R0,??DataTable76_5
   \   00000030   0x.... 0x....      BL       assert_failed
   2572            assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
   \                     ??TIM_EncoderInterfaceConfig_0: (+1)
   \   00000034   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000036   0x2D01             CMP      R5,#+1
   \   00000038   0xD00A             BEQ.N    ??TIM_EncoderInterfaceConfig_1
   \   0000003A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000003C   0x2D02             CMP      R5,#+2
   \   0000003E   0xD007             BEQ.N    ??TIM_EncoderInterfaceConfig_1
   \   00000040   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000042   0x2D03             CMP      R5,#+3
   \   00000044   0xD004             BEQ.N    ??TIM_EncoderInterfaceConfig_1
   \   00000046   0xF640 0x210C      MOVW     R1,#+2572
   \   0000004A   0x....             LDR.N    R0,??DataTable76_5
   \   0000004C   0x.... 0x....      BL       assert_failed
   2573            assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
   \                     ??TIM_EncoderInterfaceConfig_1: (+1)
   \   00000050   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000052   0x2E00             CMP      R6,#+0
   \   00000054   0xD00A             BEQ.N    ??TIM_EncoderInterfaceConfig_2
   \   00000056   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000058   0x2E02             CMP      R6,#+2
   \   0000005A   0xD007             BEQ.N    ??TIM_EncoderInterfaceConfig_2
   \   0000005C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000005E   0x2E0A             CMP      R6,#+10
   \   00000060   0xD004             BEQ.N    ??TIM_EncoderInterfaceConfig_2
   \   00000062   0xF640 0x210D      MOVW     R1,#+2573
   \   00000066   0x....             LDR.N    R0,??DataTable76_5
   \   00000068   0x.... 0x....      BL       assert_failed
   2574            assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
   \                     ??TIM_EncoderInterfaceConfig_2: (+1)
   \   0000006C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000006E   0x2F00             CMP      R7,#+0
   \   00000070   0xD00A             BEQ.N    ??TIM_EncoderInterfaceConfig_3
   \   00000072   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000074   0x2F02             CMP      R7,#+2
   \   00000076   0xD007             BEQ.N    ??TIM_EncoderInterfaceConfig_3
   \   00000078   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000007A   0x2F0A             CMP      R7,#+10
   \   0000007C   0xD004             BEQ.N    ??TIM_EncoderInterfaceConfig_3
   \   0000007E   0xF640 0x210E      MOVW     R1,#+2574
   \   00000082   0x....             LDR.N    R0,??DataTable76_5
   \   00000084   0x.... 0x....      BL       assert_failed
   2575            
   2576            /* Get the TIMx SMCR register value */
   2577            tmpsmcr = TIMx->SMCR;
   \                     ??TIM_EncoderInterfaceConfig_3: (+1)
   \   00000088   0x8920             LDRH     R0,[R4, #+8]
   \   0000008A   0x4680             MOV      R8,R0
   2578            /* Get the TIMx CCMR1 register value */
   2579            tmpccmr1 = TIMx->CCMR1;
   \   0000008C   0x8B20             LDRH     R0,[R4, #+24]
   \   0000008E   0x4681             MOV      R9,R0
   2580            /* Get the TIMx CCER register value */
   2581            tmpccer = TIMx->CCER;
   \   00000090   0x8C20             LDRH     R0,[R4, #+32]
   \   00000092   0x4682             MOV      R10,R0
   2582            /* Set the encoder Mode */
   2583            tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
   \   00000094   0xF64F 0x70F8      MOVW     R0,#+65528
   \   00000098   0xEA10 0x0808      ANDS     R8,R0,R8
   2584            tmpsmcr |= TIM_EncoderMode;
   \   0000009C   0xEA55 0x0808      ORRS     R8,R5,R8
   2585            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   2586            tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S)));
   \   000000A0   0xF64F 0x40FC      MOVW     R0,#+64764
   \   000000A4   0xEA10 0x0909      ANDS     R9,R0,R9
   2587            tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
   \   000000A8   0xF240 0x1001      MOVW     R0,#+257
   \   000000AC   0xEA50 0x0909      ORRS     R9,R0,R9
   2588            /* Set the TI1 and the TI2 Polarities */
   2589            tmpccer &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCER_CC1P)) & ((uint16_t)~((uint16_t)TIM_CCER_CC2P)));
   \   000000B0   0xF64F 0x70DD      MOVW     R0,#+65501
   \   000000B4   0xEA10 0x0A0A      ANDS     R10,R0,R10
   2590             tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
   \   000000B8   0xEA56 0x1007      ORRS     R0,R6,R7, LSL #+4
   \   000000BC   0xEA50 0x0A0A      ORRS     R10,R0,R10
   2591            /* Write to TIMx SMCR */
   2592            TIMx->SMCR = tmpsmcr;
   \   000000C0   0xF8A4 0x8008      STRH     R8,[R4, #+8]
   2593            /* Write to TIMx CCMR1 */
   2594            TIMx->CCMR1 = tmpccmr1;
   \   000000C4   0xF8A4 0x9018      STRH     R9,[R4, #+24]
   2595            /* Write to TIMx CCER */
   2596            TIMx->CCER = tmpccer;
   \   000000C8   0xF8A4 0xA020      STRH     R10,[R4, #+32]
   2597          }
   \   000000CC   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   2598          
   2599          /**
   2600            * @brief  Enables or disables the TIMxs Hall sensor interface.
   2601            * @param  TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2602            * @param  NewState: new state of the TIMx Hall sensor interface.
   2603            *   This parameter can be: ENABLE or DISABLE.
   2604            * @retval None
   2605            */

   \                                 In section .text, align 2, keep-with-next
   2606          void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
   2607          {
   \                     TIM_SelectHallSensor: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2608            /* Check the parameters */
   2609            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   \   00000006   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000A   0xD00A             BEQ.N    ??TIM_SelectHallSensor_0
   \   0000000C   0x....             LDR.N    R0,??DataTable76  ;; 0x40000400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD007             BEQ.N    ??TIM_SelectHallSensor_0
   \   00000012   0x....             LDR.N    R0,??DataTable76_1  ;; 0x40000800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD004             BEQ.N    ??TIM_SelectHallSensor_0
   \   00000018   0xF640 0x2131      MOVW     R1,#+2609
   \   0000001C   0x....             LDR.N    R0,??DataTable76_5
   \   0000001E   0x.... 0x....      BL       assert_failed
   2610            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??TIM_SelectHallSensor_0: (+1)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD007             BEQ.N    ??TIM_SelectHallSensor_1
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD004             BEQ.N    ??TIM_SelectHallSensor_1
   \   0000002E   0xF640 0x2132      MOVW     R1,#+2610
   \   00000032   0x....             LDR.N    R0,??DataTable76_5
   \   00000034   0x.... 0x....      BL       assert_failed
   2611            
   2612            if (NewState != DISABLE)
   \                     ??TIM_SelectHallSensor_1: (+1)
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0xD004             BEQ.N    ??TIM_SelectHallSensor_2
   2613            {
   2614              /* Set the TI1S Bit */
   2615              TIMx->CR2 |= TIM_CR2_TI1S;
   \   0000003E   0x88A0             LDRH     R0,[R4, #+4]
   \   00000040   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000044   0x80A0             STRH     R0,[R4, #+4]
   \   00000046   0xE004             B.N      ??TIM_SelectHallSensor_3
   2616            }
   2617            else
   2618            {
   2619              /* Reset the TI1S Bit */
   2620              TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_TI1S);
   \                     ??TIM_SelectHallSensor_2: (+1)
   \   00000048   0x88A0             LDRH     R0,[R4, #+4]
   \   0000004A   0xF64F 0x717F      MOVW     R1,#+65407
   \   0000004E   0x4008             ANDS     R0,R1,R0
   \   00000050   0x80A0             STRH     R0,[R4, #+4]
   2621            }
   2622          }
   \                     ??TIM_SelectHallSensor_3: (+1)
   \   00000052   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2623          
   2624          /**
   2625            * @}
   2626            */
   2627          
   2628          /** @defgroup TIM_Group8 Specific remapping management function
   2629           *  @brief   Specific remapping management function
   2630           *
   2631          @verbatim   
   2632           ===============================================================================
   2633                               Specific remapping management function
   2634           ===============================================================================  
   2635          
   2636          @endverbatim
   2637            * @{
   2638            */
   2639          
   2640          /**
   2641            * @brief  Configures the TIM9, TIM10 and TIM11 Remapping input Capabilities.
   2642            * @param  TIMx: where x can be 9, 10 or 11 to select the TIM peripheral.
   2643            * @param  TIM_Remap: specifies the TIM input remapping source.
   2644            *   This parameter can be one of the following values:
   2645            *     @arg TIM9_GPIO: TIM9 Channel 1 is connected to dedicated Timer pin(default)
   2646            *     @arg TIM9_LSE: TIM9 Channel 1 is connected to LSE clock.
   2647            *     @arg TIM10_GPIO: TIM10 Channel 1 is connected to dedicated Timer pin(default) 
   2648            *     @arg TIM10_LSI: TIM10 Channel 1 is connected to LSI clock.
   2649            *     @arg TIM10_LSE: TIM10 Channel 1 is connected to LSE clock.
   2650            *     @arg TIM10_RTC: TIM10 Channel 1 is connected to RTC Output event. 
   2651            *     @arg TIM11_GPIO: TIM11 Channel 1 is connected to dedicated Timer pin(default) 
   2652            *     @arg TIM11_MSI: TIM11 Channel 1 is connected to MSI clock.
   2653            *     @arg TIM11_HSE_RTC: TIM11 Channel 1 is connected to HSE_RTC clock.  
   2654            * @retval None
   2655            */

   \                                 In section .text, align 2, keep-with-next
   2656          void TIM_RemapConfig(TIM_TypeDef* TIMx, uint16_t TIM_Remap)
   2657          {
   \                     TIM_RemapConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2658           /* Check the parameters */
   2659            assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   \   00000006   0x....             LDR.N    R0,??DataTable76_2  ;; 0x40010800
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00A             BEQ.N    ??TIM_RemapConfig_0
   \   0000000C   0x....             LDR.N    R0,??DataTable76_3  ;; 0x40010c00
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD007             BEQ.N    ??TIM_RemapConfig_0
   \   00000012   0x....             LDR.N    R0,??DataTable76_4  ;; 0x40011000
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD004             BEQ.N    ??TIM_RemapConfig_0
   \   00000018   0xF640 0x2163      MOVW     R1,#+2659
   \   0000001C   0x....             LDR.N    R0,??DataTable76_5
   \   0000001E   0x.... 0x....      BL       assert_failed
   2660            assert_param(IS_TIM_REMAP(TIM_Remap));
   \                     ??TIM_RemapConfig_0: (+1)
   \   00000022   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD01C             BEQ.N    ??TIM_RemapConfig_1
   \   00000028   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD019             BEQ.N    ??TIM_RemapConfig_1
   \   0000002E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000030   0x2D00             CMP      R5,#+0
   \   00000032   0xD016             BEQ.N    ??TIM_RemapConfig_1
   \   00000034   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000036   0x2D01             CMP      R5,#+1
   \   00000038   0xD013             BEQ.N    ??TIM_RemapConfig_1
   \   0000003A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000003C   0x2D02             CMP      R5,#+2
   \   0000003E   0xD010             BEQ.N    ??TIM_RemapConfig_1
   \   00000040   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000042   0x2D03             CMP      R5,#+3
   \   00000044   0xD00D             BEQ.N    ??TIM_RemapConfig_1
   \   00000046   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000048   0x2D00             CMP      R5,#+0
   \   0000004A   0xD00A             BEQ.N    ??TIM_RemapConfig_1
   \   0000004C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004E   0x2D01             CMP      R5,#+1
   \   00000050   0xD007             BEQ.N    ??TIM_RemapConfig_1
   \   00000052   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000054   0x2D02             CMP      R5,#+2
   \   00000056   0xD004             BEQ.N    ??TIM_RemapConfig_1
   \   00000058   0xF640 0x2164      MOVW     R1,#+2660
   \   0000005C   0x....             LDR.N    R0,??DataTable76_5
   \   0000005E   0x.... 0x....      BL       assert_failed
   2661          
   2662            /* Set the Timer remapping configuration */
   2663            TIMx->OR =  TIM_Remap;
   \                     ??TIM_RemapConfig_1: (+1)
   \   00000062   0xF8A4 0x5050      STRH     R5,[R4, #+80]
   2664          }
   \   00000066   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2665          
   2666          /**
   2667            * @}
   2668            */
   2669          
   2670          /**
   2671            * @brief  Configure the TI1 as Input.
   2672            * @param  TIMx: where x can be 2, 3, 4, 9, 10 or 11 to select the TIM peripheral.
   2673            * @param  TIM_ICPolarity : The Input Polarity.
   2674            *   This parameter can be one of the following values:
   2675            *     @arg TIM_ICPolarity_Rising
   2676            *     @arg TIM_ICPolarity_Falling
   2677            * @param  TIM_ICSelection: specifies the input to be used.
   2678            *   This parameter can be one of the following values:
   2679            *     @arg TIM_ICSelection_DirectTI: TIM Input 1 is selected to be connected to IC1.
   2680            *     @arg TIM_ICSelection_IndirectTI: TIM Input 1 is selected to be connected to IC2.
   2681            *     @arg TIM_ICSelection_TRC: TIM Input 1 is selected to be connected to TRC.
   2682            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   2683            *   This parameter must be a value between 0x00 and 0x0F.
   2684            * @retval None
   2685            */

   \                                 In section .text, align 2, keep-with-next
   2686          static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   2687                                 uint16_t TIM_ICFilter)
   2688          {
   \                     TI1_Config: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   2689            uint16_t tmpccmr1 = 0, tmpccer = 0;
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0x2500             MOVS     R5,#+0
   2690            
   2691            /* Disable the Channel 1: Reset the CC1E Bit */
   2692            TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC1E);
   \   00000006   0x8C06             LDRH     R6,[R0, #+32]
   \   00000008   0xF64F 0x77FE      MOVW     R7,#+65534
   \   0000000C   0x403E             ANDS     R6,R7,R6
   \   0000000E   0x8406             STRH     R6,[R0, #+32]
   2693            tmpccmr1 = TIMx->CCMR1;
   \   00000010   0x8B06             LDRH     R6,[R0, #+24]
   \   00000012   0x0034             MOVS     R4,R6
   2694            tmpccer = TIMx->CCER;
   \   00000014   0x8C06             LDRH     R6,[R0, #+32]
   \   00000016   0x0035             MOVS     R5,R6
   2695            /* Select the Input and set the filter */
   2696            tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC1F)));
   \   00000018   0xF64F 0x760C      MOVW     R6,#+65292
   \   0000001C   0x4034             ANDS     R4,R6,R4
   2697            tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
   \   0000001E   0xEA52 0x1603      ORRS     R6,R2,R3, LSL #+4
   \   00000022   0x4334             ORRS     R4,R6,R4
   2698            /* Select the Polarity and set the CC1E Bit */
   2699            tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P | TIM_CCER_CC1NP));
   \   00000024   0xF64F 0x76F5      MOVW     R6,#+65525
   \   00000028   0x4035             ANDS     R5,R6,R5
   2700            tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
   \   0000002A   0xF051 0x0601      ORRS     R6,R1,#0x1
   \   0000002E   0x4335             ORRS     R5,R6,R5
   2701            /* Write to TIMx CCMR1 and CCER registers */
   2702            TIMx->CCMR1 = tmpccmr1;
   \   00000030   0x8304             STRH     R4,[R0, #+24]
   2703            TIMx->CCER = tmpccer;
   \   00000032   0x8405             STRH     R5,[R0, #+32]
   2704          }
   \   00000034   0xBCF0             POP      {R4-R7}
   \   00000036   0x4770             BX       LR               ;; return
   2705          
   2706          /**
   2707            * @brief  Configure the TI2 as Input.
   2708            * @param  TIMx: where x can be 2, 3, 4 or 9 to select the TIM peripheral.
   2709            * @param  TIM_ICPolarity : The Input Polarity.
   2710            *   This parameter can be one of the following values:
   2711            *     @arg TIM_ICPolarity_Rising
   2712            *     @arg TIM_ICPolarity_Falling
   2713            * @param  TIM_ICSelection: specifies the input to be used.
   2714            *   This parameter can be one of the following values:
   2715            *     @arg TIM_ICSelection_DirectTI: TIM Input 2 is selected to be connected to IC2.
   2716            *     @arg TIM_ICSelection_IndirectTI: TIM Input 2 is selected to be connected to IC1.
   2717            *     @arg TIM_ICSelection_TRC: TIM Input 2 is selected to be connected to TRC.
   2718            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   2719            *   This parameter must be a value between 0x00 and 0x0F.
   2720            * @retval None
   2721            */

   \                                 In section .text, align 2, keep-with-next
   2722          static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   2723                                 uint16_t TIM_ICFilter)
   2724          {
   \                     TI2_Config: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   2725            uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
   \   00000002   0x2500             MOVS     R5,#+0
   \   00000004   0x2600             MOVS     R6,#+0
   \   00000006   0x2400             MOVS     R4,#+0
   2726            
   2727            /* Disable the Channel 2: Reset the CC2E Bit */
   2728            TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC2E);
   \   00000008   0x8C07             LDRH     R7,[R0, #+32]
   \   0000000A   0xF64F 0x7CEF      MOVW     R12,#+65519
   \   0000000E   0xEA1C 0x0707      ANDS     R7,R12,R7
   \   00000012   0x8407             STRH     R7,[R0, #+32]
   2729            tmpccmr1 = TIMx->CCMR1;
   \   00000014   0x8B07             LDRH     R7,[R0, #+24]
   \   00000016   0x003D             MOVS     R5,R7
   2730            tmpccer = TIMx->CCER;
   \   00000018   0x8C07             LDRH     R7,[R0, #+32]
   \   0000001A   0x003E             MOVS     R6,R7
   2731            tmp = (uint16_t)(TIM_ICPolarity << 4);
   \   0000001C   0x010F             LSLS     R7,R1,#+4
   \   0000001E   0x003C             MOVS     R4,R7
   2732            /* Select the Input and set the filter */
   2733            tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
   \   00000020   0xF640 0x47FF      MOVW     R7,#+3327
   \   00000024   0x403D             ANDS     R5,R7,R5
   2734            tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
   \   00000026   0xEA55 0x3503      ORRS     R5,R5,R3, LSL #+12
   2735            tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
   \   0000002A   0xEA55 0x2502      ORRS     R5,R5,R2, LSL #+8
   2736            /* Select the Polarity and set the CC2E Bit */
   2737            tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P | TIM_CCER_CC2NP));
   \   0000002E   0xF64F 0x775F      MOVW     R7,#+65375
   \   00000032   0x403E             ANDS     R6,R7,R6
   2738            tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
   \   00000034   0xF054 0x0710      ORRS     R7,R4,#0x10
   \   00000038   0x433E             ORRS     R6,R7,R6
   2739            /* Write to TIMx CCMR1 and CCER registers */
   2740            TIMx->CCMR1 = tmpccmr1 ;
   \   0000003A   0x8305             STRH     R5,[R0, #+24]
   2741            TIMx->CCER = tmpccer;
   \   0000003C   0x8406             STRH     R6,[R0, #+32]
   2742          }
   \   0000003E   0xBCF0             POP      {R4-R7}
   \   00000040   0x4770             BX       LR               ;; return
   2743          
   2744          /**
   2745            * @brief  Configure the TI3 as Input.
   2746            * @param  TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2747            * @param  TIM_ICPolarity : The Input Polarity.
   2748            *   This parameter can be one of the following values:
   2749            *     @arg TIM_ICPolarity_Rising
   2750            *     @arg TIM_ICPolarity_Falling
   2751            * @param  TIM_ICSelection: specifies the input to be used.
   2752            *   This parameter can be one of the following values:
   2753            *     @arg TIM_ICSelection_DirectTI: TIM Input 3 is selected to be connected to IC3.
   2754            *     @arg TIM_ICSelection_IndirectTI: TIM Input 3 is selected to be connected to IC4.
   2755            *     @arg TIM_ICSelection_TRC: TIM Input 3 is selected to be connected to TRC.
   2756            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   2757            *   This parameter must be a value between 0x00 and 0x0F.
   2758            * @retval None
   2759            */

   \                                 In section .text, align 2, keep-with-next
   2760          static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   2761                                 uint16_t TIM_ICFilter)
   2762          {
   \                     TI3_Config: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   2763            uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
   \   00000002   0x2600             MOVS     R6,#+0
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0x2500             MOVS     R5,#+0
   2764            
   2765            /* Disable the Channel 3: Reset the CC3E Bit */
   2766            TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC3E);
   \   00000008   0x8C07             LDRH     R7,[R0, #+32]
   \   0000000A   0xF64F 0x6CFF      MOVW     R12,#+65279
   \   0000000E   0xEA1C 0x0707      ANDS     R7,R12,R7
   \   00000012   0x8407             STRH     R7,[R0, #+32]
   2767            tmpccmr2 = TIMx->CCMR2;
   \   00000014   0x8B87             LDRH     R7,[R0, #+28]
   \   00000016   0x003E             MOVS     R6,R7
   2768            tmpccer = TIMx->CCER;
   \   00000018   0x8C07             LDRH     R7,[R0, #+32]
   \   0000001A   0x003C             MOVS     R4,R7
   2769            tmp = (uint16_t)(TIM_ICPolarity << 8);
   \   0000001C   0x020F             LSLS     R7,R1,#+8
   \   0000001E   0x003D             MOVS     R5,R7
   2770            /* Select the Input and set the filter */
   2771            tmpccmr2 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR2_CC3S)) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC3F)));
   \   00000020   0xF64F 0x770C      MOVW     R7,#+65292
   \   00000024   0x403E             ANDS     R6,R7,R6
   2772            tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
   \   00000026   0xEA52 0x1703      ORRS     R7,R2,R3, LSL #+4
   \   0000002A   0x433E             ORRS     R6,R7,R6
   2773            /* Select the Polarity and set the CC3E Bit */
   2774            tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P | TIM_CCER_CC3NP));
   \   0000002C   0xF24F 0x57FF      MOVW     R7,#+62975
   \   00000030   0x403C             ANDS     R4,R7,R4
   2775            tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);
   \   00000032   0xF455 0x7780      ORRS     R7,R5,#0x100
   \   00000036   0x433C             ORRS     R4,R7,R4
   2776            /* Write to TIMx CCMR2 and CCER registers */
   2777            TIMx->CCMR2 = tmpccmr2;
   \   00000038   0x8386             STRH     R6,[R0, #+28]
   2778            TIMx->CCER = tmpccer;
   \   0000003A   0x8404             STRH     R4,[R0, #+32]
   2779          }
   \   0000003C   0xBCF0             POP      {R4-R7}
   \   0000003E   0x4770             BX       LR               ;; return
   2780          
   2781          /**
   2782            * @brief  Configure the TI4 as Input.
   2783            * @param  TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2784            * @param  TIM_ICPolarity : The Input Polarity.
   2785            *   This parameter can be one of the following values:
   2786            *     @arg TIM_ICPolarity_Rising
   2787            *     @arg TIM_ICPolarity_Falling
   2788            * @param  TIM_ICSelection: specifies the input to be used.
   2789            *   This parameter can be one of the following values:
   2790            *     @arg TIM_ICSelection_DirectTI: TIM Input 4 is selected to be connected to IC4.
   2791            *     @arg TIM_ICSelection_IndirectTI: TIM Input 4 is selected to be connected to IC3.
   2792            *     @arg TIM_ICSelection_TRC: TIM Input 4 is selected to be connected to TRC.
   2793            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   2794            *   This parameter must be a value between 0x00 and 0x0F.
   2795            * @retval None
   2796            */

   \                                 In section .text, align 2, keep-with-next
   2797          static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   2798                                 uint16_t TIM_ICFilter)
   2799          {
   \                     TI4_Config: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   2800            uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
   \   00000002   0x2500             MOVS     R5,#+0
   \   00000004   0x2600             MOVS     R6,#+0
   \   00000006   0x2400             MOVS     R4,#+0
   2801            
   2802            /* Disable the Channel 4: Reset the CC4E Bit */
   2803            TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC4E);
   \   00000008   0x8C07             LDRH     R7,[R0, #+32]
   \   0000000A   0xF64E 0x7CFF      MOVW     R12,#+61439
   \   0000000E   0xEA1C 0x0707      ANDS     R7,R12,R7
   \   00000012   0x8407             STRH     R7,[R0, #+32]
   2804            tmpccmr2 = TIMx->CCMR2;
   \   00000014   0x8B87             LDRH     R7,[R0, #+28]
   \   00000016   0x003D             MOVS     R5,R7
   2805            tmpccer = TIMx->CCER;
   \   00000018   0x8C07             LDRH     R7,[R0, #+32]
   \   0000001A   0x003E             MOVS     R6,R7
   2806            tmp = (uint16_t)(TIM_ICPolarity << 12);
   \   0000001C   0x030F             LSLS     R7,R1,#+12
   \   0000001E   0x003C             MOVS     R4,R7
   2807            /* Select the Input and set the filter */
   2808            tmpccmr2 &= (uint16_t)((uint16_t)(~(uint16_t)TIM_CCMR2_CC4S) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC4F)));
   \   00000020   0xF640 0x47FF      MOVW     R7,#+3327
   \   00000024   0x403D             ANDS     R5,R7,R5
   2809            tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
   \   00000026   0xEA55 0x2502      ORRS     R5,R5,R2, LSL #+8
   2810            tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);
   \   0000002A   0xEA55 0x3503      ORRS     R5,R5,R3, LSL #+12
   2811          
   2812            /* Select the Polarity and set the CC4E Bit */
   2813            tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC4P | TIM_CCER_CC4NP));
   \   0000002E   0xF645 0x77FF      MOVW     R7,#+24575
   \   00000032   0x403E             ANDS     R6,R7,R6
   2814            tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
   \   00000034   0xF454 0x5780      ORRS     R7,R4,#0x1000
   \   00000038   0x433E             ORRS     R6,R7,R6
   2815            /* Write to TIMx CCMR2 and CCER registers */
   2816            TIMx->CCMR2 = tmpccmr2;
   \   0000003A   0x8385             STRH     R5,[R0, #+28]
   2817            TIMx->CCER = tmpccer ;
   \   0000003C   0x8406             STRH     R6,[R0, #+32]
   2818          }
   \   0000003E   0xBCF0             POP      {R4-R7}
   \   00000040   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x40000400         DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x40000800         DC32     0x40000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0x40001000         DC32     0x40001000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   0x40001400         DC32     0x40001400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   0x40010800         DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   0x40010C00         DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43:
   \   00000000   0x40000400         DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_1:
   \   00000000   0x40000800         DC32     0x40000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44:
   \   00000000   0x40010800         DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_1:
   \   00000000   0x40010C00         DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_2:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable49:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable62:
   \   00000000   0x40000400         DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable63:
   \   00000000   0x40000800         DC32     0x40000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable65:
   \   00000000   0x40010800         DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable65_1:
   \   00000000   0x40010C00         DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable65_2:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67:
   \   00000000   0x40010800         DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_1:
   \   00000000   0x40010C00         DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_2:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72:
   \   00000000   0x40001000         DC32     0x40001000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72_1:
   \   00000000   0x40001400         DC32     0x40001400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable73:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable76:
   \   00000000   0x40000400         DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable76_1:
   \   00000000   0x40000800         DC32     0x40000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable76_2:
   \   00000000   0x40010800         DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable76_3:
   \   00000000   0x40010C00         DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable76_4:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable76_5:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x45 0x3A          DC8 45H, 3AH, 5CH, 41H, 43H, 51H, 5CH, 50H
   \              0x5C 0x41    
   \              0x43 0x51    
   \              0x5C 0x50    
   \   00000008   0x72 0x6F          DC8 72H, 6FH, 6AH, 5FH, 76H, 65H, 72H, 30H
   \              0x6A 0x5F    
   \              0x76 0x65    
   \              0x72 0x30    
   \   00000010   0x39 0x61          DC8 39H, 61H, 5FH, 31H, 35H, 31H, 30H, 32H
   \              0x5F 0x31    
   \              0x35 0x31    
   \              0x30 0x32    
   \   00000018   0x30 0x31          DC8 30H, 31H, 35H, 5CH, 42H, 61H, 73H, 65H
   \              0x35 0x5C    
   \              0x42 0x61    
   \              0x73 0x65    
   \   00000020   0x5F 0x30          DC8 5FH, 30H, 32H, 5CH, 32H, 30H, 31H, 33H
   \              0x32 0x5C    
   \              0x32 0x30    
   \              0x31 0x33    
   \   00000028   0x5F 0x31          DC8 5FH, 31H, 31H, 5FH, 32H, 35H, 5FH, 53H
   \              0x31 0x5F    
   \              0x32 0x35    
   \              0x5F 0x53    
   \   00000030   0x70 0x69          DC8 70H, 69H, 72H, 69H, 74H, 31H, 5FH, 45H
   \              0x72 0x69    
   \              0x74 0x31    
   \              0x5F 0x45    
   \   00000038   0x6C 0x65          DC8 6CH, 65H, 6BH, 74H, 72H, 6FH, 6CH, 75H
   \              0x6B 0x74    
   \              0x72 0x6F    
   \              0x6C 0x75    
   \   00000040   0x78 0x5C          DC8 78H, 5CH, 53H, 54H, 4DH, 33H, 32H, 4CH
   \              0x53 0x54    
   \              0x4D 0x33    
   \              0x32 0x4C    
   \   00000048   0x5C 0x53          DC8 5CH, 53H, 54H, 4DH, 33H, 32H, 4CH, 31H
   \              0x54 0x4D    
   \              0x33 0x32    
   \              0x4C 0x31    
   \   00000050   0x78 0x78          DC8 78H, 78H, 5FH, 53H, 74H, 64H, 50H, 65H
   \              0x5F 0x53    
   \              0x74 0x64    
   \              0x50 0x65    
   \   00000058   0x72 0x69          DC8 72H, 69H, 70H, 68H, 5FH, 4CH, 69H, 62H
   \              0x70 0x68    
   \              0x5F 0x4C    
   \              0x69 0x62    
   \   00000060   0x5C 0x53          DC8 5CH, 53H, 6FH, 75H, 72H, 63H, 65H, 5CH
   \              0x6F 0x75    
   \              0x72 0x63    
   \              0x65 0x5C    
   \   00000068   0x53 0x54          DC8 53H, 54H, 4DH, 33H, 32H, 4CH, 31H, 78H
   \              0x4D 0x33    
   \              0x32 0x4C    
   \              0x31 0x78    
   \   00000070   0x78 0x5F          DC8 78H, 5FH, 53H, 74H, 64H, 50H, 65H, 72H
   \              0x53 0x74    
   \              0x64 0x50    
   \              0x65 0x72    
   \   00000078   0x69 0x70          DC8 69H, 70H, 68H, 5FH, 44H, 72H, 69H, 76H
   \              0x68 0x5F    
   \              0x44 0x72    
   \              0x69 0x76    
   \   00000080   0x65 0x72          DC8 65H, 72H, 5CH, 73H, 72H, 63H, 5CH, 73H
   \              0x5C 0x73    
   \              0x72 0x63    
   \              0x5C 0x73    
   \   00000088   0x74 0x6D          DC8 74H, 6DH, 33H, 32H, 6CH, 31H, 78H, 78H
   \              0x33 0x32    
   \              0x6C 0x31    
   \              0x78 0x78    
   \   00000090   0x5F 0x74          DC8 5FH, 74H, 69H, 6DH, 2EH, 63H, 0
   \              0x69 0x6D    
   \              0x2E 0x63    
   \              0x00         
   \   00000097   0x00               DC8 0
   2819          
   2820          /**
   2821            * @}
   2822            */
   2823          
   2824          /**
   2825            * @}
   2826            */
   2827          
   2828          /**
   2829            * @}
   2830            */
   2831          
   2832          /******************* (C) COPYRIGHT 2010 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   TI1_Config
      16   TI2_Config
      16   TI3_Config
      16   TI4_Config
      16   TIM_ARRPreloadConfig
        16   -> assert_failed
      24   TIM_CCxCmd
        24   -> assert_failed
      16   TIM_ClearFlag
        16   -> assert_failed
      16   TIM_ClearITPendingBit
        16   -> assert_failed
      16   TIM_ClearOC1Ref
        16   -> assert_failed
      16   TIM_ClearOC2Ref
        16   -> assert_failed
      16   TIM_ClearOC3Ref
        16   -> assert_failed
      16   TIM_ClearOC4Ref
        16   -> assert_failed
      16   TIM_Cmd
        16   -> assert_failed
      16   TIM_CounterModeConfig
        16   -> assert_failed
      16   TIM_DMACmd
        16   -> assert_failed
      16   TIM_DMAConfig
        16   -> assert_failed
       8   TIM_DeInit
         8   -> RCC_APB1PeriphResetCmd
         8   -> RCC_APB2PeriphResetCmd
         8   -> assert_failed
      24   TIM_ETRClockMode1Config
        24   -> TIM_ETRConfig
        24   -> assert_failed
      24   TIM_ETRClockMode2Config
        24   -> TIM_ETRConfig
        24   -> assert_failed
      24   TIM_ETRConfig
        24   -> assert_failed
      32   TIM_EncoderInterfaceConfig
        32   -> assert_failed
      16   TIM_ForcedOC1Config
        16   -> assert_failed
      16   TIM_ForcedOC2Config
        16   -> assert_failed
      16   TIM_ForcedOC3Config
        16   -> assert_failed
      16   TIM_ForcedOC4Config
        16   -> assert_failed
      16   TIM_GenerateEvent
        16   -> assert_failed
       8   TIM_GetCapture1
         8   -> assert_failed
       8   TIM_GetCapture2
         8   -> assert_failed
       8   TIM_GetCapture3
         8   -> assert_failed
       8   TIM_GetCapture4
         8   -> assert_failed
       8   TIM_GetCounter
         8   -> assert_failed
      16   TIM_GetFlagStatus
        16   -> assert_failed
      24   TIM_GetITStatus
        24   -> assert_failed
       8   TIM_GetPrescaler
         8   -> assert_failed
      16   TIM_ICInit
        16   -> TI1_Config
        16   -> TI2_Config
        16   -> TI3_Config
        16   -> TI4_Config
        16   -> TIM_SetIC1Prescaler
        16   -> TIM_SetIC2Prescaler
        16   -> TIM_SetIC3Prescaler
        16   -> TIM_SetIC4Prescaler
        16   -> assert_failed
       0   TIM_ICStructInit
      16   TIM_ITConfig
        16   -> assert_failed
      16   TIM_ITRxExternalClockConfig
        16   -> TIM_SelectInputTrigger
        16   -> assert_failed
       8   TIM_InternalClockConfig
         8   -> assert_failed
      16   TIM_OC1FastConfig
        16   -> assert_failed
      24   TIM_OC1Init
        24   -> assert_failed
      16   TIM_OC1PolarityConfig
        16   -> assert_failed
      16   TIM_OC1PreloadConfig
        16   -> assert_failed
      16   TIM_OC2FastConfig
        16   -> assert_failed
      24   TIM_OC2Init
        24   -> assert_failed
      16   TIM_OC2PolarityConfig
        16   -> assert_failed
      16   TIM_OC2PreloadConfig
        16   -> assert_failed
      16   TIM_OC3FastConfig
        16   -> assert_failed
      24   TIM_OC3Init
        24   -> assert_failed
      16   TIM_OC3PolarityConfig
        16   -> assert_failed
      16   TIM_OC3PreloadConfig
        16   -> assert_failed
      16   TIM_OC4FastConfig
        16   -> assert_failed
      24   TIM_OC4Init
        24   -> assert_failed
      16   TIM_OC4PolarityConfig
        16   -> assert_failed
      16   TIM_OC4PreloadConfig
        16   -> assert_failed
       0   TIM_OCStructInit
      24   TIM_PWMIConfig
        24   -> TI1_Config
        24   -> TI2_Config
        24   -> TIM_SetIC1Prescaler
        24   -> TIM_SetIC2Prescaler
        24   -> assert_failed
      16   TIM_PrescalerConfig
        16   -> assert_failed
      16   TIM_RemapConfig
        16   -> assert_failed
      16   TIM_SelectCCDMA
        16   -> assert_failed
      16   TIM_SelectHallSensor
        16   -> assert_failed
      16   TIM_SelectInputTrigger
        16   -> assert_failed
      16   TIM_SelectMasterSlaveMode
        16   -> assert_failed
      16   TIM_SelectOCREFClear
        16   -> assert_failed
      24   TIM_SelectOCxM
        24   -> assert_failed
      16   TIM_SelectOnePulseMode
        16   -> assert_failed
      16   TIM_SelectOutputTrigger
        16   -> assert_failed
      16   TIM_SelectSlaveMode
        16   -> assert_failed
      16   TIM_SetAutoreload
        16   -> assert_failed
      16   TIM_SetClockDivision
        16   -> assert_failed
      16   TIM_SetCompare1
        16   -> assert_failed
      16   TIM_SetCompare2
        16   -> assert_failed
      16   TIM_SetCompare3
        16   -> assert_failed
      16   TIM_SetCompare4
        16   -> assert_failed
      16   TIM_SetCounter
        16   -> assert_failed
      16   TIM_SetIC1Prescaler
        16   -> assert_failed
      16   TIM_SetIC2Prescaler
        16   -> assert_failed
      16   TIM_SetIC3Prescaler
        16   -> assert_failed
      16   TIM_SetIC4Prescaler
        16   -> assert_failed
      24   TIM_TIxExternalClockConfig
        24   -> TI1_Config
        24   -> TI2_Config
        24   -> TIM_SelectInputTrigger
        24   -> assert_failed
      16   TIM_TimeBaseInit
        16   -> assert_failed
       0   TIM_TimeBaseStructInit
      16   TIM_UpdateDisableConfig
        16   -> assert_failed
      16   TIM_UpdateRequestConfig
        16   -> assert_failed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable17
       4  ??DataTable43
       4  ??DataTable43_1
       4  ??DataTable44
       4  ??DataTable44_1
       4  ??DataTable44_2
       4  ??DataTable49
       4  ??DataTable62
       4  ??DataTable63
       4  ??DataTable65
       4  ??DataTable65_1
       4  ??DataTable65_2
       4  ??DataTable67
       4  ??DataTable67_1
       4  ??DataTable67_2
       4  ??DataTable72
       4  ??DataTable72_1
       4  ??DataTable73
       4  ??DataTable76
       4  ??DataTable76_1
       4  ??DataTable76_2
       4  ??DataTable76_3
       4  ??DataTable76_4
       4  ??DataTable76_5
     152  ?_0
      56  TI1_Config
      66  TI2_Config
      64  TI3_Config
      66  TI4_Config
     132  TIM_ARRPreloadConfig
     108  TIM_CCxCmd
     114  TIM_ClearFlag
     110  TIM_ClearITPendingBit
     102  TIM_ClearOC1Ref
      84  TIM_ClearOC2Ref
      78  TIM_ClearOC3Ref
      78  TIM_ClearOC4Ref
     116  TIM_Cmd
     100  TIM_CounterModeConfig
     126  TIM_DMACmd
     316  TIM_DMAConfig
     282  TIM_DeInit
     196  TIM_ETRClockMode1Config
     174  TIM_ETRClockMode2Config
     168  TIM_ETRConfig
     208  TIM_EncoderInterfaceConfig
     106  TIM_ForcedOC1Config
      92  TIM_ForcedOC2Config
      82  TIM_ForcedOC3Config
      84  TIM_ForcedOC4Config
     110  TIM_GenerateEvent
      64  TIM_GetCapture1
      48  TIM_GetCapture2
      40  TIM_GetCapture3
      44  TIM_GetCapture4
      82  TIM_GetCounter
     184  TIM_GetFlagStatus
     180  TIM_GetITStatus
      82  TIM_GetPrescaler
     274  TIM_ICInit
      22  TIM_ICStructInit
     154  TIM_ITConfig
     102  TIM_ITRxExternalClockConfig
      56  TIM_InternalClockConfig
     106  TIM_OC1FastConfig
     204  TIM_OC1Init
      96  TIM_OC1PolarityConfig
     106  TIM_OC1PreloadConfig
      92  TIM_OC2FastConfig
     192  TIM_OC2Init
      86  TIM_OC2PolarityConfig
      92  TIM_OC2PreloadConfig
      82  TIM_OC3FastConfig
     184  TIM_OC3Init
      80  TIM_OC3PolarityConfig
      82  TIM_OC3PreloadConfig
      80  TIM_OC4FastConfig
     200  TIM_OC4Init
      80  TIM_OC4PolarityConfig
      84  TIM_OC4PreloadConfig
      18  TIM_OCStructInit
     180  TIM_PWMIConfig
     112  TIM_PrescalerConfig
     104  TIM_RemapConfig
      90  TIM_SelectCCDMA
      84  TIM_SelectHallSensor
     138  TIM_SelectInputTrigger
      80  TIM_SelectMasterSlaveMode
      74  TIM_SelectOCREFClear
     222  TIM_SelectOCxM
     122  TIM_SelectOnePulseMode
     134  TIM_SelectOutputTrigger
      92  TIM_SelectSlaveMode
      84  TIM_SetAutoreload
     104  TIM_SetClockDivision
      68  TIM_SetCompare1
      52  TIM_SetCompare2
      44  TIM_SetCompare3
      46  TIM_SetCompare4
      84  TIM_SetCounter
     118  TIM_SetIC1Prescaler
     104  TIM_SetIC2Prescaler
      94  TIM_SetIC3Prescaler
      96  TIM_SetIC4Prescaler
     158  TIM_TIxExternalClockConfig
     230  TIM_TimeBaseInit
      20  TIM_TimeBaseStructInit
     132  TIM_UpdateDisableConfig
     132  TIM_UpdateRequestConfig

 
   152 bytes in section .rodata
 9 536 bytes in section .text
 
 9 536 bytes of CODE  memory
   152 bytes of CONST memory

Errors: none
Warnings: none
